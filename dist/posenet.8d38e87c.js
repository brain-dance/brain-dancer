// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/core-js/modules/_global.js":[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],"../node_modules/core-js/modules/_has.js":[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],"../node_modules/core-js/modules/_fails.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],"../node_modules/core-js/modules/_descriptors.js":[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/_core.js":[function(require,module,exports) {
var core = module.exports = { version: '2.6.10' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],"../node_modules/core-js/modules/_is-object.js":[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"../node_modules/core-js/modules/_an-object.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js"}],"../node_modules/core-js/modules/_dom-create.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/_ie8-dom-define.js":[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_dom-create":"../node_modules/core-js/modules/_dom-create.js"}],"../node_modules/core-js/modules/_to-primitive.js":[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js"}],"../node_modules/core-js/modules/_object-dp.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_ie8-dom-define":"../node_modules/core-js/modules/_ie8-dom-define.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js"}],"../node_modules/core-js/modules/_property-desc.js":[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],"../node_modules/core-js/modules/_hide.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js"}],"../node_modules/core-js/modules/_uid.js":[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],"../node_modules/core-js/modules/_library.js":[function(require,module,exports) {
module.exports = false;

},{}],"../node_modules/core-js/modules/_shared.js":[function(require,module,exports) {

var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":"../node_modules/core-js/modules/_core.js","./_global":"../node_modules/core-js/modules/_global.js","./_library":"../node_modules/core-js/modules/_library.js"}],"../node_modules/core-js/modules/_function-to-string.js":[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":"../node_modules/core-js/modules/_shared.js"}],"../node_modules/core-js/modules/_redefine.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":"../node_modules/core-js/modules/_global.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_has":"../node_modules/core-js/modules/_has.js","./_uid":"../node_modules/core-js/modules/_uid.js","./_function-to-string":"../node_modules/core-js/modules/_function-to-string.js","./_core":"../node_modules/core-js/modules/_core.js"}],"../node_modules/core-js/modules/_a-function.js":[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],"../node_modules/core-js/modules/_ctx.js":[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":"../node_modules/core-js/modules/_a-function.js"}],"../node_modules/core-js/modules/_export.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":"../node_modules/core-js/modules/_global.js","./_core":"../node_modules/core-js/modules/_core.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_ctx":"../node_modules/core-js/modules/_ctx.js"}],"../node_modules/core-js/modules/_meta.js":[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_uid":"../node_modules/core-js/modules/_uid.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_has":"../node_modules/core-js/modules/_has.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/_wks.js":[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_shared":"../node_modules/core-js/modules/_shared.js","./_uid":"../node_modules/core-js/modules/_uid.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/_set-to-string-tag.js":[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_has":"../node_modules/core-js/modules/_has.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/_wks-ext.js":[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/_wks-define.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_global":"../node_modules/core-js/modules/_global.js","./_core":"../node_modules/core-js/modules/_core.js","./_library":"../node_modules/core-js/modules/_library.js","./_wks-ext":"../node_modules/core-js/modules/_wks-ext.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js"}],"../node_modules/core-js/modules/_cof.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],"../node_modules/core-js/modules/_iobject.js":[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/_defined.js":[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],"../node_modules/core-js/modules/_to-iobject.js":[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_iobject":"../node_modules/core-js/modules/_iobject.js","./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/_to-integer.js":[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],"../node_modules/core-js/modules/_to-length.js":[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":"../node_modules/core-js/modules/_to-integer.js"}],"../node_modules/core-js/modules/_to-absolute-index.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":"../node_modules/core-js/modules/_to-integer.js"}],"../node_modules/core-js/modules/_array-includes.js":[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js"}],"../node_modules/core-js/modules/_shared-key.js":[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":"../node_modules/core-js/modules/_shared.js","./_uid":"../node_modules/core-js/modules/_uid.js"}],"../node_modules/core-js/modules/_object-keys-internal.js":[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_has":"../node_modules/core-js/modules/_has.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_array-includes":"../node_modules/core-js/modules/_array-includes.js","./_shared-key":"../node_modules/core-js/modules/_shared-key.js"}],"../node_modules/core-js/modules/_enum-bug-keys.js":[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],"../node_modules/core-js/modules/_object-keys.js":[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":"../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../node_modules/core-js/modules/_enum-bug-keys.js"}],"../node_modules/core-js/modules/_object-gops.js":[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],"../node_modules/core-js/modules/_object-pie.js":[function(require,module,exports) {
exports.f = {}.propertyIsEnumerable;

},{}],"../node_modules/core-js/modules/_enum-keys.js":[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../node_modules/core-js/modules/_object-pie.js"}],"../node_modules/core-js/modules/_is-array.js":[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/_to-object.js":[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/_object-dps.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js"}],"../node_modules/core-js/modules/_html.js":[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/_object-create.js":[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_object-dps":"../node_modules/core-js/modules/_object-dps.js","./_enum-bug-keys":"../node_modules/core-js/modules/_enum-bug-keys.js","./_shared-key":"../node_modules/core-js/modules/_shared-key.js","./_dom-create":"../node_modules/core-js/modules/_dom-create.js","./_html":"../node_modules/core-js/modules/_html.js"}],"../node_modules/core-js/modules/_object-gopn.js":[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":"../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../node_modules/core-js/modules/_enum-bug-keys.js"}],"../node_modules/core-js/modules/_object-gopn-ext.js":[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js"}],"../node_modules/core-js/modules/_object-gopd.js":[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":"../node_modules/core-js/modules/_object-pie.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_has":"../node_modules/core-js/modules/_has.js","./_ie8-dom-define":"../node_modules/core-js/modules/_ie8-dom-define.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js"}],"../node_modules/core-js/modules/es6.symbol.js":[function(require,module,exports) {

'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":"../node_modules/core-js/modules/_global.js","./_has":"../node_modules/core-js/modules/_has.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_export":"../node_modules/core-js/modules/_export.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_shared":"../node_modules/core-js/modules/_shared.js","./_set-to-string-tag":"../node_modules/core-js/modules/_set-to-string-tag.js","./_uid":"../node_modules/core-js/modules/_uid.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_wks-ext":"../node_modules/core-js/modules/_wks-ext.js","./_wks-define":"../node_modules/core-js/modules/_wks-define.js","./_enum-keys":"../node_modules/core-js/modules/_enum-keys.js","./_is-array":"../node_modules/core-js/modules/_is-array.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js","./_object-create":"../node_modules/core-js/modules/_object-create.js","./_object-gopn-ext":"../node_modules/core-js/modules/_object-gopn-ext.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_object-gops":"../node_modules/core-js/modules/_object-gops.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js","./_object-pie":"../node_modules/core-js/modules/_object-pie.js","./_library":"../node_modules/core-js/modules/_library.js","./_hide":"../node_modules/core-js/modules/_hide.js"}],"../node_modules/core-js/modules/es6.object.create.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-create":"../node_modules/core-js/modules/_object-create.js"}],"../node_modules/core-js/modules/es6.object.define-property.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js"}],"../node_modules/core-js/modules/es6.object.define-properties.js":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-dps":"../node_modules/core-js/modules/_object-dps.js"}],"../node_modules/core-js/modules/_object-sap.js":[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_export":"../node_modules/core-js/modules/_export.js","./_core":"../node_modules/core-js/modules/_core.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/_object-gpo.js":[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":"../node_modules/core-js/modules/_has.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_shared-key":"../node_modules/core-js/modules/_shared-key.js"}],"../node_modules/core-js/modules/es6.object.get-prototype-of.js":[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_to-object":"../node_modules/core-js/modules/_to-object.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.keys.js":[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_to-object":"../node_modules/core-js/modules/_to-object.js","./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.get-own-property-names.js":[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-sap":"../node_modules/core-js/modules/_object-sap.js","./_object-gopn-ext":"../node_modules/core-js/modules/_object-gopn-ext.js"}],"../node_modules/core-js/modules/es6.object.freeze.js":[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.seal.js":[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.prevent-extensions.js":[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.is-frozen.js":[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.is-sealed.js":[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/es6.object.is-extensible.js":[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_object-sap":"../node_modules/core-js/modules/_object-sap.js"}],"../node_modules/core-js/modules/_object-assign.js":[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../node_modules/core-js/modules/_object-pie.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_iobject":"../node_modules/core-js/modules/_iobject.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.object.assign.js":[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-assign":"../node_modules/core-js/modules/_object-assign.js"}],"../node_modules/core-js/modules/_same-value.js":[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"../node_modules/core-js/modules/es6.object.is.js":[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_same-value":"../node_modules/core-js/modules/_same-value.js"}],"../node_modules/core-js/modules/_set-proto.js":[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_ctx":"../node_modules/core-js/modules/_ctx.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js"}],"../node_modules/core-js/modules/es6.object.set-prototype-of.js":[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_set-proto":"../node_modules/core-js/modules/_set-proto.js"}],"../node_modules/core-js/modules/_classof.js":[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":"../node_modules/core-js/modules/_cof.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es6.object.to-string.js":[function(require,module,exports) {
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":"../node_modules/core-js/modules/_classof.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_redefine":"../node_modules/core-js/modules/_redefine.js"}],"../node_modules/core-js/modules/_invoke.js":[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],"../node_modules/core-js/modules/_bind.js":[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":"../node_modules/core-js/modules/_a-function.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_invoke":"../node_modules/core-js/modules/_invoke.js"}],"../node_modules/core-js/modules/es6.function.bind.js":[function(require,module,exports) {
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_bind":"../node_modules/core-js/modules/_bind.js"}],"../node_modules/core-js/modules/es6.function.name.js":[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js"}],"../node_modules/core-js/modules/es6.function.has-instance.js":[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js"}],"../node_modules/core-js/modules/_string-ws.js":[function(require,module,exports) {
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],"../node_modules/core-js/modules/_string-trim.js":[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_export":"../node_modules/core-js/modules/_export.js","./_defined":"../node_modules/core-js/modules/_defined.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_string-ws":"../node_modules/core-js/modules/_string-ws.js"}],"../node_modules/core-js/modules/_parse-int.js":[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":"../node_modules/core-js/modules/_global.js","./_string-trim":"../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../node_modules/core-js/modules/_string-ws.js"}],"../node_modules/core-js/modules/es6.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_parse-int":"../node_modules/core-js/modules/_parse-int.js"}],"../node_modules/core-js/modules/_parse-float.js":[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":"../node_modules/core-js/modules/_global.js","./_string-trim":"../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../node_modules/core-js/modules/_string-ws.js"}],"../node_modules/core-js/modules/es6.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_parse-float":"../node_modules/core-js/modules/_parse-float.js"}],"../node_modules/core-js/modules/_inherit-if-required.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_set-proto":"../node_modules/core-js/modules/_set-proto.js"}],"../node_modules/core-js/modules/es6.number.constructor.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":"../node_modules/core-js/modules/_global.js","./_has":"../node_modules/core-js/modules/_has.js","./_cof":"../node_modules/core-js/modules/_cof.js","./_inherit-if-required":"../node_modules/core-js/modules/_inherit-if-required.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_string-trim":"../node_modules/core-js/modules/_string-trim.js","./_object-create":"../node_modules/core-js/modules/_object-create.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_redefine":"../node_modules/core-js/modules/_redefine.js"}],"../node_modules/core-js/modules/_a-number-value.js":[function(require,module,exports) {
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/_string-repeat.js":[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/es6.number.to-fixed.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_a-number-value":"../node_modules/core-js/modules/_a-number-value.js","./_string-repeat":"../node_modules/core-js/modules/_string-repeat.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.number.to-precision.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_a-number-value":"../node_modules/core-js/modules/_a-number-value.js"}],"../node_modules/core-js/modules/es6.number.epsilon.js":[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.number.is-finite.js":[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/_is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js"}],"../node_modules/core-js/modules/es6.number.is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_is-integer":"../node_modules/core-js/modules/_is-integer.js"}],"../node_modules/core-js/modules/es6.number.is-nan.js":[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.number.is-safe-integer.js":[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_is-integer":"../node_modules/core-js/modules/_is-integer.js"}],"../node_modules/core-js/modules/es6.number.max-safe-integer.js":[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.number.min-safe-integer.js":[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.number.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_parse-float":"../node_modules/core-js/modules/_parse-float.js"}],"../node_modules/core-js/modules/es6.number.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_parse-int":"../node_modules/core-js/modules/_parse-int.js"}],"../node_modules/core-js/modules/_math-log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],"../node_modules/core-js/modules/es6.math.acosh.js":[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-log1p":"../node_modules/core-js/modules/_math-log1p.js"}],"../node_modules/core-js/modules/es6.math.asinh.js":[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.math.atanh.js":[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/_math-sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"../node_modules/core-js/modules/es6.math.cbrt.js":[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-sign":"../node_modules/core-js/modules/_math-sign.js"}],"../node_modules/core-js/modules/es6.math.clz32.js":[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.math.cosh.js":[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/_math-expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],"../node_modules/core-js/modules/es6.math.expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-expm1":"../node_modules/core-js/modules/_math-expm1.js"}],"../node_modules/core-js/modules/_math-fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":"../node_modules/core-js/modules/_math-sign.js"}],"../node_modules/core-js/modules/es6.math.fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-fround":"../node_modules/core-js/modules/_math-fround.js"}],"../node_modules/core-js/modules/es6.math.hypot.js":[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.math.imul.js":[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.math.log10.js":[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.math.log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-log1p":"../node_modules/core-js/modules/_math-log1p.js"}],"../node_modules/core-js/modules/es6.math.log2.js":[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.math.sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-sign":"../node_modules/core-js/modules/_math-sign.js"}],"../node_modules/core-js/modules/es6.math.sinh.js":[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-expm1":"../node_modules/core-js/modules/_math-expm1.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.math.tanh.js":[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-expm1":"../node_modules/core-js/modules/_math-expm1.js"}],"../node_modules/core-js/modules/es6.math.trunc.js":[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.string.from-code-point.js":[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js"}],"../node_modules/core-js/modules/es6.string.raw.js":[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../node_modules/core-js/modules/_to-length.js"}],"../node_modules/core-js/modules/es6.string.trim.js":[function(require,module,exports) {
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":"../node_modules/core-js/modules/_string-trim.js"}],"../node_modules/core-js/modules/_string-at.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/_iterators.js":[function(require,module,exports) {
module.exports = {};

},{}],"../node_modules/core-js/modules/_iter-create.js":[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":"../node_modules/core-js/modules/_object-create.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js","./_set-to-string-tag":"../node_modules/core-js/modules/_set-to-string-tag.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/_iter-define.js":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_library":"../node_modules/core-js/modules/_library.js","./_export":"../node_modules/core-js/modules/_export.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_iterators":"../node_modules/core-js/modules/_iterators.js","./_iter-create":"../node_modules/core-js/modules/_iter-create.js","./_set-to-string-tag":"../node_modules/core-js/modules/_set-to-string-tag.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es6.string.iterator.js":[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_string-at":"../node_modules/core-js/modules/_string-at.js","./_iter-define":"../node_modules/core-js/modules/_iter-define.js"}],"../node_modules/core-js/modules/es6.string.code-point-at.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_string-at":"../node_modules/core-js/modules/_string-at.js"}],"../node_modules/core-js/modules/_is-regexp.js":[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_cof":"../node_modules/core-js/modules/_cof.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/_string-context.js":[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_is-regexp":"../node_modules/core-js/modules/_is-regexp.js","./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/_fails-is-regexp.js":[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es6.string.ends-with.js":[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_string-context":"../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../node_modules/core-js/modules/_fails-is-regexp.js"}],"../node_modules/core-js/modules/es6.string.includes.js":[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_string-context":"../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../node_modules/core-js/modules/_fails-is-regexp.js"}],"../node_modules/core-js/modules/es6.string.repeat.js":[function(require,module,exports) {
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_string-repeat":"../node_modules/core-js/modules/_string-repeat.js"}],"../node_modules/core-js/modules/es6.string.starts-with.js":[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_string-context":"../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../node_modules/core-js/modules/_fails-is-regexp.js"}],"../node_modules/core-js/modules/_string-html.js":[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_export":"../node_modules/core-js/modules/_export.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/es6.string.anchor.js":[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.big.js":[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.blink.js":[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.bold.js":[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.fixed.js":[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.fontcolor.js":[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.fontsize.js":[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.italics.js":[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.link.js":[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.small.js":[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.strike.js":[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.sub.js":[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.string.sup.js":[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":"../node_modules/core-js/modules/_string-html.js"}],"../node_modules/core-js/modules/es6.date.now.js":[function(require,module,exports) {
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.date.to-json.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/_date-to-iso-string.js":[function(require,module,exports) {
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.date.to-iso-string.js":[function(require,module,exports) {
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_date-to-iso-string":"../node_modules/core-js/modules/_date-to-iso-string.js"}],"../node_modules/core-js/modules/es6.date.to-string.js":[function(require,module,exports) {
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":"../node_modules/core-js/modules/_redefine.js"}],"../node_modules/core-js/modules/_date-to-primitive.js":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js"}],"../node_modules/core-js/modules/es6.date.to-primitive.js":[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":"../node_modules/core-js/modules/_wks.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_date-to-primitive":"../node_modules/core-js/modules/_date-to-primitive.js"}],"../node_modules/core-js/modules/es6.array.is-array.js":[function(require,module,exports) {
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_is-array":"../node_modules/core-js/modules/_is-array.js"}],"../node_modules/core-js/modules/_iter-call.js":[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/_is-array-iter.js":[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":"../node_modules/core-js/modules/_iterators.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/_create-property.js":[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js"}],"../node_modules/core-js/modules/core.get-iterator-method.js":[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":"../node_modules/core-js/modules/_classof.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_iterators":"../node_modules/core-js/modules/_iterators.js","./_core":"../node_modules/core-js/modules/_core.js"}],"../node_modules/core-js/modules/_iter-detect.js":[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es6.array.from.js":[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_ctx":"../node_modules/core-js/modules/_ctx.js","./_export":"../node_modules/core-js/modules/_export.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_iter-call":"../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../node_modules/core-js/modules/_is-array-iter.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_create-property":"../node_modules/core-js/modules/_create-property.js","./core.get-iterator-method":"../node_modules/core-js/modules/core.get-iterator-method.js","./_iter-detect":"../node_modules/core-js/modules/_iter-detect.js"}],"../node_modules/core-js/modules/es6.array.of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_create-property":"../node_modules/core-js/modules/_create-property.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/_strict-method.js":[function(require,module,exports) {
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.array.join.js":[function(require,module,exports) {
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_iobject":"../node_modules/core-js/modules/_iobject.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.slice.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_html":"../node_modules/core-js/modules/_html.js","./_cof":"../node_modules/core-js/modules/_cof.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.array.sort.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/_array-species-constructor.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js","./_is-array":"../node_modules/core-js/modules/_is-array.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/_array-species-create.js":[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":"../node_modules/core-js/modules/_array-species-constructor.js"}],"../node_modules/core-js/modules/_array-methods.js":[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_ctx":"../node_modules/core-js/modules/_ctx.js","./_iobject":"../node_modules/core-js/modules/_iobject.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_array-species-create":"../node_modules/core-js/modules/_array-species-create.js"}],"../node_modules/core-js/modules/es6.array.for-each.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.map.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.filter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.some.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.every.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/_array-reduce.js":[function(require,module,exports) {
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":"../node_modules/core-js/modules/_a-function.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_iobject":"../node_modules/core-js/modules/_iobject.js","./_to-length":"../node_modules/core-js/modules/_to-length.js"}],"../node_modules/core-js/modules/es6.array.reduce.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-reduce":"../node_modules/core-js/modules/_array-reduce.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.reduce-right.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-reduce":"../node_modules/core-js/modules/_array-reduce.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.index-of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-includes":"../node_modules/core-js/modules/_array-includes.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/es6.array.last-index-of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_strict-method":"../node_modules/core-js/modules/_strict-method.js"}],"../node_modules/core-js/modules/_array-copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../node_modules/core-js/modules/_to-length.js"}],"../node_modules/core-js/modules/_add-to-unscopables.js":[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":"../node_modules/core-js/modules/_wks.js","./_hide":"../node_modules/core-js/modules/_hide.js"}],"../node_modules/core-js/modules/es6.array.copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-copy-within":"../node_modules/core-js/modules/_array-copy-within.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/_array-fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../node_modules/core-js/modules/_to-length.js"}],"../node_modules/core-js/modules/es6.array.fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-fill":"../node_modules/core-js/modules/_array-fill.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/es6.array.find.js":[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/es6.array.find-index.js":[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/_set-species.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_global":"../node_modules/core-js/modules/_global.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es6.array.species.js":[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":"../node_modules/core-js/modules/_set-species.js"}],"../node_modules/core-js/modules/_iter-step.js":[function(require,module,exports) {
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],"../node_modules/core-js/modules/es6.array.iterator.js":[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js","./_iter-step":"../node_modules/core-js/modules/_iter-step.js","./_iterators":"../node_modules/core-js/modules/_iterators.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_iter-define":"../node_modules/core-js/modules/_iter-define.js"}],"../node_modules/core-js/modules/_flags.js":[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es6.regexp.constructor.js":[function(require,module,exports) {

var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_global":"../node_modules/core-js/modules/_global.js","./_inherit-if-required":"../node_modules/core-js/modules/_inherit-if-required.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js","./_is-regexp":"../node_modules/core-js/modules/_is-regexp.js","./_flags":"../node_modules/core-js/modules/_flags.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_set-species":"../node_modules/core-js/modules/_set-species.js"}],"../node_modules/core-js/modules/_regexp-exec.js":[function(require,module,exports) {
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":"../node_modules/core-js/modules/_flags.js"}],"../node_modules/core-js/modules/es6.regexp.exec.js":[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_regexp-exec":"../node_modules/core-js/modules/_regexp-exec.js","./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.regexp.flags.js":[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_flags":"../node_modules/core-js/modules/_flags.js"}],"../node_modules/core-js/modules/es6.regexp.to-string.js":[function(require,module,exports) {

'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./es6.regexp.flags":"../node_modules/core-js/modules/es6.regexp.flags.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_flags":"../node_modules/core-js/modules/_flags.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/_advance-string-index.js":[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":"../node_modules/core-js/modules/_string-at.js"}],"../node_modules/core-js/modules/_regexp-exec-abstract.js":[function(require,module,exports) {
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":"../node_modules/core-js/modules/_classof.js"}],"../node_modules/core-js/modules/_fix-re-wks.js":[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./es6.regexp.exec":"../node_modules/core-js/modules/es6.regexp.exec.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_defined":"../node_modules/core-js/modules/_defined.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_regexp-exec":"../node_modules/core-js/modules/_regexp-exec.js"}],"../node_modules/core-js/modules/es6.regexp.match.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_advance-string-index":"../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../node_modules/core-js/modules/_fix-re-wks.js"}],"../node_modules/core-js/modules/es6.regexp.replace.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_advance-string-index":"../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../node_modules/core-js/modules/_fix-re-wks.js"}],"../node_modules/core-js/modules/es6.regexp.search.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_same-value":"../node_modules/core-js/modules/_same-value.js","./_regexp-exec-abstract":"../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../node_modules/core-js/modules/_fix-re-wks.js"}],"../node_modules/core-js/modules/_species-constructor.js":[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es6.regexp.split.js":[function(require,module,exports) {
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_is-regexp":"../node_modules/core-js/modules/_is-regexp.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_species-constructor":"../node_modules/core-js/modules/_species-constructor.js","./_advance-string-index":"../node_modules/core-js/modules/_advance-string-index.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_regexp-exec-abstract":"../node_modules/core-js/modules/_regexp-exec-abstract.js","./_regexp-exec":"../node_modules/core-js/modules/_regexp-exec.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_fix-re-wks":"../node_modules/core-js/modules/_fix-re-wks.js"}],"../node_modules/core-js/modules/_an-instance.js":[function(require,module,exports) {
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],"../node_modules/core-js/modules/_for-of.js":[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":"../node_modules/core-js/modules/_ctx.js","./_iter-call":"../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../node_modules/core-js/modules/_is-array-iter.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./core.get-iterator-method":"../node_modules/core-js/modules/core.get-iterator-method.js"}],"../node_modules/core-js/modules/_task.js":[function(require,module,exports) {


var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_ctx":"../node_modules/core-js/modules/_ctx.js","./_invoke":"../node_modules/core-js/modules/_invoke.js","./_html":"../node_modules/core-js/modules/_html.js","./_dom-create":"../node_modules/core-js/modules/_dom-create.js","./_global":"../node_modules/core-js/modules/_global.js","./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/_microtask.js":[function(require,module,exports) {


var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_global":"../node_modules/core-js/modules/_global.js","./_task":"../node_modules/core-js/modules/_task.js","./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/_new-promise-capability.js":[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":"../node_modules/core-js/modules/_a-function.js"}],"../node_modules/core-js/modules/_perform.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],"../node_modules/core-js/modules/_user-agent.js":[function(require,module,exports) {

var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/_promise-resolve.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":"../node_modules/core-js/modules/_an-object.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_new-promise-capability":"../node_modules/core-js/modules/_new-promise-capability.js"}],"../node_modules/core-js/modules/_redefine-all.js":[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":"../node_modules/core-js/modules/_redefine.js"}],"../node_modules/core-js/modules/es6.promise.js":[function(require,module,exports) {


'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_library":"../node_modules/core-js/modules/_library.js","./_global":"../node_modules/core-js/modules/_global.js","./_ctx":"../node_modules/core-js/modules/_ctx.js","./_classof":"../node_modules/core-js/modules/_classof.js","./_export":"../node_modules/core-js/modules/_export.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_for-of":"../node_modules/core-js/modules/_for-of.js","./_species-constructor":"../node_modules/core-js/modules/_species-constructor.js","./_task":"../node_modules/core-js/modules/_task.js","./_microtask":"../node_modules/core-js/modules/_microtask.js","./_new-promise-capability":"../node_modules/core-js/modules/_new-promise-capability.js","./_perform":"../node_modules/core-js/modules/_perform.js","./_user-agent":"../node_modules/core-js/modules/_user-agent.js","./_promise-resolve":"../node_modules/core-js/modules/_promise-resolve.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_set-to-string-tag":"../node_modules/core-js/modules/_set-to-string-tag.js","./_set-species":"../node_modules/core-js/modules/_set-species.js","./_core":"../node_modules/core-js/modules/_core.js","./_iter-detect":"../node_modules/core-js/modules/_iter-detect.js"}],"../node_modules/core-js/modules/_validate-collection.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":"../node_modules/core-js/modules/_is-object.js"}],"../node_modules/core-js/modules/_collection-strong.js":[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_object-create":"../node_modules/core-js/modules/_object-create.js","./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_ctx":"../node_modules/core-js/modules/_ctx.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_for-of":"../node_modules/core-js/modules/_for-of.js","./_iter-define":"../node_modules/core-js/modules/_iter-define.js","./_iter-step":"../node_modules/core-js/modules/_iter-step.js","./_set-species":"../node_modules/core-js/modules/_set-species.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_validate-collection":"../node_modules/core-js/modules/_validate-collection.js"}],"../node_modules/core-js/modules/_collection.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_global":"../node_modules/core-js/modules/_global.js","./_export":"../node_modules/core-js/modules/_export.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_for-of":"../node_modules/core-js/modules/_for-of.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_iter-detect":"../node_modules/core-js/modules/_iter-detect.js","./_set-to-string-tag":"../node_modules/core-js/modules/_set-to-string-tag.js","./_inherit-if-required":"../node_modules/core-js/modules/_inherit-if-required.js"}],"../node_modules/core-js/modules/es6.map.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection-strong":"../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../node_modules/core-js/modules/_validate-collection.js","./_collection":"../node_modules/core-js/modules/_collection.js"}],"../node_modules/core-js/modules/es6.set.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection-strong":"../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../node_modules/core-js/modules/_validate-collection.js","./_collection":"../node_modules/core-js/modules/_collection.js"}],"../node_modules/core-js/modules/_collection-weak.js":[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_for-of":"../node_modules/core-js/modules/_for-of.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_has":"../node_modules/core-js/modules/_has.js","./_validate-collection":"../node_modules/core-js/modules/_validate-collection.js"}],"../node_modules/core-js/modules/es6.weak-map.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_global":"../node_modules/core-js/modules/_global.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_meta":"../node_modules/core-js/modules/_meta.js","./_object-assign":"../node_modules/core-js/modules/_object-assign.js","./_collection-weak":"../node_modules/core-js/modules/_collection-weak.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_validate-collection":"../node_modules/core-js/modules/_validate-collection.js","./_collection":"../node_modules/core-js/modules/_collection.js"}],"../node_modules/core-js/modules/es6.weak-set.js":[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection-weak":"../node_modules/core-js/modules/_collection-weak.js","./_validate-collection":"../node_modules/core-js/modules/_validate-collection.js","./_collection":"../node_modules/core-js/modules/_collection.js"}],"../node_modules/core-js/modules/_typed.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":"../node_modules/core-js/modules/_global.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_uid":"../node_modules/core-js/modules/_uid.js"}],"../node_modules/core-js/modules/_to-index.js":[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_to-length":"../node_modules/core-js/modules/_to-length.js"}],"../node_modules/core-js/modules/_typed-buffer.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":"../node_modules/core-js/modules/_global.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_library":"../node_modules/core-js/modules/_library.js","./_typed":"../node_modules/core-js/modules/_typed.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_to-index":"../node_modules/core-js/modules/_to-index.js","./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_array-fill":"../node_modules/core-js/modules/_array-fill.js","./_set-to-string-tag":"../node_modules/core-js/modules/_set-to-string-tag.js"}],"../node_modules/core-js/modules/es6.typed.array-buffer.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_export":"../node_modules/core-js/modules/_export.js","./_typed":"../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../node_modules/core-js/modules/_typed-buffer.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_global":"../node_modules/core-js/modules/_global.js","./_species-constructor":"../node_modules/core-js/modules/_species-constructor.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_set-species":"../node_modules/core-js/modules/_set-species.js"}],"../node_modules/core-js/modules/es6.typed.data-view.js":[function(require,module,exports) {
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_typed":"../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../node_modules/core-js/modules/_typed-buffer.js"}],"../node_modules/core-js/modules/_typed-array.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_library":"../node_modules/core-js/modules/_library.js","./_global":"../node_modules/core-js/modules/_global.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_export":"../node_modules/core-js/modules/_export.js","./_typed":"../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../node_modules/core-js/modules/_typed-buffer.js","./_ctx":"../node_modules/core-js/modules/_ctx.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_to-index":"../node_modules/core-js/modules/_to-index.js","./_to-absolute-index":"../node_modules/core-js/modules/_to-absolute-index.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_has":"../node_modules/core-js/modules/_has.js","./_classof":"../node_modules/core-js/modules/_classof.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_is-array-iter":"../node_modules/core-js/modules/_is-array-iter.js","./_object-create":"../node_modules/core-js/modules/_object-create.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js","./core.get-iterator-method":"../node_modules/core-js/modules/core.get-iterator-method.js","./_uid":"../node_modules/core-js/modules/_uid.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_array-methods":"../node_modules/core-js/modules/_array-methods.js","./_array-includes":"../node_modules/core-js/modules/_array-includes.js","./_species-constructor":"../node_modules/core-js/modules/_species-constructor.js","./es6.array.iterator":"../node_modules/core-js/modules/es6.array.iterator.js","./_iterators":"../node_modules/core-js/modules/_iterators.js","./_iter-detect":"../node_modules/core-js/modules/_iter-detect.js","./_set-species":"../node_modules/core-js/modules/_set-species.js","./_array-fill":"../node_modules/core-js/modules/_array-fill.js","./_array-copy-within":"../node_modules/core-js/modules/_array-copy-within.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js"}],"../node_modules/core-js/modules/es6.typed.int8-array.js":[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.uint8-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.int16-array.js":[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.uint16-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.int32-array.js":[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.uint32-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.float32-array.js":[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.typed.float64-array.js":[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../node_modules/core-js/modules/_typed-array.js"}],"../node_modules/core-js/modules/es6.reflect.apply.js":[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_global":"../node_modules/core-js/modules/_global.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.reflect.construct.js":[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-create":"../node_modules/core-js/modules/_object-create.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_bind":"../node_modules/core-js/modules/_bind.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/es6.reflect.define-property.js":[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_export":"../node_modules/core-js/modules/_export.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_fails":"../node_modules/core-js/modules/_fails.js"}],"../node_modules/core-js/modules/es6.reflect.delete-property.js":[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es6.reflect.enumerate.js":[function(require,module,exports) {
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_iter-create":"../node_modules/core-js/modules/_iter-create.js"}],"../node_modules/core-js/modules/es6.reflect.get.js":[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_has":"../node_modules/core-js/modules/_has.js","./_export":"../node_modules/core-js/modules/_export.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_export":"../node_modules/core-js/modules/_export.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es6.reflect.get-prototype-of.js":[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es6.reflect.has.js":[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es6.reflect.is-extensible.js":[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/_own-keys.js":[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":"../node_modules/core-js/modules/_object-gopn.js","./_object-gops":"../node_modules/core-js/modules/_object-gops.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/es6.reflect.own-keys.js":[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_own-keys":"../node_modules/core-js/modules/_own-keys.js"}],"../node_modules/core-js/modules/es6.reflect.prevent-extensions.js":[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es6.reflect.set.js":[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_has":"../node_modules/core-js/modules/_has.js","./_export":"../node_modules/core-js/modules/_export.js","./_property-desc":"../node_modules/core-js/modules/_property-desc.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_is-object":"../node_modules/core-js/modules/_is-object.js"}],"../node_modules/core-js/modules/es6.reflect.set-prototype-of.js":[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_set-proto":"../node_modules/core-js/modules/_set-proto.js"}],"../node_modules/core-js/modules/es7.array.includes.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_export":"../node_modules/core-js/modules/_export.js","./_array-includes":"../node_modules/core-js/modules/_array-includes.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/_flatten-into-array.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_is-array":"../node_modules/core-js/modules/_is-array.js","./_is-object":"../node_modules/core-js/modules/_is-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_ctx":"../node_modules/core-js/modules/_ctx.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/modules/es7.array.flat-map.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_export":"../node_modules/core-js/modules/_export.js","./_flatten-into-array":"../node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_array-species-create":"../node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/es7.array.flatten.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_export":"../node_modules/core-js/modules/_export.js","./_flatten-into-array":"../node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_to-integer":"../node_modules/core-js/modules/_to-integer.js","./_array-species-create":"../node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"../node_modules/core-js/modules/_add-to-unscopables.js"}],"../node_modules/core-js/modules/es7.string.at.js":[function(require,module,exports) {
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_string-at":"../node_modules/core-js/modules/_string-at.js"}],"../node_modules/core-js/modules/_string-pad.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":"../node_modules/core-js/modules/_to-length.js","./_string-repeat":"../node_modules/core-js/modules/_string-repeat.js","./_defined":"../node_modules/core-js/modules/_defined.js"}],"../node_modules/core-js/modules/es7.string.pad-start.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_string-pad":"../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../node_modules/core-js/modules/_user-agent.js"}],"../node_modules/core-js/modules/es7.string.pad-end.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_string-pad":"../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../node_modules/core-js/modules/_user-agent.js"}],"../node_modules/core-js/modules/es7.string.trim-left.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":"../node_modules/core-js/modules/_string-trim.js"}],"../node_modules/core-js/modules/es7.string.trim-right.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":"../node_modules/core-js/modules/_string-trim.js"}],"../node_modules/core-js/modules/es7.string.match-all.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_defined":"../node_modules/core-js/modules/_defined.js","./_to-length":"../node_modules/core-js/modules/_to-length.js","./_is-regexp":"../node_modules/core-js/modules/_is-regexp.js","./_flags":"../node_modules/core-js/modules/_flags.js","./_iter-create":"../node_modules/core-js/modules/_iter-create.js"}],"../node_modules/core-js/modules/es7.symbol.async-iterator.js":[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":"../node_modules/core-js/modules/_wks-define.js"}],"../node_modules/core-js/modules/es7.symbol.observable.js":[function(require,module,exports) {
require('./_wks-define')('observable');

},{"./_wks-define":"../node_modules/core-js/modules/_wks-define.js"}],"../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_own-keys":"../node_modules/core-js/modules/_own-keys.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_create-property":"../node_modules/core-js/modules/_create-property.js"}],"../node_modules/core-js/modules/_object-to-array.js":[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_to-iobject":"../node_modules/core-js/modules/_to-iobject.js","./_object-pie":"../node_modules/core-js/modules/_object-pie.js"}],"../node_modules/core-js/modules/es7.object.values.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-to-array":"../node_modules/core-js/modules/_object-to-array.js"}],"../node_modules/core-js/modules/es7.object.entries.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_object-to-array":"../node_modules/core-js/modules/_object-to-array.js"}],"../node_modules/core-js/modules/_object-forced-pam.js":[function(require,module,exports) {
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_library":"../node_modules/core-js/modules/_library.js","./_fails":"../node_modules/core-js/modules/_fails.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/es7.object.define-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../node_modules/core-js/modules/_object-forced-pam.js"}],"../node_modules/core-js/modules/es7.object.define-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_object-dp":"../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../node_modules/core-js/modules/_object-forced-pam.js"}],"../node_modules/core-js/modules/es7.object.lookup-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../node_modules/core-js/modules/_object-forced-pam.js"}],"../node_modules/core-js/modules/es7.object.lookup-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_to-object":"../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../node_modules/core-js/modules/_object-forced-pam.js"}],"../node_modules/core-js/modules/_array-from-iterable.js":[function(require,module,exports) {
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":"../node_modules/core-js/modules/_for-of.js"}],"../node_modules/core-js/modules/_collection-to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_classof":"../node_modules/core-js/modules/_classof.js","./_array-from-iterable":"../node_modules/core-js/modules/_array-from-iterable.js"}],"../node_modules/core-js/modules/es7.map.to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_collection-to-json":"../node_modules/core-js/modules/_collection-to-json.js"}],"../node_modules/core-js/modules/es7.set.to-json.js":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_collection-to-json":"../node_modules/core-js/modules/_collection-to-json.js"}],"../node_modules/core-js/modules/_set-collection-of.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.map.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":"../node_modules/core-js/modules/_set-collection-of.js"}],"../node_modules/core-js/modules/es7.set.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":"../node_modules/core-js/modules/_set-collection-of.js"}],"../node_modules/core-js/modules/es7.weak-map.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":"../node_modules/core-js/modules/_set-collection-of.js"}],"../node_modules/core-js/modules/es7.weak-set.of.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":"../node_modules/core-js/modules/_set-collection-of.js"}],"../node_modules/core-js/modules/_set-collection-from.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_export":"../node_modules/core-js/modules/_export.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_ctx":"../node_modules/core-js/modules/_ctx.js","./_for-of":"../node_modules/core-js/modules/_for-of.js"}],"../node_modules/core-js/modules/es7.map.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":"../node_modules/core-js/modules/_set-collection-from.js"}],"../node_modules/core-js/modules/es7.set.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":"../node_modules/core-js/modules/_set-collection-from.js"}],"../node_modules/core-js/modules/es7.weak-map.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":"../node_modules/core-js/modules/_set-collection-from.js"}],"../node_modules/core-js/modules/es7.weak-set.from.js":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":"../node_modules/core-js/modules/_set-collection-from.js"}],"../node_modules/core-js/modules/es7.global.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/es7.system.global.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_global":"../node_modules/core-js/modules/_global.js"}],"../node_modules/core-js/modules/es7.error.is-error.js":[function(require,module,exports) {
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/es7.math.clamp.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.deg-per-rad.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.degrees.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/_math-scale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],"../node_modules/core-js/modules/es7.math.fscale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-scale":"../node_modules/core-js/modules/_math-scale.js","./_math-fround":"../node_modules/core-js/modules/_math-fround.js"}],"../node_modules/core-js/modules/es7.math.iaddh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.isubh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.imulh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.rad-per-deg.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.radians.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.scale.js":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_math-scale":"../node_modules/core-js/modules/_math-scale.js"}],"../node_modules/core-js/modules/es7.math.umulh.js":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.math.signbit.js":[function(require,module,exports) {
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":"../node_modules/core-js/modules/_export.js"}],"../node_modules/core-js/modules/es7.promise.finally.js":[function(require,module,exports) {

// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_core":"../node_modules/core-js/modules/_core.js","./_global":"../node_modules/core-js/modules/_global.js","./_species-constructor":"../node_modules/core-js/modules/_species-constructor.js","./_promise-resolve":"../node_modules/core-js/modules/_promise-resolve.js"}],"../node_modules/core-js/modules/es7.promise.try.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_new-promise-capability":"../node_modules/core-js/modules/_new-promise-capability.js","./_perform":"../node_modules/core-js/modules/_perform.js"}],"../node_modules/core-js/modules/_metadata.js":[function(require,module,exports) {
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./es6.map":"../node_modules/core-js/modules/es6.map.js","./_export":"../node_modules/core-js/modules/_export.js","./_shared":"../node_modules/core-js/modules/_shared.js","./es6.weak-map":"../node_modules/core-js/modules/es6.weak-map.js"}],"../node_modules/core-js/modules/es7.reflect.define-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es7.reflect.delete-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es7.reflect.get-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js"}],"../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":[function(require,module,exports) {
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./es6.set":"../node_modules/core-js/modules/es6.set.js","./_array-from-iterable":"../node_modules/core-js/modules/_array-from-iterable.js","./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js"}],"../node_modules/core-js/modules/es7.reflect.get-own-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es7.reflect.has-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_object-gpo":"../node_modules/core-js/modules/_object-gpo.js"}],"../node_modules/core-js/modules/es7.reflect.has-own-metadata.js":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js"}],"../node_modules/core-js/modules/es7.reflect.metadata.js":[function(require,module,exports) {
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_metadata":"../node_modules/core-js/modules/_metadata.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_a-function":"../node_modules/core-js/modules/_a-function.js"}],"../node_modules/core-js/modules/es7.asap.js":[function(require,module,exports) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_microtask":"../node_modules/core-js/modules/_microtask.js","./_global":"../node_modules/core-js/modules/_global.js","./_cof":"../node_modules/core-js/modules/_cof.js"}],"../node_modules/core-js/modules/es7.observable.js":[function(require,module,exports) {

'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_export":"../node_modules/core-js/modules/_export.js","./_global":"../node_modules/core-js/modules/_global.js","./_core":"../node_modules/core-js/modules/_core.js","./_microtask":"../node_modules/core-js/modules/_microtask.js","./_wks":"../node_modules/core-js/modules/_wks.js","./_a-function":"../node_modules/core-js/modules/_a-function.js","./_an-object":"../node_modules/core-js/modules/_an-object.js","./_an-instance":"../node_modules/core-js/modules/_an-instance.js","./_redefine-all":"../node_modules/core-js/modules/_redefine-all.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_for-of":"../node_modules/core-js/modules/_for-of.js","./_set-species":"../node_modules/core-js/modules/_set-species.js"}],"../node_modules/core-js/modules/web.timers.js":[function(require,module,exports) {

// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_global":"../node_modules/core-js/modules/_global.js","./_export":"../node_modules/core-js/modules/_export.js","./_user-agent":"../node_modules/core-js/modules/_user-agent.js"}],"../node_modules/core-js/modules/web.immediate.js":[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":"../node_modules/core-js/modules/_export.js","./_task":"../node_modules/core-js/modules/_task.js"}],"../node_modules/core-js/modules/web.dom.iterable.js":[function(require,module,exports) {

var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./es6.array.iterator":"../node_modules/core-js/modules/es6.array.iterator.js","./_object-keys":"../node_modules/core-js/modules/_object-keys.js","./_redefine":"../node_modules/core-js/modules/_redefine.js","./_global":"../node_modules/core-js/modules/_global.js","./_hide":"../node_modules/core-js/modules/_hide.js","./_iterators":"../node_modules/core-js/modules/_iterators.js","./_wks":"../node_modules/core-js/modules/_wks.js"}],"../node_modules/core-js/shim.js":[function(require,module,exports) {
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.exec');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/es6.symbol":"../node_modules/core-js/modules/es6.symbol.js","./modules/es6.object.create":"../node_modules/core-js/modules/es6.object.create.js","./modules/es6.object.define-property":"../node_modules/core-js/modules/es6.object.define-property.js","./modules/es6.object.define-properties":"../node_modules/core-js/modules/es6.object.define-properties.js","./modules/es6.object.get-own-property-descriptor":"../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","./modules/es6.object.get-prototype-of":"../node_modules/core-js/modules/es6.object.get-prototype-of.js","./modules/es6.object.keys":"../node_modules/core-js/modules/es6.object.keys.js","./modules/es6.object.get-own-property-names":"../node_modules/core-js/modules/es6.object.get-own-property-names.js","./modules/es6.object.freeze":"../node_modules/core-js/modules/es6.object.freeze.js","./modules/es6.object.seal":"../node_modules/core-js/modules/es6.object.seal.js","./modules/es6.object.prevent-extensions":"../node_modules/core-js/modules/es6.object.prevent-extensions.js","./modules/es6.object.is-frozen":"../node_modules/core-js/modules/es6.object.is-frozen.js","./modules/es6.object.is-sealed":"../node_modules/core-js/modules/es6.object.is-sealed.js","./modules/es6.object.is-extensible":"../node_modules/core-js/modules/es6.object.is-extensible.js","./modules/es6.object.assign":"../node_modules/core-js/modules/es6.object.assign.js","./modules/es6.object.is":"../node_modules/core-js/modules/es6.object.is.js","./modules/es6.object.set-prototype-of":"../node_modules/core-js/modules/es6.object.set-prototype-of.js","./modules/es6.object.to-string":"../node_modules/core-js/modules/es6.object.to-string.js","./modules/es6.function.bind":"../node_modules/core-js/modules/es6.function.bind.js","./modules/es6.function.name":"../node_modules/core-js/modules/es6.function.name.js","./modules/es6.function.has-instance":"../node_modules/core-js/modules/es6.function.has-instance.js","./modules/es6.parse-int":"../node_modules/core-js/modules/es6.parse-int.js","./modules/es6.parse-float":"../node_modules/core-js/modules/es6.parse-float.js","./modules/es6.number.constructor":"../node_modules/core-js/modules/es6.number.constructor.js","./modules/es6.number.to-fixed":"../node_modules/core-js/modules/es6.number.to-fixed.js","./modules/es6.number.to-precision":"../node_modules/core-js/modules/es6.number.to-precision.js","./modules/es6.number.epsilon":"../node_modules/core-js/modules/es6.number.epsilon.js","./modules/es6.number.is-finite":"../node_modules/core-js/modules/es6.number.is-finite.js","./modules/es6.number.is-integer":"../node_modules/core-js/modules/es6.number.is-integer.js","./modules/es6.number.is-nan":"../node_modules/core-js/modules/es6.number.is-nan.js","./modules/es6.number.is-safe-integer":"../node_modules/core-js/modules/es6.number.is-safe-integer.js","./modules/es6.number.max-safe-integer":"../node_modules/core-js/modules/es6.number.max-safe-integer.js","./modules/es6.number.min-safe-integer":"../node_modules/core-js/modules/es6.number.min-safe-integer.js","./modules/es6.number.parse-float":"../node_modules/core-js/modules/es6.number.parse-float.js","./modules/es6.number.parse-int":"../node_modules/core-js/modules/es6.number.parse-int.js","./modules/es6.math.acosh":"../node_modules/core-js/modules/es6.math.acosh.js","./modules/es6.math.asinh":"../node_modules/core-js/modules/es6.math.asinh.js","./modules/es6.math.atanh":"../node_modules/core-js/modules/es6.math.atanh.js","./modules/es6.math.cbrt":"../node_modules/core-js/modules/es6.math.cbrt.js","./modules/es6.math.clz32":"../node_modules/core-js/modules/es6.math.clz32.js","./modules/es6.math.cosh":"../node_modules/core-js/modules/es6.math.cosh.js","./modules/es6.math.expm1":"../node_modules/core-js/modules/es6.math.expm1.js","./modules/es6.math.fround":"../node_modules/core-js/modules/es6.math.fround.js","./modules/es6.math.hypot":"../node_modules/core-js/modules/es6.math.hypot.js","./modules/es6.math.imul":"../node_modules/core-js/modules/es6.math.imul.js","./modules/es6.math.log10":"../node_modules/core-js/modules/es6.math.log10.js","./modules/es6.math.log1p":"../node_modules/core-js/modules/es6.math.log1p.js","./modules/es6.math.log2":"../node_modules/core-js/modules/es6.math.log2.js","./modules/es6.math.sign":"../node_modules/core-js/modules/es6.math.sign.js","./modules/es6.math.sinh":"../node_modules/core-js/modules/es6.math.sinh.js","./modules/es6.math.tanh":"../node_modules/core-js/modules/es6.math.tanh.js","./modules/es6.math.trunc":"../node_modules/core-js/modules/es6.math.trunc.js","./modules/es6.string.from-code-point":"../node_modules/core-js/modules/es6.string.from-code-point.js","./modules/es6.string.raw":"../node_modules/core-js/modules/es6.string.raw.js","./modules/es6.string.trim":"../node_modules/core-js/modules/es6.string.trim.js","./modules/es6.string.iterator":"../node_modules/core-js/modules/es6.string.iterator.js","./modules/es6.string.code-point-at":"../node_modules/core-js/modules/es6.string.code-point-at.js","./modules/es6.string.ends-with":"../node_modules/core-js/modules/es6.string.ends-with.js","./modules/es6.string.includes":"../node_modules/core-js/modules/es6.string.includes.js","./modules/es6.string.repeat":"../node_modules/core-js/modules/es6.string.repeat.js","./modules/es6.string.starts-with":"../node_modules/core-js/modules/es6.string.starts-with.js","./modules/es6.string.anchor":"../node_modules/core-js/modules/es6.string.anchor.js","./modules/es6.string.big":"../node_modules/core-js/modules/es6.string.big.js","./modules/es6.string.blink":"../node_modules/core-js/modules/es6.string.blink.js","./modules/es6.string.bold":"../node_modules/core-js/modules/es6.string.bold.js","./modules/es6.string.fixed":"../node_modules/core-js/modules/es6.string.fixed.js","./modules/es6.string.fontcolor":"../node_modules/core-js/modules/es6.string.fontcolor.js","./modules/es6.string.fontsize":"../node_modules/core-js/modules/es6.string.fontsize.js","./modules/es6.string.italics":"../node_modules/core-js/modules/es6.string.italics.js","./modules/es6.string.link":"../node_modules/core-js/modules/es6.string.link.js","./modules/es6.string.small":"../node_modules/core-js/modules/es6.string.small.js","./modules/es6.string.strike":"../node_modules/core-js/modules/es6.string.strike.js","./modules/es6.string.sub":"../node_modules/core-js/modules/es6.string.sub.js","./modules/es6.string.sup":"../node_modules/core-js/modules/es6.string.sup.js","./modules/es6.date.now":"../node_modules/core-js/modules/es6.date.now.js","./modules/es6.date.to-json":"../node_modules/core-js/modules/es6.date.to-json.js","./modules/es6.date.to-iso-string":"../node_modules/core-js/modules/es6.date.to-iso-string.js","./modules/es6.date.to-string":"../node_modules/core-js/modules/es6.date.to-string.js","./modules/es6.date.to-primitive":"../node_modules/core-js/modules/es6.date.to-primitive.js","./modules/es6.array.is-array":"../node_modules/core-js/modules/es6.array.is-array.js","./modules/es6.array.from":"../node_modules/core-js/modules/es6.array.from.js","./modules/es6.array.of":"../node_modules/core-js/modules/es6.array.of.js","./modules/es6.array.join":"../node_modules/core-js/modules/es6.array.join.js","./modules/es6.array.slice":"../node_modules/core-js/modules/es6.array.slice.js","./modules/es6.array.sort":"../node_modules/core-js/modules/es6.array.sort.js","./modules/es6.array.for-each":"../node_modules/core-js/modules/es6.array.for-each.js","./modules/es6.array.map":"../node_modules/core-js/modules/es6.array.map.js","./modules/es6.array.filter":"../node_modules/core-js/modules/es6.array.filter.js","./modules/es6.array.some":"../node_modules/core-js/modules/es6.array.some.js","./modules/es6.array.every":"../node_modules/core-js/modules/es6.array.every.js","./modules/es6.array.reduce":"../node_modules/core-js/modules/es6.array.reduce.js","./modules/es6.array.reduce-right":"../node_modules/core-js/modules/es6.array.reduce-right.js","./modules/es6.array.index-of":"../node_modules/core-js/modules/es6.array.index-of.js","./modules/es6.array.last-index-of":"../node_modules/core-js/modules/es6.array.last-index-of.js","./modules/es6.array.copy-within":"../node_modules/core-js/modules/es6.array.copy-within.js","./modules/es6.array.fill":"../node_modules/core-js/modules/es6.array.fill.js","./modules/es6.array.find":"../node_modules/core-js/modules/es6.array.find.js","./modules/es6.array.find-index":"../node_modules/core-js/modules/es6.array.find-index.js","./modules/es6.array.species":"../node_modules/core-js/modules/es6.array.species.js","./modules/es6.array.iterator":"../node_modules/core-js/modules/es6.array.iterator.js","./modules/es6.regexp.constructor":"../node_modules/core-js/modules/es6.regexp.constructor.js","./modules/es6.regexp.exec":"../node_modules/core-js/modules/es6.regexp.exec.js","./modules/es6.regexp.to-string":"../node_modules/core-js/modules/es6.regexp.to-string.js","./modules/es6.regexp.flags":"../node_modules/core-js/modules/es6.regexp.flags.js","./modules/es6.regexp.match":"../node_modules/core-js/modules/es6.regexp.match.js","./modules/es6.regexp.replace":"../node_modules/core-js/modules/es6.regexp.replace.js","./modules/es6.regexp.search":"../node_modules/core-js/modules/es6.regexp.search.js","./modules/es6.regexp.split":"../node_modules/core-js/modules/es6.regexp.split.js","./modules/es6.promise":"../node_modules/core-js/modules/es6.promise.js","./modules/es6.map":"../node_modules/core-js/modules/es6.map.js","./modules/es6.set":"../node_modules/core-js/modules/es6.set.js","./modules/es6.weak-map":"../node_modules/core-js/modules/es6.weak-map.js","./modules/es6.weak-set":"../node_modules/core-js/modules/es6.weak-set.js","./modules/es6.typed.array-buffer":"../node_modules/core-js/modules/es6.typed.array-buffer.js","./modules/es6.typed.data-view":"../node_modules/core-js/modules/es6.typed.data-view.js","./modules/es6.typed.int8-array":"../node_modules/core-js/modules/es6.typed.int8-array.js","./modules/es6.typed.uint8-array":"../node_modules/core-js/modules/es6.typed.uint8-array.js","./modules/es6.typed.uint8-clamped-array":"../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","./modules/es6.typed.int16-array":"../node_modules/core-js/modules/es6.typed.int16-array.js","./modules/es6.typed.uint16-array":"../node_modules/core-js/modules/es6.typed.uint16-array.js","./modules/es6.typed.int32-array":"../node_modules/core-js/modules/es6.typed.int32-array.js","./modules/es6.typed.uint32-array":"../node_modules/core-js/modules/es6.typed.uint32-array.js","./modules/es6.typed.float32-array":"../node_modules/core-js/modules/es6.typed.float32-array.js","./modules/es6.typed.float64-array":"../node_modules/core-js/modules/es6.typed.float64-array.js","./modules/es6.reflect.apply":"../node_modules/core-js/modules/es6.reflect.apply.js","./modules/es6.reflect.construct":"../node_modules/core-js/modules/es6.reflect.construct.js","./modules/es6.reflect.define-property":"../node_modules/core-js/modules/es6.reflect.define-property.js","./modules/es6.reflect.delete-property":"../node_modules/core-js/modules/es6.reflect.delete-property.js","./modules/es6.reflect.enumerate":"../node_modules/core-js/modules/es6.reflect.enumerate.js","./modules/es6.reflect.get":"../node_modules/core-js/modules/es6.reflect.get.js","./modules/es6.reflect.get-own-property-descriptor":"../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","./modules/es6.reflect.get-prototype-of":"../node_modules/core-js/modules/es6.reflect.get-prototype-of.js","./modules/es6.reflect.has":"../node_modules/core-js/modules/es6.reflect.has.js","./modules/es6.reflect.is-extensible":"../node_modules/core-js/modules/es6.reflect.is-extensible.js","./modules/es6.reflect.own-keys":"../node_modules/core-js/modules/es6.reflect.own-keys.js","./modules/es6.reflect.prevent-extensions":"../node_modules/core-js/modules/es6.reflect.prevent-extensions.js","./modules/es6.reflect.set":"../node_modules/core-js/modules/es6.reflect.set.js","./modules/es6.reflect.set-prototype-of":"../node_modules/core-js/modules/es6.reflect.set-prototype-of.js","./modules/es7.array.includes":"../node_modules/core-js/modules/es7.array.includes.js","./modules/es7.array.flat-map":"../node_modules/core-js/modules/es7.array.flat-map.js","./modules/es7.array.flatten":"../node_modules/core-js/modules/es7.array.flatten.js","./modules/es7.string.at":"../node_modules/core-js/modules/es7.string.at.js","./modules/es7.string.pad-start":"../node_modules/core-js/modules/es7.string.pad-start.js","./modules/es7.string.pad-end":"../node_modules/core-js/modules/es7.string.pad-end.js","./modules/es7.string.trim-left":"../node_modules/core-js/modules/es7.string.trim-left.js","./modules/es7.string.trim-right":"../node_modules/core-js/modules/es7.string.trim-right.js","./modules/es7.string.match-all":"../node_modules/core-js/modules/es7.string.match-all.js","./modules/es7.symbol.async-iterator":"../node_modules/core-js/modules/es7.symbol.async-iterator.js","./modules/es7.symbol.observable":"../node_modules/core-js/modules/es7.symbol.observable.js","./modules/es7.object.get-own-property-descriptors":"../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","./modules/es7.object.values":"../node_modules/core-js/modules/es7.object.values.js","./modules/es7.object.entries":"../node_modules/core-js/modules/es7.object.entries.js","./modules/es7.object.define-getter":"../node_modules/core-js/modules/es7.object.define-getter.js","./modules/es7.object.define-setter":"../node_modules/core-js/modules/es7.object.define-setter.js","./modules/es7.object.lookup-getter":"../node_modules/core-js/modules/es7.object.lookup-getter.js","./modules/es7.object.lookup-setter":"../node_modules/core-js/modules/es7.object.lookup-setter.js","./modules/es7.map.to-json":"../node_modules/core-js/modules/es7.map.to-json.js","./modules/es7.set.to-json":"../node_modules/core-js/modules/es7.set.to-json.js","./modules/es7.map.of":"../node_modules/core-js/modules/es7.map.of.js","./modules/es7.set.of":"../node_modules/core-js/modules/es7.set.of.js","./modules/es7.weak-map.of":"../node_modules/core-js/modules/es7.weak-map.of.js","./modules/es7.weak-set.of":"../node_modules/core-js/modules/es7.weak-set.of.js","./modules/es7.map.from":"../node_modules/core-js/modules/es7.map.from.js","./modules/es7.set.from":"../node_modules/core-js/modules/es7.set.from.js","./modules/es7.weak-map.from":"../node_modules/core-js/modules/es7.weak-map.from.js","./modules/es7.weak-set.from":"../node_modules/core-js/modules/es7.weak-set.from.js","./modules/es7.global":"../node_modules/core-js/modules/es7.global.js","./modules/es7.system.global":"../node_modules/core-js/modules/es7.system.global.js","./modules/es7.error.is-error":"../node_modules/core-js/modules/es7.error.is-error.js","./modules/es7.math.clamp":"../node_modules/core-js/modules/es7.math.clamp.js","./modules/es7.math.deg-per-rad":"../node_modules/core-js/modules/es7.math.deg-per-rad.js","./modules/es7.math.degrees":"../node_modules/core-js/modules/es7.math.degrees.js","./modules/es7.math.fscale":"../node_modules/core-js/modules/es7.math.fscale.js","./modules/es7.math.iaddh":"../node_modules/core-js/modules/es7.math.iaddh.js","./modules/es7.math.isubh":"../node_modules/core-js/modules/es7.math.isubh.js","./modules/es7.math.imulh":"../node_modules/core-js/modules/es7.math.imulh.js","./modules/es7.math.rad-per-deg":"../node_modules/core-js/modules/es7.math.rad-per-deg.js","./modules/es7.math.radians":"../node_modules/core-js/modules/es7.math.radians.js","./modules/es7.math.scale":"../node_modules/core-js/modules/es7.math.scale.js","./modules/es7.math.umulh":"../node_modules/core-js/modules/es7.math.umulh.js","./modules/es7.math.signbit":"../node_modules/core-js/modules/es7.math.signbit.js","./modules/es7.promise.finally":"../node_modules/core-js/modules/es7.promise.finally.js","./modules/es7.promise.try":"../node_modules/core-js/modules/es7.promise.try.js","./modules/es7.reflect.define-metadata":"../node_modules/core-js/modules/es7.reflect.define-metadata.js","./modules/es7.reflect.delete-metadata":"../node_modules/core-js/modules/es7.reflect.delete-metadata.js","./modules/es7.reflect.get-metadata":"../node_modules/core-js/modules/es7.reflect.get-metadata.js","./modules/es7.reflect.get-metadata-keys":"../node_modules/core-js/modules/es7.reflect.get-metadata-keys.js","./modules/es7.reflect.get-own-metadata":"../node_modules/core-js/modules/es7.reflect.get-own-metadata.js","./modules/es7.reflect.get-own-metadata-keys":"../node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js","./modules/es7.reflect.has-metadata":"../node_modules/core-js/modules/es7.reflect.has-metadata.js","./modules/es7.reflect.has-own-metadata":"../node_modules/core-js/modules/es7.reflect.has-own-metadata.js","./modules/es7.reflect.metadata":"../node_modules/core-js/modules/es7.reflect.metadata.js","./modules/es7.asap":"../node_modules/core-js/modules/es7.asap.js","./modules/es7.observable":"../node_modules/core-js/modules/es7.observable.js","./modules/web.timers":"../node_modules/core-js/modules/web.timers.js","./modules/web.immediate":"../node_modules/core-js/modules/web.immediate.js","./modules/web.dom.iterable":"../node_modules/core-js/modules/web.dom.iterable.js","./modules/_core":"../node_modules/core-js/modules/_core.js"}],"../node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var global = arguments[3];
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

},{}],"../node_modules/core-js/modules/_replacer.js":[function(require,module,exports) {
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],"../node_modules/core-js/modules/core.regexp.escape.js":[function(require,module,exports) {
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":"../node_modules/core-js/modules/_export.js","./_replacer":"../node_modules/core-js/modules/_replacer.js"}],"../node_modules/core-js/fn/regexp/escape.js":[function(require,module,exports) {
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/core.regexp.escape":"../node_modules/core-js/modules/core.regexp.escape.js","../../modules/_core":"../node_modules/core-js/modules/_core.js"}],"../node_modules/babel-polyfill/lib/index.js":[function(require,module,exports) {
var global = arguments[3];

"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
},{"core-js/shim":"../node_modules/core-js/shim.js","regenerator-runtime/runtime":"../node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js","core-js/fn/regexp/escape":"../node_modules/core-js/fn/regexp/escape.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backend = on;
exports.buffer = ur;
exports.customGrad = oo;
exports.deprecationWarn = ze;
exports.disableDeprecationWarnings = Ve;
exports.dispose = Xe;
exports.disposeVariables = Ge;
exports.enableDebugMode = Ue;
exports.enableProdMode = We;
exports.engine = He;
exports.env = a;
exports.fill = Ln;
exports.findBackend = en;
exports.findBackendFactory = nn;
exports.getBackend = Ze;
exports.getKernel = s;
exports.getKernelsForBackend = c;
exports.grad = Zr;
exports.grads = to;
exports.keep = $e;
exports.linspace = Wn;
exports.memory = qe;
exports.nextFrame = np;
exports.ones = Bn;
exports.op = Cn;
exports.print = sr;
exports.profile = Ke;
exports.range = Un;
exports.ready = Je;
exports.registerBackend = rn;
exports.registerKernel = l;
exports.removeBackend = tn;
exports.scalar = An;
exports.setBackend = Qe;
exports.setPlatform = an;
exports.tensor = kn;
exports.tensor1d = Dn;
exports.tensor2d = Tn;
exports.tensor3d = Nn;
exports.tensor4d = Fn;
exports.tensor5d = On;
exports.tensor6d = _n;
exports.tidy = je;
exports.time = Ye;
exports.unregisterKernel = h;
exports.valueAndGrad = eo;
exports.valueAndGrads = no;
exports.variable = Mn;
exports.variableGrads = ro;
exports.zeros = Pn;
exports.irfft = exports.io = exports.inTopKAsync = exports.image = exports.imag = exports.ifft = exports.hannWindow = exports.hammingWindow = exports.greaterStrict = exports.greaterEqualStrict = exports.greaterEqual = exports.greater = exports.gatherND = exports.gather = exports.fused = exports.frame = exports.floorDiv = exports.floor = exports.fft = exports.eye = exports.expm1 = exports.expandDims = exports.exp = exports.erf = exports.equalStrict = exports.equal = exports.elu = exports.dropout = exports.dot = exports.divStrict = exports.divNoNan = exports.div = exports.diag = exports.depthwiseConv2d = exports.depthToSpace = exports.cumsum = exports.cosh = exports.cos = exports.conv3dTranspose = exports.conv3d = exports.conv2dTranspose = exports.conv2d = exports.conv1d = exports.concat4d = exports.concat3d = exports.concat2d = exports.concat1d = exports.concat = exports.complex = exports.clone = exports.clipByValue = exports.ceil = exports.cast = exports.browser = exports.booleanMaskAsync = exports.batchToSpaceND = exports.batchNormalization4d = exports.batchNormalization3d = exports.batchNormalization2d = exports.batchNormalization = exports.batchNorm4d = exports.batchNorm3d = exports.batchNorm2d = exports.batchNorm = exports.basicLSTMCell = exports.backend_util = exports.avgPool3d = exports.avgPool = exports.atanh = exports.atan2 = exports.atan = exports.asinh = exports.asin = exports.argMin = exports.argMax = exports.any = exports.all = exports.addStrict = exports.addN = exports.add = exports.acosh = exports.acos = exports.abs = exports.Variable = exports.TensorBuffer = exports.Tensor = exports.SGDOptimizer = exports.Reduction = exports.Rank = exports.RMSPropOptimizer = exports.Optimizer = exports.MomentumOptimizer = exports.KernelBackend = exports.Environment = exports.ENV = exports.DataStorage = exports.AdamaxOptimizer = exports.AdamOptimizer = exports.AdagradOptimizer = exports.AdadeltaOptimizer = void 0;
exports.squeeze = exports.squaredDifferenceStrict = exports.squaredDifference = exports.square = exports.sqrt = exports.split = exports.spectral = exports.sparseToDense = exports.spaceToBatchND = exports.softplus = exports.softmax = exports.slice_util = exports.slice4d = exports.slice3d = exports.slice2d = exports.slice1d = exports.slice = exports.sinh = exports.sin = exports.signal = exports.sign = exports.sigmoid = exports.setdiff1dAsync = exports.serialization = exports.separableConv2d = exports.selu = exports.scatterND = exports.rsqrt = exports.round = exports.rfft = exports.reverse4d = exports.reverse3d = exports.reverse2d = exports.reverse1d = exports.reverse = exports.reshape = exports.relu6 = exports.relu = exports.reciprocal = exports.real = exports.randomUniform = exports.randomNormal = exports.randomGamma = exports.rand = exports.prod = exports.prelu = exports.powStrict = exports.pow = exports.pool = exports.pad4d = exports.pad3d = exports.pad2d = exports.pad1d = exports.pad = exports.outerProduct = exports.onesLike = exports.oneHot = exports.notEqualStrict = exports.notEqual = exports.norm = exports.neg = exports.multinomial = exports.multiRNNCell = exports.mulStrict = exports.mul = exports.movingAverage = exports.moments = exports.modStrict = exports.mod = exports.minimumStrict = exports.minimum = exports.min = exports.mean = exports.maximumStrict = exports.maximum = exports.maxPool3d = exports.maxPool = exports.max = exports.math = exports.matMul = exports.losses = exports.logicalXor = exports.logicalOr = exports.logicalNot = exports.logicalAnd = exports.logSumExp = exports.logSoftmax = exports.logSigmoid = exports.log1p = exports.log = exports.localResponseNormalization = exports.linalg = exports.lessStrict = exports.lessEqualStrict = exports.lessEqual = exports.less = exports.leakyRelu = exports.isNaN = exports.isInf = exports.isFinite = void 0;
exports.zerosLike = exports.whereAsync = exports.where = exports.webgl = exports.version_core = exports.util = exports.unstack = exports.unsortedSegmentSum = exports.truncatedNormal = exports.transpose = exports.train = exports.topk = exports.tile = exports.test_util = exports.tensor_util = exports.tanh = exports.tan = exports.sum = exports.subStrict = exports.sub = exports.stridedSlice = exports.stft = exports.step = exports.stack = void 0;

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t = function (e, n) {
  return (t = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (t, e) {
    t.__proto__ = e;
  } || function (t, e) {
    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  })(e, n);
};

function e(e, n) {
  function r() {
    this.constructor = e;
  }

  t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());
}

function n(t, e, n, r) {
  return new (n || (n = Promise))(function (o, a) {
    function i(t) {
      try {
        s(r.next(t));
      } catch (t) {
        a(t);
      }
    }

    function u(t) {
      try {
        s(r.throw(t));
      } catch (t) {
        a(t);
      }
    }

    function s(t) {
      t.done ? o(t.value) : new n(function (e) {
        e(t.value);
      }).then(i, u);
    }

    s((r = r.apply(t, e || [])).next());
  });
}

function r(t, e) {
  var n,
      r,
      o,
      a,
      i = {
    label: 0,
    sent: function () {
      if (1 & o[0]) throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return a = {
    next: u(0),
    throw: u(1),
    return: u(2)
  }, "function" == typeof Symbol && (a[Symbol.iterator] = function () {
    return this;
  }), a;

  function u(a) {
    return function (u) {
      return function (a) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; i;) try {
          if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;

          switch (r = 0, o && (a = [2 & a[0], o.value]), a[0]) {
            case 0:
            case 1:
              o = a;
              break;

            case 4:
              return i.label++, {
                value: a[1],
                done: !1
              };

            case 5:
              i.label++, r = a[1], a = [0];
              continue;

            case 7:
              a = i.ops.pop(), i.trys.pop();
              continue;

            default:
              if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {
                i = 0;
                continue;
              }

              if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                i.label = a[1];
                break;
              }

              if (6 === a[0] && i.label < o[1]) {
                i.label = o[1], o = a;
                break;
              }

              if (o && i.label < o[2]) {
                i.label = o[2], i.ops.push(a);
                break;
              }

              o[2] && i.ops.pop(), i.trys.pop();
              continue;
          }

          a = e.call(t, i);
        } catch (t) {
          a = [6, t], r = 0;
        } finally {
          n = o = 0;
        }

        if (5 & a[0]) throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        };
      }([a, u]);
    };
  }
}

var o = function () {
  function t(t) {
    this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }

  return t.prototype.setPlatform = function (t, e) {
    null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e + "."), this.platformName = t, this.platform = e;
  }, t.prototype.registerFlag = function (t, e, n) {
    if (this.flagRegistry[t] = {
      evaluationFn: e,
      setHook: n
    }, null != this.urlFlags[t]) {
      var r = this.urlFlags[t];
      console.warn("Setting feature override from URL " + t + ": " + r + "."), this.set(t, r);
    }
  }, t.prototype.get = function (t) {
    return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t]);
  }, t.prototype.getNumber = function (t) {
    return this.get(t);
  }, t.prototype.getBool = function (t) {
    return this.get(t);
  }, t.prototype.getFlags = function () {
    return this.flags;
  }, Object.defineProperty(t.prototype, "features", {
    get: function () {
      return this.flags;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.set = function (t, e) {
    if (null == this.flagRegistry[t]) throw new Error("Cannot set flag " + t + " as it has not been registered.");
    this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e);
  }, t.prototype.evaluateFlag = function (t) {
    if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.");
    return this.flagRegistry[t].evaluationFn();
  }, t.prototype.setFlags = function (t) {
    this.flags = Object.assign({}, t);
  }, t.prototype.reset = function () {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, t.prototype.populateURLFlags = function () {
    var t = this;

    if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
      var e,
          n,
          r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
        for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];

        return function (t, e, n) {
          t[decodeURIComponent(e)] = decodeURIComponent(n || "");
        }(n, e[0], e[1]), e.join("=");
      }), n);
      if ("tfjsflags" in r) r.tfjsflags.split(",").forEach(function (e) {
        var n = e.split(":"),
            r = n[0],
            o = n[1];

        t.urlFlags[r] = function (t, e) {
          if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
          if ("" + +e === e) return +e;
          throw new Error("Could not parse value flag value " + e + " for flag " + t + ".");
        }(r, o);
      });
    }
  }, t;
}();

exports.Environment = o;

function a() {
  return i;
}

var i = null;
exports.ENV = i;
var u = new Map();

function s(t, e) {
  var n = f(t, e);
  return u.get(n);
}

function c(t) {
  for (var e = u.entries(), n = [];;) {
    var r = e.next(),
        o = r.done,
        a = r.value;
    if (o) break;
    var i = a[0],
        s = a[1];
    i.split("_")[0] === t && n.push(s);
  }

  return n;
}

function l(t) {
  var e = t.kernelName,
      n = t.backendName,
      r = f(e, n);
  if (u.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered");
  u.set(r, t);
}

function h(t, e) {
  var n = f(t, e);
  if (!u.has(n)) throw new Error("The kernel '" + t + "' for backend '" + e + "' is not registered");
  u.delete(n);
}

function f(t, e) {
  return e + "_" + t;
}

function p(t) {
  for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n;
}

function d(t, e, n) {
  return Math.max(t, Math.min(e, n));
}

function v(t) {
  return t % 2 == 0 ? t : t + 1;
}

function m(t) {
  for (var e = 0, n = 0; n < t.length; n++) e += t[n];

  return e;
}

function g(t, e) {
  if (!t) throw new Error("string" == typeof e ? e : e());
}

function y(t, e, n) {
  void 0 === n && (n = ""), g(C(t, e), function () {
    return n + " Shapes " + t + " and " + e + " must match";
  });
}

function x(t) {
  g(null != t, function () {
    return "The input to the tensor constructor must be a non-null value.";
  });
}

function b(t, e, n) {
  if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || B(t) && !n) for (var r = 0; r < t.length; ++r) b(t[r], e, n);else e.push(t);
  return e;
}

function w(t) {
  if (0 === t.length) return 1;

  for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];

  return e;
}

function C(t, e) {
  if (t === e) return !0;
  if (null == t || null == e) return !1;
  if (t.length !== e.length) return !1;

  for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;

  return !0;
}

function E(t) {
  return t % 1 == 0;
}

function R(t) {
  if (null != Math.tanh) return Math.tanh(t);
  if (t === 1 / 0) return 1;
  if (t === -1 / 0) return -1;
  var e = Math.exp(2 * t);
  return (e - 1) / (e + 1);
}

function I(t) {
  var e = Math.ceil(Math.sqrt(t));
  return [e, Math.ceil(t / e)];
}

function k(t, e) {
  return e <= t.length ? t : t + " ".repeat(e - t.length);
}

function S(t, e, n) {
  return void 0 === e && (e = function (t) {
    return 0;
  }), new Promise(function (r, o) {
    var a = 0,
        i = function () {
      if (t()) r();else {
        var u = e(++a);
        null != n && a >= n ? o() : setTimeout(i, u);
      }
    };

    i();
  });
}

function A(t, e) {
  for (var n = 1, r = -1, o = 0; o < t.length; ++o) if (t[o] >= 0) n *= t[o];else if (-1 === t[o]) {
    if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + o);
    r = o;
  } else if (t[o] < 0) throw Error("Shapes can not be < 0. Found " + t[o] + " at dim " + o);

  if (-1 === r) {
    if (e > 0 && e !== n) throw Error("Size(" + e + ") must match the product of shape " + t);
    return t;
  }

  if (0 === n) throw Error("Cannot infer the missing size in [" + t + "] when there are 0 elements");
  if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + n);
  var a = t.slice();
  return a[r] = e / n, a;
}

function D(t, e) {
  var n = e.length;
  return g((t = null == t ? e.map(function (t, e) {
    return e;
  }) : [].concat(t)).every(function (t) {
    return t >= -n && t < n;
  }), function () {
    return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + t;
  }), g(t.every(function (t) {
    return E(t);
  }), function () {
    return "All values in axis param must be integers but got axis " + t;
  }), t.map(function (t) {
    return t < 0 ? n + t : t;
  });
}

function T(t, e) {
  for (var n = [], r = [], o = null != e && Array.isArray(e) && 0 === e.length, a = null == e || o ? null : D(e, t).sort(), i = 0, u = 0; u < t.length; ++u) {
    if (null != a) {
      if (a[i] === u && 1 !== t[u]) throw new Error("Can't squeeze axis " + u + " since its dim '" + t[u] + "' is not 1");
      (null == a[i] || a[i] > u) && 1 === t[u] && (n.push(t[u]), r.push(u)), a[i] <= u && i++;
    }

    1 !== t[u] && (n.push(t[u]), r.push(u));
  }

  return {
    newShape: n,
    keptDims: r
  };
}

function N(t, e) {
  var n = null;
  if (null == t || "float32" === t) n = new Float32Array(e);else if ("int32" === t) n = new Int32Array(e);else {
    if ("bool" !== t) throw new Error("Unknown data type " + t);
    n = new Uint8Array(e);
  }
  return n;
}

function F(t, e) {
  var n = null;
  if (null == t || "float32" === t) n = new Float32Array(e);else if ("int32" === t) n = new Int32Array(e);else if ("bool" === t) n = new Uint8Array(e);else {
    if ("string" !== t) throw new Error("Unknown data type " + t);
    n = new Array(e);
  }
  return n;
}

function O(t, e) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".");
  }
}

function _(t) {
  return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t;
}

function M(t, e) {
  return "complex64" !== e && ("float32" !== e || "complex64" === t) && ("int32" !== e || "float32" === t || "complex64" === t) && ("bool" !== e || "bool" !== t);
}

function B(t) {
  return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array;
}

function P(t) {
  if ("float32" === t || "int32" === t) return 4;
  if ("complex64" === t) return 8;
  if ("bool" === t) return 1;
  throw new Error("Unknown dtype " + t);
}

function L(t) {
  if (null == t) return 0;
  var e = 0;
  return t.forEach(function (t) {
    return e += t.length;
  }), e;
}

function W(t) {
  return "string" == typeof t || t instanceof String;
}

function U(t) {
  return "boolean" == typeof t;
}

function V(t) {
  return "number" == typeof t;
}

function z(t) {
  return Array.isArray(t) ? z(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : V(t) ? "float32" : W(t) ? "string" : U(t) ? "bool" : "float32";
}

function G(t) {
  return !!(t && t.constructor && t.call && t.apply);
}

function H(t, e) {
  for (var n = e; n < t; ++n) if (t % n == 0) return n;

  return t;
}

function q(t) {
  var e = t.length;
  if (e < 2) return [];
  var n = new Array(e - 1);
  n[e - 2] = t[e - 1];

  for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];

  return n;
}

function K(t, e, n) {
  if ("string" === e) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t) && (t = b(t)), n && O(t, e), function (t, e) {
    return t instanceof Float32Array && "float32" === e || t instanceof Int32Array && "int32" === e || t instanceof Uint8Array && "bool" === e;
  }(t, e)) return t;
  if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
  if ("int32" === e) return new Int32Array(t);

  if ("bool" === e) {
    for (var r = new Uint8Array(t.length), o = 0; o < r.length; ++o) 0 !== Math.round(t[o]) && (r[o] = 1);

    return r;
  }

  throw new Error("Unknown data type " + e);
}

function j(t, e) {
  if (0 === t.length) return e[0];
  var n = t.reduce(function (t, e) {
    return t * e;
  });
  if (0 === n) return [];
  if (n !== e.length) throw new Error("[" + t + "] does not match the input size.");
  return function t(e, n, r) {
    var o = new Array();
    if (1 === n.length) for (var a = n[0], i = 0; i < a; i++) o[i] = r[e + i];else {
      a = n[0];
      var u = n.slice(1),
          s = u.reduce(function (t, e) {
        return t * e;
      });

      for (i = 0; i < a; i++) o[i] = t(e + i * s, u, r);
    }
    return o;
  }(0, t, e);
}

function X(t, e) {
  for (var n = $(t, e), r = 0; r < n.length; r++) n[r] = 1;

  return n;
}

function $(t, e) {
  if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
  if ("int32" === e) return new Int32Array(t);
  if ("bool" === e) return new Uint8Array(t);
  throw new Error("Unknown data type " + e);
}

function Y() {
  return a().platform.now();
}

function Q(t) {
  t.forEach(function (e) {
    g(Number.isInteger(e) && e >= 0, function () {
      return "Tensor must have a shape comprised of positive integers but got shape [" + t + "].";
    });
  });
}

function J(t, e) {
  return void 0 === e && (e = "utf-8"), e = e || "utf-8", a().platform.encode(t, e);
}

function Z(t, e) {
  return void 0 === e && (e = "utf-8"), e = e || "utf-8", a().platform.decode(t, e);
}

var tt = Object.freeze({
  shuffle: p,
  clamp: d,
  nearestLargerEven: v,
  sum: m,
  randUniform: function (t, e) {
    var n = Math.random();
    return e * n + (1 - n) * t;
  },
  distSquared: function (t, e) {
    for (var n = 0, r = 0; r < t.length; r++) {
      var o = Number(t[r]) - Number(e[r]);
      n += o * o;
    }

    return n;
  },
  assert: g,
  assertShapesMatch: y,
  assertNonNull: x,
  flatten: b,
  sizeFromShape: w,
  isScalarShape: function (t) {
    return 0 === t.length;
  },
  arraysEqual: C,
  isInt: E,
  tanh: R,
  sizeToSquarishShape: I,
  createShuffledIndices: function (t) {
    for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;

    return p(e), e;
  },
  rightPad: k,
  repeatedTry: S,
  inferFromImplicitShape: A,
  parseAxisParam: D,
  squeezeShape: T,
  getTypedArrayFromDType: N,
  getArrayFromDType: F,
  checkConversionForErrors: O,
  isValidDtype: _,
  hasEncodingLoss: M,
  isTypedArray: B,
  bytesPerElement: P,
  bytesFromStringArray: L,
  isString: W,
  isBoolean: U,
  isNumber: V,
  inferDtype: z,
  isFunction: G,
  nearestDivisor: H,
  computeStrides: q,
  toTypedArray: K,
  toNestedArray: j,
  makeOnesTypedArray: X,
  makeZerosTypedArray: $,
  now: Y,
  assertNonNegativeIntegerDimensions: Q,
  fetch: function (t, e) {
    return a().platform.fetch(t, e);
  },
  encodeString: J,
  decodeString: Z
}),
    et = function () {
  function t(t, e) {
    this.backendTimer = t, this.logger = e, null == e && (this.logger = new nt());
  }

  return t.prototype.profileKernel = function (t, e, n) {
    var r,
        o = this,
        a = this.backendTimer.time(function () {
      r = n();
    });
    return r.forEach(function (n) {
      n.data().then(function (r) {
        !function (t, e, n) {
          if ("float32" !== e) return !1;

          for (var r = 0; r < t.length; r++) {
            var o = t[r];
            if (isNaN(o) || !isFinite(o)) return console.warn("Found " + o + " in the result of '" + n + "'"), !0;
          }
        }(r, n.dtype, t), a.then(function (a) {
          var i = "";
          null != a.getExtraProfileInfo && (i = a.getExtraProfileInfo()), o.logger.logKernelProfile(t, n, r, a.kernelMs, e, i);
        });
      });
    }), r;
  }, t;
}();

exports.util = tt;

var nt = function () {
  function t() {}

  return t.prototype.logKernelProfile = function (t, e, n, r, o, a) {
    var i = k(r + "ms", 9),
        u = k(t, 25),
        s = e.rank,
        c = e.size,
        l = k(e.shape.toString(), 14),
        h = "";

    for (var f in o) {
      var p = o[f].shape,
          d = p.length;
      h += f + ": " + d + "D " + (d > 0 ? p : "") + " ";
    }

    console.log("%c" + u + "\t%c" + i + "\t%c" + s + "D " + l + "\t%c" + c + "\t%c" + h + "\t%c" + a, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, t;
}();

var rt = 20,
    ot = 3,
    at = 7;

function it(t, e, n, r) {
  var o = q(e),
      a = function (t, e, n, r) {
    var o = w(e),
        a = r[r.length - 1],
        i = new Array(a).fill(0),
        u = e.length,
        s = "complex64" === n ? ct(t) : t;
    if (u > 1) for (var c = 0; c < o / a; c++) for (var l = c * a, h = 0; h < a; h++) i[h] = Math.max(i[h], ut(s[l + h], 0, n).length);
    return i;
  }(t, e, n, o),
      i = e.length,
      u = function t(e, n, r, o, a, i) {
    void 0 === i && (i = !0);
    var u = "complex64" === r ? 2 : 1;
    var s = n[0];
    var c = n.length;

    if (0 === c) {
      if ("complex64" === r) {
        var l = ct(e);
        return [ut(l[0], 0, r)];
      }

      return "bool" === r ? [st(e[0])] : [e[0].toString()];
    }

    if (1 === c) {
      if (s > rt) {
        var h = ot * u,
            f = Array.from(e.slice(0, h)),
            p = Array.from(e.slice((s - ot) * u, s * u));
        return "complex64" === r && (f = ct(f), p = ct(p)), ["[" + f.map(function (t, e) {
          return ut(t, a[e], r);
        }).join(", ") + ", ..., " + p.map(function (t, e) {
          return ut(t, a[s - ot + e], r);
        }).join(", ") + "]"];
      }

      var d = "complex64" === r ? ct(e) : Array.from(e);
      return ["[" + d.map(function (t, e) {
        return ut(t, a[e], r);
      }).join(", ") + "]"];
    }

    var v = n.slice(1);
    var m = o.slice(1);
    var g = o[0] * u;
    var y = [];

    if (s > rt) {
      for (var x = 0; x < ot; x++) {
        var b = x * g,
            w = b + g;
        y.push.apply(y, t(e.slice(b, w), v, r, m, a, !1));
      }

      y.push("...");

      for (var x = s - ot; x < s; x++) {
        var b = x * g,
            w = b + g;
        y.push.apply(y, t(e.slice(b, w), v, r, m, a, x === s - 1));
      }
    } else for (var x = 0; x < s; x++) {
      var b = x * g,
          w = b + g;
      y.push.apply(y, t(e.slice(b, w), v, r, m, a, x === s - 1));
    }

    var C = 2 === c ? "," : "";
    y[0] = "[" + y[0] + C;

    for (var x = 1; x < y.length - 1; x++) y[x] = " " + y[x] + C;

    var E = ",\n";

    for (var x = 2; x < c; x++) E += "\n";

    y[y.length - 1] = " " + y[y.length - 1] + "]" + (i ? "" : E);
    return y;
  }(t, e, n, o, a),
      s = ["Tensor"];

  return r && (s.push("  dtype: " + n), s.push("  rank: " + i), s.push("  shape: [" + e + "]"), s.push("  values:")), s.push(u.map(function (t) {
    return "    " + t;
  }).join("\n")), s.join("\n");
}

function ut(t, e, n) {
  return k(Array.isArray(t) ? parseFloat(t[0].toFixed(at)) + " + " + parseFloat(t[1].toFixed(at)) + "j" : W(t) ? "'" + t + "'" : "bool" === n ? st(t) : parseFloat(t.toFixed(at)).toString(), e);
}

function st(t) {
  return 0 === t ? "false" : "true";
}

function ct(t) {
  for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);

  return e;
}

var lt = function () {
  function t(t, e, n) {
    var r = this;

    if (this.dtype = e, this.shape = t.slice(), this.size = w(t), null != n) {
      var o = n.length;
      g(o === this.size, function () {
        return "Length of values '" + o + "' does not match the size inferred by the shape '" + r.size + "'.";
      });
    }

    if ("complex64" === e) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n || F(e, this.size), this.strides = q(t);
  }

  return t.prototype.set = function (t) {
    for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];

    0 === n.length && (n = [0]), g(n.length === this.rank, function () {
      return "The number of provided coordinates (" + n.length + ") must match the rank (" + e.rank + ")";
    });
    var o = this.locToIndex(n);
    this.values[o] = t;
  }, t.prototype.get = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

    0 === t.length && (t = [0]);

    for (var n = 0, r = 0, o = t; r < o.length; r++) {
      var a = o[r];

      if (a < 0 || a >= this.shape[n]) {
        var i = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
        throw new Error(i);
      }

      n++;
    }

    for (var u = t[t.length - 1], s = 0; s < t.length - 1; ++s) u += this.strides[s] * t[s];

    return this.values[u];
  }, t.prototype.locToIndex = function (t) {
    if (0 === this.rank) return 0;
    if (1 === this.rank) return t[0];

    for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];

    return e;
  }, t.prototype.indexToLoc = function (t) {
    if (0 === this.rank) return [];
    if (1 === this.rank) return [t];

    for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];

    return e[e.length - 1] = t, e;
  }, Object.defineProperty(t.prototype, "rank", {
    get: function () {
      return this.shape.length;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.toTensor = function () {
    return ht().makeTensor(this.values, this.shape, this.dtype);
  }, t;
}(),
    ht = null,
    ft = null,
    pt = null;

exports.TensorBuffer = lt;

var dt = function () {
  function t(t, e, n, r) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || "float32", this.size = w(t), this.strides = q(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }

  return t.prototype.flatten = function () {
    return this.throwIfDisposed(), this.as1D();
  }, t.prototype.asScalar = function () {
    return this.throwIfDisposed(), g(1 === this.size, function () {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, t.prototype.as1D = function () {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, t.prototype.as2D = function (t, e) {
    return this.throwIfDisposed(), this.reshape([t, e]);
  }, t.prototype.as3D = function (t, e, n) {
    return this.throwIfDisposed(), this.reshape([t, e, n]);
  }, t.prototype.as4D = function (t, e, n, r) {
    return this.throwIfDisposed(), this.reshape([t, e, n, r]);
  }, t.prototype.as5D = function (t, e, n, r, o) {
    return this.throwIfDisposed(), this.reshape([t, e, n, r, o]);
  }, t.prototype.asType = function (t) {
    return this.throwIfDisposed(), ft.cast(this, t);
  }, Object.defineProperty(t.prototype, "rank", {
    get: function () {
      return this.shape.length;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.buffer = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.data()];

          case 1:
            return t = e.sent(), [2, ft.buffer(this.shape, this.dtype, t)];
        }
      });
    });
  }, t.prototype.bufferSync = function () {
    return ft.buffer(this.shape, this.dtype, this.dataSync());
  }, t.prototype.array = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.data()];

          case 1:
            return t = e.sent(), [2, j(this.shape, t)];
        }
      });
    });
  }, t.prototype.arraySync = function () {
    return j(this.shape, this.dataSync());
  }, t.prototype.data = function () {
    return n(this, void 0, void 0, function () {
      var t, e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return this.throwIfDisposed(), t = ht().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t];

          case 1:
            e = n.sent();

            try {
              return [2, e.map(function (t) {
                return Z(t);
              })];
            } catch (t) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }

            n.label = 2;

          case 2:
            return [2, t];
        }
      });
    });
  }, t.prototype.dataSync = function () {
    this.throwIfDisposed();
    var t = ht().readSync(this.dataId);
    if ("string" === this.dtype) try {
      return t.map(function (t) {
        return Z(t);
      });
    } catch (t) {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return t;
  }, t.prototype.bytes = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return this.throwIfDisposed(), [4, ht().read(this.dataId)];

          case 1:
            return t = e.sent(), "string" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)];
        }
      });
    });
  }, t.prototype.dispose = function () {
    this.isDisposed || (ht().disposeTensor(this), this.isDisposedInternal = !0);
  }, Object.defineProperty(t.prototype, "isDisposed", {
    get: function () {
      return this.isDisposedInternal;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.throwIfDisposed = function () {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }, t.prototype.toFloat = function () {
    return this.asType("float32");
  }, t.prototype.toInt = function () {
    return this.asType("int32");
  }, t.prototype.toBool = function () {
    return this.asType("bool");
  }, t.prototype.print = function (t) {
    return void 0 === t && (t = !1), ft.print(this, t);
  }, t.prototype.reshape = function (t) {
    return this.throwIfDisposed(), ft.reshape(this, t);
  }, t.prototype.reshapeAs = function (t) {
    return this.throwIfDisposed(), this.reshape(t.shape);
  }, t.prototype.expandDims = function (t) {
    return void 0 === t && (t = 0), ft.expandDims(this, t);
  }, t.prototype.cumsum = function (t, e, n) {
    return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), ft.cumsum(this, t, e, n);
  }, t.prototype.squeeze = function (t) {
    return this.throwIfDisposed(), ft.squeeze(this, t);
  }, t.prototype.clone = function () {
    return this.throwIfDisposed(), ft.clone(this);
  }, t.prototype.oneHot = function (t, e, n) {
    return this.throwIfDisposed(), ft.oneHot(this, t, e, n);
  }, t.prototype.toString = function (t) {
    return void 0 === t && (t = !1), it(this.dataSync(), this.shape, this.dtype, t);
  }, t.prototype.tile = function (t) {
    return this.throwIfDisposed(), ft.tile(this, t);
  }, t.prototype.gather = function (t, e) {
    return void 0 === e && (e = 0), this.throwIfDisposed(), ft.gather(this, t, e);
  }, t.prototype.matMul = function (t, e, n) {
    return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), ft.matMul(this, t, e, n);
  }, t.prototype.dot = function (t) {
    return this.throwIfDisposed(), ft.dot(this, t);
  }, t.prototype.norm = function (t, e, n) {
    return void 0 === t && (t = "euclidean"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), ft.norm(this, t, e, n);
  }, t.prototype.slice = function (t, e) {
    return this.throwIfDisposed(), ft.slice(this, t, e);
  }, t.prototype.reverse = function (t) {
    return this.throwIfDisposed(), ft.reverse(this, t);
  }, t.prototype.concat = function (e, n) {
    return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), ft.concat([this].concat(e), n);
  }, t.prototype.split = function (t, e) {
    return void 0 === e && (e = 0), this.throwIfDisposed(), ft.split(this, t, e);
  }, t.prototype.stack = function (t, e) {
    return void 0 === e && (e = 0), ft.stack([this, t], e);
  }, t.prototype.unstack = function (t) {
    return void 0 === t && (t = 0), ft.unstack(this, t);
  }, t.prototype.pad = function (t, e) {
    return void 0 === e && (e = 0), ft.pad(this, t, e);
  }, t.prototype.batchNormalization = function (t, e, n, r, o) {
    return void 0 === n && (n = .001), pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t, e, o, r, n);
  }, t.prototype.batchNorm = function (t, e, n, r, o) {
    return void 0 === o && (o = .001), this.throwIfDisposed(), ft.batchNorm(this, t, e, n, r, o);
  }, t.prototype.all = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.all(this, t, e);
  }, t.prototype.any = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.any(this, t, e);
  }, t.prototype.logSumExp = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.logSumExp(this, t, e);
  }, t.prototype.sum = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.sum(this, t, e);
  }, t.prototype.prod = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.prod(this, t, e);
  }, t.prototype.mean = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.mean(this, t, e);
  }, t.prototype.min = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.min(this, t, e);
  }, t.prototype.max = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.max(this, t, e);
  }, t.prototype.argMin = function (t) {
    return void 0 === t && (t = null), this.throwIfDisposed(), ft.argMin(this, t);
  }, t.prototype.argMax = function (t) {
    return void 0 === t && (t = null), this.throwIfDisposed(), ft.argMax(this, t);
  }, t.prototype.cast = function (t) {
    return this.throwIfDisposed(), ft.cast(this, t);
  }, t.prototype.add = function (t) {
    return this.throwIfDisposed(), ft.add(this, t);
  }, t.prototype.addStrict = function (t) {
    return this.throwIfDisposed(), ft.addStrict(this, t);
  }, t.prototype.atan2 = function (t) {
    return this.throwIfDisposed(), ft.atan2(this, t);
  }, t.prototype.sub = function (t) {
    return this.throwIfDisposed(), ft.sub(this, t);
  }, t.prototype.subStrict = function (t) {
    return this.throwIfDisposed(), ft.subStrict(this, t);
  }, t.prototype.pow = function (t) {
    return this.throwIfDisposed(), ft.pow(this, t);
  }, t.prototype.powStrict = function (t) {
    return this.throwIfDisposed(), ft.powStrict(this, t);
  }, t.prototype.mul = function (t) {
    return this.throwIfDisposed(), ft.mul(this, t);
  }, t.prototype.mulStrict = function (t) {
    return this.throwIfDisposed(), ft.mulStrict(this, t);
  }, t.prototype.div = function (t) {
    return this.throwIfDisposed(), ft.div(this, t);
  }, t.prototype.divNoNan = function (t) {
    return this.throwIfDisposed(), ft.divNoNan(this, t);
  }, t.prototype.floorDiv = function (t) {
    return this.throwIfDisposed(), ft.floorDiv(this, t);
  }, t.prototype.divStrict = function (t) {
    return this.throwIfDisposed(), ft.divStrict(this, t);
  }, t.prototype.minimum = function (t) {
    return this.throwIfDisposed(), ft.minimum(this, t);
  }, t.prototype.minimumStrict = function (t) {
    return this.throwIfDisposed(), ft.minimumStrict(this, t);
  }, t.prototype.maximum = function (t) {
    return this.throwIfDisposed(), ft.maximum(this, t);
  }, t.prototype.maximumStrict = function (t) {
    return this.throwIfDisposed(), ft.maximumStrict(this, t);
  }, t.prototype.mod = function (t) {
    return this.throwIfDisposed(), ft.mod(this, t);
  }, t.prototype.modStrict = function (t) {
    return this.throwIfDisposed(), ft.modStrict(this, t);
  }, t.prototype.squaredDifference = function (t) {
    return this.throwIfDisposed(), ft.squaredDifference(this, t);
  }, t.prototype.squaredDifferenceStrict = function (t) {
    return this.throwIfDisposed(), ft.squaredDifferenceStrict(this, t);
  }, t.prototype.transpose = function (t) {
    return this.throwIfDisposed(), ft.transpose(this, t);
  }, t.prototype.notEqual = function (t) {
    return this.throwIfDisposed(), ft.notEqual(this, t);
  }, t.prototype.notEqualStrict = function (t) {
    return this.throwIfDisposed(), ft.notEqualStrict(this, t);
  }, t.prototype.less = function (t) {
    return this.throwIfDisposed(), ft.less(this, t);
  }, t.prototype.lessStrict = function (t) {
    return this.throwIfDisposed(), ft.lessStrict(this, t);
  }, t.prototype.equal = function (t) {
    return this.throwIfDisposed(), ft.equal(this, t);
  }, t.prototype.equalStrict = function (t) {
    return this.throwIfDisposed(), ft.equalStrict(this, t);
  }, t.prototype.lessEqual = function (t) {
    return this.throwIfDisposed(), ft.lessEqual(this, t);
  }, t.prototype.lessEqualStrict = function (t) {
    return this.throwIfDisposed(), ft.lessEqualStrict(this, t);
  }, t.prototype.greater = function (t) {
    return this.throwIfDisposed(), ft.greater(this, t);
  }, t.prototype.greaterStrict = function (t) {
    return this.throwIfDisposed(), ft.greaterStrict(this, t);
  }, t.prototype.greaterEqual = function (t) {
    return this.throwIfDisposed(), ft.greaterEqual(this, t);
  }, t.prototype.greaterEqualStrict = function (t) {
    return this.throwIfDisposed(), ft.greaterEqualStrict(this, t);
  }, t.prototype.logicalAnd = function (t) {
    return this.throwIfDisposed(), ft.logicalAnd(this, t);
  }, t.prototype.logicalOr = function (t) {
    return this.throwIfDisposed(), ft.logicalOr(this, t);
  }, t.prototype.logicalNot = function () {
    return this.throwIfDisposed(), ft.logicalNot(this);
  }, t.prototype.logicalXor = function (t) {
    return this.throwIfDisposed(), ft.logicalXor(this, t);
  }, t.prototype.where = function (t, e) {
    return this.throwIfDisposed(), ft.where(t, this, e);
  }, t.prototype.neg = function () {
    return this.throwIfDisposed(), ft.neg(this);
  }, t.prototype.ceil = function () {
    return this.throwIfDisposed(), ft.ceil(this);
  }, t.prototype.floor = function () {
    return this.throwIfDisposed(), ft.floor(this);
  }, t.prototype.sign = function () {
    return this.throwIfDisposed(), ft.sign(this);
  }, t.prototype.isNaN = function () {
    return this.throwIfDisposed(), ft.isNaN(this);
  }, t.prototype.isInf = function () {
    return this.throwIfDisposed(), ft.isInf(this);
  }, t.prototype.isFinite = function () {
    return this.throwIfDisposed(), ft.isFinite(this);
  }, t.prototype.exp = function () {
    return this.throwIfDisposed(), ft.exp(this);
  }, t.prototype.expm1 = function () {
    return this.throwIfDisposed(), ft.expm1(this);
  }, t.prototype.log = function () {
    return this.throwIfDisposed(), ft.log(this);
  }, t.prototype.log1p = function () {
    return this.throwIfDisposed(), ft.log1p(this);
  }, t.prototype.sqrt = function () {
    return this.throwIfDisposed(), ft.sqrt(this);
  }, t.prototype.rsqrt = function () {
    return this.throwIfDisposed(), ft.rsqrt(this);
  }, t.prototype.square = function () {
    return this.throwIfDisposed(), ft.square(this);
  }, t.prototype.reciprocal = function () {
    return this.throwIfDisposed(), ft.reciprocal(this);
  }, t.prototype.abs = function () {
    return this.throwIfDisposed(), ft.abs(this);
  }, t.prototype.clipByValue = function (t, e) {
    return this.throwIfDisposed(), ft.clipByValue(this, t, e);
  }, t.prototype.relu = function () {
    return this.throwIfDisposed(), ft.relu(this);
  }, t.prototype.relu6 = function () {
    return this.throwIfDisposed(), ft.relu6(this);
  }, t.prototype.elu = function () {
    return this.throwIfDisposed(), ft.elu(this);
  }, t.prototype.selu = function () {
    return this.throwIfDisposed(), ft.selu(this);
  }, t.prototype.leakyRelu = function (t) {
    return void 0 === t && (t = .2), this.throwIfDisposed(), ft.leakyRelu(this, t);
  }, t.prototype.prelu = function (t) {
    return this.throwIfDisposed(), ft.prelu(this, t);
  }, t.prototype.sigmoid = function () {
    return this.throwIfDisposed(), ft.sigmoid(this);
  }, t.prototype.logSigmoid = function () {
    return this.throwIfDisposed(), ft.logSigmoid(this);
  }, t.prototype.softplus = function () {
    return this.throwIfDisposed(), ft.softplus(this);
  }, t.prototype.zerosLike = function () {
    return this.throwIfDisposed(), ft.zerosLike(this);
  }, t.prototype.onesLike = function () {
    return this.throwIfDisposed(), ft.onesLike(this);
  }, t.prototype.sin = function () {
    return this.throwIfDisposed(), ft.sin(this);
  }, t.prototype.cos = function () {
    return this.throwIfDisposed(), ft.cos(this);
  }, t.prototype.tan = function () {
    return this.throwIfDisposed(), ft.tan(this);
  }, t.prototype.asin = function () {
    return this.throwIfDisposed(), ft.asin(this);
  }, t.prototype.acos = function () {
    return this.throwIfDisposed(), ft.acos(this);
  }, t.prototype.atan = function () {
    return this.throwIfDisposed(), ft.atan(this);
  }, t.prototype.sinh = function () {
    return this.throwIfDisposed(), ft.sinh(this);
  }, t.prototype.cosh = function () {
    return this.throwIfDisposed(), ft.cosh(this);
  }, t.prototype.tanh = function () {
    return this.throwIfDisposed(), ft.tanh(this);
  }, t.prototype.asinh = function () {
    return this.throwIfDisposed(), ft.asinh(this);
  }, t.prototype.acosh = function () {
    return this.throwIfDisposed(), ft.acosh(this);
  }, t.prototype.atanh = function () {
    return this.throwIfDisposed(), ft.atanh(this);
  }, t.prototype.erf = function () {
    return this.throwIfDisposed(), ft.erf(this);
  }, t.prototype.round = function () {
    return this.throwIfDisposed(), ft.round(this);
  }, t.prototype.step = function (t) {
    return void 0 === t && (t = 0), this.throwIfDisposed(), ft.step(this, t);
  }, t.prototype.softmax = function (t) {
    return void 0 === t && (t = -1), this.throwIfDisposed(), ft.softmax(this, t);
  }, t.prototype.logSoftmax = function (t) {
    return void 0 === t && (t = -1), this.throwIfDisposed(), ft.logSoftmax(this, t);
  }, t.prototype.resizeBilinear = function (t, e) {
    return void 0 === e && (e = !1), this.throwIfDisposed(), ft.image.resizeBilinear(this, t, e);
  }, t.prototype.resizeNearestNeighbor = function (t, e) {
    return void 0 === e && (e = !1), this.throwIfDisposed(), ft.image.resizeNearestNeighbor(this, t, e);
  }, t.prototype.conv1d = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NWC"), void 0 === o && (o = 1), this.throwIfDisposed(), ft.conv1d(this, t, e, n, r, o, a);
  }, t.prototype.conv2d = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NHWC"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), ft.conv2d(this, t, e, n, r, o, a);
  }, t.prototype.conv2dTranspose = function (t, e, n, r, o) {
    return this.throwIfDisposed(), ft.conv2dTranspose(this, t, e, n, r, o);
  }, t.prototype.depthwiseConv2D = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NHWC"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), ft.depthwiseConv2d(this, t, e, n, r, o, a);
  }, t.prototype.separableConv2d = function (t, e, n, r, o, a) {
    return void 0 === o && (o = [1, 1]), void 0 === a && (a = "NHWC"), this.throwIfDisposed(), ft.separableConv2d(this, t, e, n, r, o, a);
  }, t.prototype.avgPool = function (t, e, n, r) {
    return this.throwIfDisposed(), ft.avgPool(this, t, e, n, r);
  }, t.prototype.maxPool = function (t, e, n, r) {
    return this.throwIfDisposed(), ft.maxPool(this, t, e, n, r);
  }, t.prototype.localResponseNormalization = function (t, e, n, r) {
    return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), ft.localResponseNormalization(this, t, e, n, r);
  }, t.prototype.pool = function (t, e, n, r, o) {
    return this.throwIfDisposed(), ft.pool(this, t, e, n, r, o);
  }, t.prototype.variable = function (t, e, n) {
    return void 0 === t && (t = !0), this.throwIfDisposed(), ht().makeVariable(this, t, e, n);
  }, t.prototype.unsortedSegmentSum = function (t, e) {
    return this.throwIfDisposed(), ft.unsortedSegmentSum(this, t, e);
  }, t.prototype.batchToSpaceND = function (t, e) {
    return this.throwIfDisposed(), ft.batchToSpaceND(this, t, e);
  }, t.prototype.spaceToBatchND = function (t, e) {
    return this.throwIfDisposed(), ft.spaceToBatchND(this, t, e);
  }, t.prototype.topk = function (t, e) {
    return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), ft.topk(this, t, e);
  }, t.prototype.stridedSlice = function (t, e, n, r, o, a, i, u) {
    return void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === u && (u = 0), this.throwIfDisposed(), ft.stridedSlice(this, t, e, n, r, o, a, i, u);
  }, t.prototype.depthToSpace = function (t, e) {
    return this.throwIfDisposed(), ft.depthToSpace(this, t, e);
  }, t.prototype.fft = function () {
    return this.throwIfDisposed(), ft.spectral.fft(this);
  }, t.prototype.ifft = function () {
    return this.throwIfDisposed(), ft.spectral.ifft(this);
  }, t.prototype.rfft = function () {
    return this.throwIfDisposed(), ft.spectral.rfft(this);
  }, t.prototype.irfft = function () {
    return this.throwIfDisposed(), ft.spectral.irfft(this);
  }, t;
}();

exports.Tensor = dt;
Object.defineProperty(dt, Symbol.hasInstance, {
  value: function (t) {
    return !!t && null != t.dataId && null != t.shape && null != t.dtype;
  }
});

var vt,
    mt,
    gt,
    yt,
    xt,
    bt = function (t) {
  function n(e, n, r, o) {
    var a = t.call(this, e.shape, e.dtype, e.dataId, o) || this;
    return a.trainable = n, a.name = r, a;
  }

  return e(n, t), n.prototype.assign = function (t) {
    if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!C(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
    ht().disposeTensor(this), this.dataId = t.dataId, ht().incRef(this, null);
  }, n.prototype.dispose = function () {
    ht().disposeVariable(this), this.isDisposedInternal = !0;
  }, n;
}(dt);

exports.Variable = bt;
exports.Rank = vt;
Object.defineProperty(bt, Symbol.hasInstance, {
  value: function (t) {
    return t instanceof dt && null != t.assign && t.assign instanceof Function;
  }
}), function (t) {
  t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6";
}(vt || (exports.Rank = vt = {})), function (t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64";
}(mt || (mt = {})), function (t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64";
}(gt || (gt = {})), function (t) {
  t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64";
}(yt || (yt = {})), function (t) {
  t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64";
}(xt || (xt = {}));
var wt = {
  float32: yt,
  int32: mt,
  bool: gt,
  complex64: xt
};

function Ct(t, e) {
  if ("string" === t || "string" === e) {
    if ("string" === t && "string" === e) return "string";
    throw new Error("Can not upcast " + t + " with " + e);
  }

  return wt[t][e];
}

function Et(t) {
  return Ct(t, "int32");
}

function Rt(t, e) {
  if (t.dtype === e.dtype) return [t, e];
  var n = Ct(t.dtype, e.dtype);
  return [t.cast(n), e.cast(n)];
}

function It(t, e) {
  g(t.dtype === e.dtype, function () {
    return "The dtypes of the first(" + t.dtype + ") and second(" + e.dtype + ") input must match";
  });
}

function kt(t) {
  var e = [];
  return function t(e, n, r) {
    if (null == e) return;
    if (e instanceof dt) return void n.push(e);
    if (o = e, !Array.isArray(o) && "object" != typeof o) return;
    var o;
    var a = e;

    for (var i in a) {
      var u = a[i];
      r.has(u) || (r.add(u), t(u, n, r));
    }
  }(t, e, new Set()), e;
}

var St,
    At = Object.freeze({
  makeTypesMatch: Rt,
  assertTypesMatch: It,
  isTensorInList: function (t, e) {
    for (var n = 0; n < e.length; n++) if (e[n].id === t.id) return !0;

    return !1;
  },
  getTensorsInContainer: kt
}),
    Dt = function () {
  function t() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null
    };
  }

  return t.prototype.dispose = function () {
    for (var t in this.registeredVariables) this.registeredVariables[t].dispose();
  }, t;
}(),
    Tt = function () {
  function t(t) {
    this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Dt();
  }

  return t.prototype.ready = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function () {})];
            if (null != this.backendInstance) return [2];
            t = this.getSortedBackends(), e = 0, r.label = 1;

          case 1:
            return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];

          case 2:
            return r.sent() ? [4, this.setBackend(n)] : [3, 4];

          case 3:
            return r.sent(), [2];

          case 4:
            return e++, [3, 1];

          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(t.prototype, "backend", {
    get: function () {
      if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");

      if (null == this.backendInstance) {
        var t = this.initializeBackendsAndReturnBest(),
            e = t.name;
        if (t.asyncInit) throw new Error("The highest priority backend '" + e + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
        this.setBackend(e);
      }

      return this.backendInstance;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.backendNames = function () {
    return Object.keys(this.registryFactory);
  }, t.prototype.findBackend = function (t) {
    if (!(t in this.registry)) {
      if (!(t in this.registryFactory)) return null;
      if (this.initializeBackend(t).asyncInit) return null;
    }

    return this.registry[t];
  }, t.prototype.findBackendFactory = function (t) {
    return t in this.registryFactory ? this.registryFactory[t].factory : null;
  }, t.prototype.registerBackend = function (t, e, n) {
    return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t] = {
      factory: e,
      priority: n
    }, !0);
  }, t.prototype.setBackend = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (null == this.registryFactory[t]) throw new Error("Backend name '" + t + "' not found in registry");
            return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);

          case 1:
            return o = r.sent(), [3, 3];

          case 2:
            o = n, r.label = 3;

          case 3:
            if (!o) return [2, !1];
            r.label = 4;

          case 4:
            return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new et(this.backendInstance), [2, !0];
        }
      });
    });
  }, t.prototype.setupRegisteredKernels = function () {
    var t = this;
    c(this.backendName).forEach(function (e) {
      null != e.setupFunc && e.setupFunc(t.backendInstance);
    });
  }, t.prototype.disposeRegisteredKernels = function (t) {
    var e = this;
    c(t).forEach(function (n) {
      null != n.disposeFunc && n.disposeFunc(e.registry[t]);
    });
  }, t.prototype.initializeBackend = function (t) {
    var e = this,
        n = this.registryFactory[t];
    if (null == n) throw new Error("Cannot initialize backend " + t + ", no registration found.");

    try {
      var r = n.factory();

      if (Promise.resolve(r) === r) {
        var o = ++this.pendingBackendInitId,
            a = r.then(function (n) {
          return !(o < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0);
        }).catch(function (n) {
          return !(o < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn("Initialization of backend " + t + " failed"), console.warn(n.stack || n.message), !1);
        });
        return this.pendingBackendInit = a, {
          success: a,
          asyncInit: !0
        };
      }

      return this.registry[t] = r, {
        success: !0,
        asyncInit: !1
      };
    } catch (e) {
      return console.warn("Initialization of backend " + t + " failed"), console.warn(e.stack || e.message), {
        success: !1,
        asyncInit: !1
      };
    }
  }, t.prototype.removeBackend = function (t) {
    if (!(t in this.registryFactory)) throw new Error(t + " backend not found in registry");
    this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, t.prototype.getSortedBackends = function () {
    var t = this;
    if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function (e, n) {
      return t.registryFactory[n].priority - t.registryFactory[e].priority;
    });
  }, t.prototype.initializeBackendsAndReturnBest = function () {
    for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
      var n = t[e],
          r = this.initializeBackend(n),
          o = r.success,
          a = r.asyncInit;
      if (a || o) return {
        name: n,
        asyncInit: a
      };
    }

    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, t.prototype.moveData = function (t, e) {
    var n = this.state.tensorInfo.get(e),
        r = n.backend,
        o = this.readSync(e);
    r.disposeData(e), n.backend = t, t.move(e, o, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, t.prototype.tidy = function (t, e) {
    var n,
        r = this,
        o = null;

    if (null == e) {
      if ("function" != typeof t) throw new Error("Please provide a function to tidy()");
      e = t;
    } else {
      if ("string" != typeof t && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof e) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      o = t;
    }

    return this.scopedRun(function () {
      return r.startScope(o);
    }, function () {
      return r.endScope(n);
    }, function () {
      return (n = e()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n;
    });
  }, t.prototype.scopedRun = function (t, e, n) {
    t();

    try {
      var r = n();
      return e(), r;
    } catch (t) {
      throw e(), t;
    }
  }, t.prototype.nextTensorId = function () {
    return t.nextTensorId++;
  }, t.prototype.nextVariableId = function () {
    return t.nextVariableId++;
  }, t.prototype.clone = function (t) {
    var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
        n = {
      x: t
    };
    return this.addTapeNode(this.state.activeScope.name, n, [e], function (t) {
      return {
        x: function () {
          return t.toFloat();
        }
      };
    }, []), e;
  }, t.prototype.runKernel = function (t, e, n, r, o) {
    return this.runKernelFunc(null, e, null, t, n, r, o);
  }, t.prototype.shouldCheckForMemLeaks = function () {
    return this.ENV.getBool("IS_TEST");
  }, t.prototype.checkKernelForMemLeak = function (t, e, n) {
    var r = this.backend.numDataIds(),
        o = 0;
    n.forEach(function (t) {
      o += "complex64" === t.dtype ? 3 : 1;
    });
    var a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
        i = r - e - o - a;
    if (i > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i + " data ids) after running '" + t + "'");
  }, t.prototype.runKernelFunc = function (t, e, n, r, o, a, i) {
    var u,
        c = this;
    void 0 === a && (a = []), void 0 === i && (i = []);

    var l,
        h = [],
        f = this.isTapeOn(),
        p = null != this.state.activeScope ? this.state.activeScope.name : "",
        d = function (t) {
      f && (h = t.map(function (t) {
        return c.keep(c.clone(t));
      }));
    },
        v = this.state.numBytes,
        m = this.state.numTensors;

    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var g,
        y = s(r, this.backendName);
    return l = null != y ? function () {
      var t = c.backend.numDataIds();
      g = y.kernelFunc({
        inputs: e,
        attrs: o,
        backend: c.backend
      });
      var n = Array.isArray(g) ? g : [g];
      c.shouldCheckForMemLeaks() && c.checkKernelForMemLeak(p, t, n);
      var r = n.map(function (t) {
        var e = t.dataId,
            n = t.shape,
            r = t.dtype;
        return c.makeTensorFromDataId(e, n, r);
      }),
          u = r.filter(function (t, e) {
        return i[e];
      });
      return d(a.slice().concat(u)), r;
    } : function () {
      var e = c.backend.numDataIds();
      g = c.tidy(function () {
        return t(c.backend, d);
      });
      var n = Array.isArray(g) ? g : [g];
      return c.shouldCheckForMemLeaks() && c.checkKernelForMemLeak(p, e, n), n;
    }, this.scopedRun(function () {
      return c.state.kernelDepth++;
    }, function () {
      return c.state.kernelDepth--;
    }, function () {
      u = c.ENV.getBool("DEBUG") ? c.profiler.profileKernel(p, e, function () {
        return l();
      }) : l();
    }), f && this.addTapeNode(p, e, u, n, h), this.state.profiling && this.state.activeProfile.kernels.push({
      name: p,
      bytesAdded: this.state.numBytes - v,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - m,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(e).map(function (t) {
        return e[t].shape;
      }),
      outputShapes: u.map(function (t) {
        return t.shape;
      })
    }), Array.isArray(g) ? u : u[0];
  }, t.prototype.makeTensor = function (t, e, n, r) {
    if (null == t) throw new Error("Values passed to engine.makeTensor() are null");
    n = n || "float32", r = r || this.backend;
    var o = t;
    "string" === n && W(t[0]) && (o = t.map(function (t) {
      return J(t);
    }));
    var a = r.write(o, e, n),
        i = new dt(e, n, a, this.nextTensorId());

    if (this.incRef(i, r), "string" === n) {
      var u = this.state.tensorInfo.get(a),
          s = L(o);
      this.state.numBytes += s - u.bytes, u.bytes = s;
    }

    return i;
  }, t.prototype.makeTensorFromDataId = function (t, e, n, r) {
    var o = new dt(e, n = n || "float32", t, this.nextTensorId());
    return this.incRef(o, r), o;
  }, t.prototype.makeVariable = function (t, e, n, r) {
    void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));
    var o = new bt(t, e, n, this.nextTensorId());
    if (null != this.state.registeredVariables[o.name]) throw new Error("Variable with name " + o.name + " was already registered");
    return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;
  }, t.prototype.incRef = function (t, e) {
    var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;

    if (this.state.numTensors++, "string" === t.dtype && this.state.numStringTensors++, 0 === n) {
      this.state.numDataBuffers++;
      var r = 0;
      "complex64" !== t.dtype && "string" !== t.dtype && (r = t.size * P(t.dtype)), this.state.tensorInfo.set(t.dataId, {
        backend: e || this.backend,
        dtype: t.dtype,
        shape: t.shape,
        bytes: r,
        refCount: 0
      }), this.state.numBytes += r;
    }

    this.state.tensorInfo.get(t.dataId).refCount++, t instanceof bt || this.track(t);
  }, t.prototype.disposeTensor = function (t) {
    if (this.state.tensorInfo.has(t.dataId)) {
      this.state.numTensors--, "string" === t.dtype && this.state.numStringTensors--;
      var e = this.state.tensorInfo.get(t.dataId);
      e.refCount <= 1 ? ("complex64" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--;
    }
  }, t.prototype.disposeVariables = function () {
    for (var t in this.state.registeredVariables) {
      var e = this.state.registeredVariables[t];
      this.disposeVariable(e);
    }
  }, t.prototype.disposeVariable = function (t) {
    this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name];
  }, t.prototype.memory = function () {
    var t = this.backend.memory();
    return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t;
  }, t.prototype.profile = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (t) {
          return t.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile];
      });
    });
  }, t.prototype.isTapeOn = function () {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }, t.prototype.addTapeNode = function (t, e, n, r, o) {
    var a = this,
        i = {
      id: this.state.nextTapeNodeId++,
      name: t,
      inputs: e,
      outputs: n,
      saved: o
    };
    null != r && (i.gradient = function (t) {
      return t = t.map(function (t, e) {
        if (null == t) {
          var r = n[e],
              o = $(r.size, r.dtype);
          return a.makeTensor(o, r.shape, r.dtype);
        }

        return t;
      }), r(t.length > 1 ? t : t[0], o);
    }), this.state.activeTape.push(i);
  }, t.prototype.keep = function (t) {
    return t.kept = !0, t;
  }, t.prototype.startTape = function () {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }, t.prototype.endTape = function () {
    this.state.gradientDepth--;
  }, t.prototype.startScope = function (t) {
    var e = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;
  }, t.prototype.endScope = function (t) {
    for (var e = this, n = kt(t), r = new Set(n.map(function (t) {
      return t.id;
    })), o = 0; o < this.state.activeScope.track.length; o++) {
      var a = this.state.activeScope.track[o];
      a.kept || r.has(a.id) || a.dispose();
    }

    var i = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function (t) {
      t.kept || t.scopeId !== i.id || e.track(t);
    });
  }, t.prototype.gradients = function (t, e, n, r) {
    var o = this;
    if (void 0 === r && (r = !1), g(e.length > 0, function () {
      return "gradients() received an empty list of xs.";
    }), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
    var a = this.scopedRun(function () {
      return o.startTape();
    }, function () {
      return o.endTape();
    }, function () {
      return o.tidy("forward", t);
    });
    g(a instanceof dt, function () {
      return "The result y returned by f() must be a tensor.";
    });

    var i = function (t, e, n) {
      for (var r = {}, o = {}, a = 0; a < e.length; a++) r[e[a].id] = !0;

      for (a = 0; a < t.length; a++) {
        var i = (d = t[a]).inputs;

        for (var u in i) {
          for (var s = i[u], c = !1, l = 0; l < e.length; l++) if (r[s.id]) {
            d.outputs.forEach(function (t) {
              return r[t.id] = !0;
            }), c = !0, o[d.id] = !0;
            break;
          }

          if (c) break;
        }
      }

      var h = {};
      h[n.id] = !0;
      var f = {};

      for (a = t.length - 1; a >= 0; a--) for (i = (d = t[a]).inputs, l = 0; l < d.outputs.length; l++) if (h[d.outputs[l].id]) {
        for (var u in i) h[i[u].id] = !0, f[d.id] = !0;

        break;
      }

      var p = [];

      for (a = 0; a < t.length; a++) {
        var d;

        if (o[(d = t[a]).id] && f[d.id]) {
          var v = {};

          for (var u in d.inputs) {
            var m = d.inputs[u];
            r[m.id] && (v[u] = m);
          }

          var g = Object.assign({}, d);
          g.inputs = v, g.outputs = d.outputs, p.push(g);
        }
      }

      return p;
    }(this.state.activeTape, e, a);

    if (!r && 0 === i.length && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function () {
      var t,
          r,
          u = {};
      u[a.id] = null == n ? (t = a.shape, r = X(w(t), "float32"), Nt.makeTensor(r, t, "float32")) : n, function (t, e, n) {
        for (var r = function (r) {
          var o = e[r],
              a = [];
          if (o.outputs.forEach(function (e) {
            var n = t[e.id];
            null != n ? a.push(n) : a.push(null);
          }), null == o.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + o.name + ".");

          var i = o.gradient(a),
              u = function (e) {
            if (!(e in i)) throw new Error("Cannot backprop through input " + e + ". Available gradients found: " + Object.keys(i) + ".");
            var r = n(function () {
              return i[e]();
            });
            if ("float32" !== r.dtype) throw new Error("Error in gradient for op " + o.name + ". The gradient of input " + e + " must have 'float32' dtype, but has '" + r.dtype + "'");
            var a = o.inputs[e];
            if (!C(r.shape, a.shape)) throw new Error("Error in gradient for op " + o.name + ". The gradient of input '" + e + "' has shape '" + r.shape + "', which does not match the shape of the input '" + a.shape + "'");
            if (null == t[a.id]) t[a.id] = r;else {
              var u = t[a.id];
              t[a.id] = u.add(r), u.dispose();
            }
          };

          for (var s in o.inputs) u(s);
        }, o = e.length - 1; o >= 0; o--) r(o);
      }(u, i, function (t) {
        return o.tidy(t);
      });
      var s = e.map(function (t) {
        return u[t.id];
      });
      return 0 === o.state.gradientDepth && (o.state.activeTape.forEach(function (t) {
        for (var e in t.saved) t.saved[e].dispose();
      }), o.state.activeTape = null), {
        value: a,
        grads: s
      };
    });
  }, t.prototype.customGrad = function (t) {
    var e = this;
    return g(G(t), function () {
      return "The f passed in customGrad(f) must be a function.";
    }), function () {
      for (var n, r = [], o = 0; o < arguments.length; o++) r[o] = arguments[o];

      g(r.every(function (t) {
        return t instanceof dt;
      }), function () {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var a = {};
      return r.forEach(function (t, e) {
        a[e] = t;
      }), e.runKernelFunc(function (e, o) {
        return g((n = t.apply(void 0, r.concat([o]))).value instanceof dt, function () {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), g(G(n.gradFunc), function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), n.value;
      }, a, function (t, e) {
        var o = n.gradFunc(t, e),
            a = Array.isArray(o) ? o : [o];
        g(a.length === r.length, function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), g(a.every(function (t) {
          return t instanceof dt;
        }), function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var i = {};
        return a.forEach(function (t, e) {
          i[e] = function () {
            return t;
          };
        }), i;
      });
    };
  }, t.prototype.readSync = function (t) {
    return this.state.tensorInfo.get(t).backend.readSync(t);
  }, t.prototype.read = function (t) {
    return this.state.tensorInfo.get(t).backend.read(t);
  }, t.prototype.fromPixels = function (t, e) {
    return this.backend.fromPixels(t, e);
  }, t.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return e = Y(), [4, this.backend.time(t)];

          case 1:
            return (n = r.sent()).wallMs = Y() - e, [2, n];
        }
      });
    });
  }, t.prototype.track = function (t) {
    return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;
  }, Object.defineProperty(t.prototype, "registeredVariables", {
    get: function () {
      return this.state.registeredVariables;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.reset = function () {
    for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Dt(), this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];

    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, t.nextTensorId = 0, t.nextVariableId = 0, t;
}();

exports.tensor_util = At;

var Nt = function () {
  var t = function () {
    if (null == St) {
      var t = void 0;
      if ("undefined" != typeof window) t = window;else if ("undefined" != typeof global) t = global;else if ("undefined" != typeof process) t = process;else {
        if ("undefined" == typeof self) throw new Error("Could not find a global object");
        t = self;
      }
      St = t;
    }

    return St;
  }();

  if (null == t._tfengine) {
    var e = new o(t);
    t._tfengine = new Tt(e);
  }

  return function (t) {
    exports.ENV = i = t;
  }(t._tfengine.ENV), ht = function () {
    return t._tfengine;
  }, t._tfengine;
}();

function Ft() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}

var Ot = a();
Ot.registerFlag("DEBUG", function () {
  return !1;
}, function (t) {
  t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ot.registerFlag("IS_BROWSER", function () {
  return Ft();
}), Ot.registerFlag("IS_NODE", function () {
  return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Ot.registerFlag("IS_CHROME", function () {
  return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ot.registerFlag("PROD", function () {
  return !1;
}), Ot.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
  return Ot.getBool("DEBUG");
}), Ot.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
  return !0;
}), Ot.registerFlag("IS_TEST", function () {
  return !1;
});

var _t,
    Mt,
    Bt,
    Pt = {},
    Lt = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};

function Wt(t, e) {
  Pt[t] = e;
}

function Ut(t) {
  t in Pt || (Pt[t] = function (t) {
    if (1 !== t && 2 !== t) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    var e = Vt(t);
    if (e.addEventListener("webglcontextlost", function (e) {
      e.preventDefault(), delete Pt[t];
    }, !1), 1 === t) return e.getContext("webgl", Lt) || e.getContext("experimental-webgl", Lt);
    return e.getContext("webgl2", Lt);
  }(t));
  var e = Pt[t];
  return e.isContextLost() ? (delete Pt[t], Ut(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Pt[t]);
}

function Vt(t) {
  if ("undefined" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);
  if ("undefined" != typeof document) return document.createElement("canvas");
  throw new Error("Cannot create a canvas in this context");
}

function zt(t, e) {
  return [e, t];
}

function Gt(t) {
  var e = w(t);
  return I(Math.ceil(e / 4));
}

function Ht(t, e) {
  return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))];
}

function qt(t, e) {
  var n,
      r,
      o,
      i,
      u,
      s,
      c,
      l,
      h,
      f = t;
  return 2 === a().getNumber("WEBGL_VERSION") ? (n = f.R32F, r = f.R16F, o = f.RGBA16F, i = f.RGBA32F, u = f.RED, s = 4, c = 1, l = f.HALF_FLOAT, h = f.FLOAT) : (n = t.RGBA, r = t.RGBA, o = t.RGBA, i = f.RGBA, u = t.RGBA, s = 4, c = 4, l = null != e ? e.HALF_FLOAT_OES : null, h = t.FLOAT), {
    internalFormatFloat: n,
    internalFormatHalfFloat: r,
    internalFormatPackedHalfFloat: o,
    internalFormatPackedFloat: i,
    textureFormatFloat: u,
    downloadTextureFormat: t.RGBA,
    downloadUnpackNumChannels: s,
    defaultNumChannels: c,
    textureTypeHalfFloat: l,
    textureTypeFloat: h
  };
}

function Kt(t, e, n) {
  var r = n();
  return e && function (t) {
    var e = t.getError();
    if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + Yt(t, e));
  }(t), r;
}

!function (t) {
  t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH";
}(_t || (_t = {})), function (t) {
  t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD";
}(Mt || (Mt = {})), function (t) {
  t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Bt || (Bt = {}));
var jt = 5.96e-8,
    Xt = 65504;

function $t(t) {
  return !!(a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t || jt < Math.abs(t) && Math.abs(t) < Xt);
}

function Yt(t, e) {
  switch (e) {
    case t.NO_ERROR:
      return "NO_ERROR";

    case t.INVALID_ENUM:
      return "INVALID_ENUM";

    case t.INVALID_VALUE:
      return "INVALID_VALUE";

    case t.INVALID_OPERATION:
      return "INVALID_OPERATION";

    case t.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";

    case t.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";

    case t.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";

    default:
      return "Unknown error code " + e;
  }
}

function Qt(t, e, n) {
  return be(t, e, function () {
    return t.getExtension(n);
  }, 'Extension "' + n + '" not supported on this browser.');
}

function Jt(t, e, n) {
  var r = be(t, e, function () {
    return t.createShader(t.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (Kt(t, e, function () {
    return t.shaderSource(r, n);
  }), Kt(t, e, function () {
    return t.compileShader(r);
  }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
  return r;
}

function Zt(t, e, n) {
  var r = be(t, e, function () {
    return t.createShader(t.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (Kt(t, e, function () {
    return t.shaderSource(r, n);
  }), Kt(t, e, function () {
    return t.compileShader(r);
  }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function (t, e) {
    var n = ne.exec(e);
    if (null == n) return console.log("Couldn't parse line number in error: " + e), void console.log(t);

    for (var r = +n[1], o = t.split("\n"), a = o.length.toString().length + 2, i = o.map(function (t, e) {
      return k((e + 1).toString(), a) + t;
    }), u = 0, s = 0; s < i.length; s++) u = Math.max(i[s].length, u);

    var c = i.slice(0, r - 1),
        l = i.slice(r - 1, r),
        h = i.slice(r);
    console.log(c.join("\n")), console.log(e.split("\n")[0]), console.log("%c " + k(l[0], u), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"));
  }(n, t.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
  return r;
}

var te,
    ee,
    ne = /ERROR: [0-9]+:([0-9]+):/g;

function re(t, e) {
  return be(t, e, function () {
    return t.createProgram();
  }, "Unable to create WebGLProgram.");
}

function oe(t, e, n) {
  if (Kt(t, e, function () {
    return t.linkProgram(n);
  }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Failed to link vertex and fragment shaders.");
}

function ae(t, e, n) {
  if (Kt(t, e, function () {
    return t.validateProgram(n);
  }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Shader program validation failed.");
}

function ie(t, e, n) {
  var r = be(t, e, function () {
    return t.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Kt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, r);
  }), Kt(t, e, function () {
    return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);
  }), r;
}

function ue(t, e, n) {
  var r = be(t, e, function () {
    return t.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Kt(t, e, function () {
    return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);
  }), Kt(t, e, function () {
    return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);
  }), r;
}

function se(t, e) {
  return be(t, e, function () {
    return t.createTexture();
  }, "Unable to create WebGLTexture.");
}

function ce(t, e) {
  var n = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");

  if (t <= 0 || e <= 0) {
    var r = "[" + t + "x" + e + "]";
    throw new Error("Requested texture size " + r + " is invalid.");
  }

  if (t > n || e > n) {
    r = "[" + t + "x" + e + "]";
    throw new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + ("[" + n + "x" + n + "]") + ".");
  }
}

function le(t, e) {
  return be(t, e, function () {
    return t.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}

function he(t, e, n, r, o, a, i, u) {
  var s = t.getAttribLocation(n, r);
  return -1 !== s && (Kt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, o);
  }), Kt(t, e, function () {
    return t.vertexAttribPointer(s, a, t.FLOAT, !1, i, u);
  }), Kt(t, e, function () {
    return t.enableVertexAttribArray(s);
  }), !0);
}

function fe(t, e, n, r) {
  we(t, r), Kt(t, e, function () {
    return t.activeTexture(t.TEXTURE0 + r);
  }), Kt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  });
}

function pe(t, e, n, r) {
  return be(t, e, function () {
    return t.getUniformLocation(n, r);
  }, 'uniform "' + r + '" not present in program.');
}

function de(t, e, n) {
  return t.getUniformLocation(e, n);
}

function ve(t, e, n, r, o, a) {
  Kt(t, e, function () {
    return fe(t, e, r, a);
  }), Kt(t, e, function () {
    return t.uniform1i(o, a);
  });
}

function me(t, e, n, r) {
  Kt(t, e, function () {
    return t.bindFramebuffer(t.FRAMEBUFFER, r);
  }), Kt(t, e, function () {
    return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  });
}

function ge(t, e, n) {
  Kt(t, e, function () {
    return t.bindFramebuffer(t.FRAMEBUFFER, n);
  }), Kt(t, e, function () {
    return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0);
  });
}

function ye(t) {
  var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
  if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + xe(t, e));
}

function xe(t, e) {
  switch (e) {
    case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

    case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

    case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

    case t.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";

    default:
      return "unknown error " + e;
  }
}

function be(t, e, n, r) {
  var o = Kt(t, e, function () {
    return n();
  });
  if (null == o) throw new Error(r);
  return o;
}

function we(t, e) {
  var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
      r = e + t.TEXTURE0;
  if (r < t.TEXTURE0 || r > n) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n + "]") + ".");
}

function Ce(t, e) {
  return void 0 === e && (e = 2), w(t.slice(0, t.length - e));
}

function Ee(t) {
  if (0 === t.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];
}

function Re(t) {
  var e = [1, 1, 1];
  return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [Ce(t)].concat(Ee(t))), e;
}

function Ie(t, e) {
  var n;
  void 0 === e && (e = !1);
  var r = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");

  if (e && (r *= 2, 1 === (t = t.map(function (e, n) {
    return n >= t.length - 2 ? v(t[n]) : t[n];
  })).length && (t = [2, t[0]])), 2 !== t.length) {
    var o = T(t);
    t = o.newShape;
  }

  var i = w(t);
  if (t.length <= 1 && i <= r) return [1, i];
  if (2 === t.length && t[0] <= r && t[1] <= r) return t;
  if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];
  if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];
  if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];
  if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];

  if (e) {
    var u = Ce(t),
        s = 2,
        c = 2;
    return t.length && (s = (n = Ee(t))[0], c = n[1]), I(i = u * (s / 2) * (c / 2)).map(function (t) {
      return 2 * t;
    });
  }

  return I(i);
}

function ke(t) {
  return t % 2 == 0;
}

function Se(t, e) {
  if (C(t = t.slice(-2), e = e.slice(-2))) return !0;
  if (!t.length || !e.length) return !0;
  if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;

  if (t.length !== e.length) {
    var n = t.slice(-1)[0],
        r = e.slice(-1)[0];
    if (n === r) return !0;
    if (ke(n) && ke(r) && (1 === t[0] || 1 === e[0])) return !0;
  }

  return t[1] === e[1] && ke(t[0]) && ke(e[0]);
}

function Ae(t) {
  if (null == te) {
    var e = Ut(t);
    te = e.getParameter(e.MAX_TEXTURE_SIZE);
  }

  return te;
}

function De(t) {
  if (null == ee) {
    var e = Ut(t);
    ee = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
  }

  return Math.min(16, ee);
}

function Te(t) {
  if (0 === t) return 0;
  var e = Ut(t);
  return Ne(e, "EXT_disjoint_timer_query_webgl2") && 2 === t ? 2 : Ne(e, "EXT_disjoint_timer_query") ? 1 : 0;
}

function Ne(t, e) {
  return null != t.getExtension(e);
}

function Fe(t) {
  try {
    if (null != Ut(t)) return !0;
  } catch (t) {
    return !1;
  }

  return !1;
}

function Oe(t) {
  if (0 === t) return !1;
  var e = Ut(t);

  if (1 === t) {
    if (!Ne(e, "OES_texture_float")) return !1;
  } else if (!Ne(e, "EXT_color_buffer_float")) return !1;

  return Me(e);
}

function _e(t) {
  if (0 === t) return !1;
  var e = Ut(t);

  if (1 !== t) {
    if (Ne(e, "EXT_color_buffer_float")) return Me(e);

    if (Ne(e, "EXT_color_buffer_half_float")) {
      var n = e.getExtension("EXT_color_buffer_half_float");
      return function (t, e) {
        var n = qt(t, e),
            r = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, r);
        t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
        var o = t.createFramebuffer();
        t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);
        var a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
        return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(o), a;
      }(e, n);
    }

    return !1;
  }

  return !!Ne(e, "OES_texture_float") && !!Ne(e, "WEBGL_color_buffer_float") && Me(e);
}

function Me(t) {
  var e = qt(t),
      n = t.createTexture();
  t.bindTexture(t.TEXTURE_2D, n);
  t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
  var r = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
  return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;
}

function Be(t) {
  return 2 === t && null != Ut(t).fenceSync;
}

var Pe = Object.freeze({
  callAndCheck: Kt,
  canBeRepresented: $t,
  getWebGLErrorMessage: Yt,
  getExtensionOrThrow: Qt,
  createVertexShader: Jt,
  createFragmentShader: Zt,
  createProgram: re,
  linkProgram: oe,
  validateProgram: ae,
  createStaticVertexBuffer: ie,
  createStaticIndexBuffer: ue,
  getNumChannels: function () {
    return 2 === a().getNumber("WEBGL_VERSION") ? 1 : 4;
  },
  createTexture: se,
  validateTextureSize: ce,
  createFramebuffer: le,
  bindVertexBufferToProgramAttribute: he,
  bindTextureUnit: fe,
  unbindTextureUnit: function (t, e, n) {
    we(t, n), Kt(t, e, function () {
      return t.activeTexture(t.TEXTURE0 + n);
    }), Kt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, null);
    });
  },
  getProgramUniformLocationOrThrow: pe,
  getProgramUniformLocation: de,
  bindTextureToProgramUniformSampler: ve,
  bindCanvasToFramebuffer: function (t, e) {
    Kt(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, null);
    }), Kt(t, e, function () {
      return t.viewport(0, 0, t.canvas.width, t.canvas.height);
    }), Kt(t, e, function () {
      return t.scissor(0, 0, t.canvas.width, t.canvas.height);
    });
  },
  bindColorTextureToFramebuffer: me,
  unbindColorTextureFromFramebuffer: ge,
  validateFramebuffer: ye,
  getFramebufferErrorMessage: xe,
  getBatchDim: Ce,
  getRowsCols: Ee,
  getShapeAs3D: Re,
  getTextureShapeFromLogicalShape: Ie,
  isReshapeFree: Se,
  getWebGLMaxTextureSize: Ae,
  resetMaxTextureSize: function () {
    te = null;
  },
  resetMaxTexturesInShader: function () {
    ee = null;
  },
  getMaxTexturesInShader: De,
  getWebGLDisjointQueryTimerVersion: Te,
  hasExtension: Ne,
  isWebGLVersionEnabled: Fe,
  isCapableOfRenderingToFloatTexture: Oe,
  isDownloadFloatTextureEnabled: _e,
  isWebGLFenceEnabled: Be
}),
    Le = a();

function We() {
  a().set("PROD", !0);
}

function Ue() {
  a().set("DEBUG", !0);
}

function Ve() {
  a().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}

function ze(t) {
  a().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}

function Ge() {
  Nt.disposeVariables();
}

function He() {
  return Nt;
}

function qe() {
  return Nt.memory();
}

function Ke(t) {
  return Nt.profile(t);
}

function je(t, e) {
  return Nt.tidy(t, e);
}

function Xe(t) {
  kt(t).forEach(function (t) {
    return t.dispose();
  });
}

function $e(t) {
  return Nt.keep(t);
}

function Ye(t) {
  return Nt.time(t);
}

function Qe(t) {
  return Nt.setBackend(t);
}

function Je() {
  return Nt.ready();
}

function Ze() {
  return Nt.backendName;
}

function tn(t) {
  Nt.removeBackend(t);
}

function en(t) {
  return Nt.findBackend(t);
}

function nn(t) {
  return Nt.findBackendFactory(t);
}

function rn(t, e, n) {
  return void 0 === n && (n = 1), Nt.registerBackend(t, e, n);
}

function on() {
  return Nt.backend;
}

function an(t, e) {
  a().setPlatform(t, e);
}

function un() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

  a().getBool("IS_TEST") || console.warn.apply(console, t);
}

function sn(t, e) {
  var n = t;
  if (B(t)) return "string" === e ? [] : [t.length];
  if (!Array.isArray(t)) return [];

  for (var r = []; Array.isArray(n) || B(n) && "string" !== e;) r.push(n.length), n = n[0];

  return Array.isArray(t) && a().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t(e, n, r) {
    r = r || [];
    if (!Array.isArray(e) && !B(e)) return void g(0 === n.length, function () {
      return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements";
    });
    g(n.length > 0, function () {
      return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + e.length + " elements";
    });
    g(e.length === n[0], function () {
      return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + e.length + " elements";
    });
    var o = n.slice(1);

    for (var a = 0; a < e.length; ++a) t(e[a], o, r.concat(a));
  }(t, r, []), r;
}

function cn(t, e, n, r) {
  if (null != t && ("numeric" !== t && t !== e || "numeric" === t && "string" === e)) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + " tensor, but got " + e + " tensor");
}

function ln(t, e, n, r) {
  if (void 0 === r && (r = "numeric"), t instanceof dt) return cn(r, t.dtype, e, n), t;
  var o = z(t);

  if ("string" !== o && ["bool", "int32", "float32"].indexOf(r) >= 0 && (o = r), cn(r, o, e, n), null == t || !B(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) {
    var i = null == t ? "null" : t.constructor.name;
    throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + i + "'");
  }

  var u = sn(t, o);
  B(t) || Array.isArray(t) || (t = [t]);
  var s = "string" !== o ? K(t, o, a().getBool("DEBUG")) : b(t, [], !0);
  return Nt.makeTensor(s, u, o);
}

function hn(t, e, n, r) {
  if (void 0 === r && (r = "numeric"), !Array.isArray(t)) throw new Error("Argument " + e + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
  return t.map(function (t, r) {
    return ln(t, e + "[" + r + "]", n);
  }, r);
}

function fn(t, e) {
  for (var n = 0; n < t.length; ++n) if (t[t.length - n - 1] !== e - 1 - n) return !1;

  return !0;
}

function pn(t, e, n) {
  for (var r = t.length + e.length, o = [], a = 0, i = 0, u = 0; u < r; u++) -1 === n.indexOf(u) ? o.push(t[a++]) : o.push(e[i++]);

  return o;
}

function dn(t, e) {
  for (var n = [], r = t.length, o = 0; o < r; o++) -1 === e.indexOf(o) && n.push(t[o]);

  return [n, e.map(function (e) {
    return t[e];
  })];
}

function vn(t, e) {
  return pn(t, e.map(function (t) {
    return 1;
  }), e);
}

function mn(t, e, n) {
  g(fn(e, n), function () {
    return t + " supports only inner-most axes for now. Got axes " + e + " and rank-" + n + " input.";
  });
}

function gn(t, e) {
  if (fn(t, e)) return null;

  for (var n = [], r = 0; r < e; ++r) -1 === t.indexOf(r) && n.push(r);

  return t.forEach(function (t) {
    return n.push(t);
  }), n;
}

function yn(t) {
  return t.map(function (t, e) {
    return [e, t];
  }).sort(function (t, e) {
    return t[1] - e[1];
  }).map(function (t) {
    return t[0];
  });
}

function xn(t, e) {
  for (var n = [], r = e - t; r < e; ++r) n.push(r);

  return n;
}

function bn(t, e) {
  var n = t[0].length;
  t.forEach(function (t, e) {
    g(t.length === n, function () {
      return "Error in concat" + n + "D: rank of tensors[" + e + "] must be the same as the rank of the rest (" + n + ")";
    });
  }), g(e >= 0 && e < n, function () {
    return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + ".";
  });
  var r = t[0];
  t.forEach(function (t, o) {
    for (var a = 0; a < n; a++) g(a === e || t[a] === r[a], function () {
      return "Error in concat" + n + "D: Shape of tensors[" + o + "] (" + t + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + o + ".";
    });
  });
}

function wn(t, e) {
  for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];

  return n;
}

function Cn(t) {
  var e = Object.keys(t);
  if (1 !== e.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
  var n = e[0],
      r = t[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1));

  var o = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

    Nt.startScope(n);

    try {
      var o = r.apply(void 0, t);
      return o instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Nt.endScope(o), o;
    } catch (t) {
      throw Nt.endScope(null), t;
    }
  };

  return Object.defineProperty(o, "name", {
    value: n,
    configurable: !0
  }), o;
}

Le.registerFlag("HAS_WEBGL", function () {
  return Le.getNumber("WEBGL_VERSION") > 0;
}), Le.registerFlag("WEBGL_VERSION", function () {
  return Fe(2) ? 2 : Fe(1) ? 1 : 0;
}), Le.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
  return 2 === Le.get("WEBGL_VERSION");
}), Le.registerFlag("WEBGL_CPU_FORWARD", function () {
  return !0;
}), Le.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
  return !1;
}), Le.registerFlag("WEBGL_PACK", function () {
  return Le.getBool("HAS_WEBGL");
}), Le.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_CLIP", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
  return !1;
}), Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_REDUCE", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_LAZILY_UNPACK", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_CONV_IM2COL", function () {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
  return Ae(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
  return De(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
  var t = Le.getNumber("WEBGL_VERSION");
  return 0 === t ? 0 : Te(t);
}), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
  return Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))));
  var t;
}), Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
  return Oe(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
  return !Le.getBool("WEBGL_FORCE_F16_TEXTURES") && Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
  return _e(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
  return Be(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
  return Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), pt = ze;
var En = Cn({
  complex_: function (t, e) {
    var n = ln(t, "real", "complex"),
        r = ln(e, "imag", "complex");
    return y(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."), Nt.runKernelFunc(function (t) {
      return t.complex(n, r);
    }, {
      $real: n,
      $imag: r
    });
  }
}),
    Rn = Cn({
  real_: function (t) {
    var e = ln(t, "input", "real");
    return Nt.runKernelFunc(function (t) {
      return t.real(e);
    }, {
      $input: e
    });
  }
}),
    In = Cn({
  imag_: function (t) {
    var e = ln(t, "input", "imag");
    return Nt.runKernelFunc(function (t) {
      return t.imag(e);
    }, {
      $input: e
    });
  }
});
exports.imag = In;
exports.real = Rn;
exports.complex = En;

function kn(t, e, n) {
  return Sn(t, e, sn(t, n), n);
}

function Sn(t, e, n, r) {
  if (null == r && (r = z(t)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!B(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");

  if (null != e) {
    Q(e);
    var o = w(e),
        i = w(n);
    g(o === i, function () {
      return "Based on the provided shape, [" + e + "], the tensor should have " + o + " values but has " + i;
    });

    for (var u = 0; u < n.length; ++u) {
      var s = n[u],
          c = u !== n.length - 1 || s !== w(e.slice(u));
      g(n[u] === e[u] || !c, function () {
        return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + e + "). ";
      });
    }
  }

  return B(t) || Array.isArray(t) || (t = [t]), e = e || n, t = "string" !== r ? K(t, r, a().getBool("DEBUG")) : b(t, [], !0), Nt.makeTensor(t, e, r);
}

function An(t, e) {
  if ((B(t) && "string" !== e || Array.isArray(t)) && "complex64" !== e) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === e && B(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Sn(t, [], [], e);
}

function Dn(t, e) {
  x(t);
  var n = sn(t, e);
  if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Sn(t, null, n, e);
}

function Tn(t, e, n) {
  if (x(t), null != e && 2 !== e.length) throw new Error("tensor2d() requires shape to have two numbers");
  var r = sn(t, n);
  if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Sn(t, e, r, n);
}

function Nn(t, e, n) {
  if (x(t), null != e && 3 !== e.length) throw new Error("tensor3d() requires shape to have three numbers");
  var r = sn(t, n);
  if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Sn(t, e, r, n);
}

function Fn(t, e, n) {
  if (x(t), null != e && 4 !== e.length) throw new Error("tensor4d() requires shape to have four numbers");
  var r = sn(t, n);
  if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Sn(t, e, r, n);
}

function On(t, e, n) {
  if (x(t), null != e && 5 !== e.length) throw new Error("tensor5d() requires shape to have five numbers");
  var r = sn(t, n);
  if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Sn(t, e, r, n);
}

function _n(t, e, n) {
  if (x(t), null != e && 6 !== e.length) throw new Error("tensor6d() requires shape to have six numbers");
  var r = sn(t, n);
  if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return Sn(t, e = e || r, r, n);
}

function Mn(t, e, n, r) {
  return void 0 === e && (e = !0), Nt.makeVariable(t, e, n, r);
}

function Bn(t, e) {
  if (void 0 === e && (e = "float32"), "complex64" === e) {
    var n = Bn(t, "float32"),
        r = Pn(t, "float32");
    return En(n, r);
  }

  var o = X(w(t), e);
  return Nt.makeTensor(o, t, e);
}

function Pn(t, e) {
  if (void 0 === e && (e = "float32"), "complex64" === e) {
    var n = Pn(t, "float32"),
        r = Pn(t, "float32");
    return En(n, r);
  }

  var o = $(w(t), e);
  return Nt.makeTensor(o, t, e);
}

function Ln(t, e, n) {
  return Nt.runKernelFunc(function (r) {
    return r.fill(t, e, n);
  }, {});
}

function Wn(t, e, n) {
  if (n <= 0) throw new Error("The number of values should be positive.");
  return Nt.runKernelFunc(function (r) {
    return r.linspace(t, e, n);
  }, {});
}

function Un(t, e, n, r) {
  if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
  if (t === e || t < e && n < 0 || e < t && n > 1) return Pn([0], r);
  var o = $(Math.abs(Math.ceil((e - t) / n)), r);
  e < t && 1 === n && (n = -1), o[0] = t;

  for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + n;

  return Dn(o, r);
}

var Vn = Cn({
  onesLike_: function (t) {
    var e = ln(t, "x", "onesLike");

    if ("complex64" === e.dtype) {
      var n = Vn(Rn(e)),
          r = zn(In(e));
      return En(n, r);
    }

    return Nt.runKernelFunc(function (t) {
      return t.onesLike(e);
    }, {
      $x: e
    }, function (t, e) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    zn = Cn({
  zerosLike_: function (t) {
    var e = ln(t, "x", "zerosLike");
    return Nt.runKernelFunc(function (t) {
      return t.zerosLike(e);
    }, {
      $x: e
    }, function (t, e) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
});
exports.zerosLike = zn;
exports.onesLike = Vn;
var Gn = Cn({
  concat_: function (t, e) {
    void 0 === e && (e = 0), g(t.length >= 1, function () {
      return "Pass at least one tensor to concat";
    });
    var n = hn(t, "tensors", "concat");
    "complex64" === n[0].dtype && n.forEach(function (t) {
      if ("complex64" !== t.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t.dtype + ". ");
    }), e = D(e, n[0].shape)[0];
    var r = wn(n.map(function (t) {
      return t.shape;
    }), e);
    if (0 === w(r)) return kn([], r);
    if (1 === (n = n.filter(function (t) {
      return t.size > 0;
    })).length) return n[0];
    var o = n.map(function (t) {
      return t.shape;
    });
    bn(o, e);
    var a = n,
        i = {
      axis: e
    };
    return Nt.runKernelFunc(function (t) {
      return t.concat(n, e);
    }, a, function (t) {
      var n = o.map(function (t) {
        return t[e];
      });
      return Xn(t, n, e).map(function (t) {
        return function () {
          return t;
        };
      });
    }, "Concat", i);
  }
}),
    Hn = Cn({
  concat1d_: function (t) {
    return Gn(t, 0);
  }
}),
    qn = Cn({
  concat2d_: function (t, e) {
    return Gn(t, e);
  }
}),
    Kn = Cn({
  concat3d_: function (t, e) {
    return Gn(t, e);
  }
}),
    jn = Cn({
  concat4d_: function (t, e) {
    return Gn(t, e);
  }
}),
    Xn = Cn({
  split_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r,
        o = ln(t, "x", "split");
    return n = D(n, o.shape)[0], "number" == typeof e ? (g(o.shape[n] % e == 0, function () {
      return "Number of splits must evenly divide the axis.";
    }), r = new Array(e).fill(o.shape[n] / e)) : (g(o.shape[n] === e.reduce(function (t, e) {
      return t + e;
    }), function () {
      return "The sum of sizes must match the size of the axis dimension.";
    }), r = e), Nt.runKernelFunc(function (t) {
      return t.split(o, r, n);
    }, {
      $x: o
    }, function (t) {
      return {
        $x: function () {
          return Gn(t, n);
        }
      };
    });
  }
});
exports.split = Xn;
exports.concat4d = jn;
exports.concat3d = Kn;
exports.concat2d = qn;
exports.concat1d = Hn;
exports.concat = Gn;
"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;

function $n(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var Yn = $n(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e,
          n = this,
          r = (e = 4022871197, function (t) {
        t = t.toString();

        for (var n = 0; n < t.length; n++) {
          var r = .02519603282416938 * (e += t.charCodeAt(n));
          r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e);
        }

        return 2.3283064365386963e-10 * (e >>> 0);
      });
      n.next = function () {
        var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t);
      }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null;
    }

    function o(t, e) {
      return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = n.next;
      return i.int32 = function () {
        return 4294967296 * n.next() | 0;
      }, i.double = function () {
        return i() + 1.1102230246251565e-16 * (2097152 * i() | 0);
      }, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.alea = a;
  }(0, t, !1);
}),
    Qn = $n(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
        var t = e.x ^ e.x << 11;
        return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
      }, t === (0 | t) ? e.x = t : n += t;

      for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next();
    }

    function o(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xor128 = a;
  }(0, t, !1);
}),
    Jn = $n(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.next = function () {
        var t = e.x ^ e.x >>> 2;
        return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
      }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;

      for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
    }

    function o(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xorwow = a;
  }(0, t, !1);
}),
    Zn = $n(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this;
      e.next = function () {
        var t,
            n,
            r = e.x,
            o = e.i;
        return t = r[o], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[o + 1 & 7]) ^ t >>> 10, n ^= (t = r[o + 3 & 7]) ^ t >>> 3, n ^= (t = r[o + 4 & 7]) ^ t << 7, t = r[o + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[o] = n, e.i = o + 1 & 7, n;
      }, function (t, e) {
        var n,
            r = [];
        if (e === (0 | e)) r[0] = e;else for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;

        for (; r.length < 8;) r.push(0);

        for (n = 0; n < 8 && 0 === r[n]; ++n);

        for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next();
      }(e, t);
    }

    function o(t, e) {
      return e.x = t.x.slice(), e.i = t.i, e;
    }

    function a(t, e) {
      null == t && (t = +new Date());

      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && (a.x && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xorshift7 = a;
  }(0, t, !1);
}),
    tr = $n(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this;
      e.next = function () {
        var t,
            n,
            r = e.w,
            o = e.X,
            a = e.i;
        return e.w = r = r + 1640531527 | 0, n = o[a + 34 & 127], t = o[a = a + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = o[a] = n ^ t, e.i = a, n + (r ^ r >>> 16) | 0;
      }, function (t, e) {
        var n,
            r,
            o,
            a,
            i,
            u = [],
            s = 128;

        for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, s = Math.max(s, e.length)), o = 0, a = -32; a < s; ++a) e && (r ^= e.charCodeAt((a + 32) % e.length)), 0 === a && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (n = u[127 & a] ^= r + i) ? o + 1 : 0);

        for (o >= 128 && (u[127 & (e && e.length || 0)] = -1), o = 127, a = 512; a > 0; --a) r = u[o + 34 & 127], n = u[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, u[o] = r ^ n;

        t.w = i, t.X = u, t.i = o;
      }(e, t);
    }

    function o(t, e) {
      return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;
    }

    function a(t, e) {
      null == t && (t = +new Date());

      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && (a.X && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xor4096 = a;
  }(0, t, !1);
}),
    er = $n(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.next = function () {
        var t = e.b,
            n = e.c,
            r = e.d,
            o = e.a;
        return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ o, e.a = o - t | 0;
      }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;

      for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next();
    }

    function o(t, e) {
      return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.tychei = a;
  }(0, t, !1);
}),
    nr = $n(function (t) {
  !function (e, n) {
    var r,
        o = this,
        a = 256,
        i = 6,
        u = "random",
        s = n.pow(a, i),
        c = n.pow(2, 52),
        l = 2 * c,
        h = a - 1;

    function f(t, h, f) {
      var g = [],
          y = v(function t(e, n) {
        var r,
            o = [],
            a = typeof e;
        if (n && "object" == a) for (r in e) try {
          o.push(t(e[r], n - 1));
        } catch (t) {}
        return o.length ? o : "string" == a ? e : e + "\0";
      }((h = 1 == h ? {
        entropy: !0
      } : h || {}).entropy ? [t, m(e)] : null == t ? function () {
        try {
          var t;
          return r && (t = r.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), m(t);
        } catch (t) {
          var n = o.navigator,
              i = n && n.plugins;
          return [+new Date(), o, i, o.screen, m(e)];
        }
      }() : t, 3), g),
          x = new p(g),
          b = function () {
        for (var t = x.g(i), e = s, n = 0; t < c;) t = (t + n) * a, e *= a, n = x.g(1);

        for (; t >= l;) t /= 2, e /= 2, n >>>= 1;

        return (t + n) / e;
      };

      return b.int32 = function () {
        return 0 | x.g(4);
      }, b.quick = function () {
        return x.g(4) / 4294967296;
      }, b.double = b, v(m(x.S), e), (h.pass || f || function (t, e, r, o) {
        return o && (o.S && d(o, x), t.state = function () {
          return d(x, {});
        }), r ? (n[u] = t, e) : t;
      })(b, y, "global" in h ? h.global : this == n, h.state);
    }

    function p(t) {
      var e,
          n = t.length,
          r = this,
          o = 0,
          i = r.i = r.j = 0,
          u = r.S = [];

      for (n || (t = [n++]); o < a;) u[o] = o++;

      for (o = 0; o < a; o++) u[o] = u[i = h & i + t[o % n] + (e = u[o])], u[i] = e;

      (r.g = function (t) {
        for (var e, n = 0, o = r.i, i = r.j, u = r.S; t--;) e = u[o = h & o + 1], n = n * a + u[h & (u[o] = u[i = h & i + e]) + (u[i] = e)];

        return r.i = o, r.j = i, n;
      })(a);
    }

    function d(t, e) {
      return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;
    }

    function v(t, e) {
      for (var n, r = t + "", o = 0; o < r.length;) e[h & o] = h & (n ^= 19 * e[h & o]) + r.charCodeAt(o++);

      return m(e);
    }

    function m(t) {
      return String.fromCharCode.apply(0, t);
    }

    if (n["seed" + u] = f, v(n.random(), e), t.exports) {
      t.exports = f;

      try {
        r = require("crypto");
      } catch (t) {}
    }
  }([], Math);
});
nr.alea = Yn, nr.xor128 = Qn, nr.xorwow = Jn, nr.xorshift7 = Zn, nr.xor4096 = tr, nr.tychei = er;

var rr = nr.alea,
    or = function () {
  function t(t, e, n, r, o) {
    this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = o || Math.random();
    this.random = rr(a.toString());
  }

  return t.prototype.nextValue = function () {
    if (!isNaN(this.nextVal)) {
      var t = this.nextVal;
      return this.nextVal = NaN, t;
    }

    for (var e, n, r = !1; !r;) {
      var o = void 0,
          a = void 0,
          i = void 0;

      do {
        i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;
      } while (i >= 1 || 0 === i);

      var u = Math.sqrt(-2 * Math.log(i) / i);
      e = this.mean + this.stdDev * o * u, n = this.mean + this.stdDev * a * u, this.truncated && !this.isValidTruncated(e) || (r = !0);
    }

    return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);
  }, t.prototype.convertValue = function (t) {
    return null == this.dtype || "float32" === this.dtype ? t : Math.round(t);
  }, t.prototype.isValidTruncated = function (t) {
    return t <= this.upper && t >= this.lower;
  }, t;
}(),
    ar = function () {
  function t(t, e, n, r) {
    this.alpha = t, this.beta = 1 / e, this.dtype = n;
    var o = r || Math.random();
    this.randu = rr(o.toString()), this.randn = new or(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }

  return t.prototype.nextValue = function () {
    for (var t, e, n, r, o, a;;) {
      do {
        r = this.randn.nextValue(), a = 1 + this.c * r;
      } while (a <= 0);

      if (a *= a * a, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - a + Math.log(a)), (o = this.randu()) < e || Math.log(o) < n) break;
    }

    return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);
  }, t.prototype.convertValue = function (t) {
    return "float32" === this.dtype ? t : Math.round(t);
  }, t;
}(),
    ir = function () {
  function t(t, e, n, r) {
    var o = this;
    if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function () {
      return null == o.dtype || "float32" === o.dtype;
    }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t + " - " + e + " <= 1 and dtype is not float");
    this.random = rr(r);
  }

  return t.prototype.convertValue = function (t) {
    return this.canReturnFloat() ? t : Math.round(t);
  }, t.prototype.nextValue = function () {
    return this.convertValue(this.min + this.range * this.random());
  }, t;
}();

function ur(t, e, n) {
  return void 0 === e && (e = "float32"), e = e || "float32", Q(t), new lt(t, e, n);
}

function sr(t, e) {
  void 0 === e && (e = !1), console.log(t.toString(e));
}

var cr = Cn({
  batchToSpaceND_: function (t, e, n) {
    var r = ln(t, "x", "batchToSpaceND"),
        o = e.reduce(function (t, e) {
      return t * e;
    });
    return g(r.rank >= 1 + e.length, function () {
      return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length;
    }), g(n.length === e.length, function () {
      return "crops.length is " + n.length + " but should be equal to blockShape.length  " + e.length;
    }), g(r.shape[0] % o == 0, function () {
      return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + o;
    }), Nt.runKernelFunc(function (t) {
      return t.batchToSpaceND(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.spaceToBatchND(e, n);
        }
      };
    });
  }
}),
    lr = Cn({
  cast_: function (t, e) {
    var n = ln(t, "x", "cast");
    if (!_(e)) throw new Error("Failed to cast to unknown dtype " + e);
    if ("string" === e && "string" !== n.dtype || "string" !== e && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
    var r = {
      dtype: e
    };
    return Nt.runKernelFunc(function (t) {
      return t.cast(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return t.clone();
        }
      };
    }, "Cast", r);
  }
}),
    hr = Cn({
  clone_: function (t) {
    var e = ln(t, "x", "clone", null);
    return Nt.runKernelFunc(function () {
      return Nt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return t.toFloat();
        }
      };
    });
  }
}),
    fr = Cn({
  cumsum_: function (t, e, n, r) {
    void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
    var o = ln(t, "x", "cumsum"),
        a = gn([e |= 0], o.rank),
        i = o;
    null != a && (i = o.transpose(a));
    var u = xn(1, o.rank)[0],
        s = Nt.runKernelFunc(function (t) {
      return t.cumsum(i, u, n, r);
    }, {
      permutedX: i
    }, function (t) {
      return {
        permutedX: function () {
          return t.cumsum(e, n, !r);
        }
      };
    });
    return null != a && (s = s.transpose(a)), s;
  }
}),
    pr = Cn({
  depthToSpace_: function (t, e, n) {
    void 0 === n && (n = "NHWC");
    var r = ln(t, "x", "depthToSpace"),
        o = "NHWC" === n ? r.shape[1] : r.shape[2],
        a = "NHWC" === n ? r.shape[2] : r.shape[3],
        i = "NHWC" === n ? r.shape[3] : r.shape[1];
    return g(o * e >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n      " + o + " and " + e + "  for depthToSpace with input shape\n      " + r.shape;
    }), g(a * e >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n      " + a + " and " + e + " for depthToSpace with input shape\n          " + r.shape;
    }), g(i % (e * e) == 0, function () {
      return "Dimension size must be evenly divisible by " + e * e + " but is " + i + " for depthToSpace with input shape " + r.shape;
    }), Nt.runKernelFunc(function (t) {
      return t.depthToSpace(r, e, n);
    }, {
      $x: r
    });
  }
}),
    dr = Cn({
  expandDims_: function (t, e) {
    void 0 === e && (e = 0);
    var n = ln(t, "x", "expandDims", null);
    g(e <= n.rank, function () {
      return "Axis must be <= rank of the tensor";
    });
    var r = n.shape.slice();
    return e < 0 && (g(-(n.rank + 1) <= e, function () {
      return "Axis must be in the interval [" + -(n.rank + 1) + ", " + n.rank + "]";
    }), e = n.rank + e + 1), r.splice(e, 0, 1), Sr(n, r);
  }
}),
    vr = Cn({
  eye_: function (t, e, n, r) {
    void 0 === r && (r = "float32"), null == e && (e = t);

    for (var o = ur([t, e], r), a = t <= e ? t : e, i = 0; i < a; ++i) o.set(1, i, i);

    var u = o.toTensor().as2D(t, e);
    if (null == n) return u;
    if (1 === n.length) return Nr(dr(u, 0), [n[0], 1, 1]);
    if (2 === n.length) return Nr(dr(dr(u, 0), 0), [n[0], n[1], 1, 1]);
    if (3 === n.length) return Nr(dr(dr(dr(u, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.");
  }
}),
    mr = Cn({
  multinomial_: function (t, e, n, r) {
    void 0 === r && (r = !1);
    var o = ln(t, "logits", "multinomial"),
        a = o.size,
        i = o.rank;
    if (a < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a + ".");
    if (i > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i);
    n = n || Math.random();
    var u = 1 === i ? o.as2D(1, -1) : o,
        s = Nt.runKernelFunc(function (t) {
      return t.multinomial(u, r, e, n);
    }, {
      logits2D: u
    });
    return 1 === i ? s.as1D() : s;
  }
}),
    gr = Cn({
  oneHot_: function (t, e, n, r) {
    if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
    var o = ln(t, "indices", "oneHot", "int32"),
        a = o.shape.concat([e]);
    return o = o.flatten(), Nt.runKernelFunc(function (t) {
      return t.oneHot(o, e, n, r);
    }, {
      $indices: o
    }, function (t) {
      return {
        $indices: function () {
          return Pn(o.shape, "float32");
        }
      };
    }).reshape(a);
  }
}),
    yr = Cn({
  pad_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r = ln(t, "x", "pad");
    if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    var o = e.map(function (t) {
      return t[0];
    });
    return Nt.runKernelFunc(function (t) {
      return t.pad(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.slice(o, r.shape);
        }
      };
    });
  }
}),
    xr = Cn({
  pad1d_: function (t, e, n) {
    return void 0 === n && (n = 0), g(2 === e.length, function () {
      return "Invalid number of paddings. Must be length of 2.";
    }), yr(t, [e], n);
  }
}),
    br = Cn({
  pad2d_: function (t, e, n) {
    return void 0 === n && (n = 0), g(2 === e.length && 2 === e[0].length && 2 === e[1].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), yr(t, e, n);
  }
}),
    wr = Cn({
  pad3d_: function (t, e, n) {
    return void 0 === n && (n = 0), g(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), yr(t, e, n);
  }
}),
    Cr = Cn({
  pad4d_: function (t, e, n) {
    return void 0 === n && (n = 0), g(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), yr(t, e, n);
  }
}),
    Er = Cn({
  rand_: function (t, e, n) {
    var r = w(t),
        o = null;
    if (null == n || "float32" === n) o = new Float32Array(r);else if ("int32" === n) o = new Int32Array(r);else {
      if ("bool" !== n) throw new Error("Unknown data type " + n);
      o = new Uint8Array(r);
    }

    for (var a = 0; a < r; a++) o[a] = e();

    return Nt.makeTensor(o, t, n);
  }
}),
    Rr = Cn({
  randomNormal_: function (t, e, n, r, o) {
    if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);

    for (var a = new or(e, n, r, !1, o), i = ur(t, r), u = 0; u < i.values.length; u++) i.values[u] = a.nextValue();

    return i.toTensor();
  }
}),
    Ir = Cn({
  randomGamma_: function (t, e, n, r, o) {
    if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);

    for (var a = new ar(e, n, r, o), i = ur(t, r), u = 0; u < i.values.length; u++) i.values[u] = a.nextValue();

    return i.toTensor();
  }
}),
    kr = Cn({
  randomUniform_: function (t, e, n, r, o) {
    void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");

    for (var a = ur(t, r), i = new ir(e, n, null, o), u = 0; u < a.values.length; u++) a.values[u] = i.nextValue();

    return a.toTensor();
  }
}),
    Sr = Cn({
  reshape_: function (t, e) {
    var n = ln(t, "x", "reshape", null);
    e = A(e, n.size), g(n.size === w(e), function () {
      return "new shape and old shape must have the same number of elements.";
    });
    var r = {
      shape: e
    };
    return Nt.runKernelFunc(function (t) {
      return t.reshape(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return t.reshape(n.shape);
        }
      };
    }, "Reshape", r);
  }
}),
    Ar = Cn({
  spaceToBatchND_: function (t, e, n) {
    var r = ln(t, "x", "spaceToBatchND");
    return g(r.rank >= 1 + e.length, function () {
      return "input rank " + r.rank + " should be > than [blockShape] " + e.length;
    }), g(n.length === e.length, function () {
      return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + e.length;
    }), g(r.shape.reduce(function (t, r, o) {
      return o > 0 && o <= e.length ? t && (r + n[o - 1][0] + n[o - 1][1]) % e[o - 1] == 0 : t;
    }, !0), function () {
      return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + e.toString();
    }), Nt.runKernelFunc(function (t) {
      return t.spaceToBatchND(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.batchToSpaceND(e, n);
        }
      };
    });
  }
}),
    Dr = Cn({
  squeeze_: function (t, e) {
    var n = ln(t, "x", "squeeze");
    return Sr(n, T(n.shape, e).newShape);
  }
}),
    Tr = Cn({
  stack_: function (t, e) {
    void 0 === e && (e = 0);
    var n = hn(t, "tensors", "stack");
    if (g(n.length >= 1, function () {
      return "Pass at least one tensor to tf.stack";
    }), 1 === n.length) return n[0].expandDims(e);
    var r = n[0].rank,
        o = n[0].shape,
        a = n[0].dtype;
    g(e <= r, function () {
      return "Axis must be <= rank of the tensor";
    }), n.forEach(function (t) {
      y(o, t.shape, "All tensors passed to stack must have matching shapes");
    }), n.forEach(function (t) {
      g(a === t.dtype, function () {
        return "All tensors passed to stack must have matching dtypes";
      });
    });
    var i = n.map(function (t) {
      return t.expandDims(e);
    });
    return Gn(i, e);
  }
}),
    Nr = Cn({
  tile_: function (t, e) {
    var n = ln(t, "x", "tile", null);
    return g(n.rank === e.length, function () {
      return "Error in transpose: rank of input " + n.rank + " must match length of reps " + e + ".";
    }), Nt.runKernelFunc(function (t, r) {
      var o = t.tile(n, e);
      return r([n]), o;
    }, {
      $x: n
    }, function (t, n) {
      var r = n[0];
      return {
        $x: function () {
          var n = zn(r);
          if (1 === r.rank) for (var o = 0; o < e[0]; ++o) n = n.add(t.slice([o * r.shape[0]], [r.shape[0]]));else if (2 === r.rank) for (o = 0; o < e[0]; ++o) for (var a = 0; a < e[1]; ++a) n = n.add(t.slice([o * r.shape[0], a * r.shape[1]], [r.shape[0], r.shape[1]]));else if (3 === r.rank) for (o = 0; o < e[0]; ++o) for (a = 0; a < e[1]; ++a) for (var i = 0; i < e[2]; ++i) n = n.add(t.slice([o * r.shape[0], a * r.shape[1], i * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));else {
            if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");

            for (o = 0; o < e[0]; ++o) for (a = 0; a < e[1]; ++a) for (i = 0; i < e[2]; ++i) for (var u = 0; u < e[3]; ++u) n = n.add(t.slice([o * r.shape[0], a * r.shape[1], i * r.shape[2], u * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));
          }
          return n;
        }
      };
    });
  }
}),
    Fr = Cn({
  truncatedNormal_: function (t, e, n, r, o) {
    if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);

    for (var a = new or(e, n, r, !0, o), i = ur(t, r), u = 0; u < i.values.length; u++) i.values[u] = a.nextValue();

    return i.toTensor();
  }
}),
    Or = Cn({
  unstack_: function (t, e) {
    void 0 === e && (e = 0), e = e || 0;
    var n = ln(t, "x", "unstack");
    return g(e >= -n.shape.length && e < n.shape.length, function () {
      return "Axis = " + e + " is not in [-" + n.shape.length + ", " + n.shape.length + ")";
    }), e < 0 && (e += n.shape.length), Nt.runKernelFunc(function (t) {
      return t.unstack(n, e);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return Tr(t, e);
        }
      };
    });
  }
}),
    _r = function (t, e) {
  return n(this, void 0, void 0, function () {
    var n, o, a, i, u, s, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = ln(t, "x", "setdiff1d"), o = ln(e, "y", "setdiff1d"), g(n.dtype === o.dtype, function () {
            return "x and y should have the same dtype, but got x (" + n.dtype + ") and y (" + o.dtype + ").";
          }), g(1 === n.rank, function () {
            return "x should be 1D tensor, but got x (" + n.shape + ").";
          }), g(1 === o.rank, function () {
            return "y should be 1D tensor, but got y (" + o.shape + ").";
          }), [4, n.data()];

        case 1:
          return a = r.sent(), [4, o.data()];

        case 2:
          for (i = r.sent(), u = new Set(i), s = 0, h = 0; h < a.length; h++) u.has(a[h]) || s++;

          for (c = new lt([s], n.dtype), l = new lt([s], "int32"), h = 0, f = 0; h < a.length; h++) u.has(a[h]) || (c.values[f] = a[h], l.values[f] = h, f++);

          return [2, [c.toTensor(), l.toTensor()]];
      }
    });
  });
};

exports.setdiff1dAsync = _r;
exports.unstack = Or;
exports.truncatedNormal = Fr;
exports.tile = Nr;
exports.stack = Tr;
exports.squeeze = Dr;
exports.spaceToBatchND = Ar;
exports.reshape = Sr;
exports.randomUniform = kr;
exports.randomGamma = Ir;
exports.randomNormal = Rr;
exports.rand = Er;
exports.pad4d = Cr;
exports.pad3d = wr;
exports.pad2d = br;
exports.pad1d = xr;
exports.pad = yr;
exports.oneHot = gr;
exports.multinomial = mr;
exports.eye = vr;
exports.expandDims = dr;
exports.depthToSpace = pr;
exports.cumsum = fr;
exports.clone = hr;
exports.cast = lr;
exports.batchToSpaceND = cr;

function Mr(t, e, n, r) {
  void 0 === r && (r = !0);
  var o = [];
  if (r) (o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1));else {
    o = o.concat(t[0]);

    for (var a = e.length, i = 0; i < a; ++i) o = o.concat([t[i + 1] / e[i], e[i]]);

    o = o.concat(t.slice(a + 1));
  }
  return o;
}

function Br(t, e, n) {
  void 0 === n && (n = !0);
  var r = [];

  if (n) {
    r.push(e);

    for (var o = e + 1; o < t; ++o) o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);
  } else {
    var a = [],
        i = [];

    for (o = 1; o < t; ++o) o >= 2 * e + 1 || o % 2 == 1 ? i.push(o) : a.push(o);

    r.push.apply(r, a), r.push(0), r.push.apply(r, i);
  }

  return r;
}

function Pr(t, e, n, r) {
  void 0 === r && (r = !0);
  var o = [];
  r ? o.push(t[0] / n) : o.push(t[0] * n);

  for (var a = 1; a < t.length; ++a) a <= e.length ? r ? o.push(e[a - 1] * t[a]) : o.push(t[a] / e[a - 1]) : o.push(t[a]);

  return o;
}

function Lr(t, e) {
  for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);

  return n;
}

function Wr(t, e, n) {
  for (var r = t.slice(0, 1), o = 0; o < n; ++o) r.push(t[o + 1] - e[o][0] - e[o][1]);

  return r;
}

function Ur(t, e) {
  if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t.rank + ".");
  if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if ("int32" !== e.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
  if (e.shape[e.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + t.rank);
  if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t.shape + ".");

  for (var n = e.shape, r = n[n.length - 1], o = 1, a = 0; a < n.length - 1; ++a) o *= n[a];

  var i = t.shape,
      u = n.slice();
  u.pop();
  var s = 1;

  for (a = r; a < t.rank; ++a) s *= i[a], u.push(i[a]);

  var c = q(t.shape).map(function (t) {
    return t / s;
  }).concat([1]).slice(0, r);
  return [u, o, s, c];
}

var Vr = 30;

function zr(t) {
  return t <= Vr ? t : H(t, Math.floor(Math.sqrt(t)));
}

function Gr(t, e, n) {
  if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (t.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t.rank + ".");
  if ("int32" !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
  if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);

  if (0 === n.length) {
    if (0 === e.size) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
    if (0 === t.size) throw new Error("Updates specified for empty output. updates shape: " + t.shape);
  }

  !function (t, e, n) {
    var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
        o = e.rank > 1 ? e.rank - 1 : 1,
        a = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + e.shape + ", shape: " + t + ", sliceDim: " + r + ", and batchDim: " + o + ".";
    if (n.rank < o) throw new Error(a + " update.rank < " + o + ". ");
    if (t.length < r + (n.rank - o)) throw new Error(a + " Output shape length < " + (r + (n.rank - o)));
    if (n.rank !== o + t.length - r) throw new Error(a + " update.rank != " + (o + t.length - r));

    for (var i = 0; i < o; ++i) if (n.shape[i] !== e.shape[i]) throw new Error(a + " updates.shape[" + i + "] (" + n.shape[i] + ") != indices.shape[" + i + "] (" + e.shape[i] + ").");

    for (i = 0; i < n.rank - o; ++i) if (n.shape[i + o] !== t[i + r]) throw new Error(a + " updates.shape[" + (i + o) + "] (" + n.shape[i + o] + ") != shape[" + (i + o) + "] (" + t[i + o] + ")");
  }(n, e, t);
}

function Hr(t, e, n) {
  for (var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, o = n.length, a = 1, i = r; i < o; ++i) a *= n[i];

  var u = r < 1 ? 1 : r;
  return {
    sliceRank: r,
    numUpdates: e.size / u,
    sliceSize: a,
    strides: q(n.slice(0, r)).concat([1]),
    outputSize: w(n)
  };
}

function qr(t, e, n) {
  g(t.rank === e.length, function () {
    return "Error in slice" + t.rank + "D: Length of begin " + e + " must match the rank of the array (" + t.rank + ").";
  }), g(t.rank === n.length, function () {
    return "Error in slice" + t.rank + "D: Length of size " + n + " must match the rank of the array (" + t.rank + ").";
  });

  for (var r = function (r) {
    g(e[r] + n[r] <= t.shape[r], function () {
      return "Error in slice" + t.rank + "D: begin[" + r + "] + size[" + r + "] (" + (e[r] + n[r]) + ") would overflow input.shape[" + r + "] (" + t.shape[r] + ")";
    });
  }, o = 0; o < t.rank; ++o) r(o);
}

function Kr(t) {
  for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;

  return e;
}

function jr(t, e, n) {
  for (var r = [], o = 0; o < t.length; o++) r[o] = Math.ceil((e[o] - t[o]) / n[o]);

  return r;
}

function Xr(t, e, n, r, o) {
  var a = e[o],
      i = n[o] || 1;
  (t & 1 << o || null == a) && (a = i > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var u = r[o];
  return a < 0 && (a += u), a = d(0, a, u - 1);
}

function $r(t, e, n, r, o) {
  var a = e[o],
      i = n[o] || 1;
  (t & 1 << o || null == a) && (a = i > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var u = r[o];
  return a < 0 && (a += u), a = i > 0 ? d(0, a, u) : d(-1, a, u - 1);
}

function Yr(t, e, n) {
  for (var r = n.length, o = 0; o < n.length; o++) if (n[o] > 1) {
    r = o;
    break;
  }

  for (o = r + 1; o < n.length; o++) if (e[o] > 0 || n[o] !== t[o]) return !1;

  return !0;
}

function Qr(t, e) {
  for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];

  return n;
}

var Jr = Object.freeze({
  assertParamsValid: qr,
  maskToAxes: Kr,
  computeOutShape: jr,
  startForAxis: Xr,
  stopForAxis: $r,
  isSliceContinous: Yr,
  computeFlatOffset: Qr
});
exports.slice_util = Jr;

function Zr(t) {
  return g(G(t), function () {
    return "The f passed in grad(f) must be a function";
  }), function (e, n) {
    var r = ln(e, "x", "tf.grad", null),
        o = null != n ? ln(n, "dy", "tf.grad") : null;
    return Nt.tidy(function () {
      var e = Nt.gradients(function () {
        return t(r);
      }, [r], o),
          n = e.value,
          a = e.grads;
      return null != o && y(n.shape, o.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), ao(a), a[0];
    });
  };
}

function to(t) {
  return g(G(t), function () {
    return "The f passed in grads(f) must be a function";
  }), function (e, n) {
    g(Array.isArray(e), function () {
      return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
    });
    var r = hn(e, "args", "tf.grads", null),
        o = null != n ? ln(n, "dy", "tf.grads") : null;
    return Nt.tidy(function () {
      var e = Nt.gradients(function () {
        return t.apply(void 0, r);
      }, r, o),
          n = e.value,
          a = e.grads;
      return null != o && y(n.shape, o.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), ao(a), a;
    });
  };
}

function eo(t) {
  return g(G(t), function () {
    return "The f passed in valueAndGrad(f) must be a function";
  }), function (e, n) {
    g(e instanceof dt, function () {
      return "The x passed in valueAndGrad(f)(x) must be a tensor";
    }), g(null == n || n instanceof dt, function () {
      return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
    });
    var r = Nt.gradients(function () {
      return t(e);
    }, [e], n),
        o = r.grads,
        a = r.value;
    return ao(o), {
      grad: o[0],
      value: a
    };
  };
}

function no(t) {
  return g(G(t), function () {
    return "The f passed in valueAndGrads(f) must be a function";
  }), function (e, n) {
    g(Array.isArray(e) && e.every(function (t) {
      return t instanceof dt;
    }), function () {
      return "The args passed in valueAndGrads(f)(args) must be array of tensors";
    }), g(null == n || n instanceof dt, function () {
      return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
    });
    var r = Nt.gradients(function () {
      return t.apply(void 0, e);
    }, e, n);
    return null != n && y(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), ao(r.grads), r;
  };
}

function ro(t, e) {
  g(G(t), function () {
    return "The f passed in variableGrads(f) must be a function";
  }), g(null == e || Array.isArray(e) && e.every(function (t) {
    return t instanceof bt;
  }), function () {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var n = null != e;
  if (!n) for (var r in e = [], Nt.registeredVariables) e.push(Nt.registeredVariables[r]);
  var o = n ? e.filter(function (t) {
    return !t.trainable;
  }) : null,
      a = e.length;
  g((e = e.filter(function (t) {
    return t.trainable;
  })).length > 0, function () {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a + " variables is trainable.";
  });
  var i = Nt.gradients(t, e, null, !0),
      u = i.value,
      s = i.grads;
  g(s.some(function (t) {
    return null != t;
  }), function () {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), g(0 === u.rank, function () {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + u.rank + " tensor";
  });
  var c = {};
  return e.forEach(function (t, e) {
    null != s[e] && (c[t.name] = s[e]);
  }), null != o && o.forEach(function (t) {
    return c[t.name] = null;
  }), {
    value: u,
    grads: c
  };
}

function oo(t) {
  return Nt.customGrad(t);
}

function ao(t) {
  if (t.filter(function (t) {
    return null == t;
  }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}

var io = Cn({
  softmax_: function (t, e) {
    void 0 === e && (e = -1);
    var n = ln(t, "logits", "softmax");
    if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + e);
    return oo(function (t, n) {
      var r = t.logSumExp([e], !0),
          o = t.toFloat().sub(r).exp();
      return n([o]), {
        value: o,
        gradFunc: function (t, n) {
          var r = n[0],
              o = t.mul(r);
          return o.sub(o.sum([e], !0).mul(r));
        }
      };
    })(n);
  }
}),
    uo = Cn({
  logSoftmax_: function (t, e) {
    void 0 === e && (e = -1);
    var n = ln(t, "logits", "logSoftmax");
    if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + e);
    return oo(function (t, n) {
      var r = t.max(e, !0),
          o = t.sub(r),
          a = o.toFloat().sub(o.exp().sum(e, !0).log());
      return n([a]), {
        value: a,
        gradFunc: function (t, n) {
          var r = n[0].exp();
          return t.sub(t.sum(e, !0).mul(r));
        }
      };
    })(n);
  }
}),
    so = function () {
  function t(t, e) {
    this.backend = t, this.dataMover = e, this.data = new WeakMap(), this.dataIdsCount = 0;
  }

  return t.prototype.get = function (t) {
    return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);
  }, t.prototype.set = function (t, e) {
    this.dataIdsCount++, this.data.set(t, e);
  }, t.prototype.has = function (t) {
    return this.data.has(t);
  }, t.prototype.delete = function (t) {
    return this.dataIdsCount--, this.data.delete(t);
  }, t.prototype.numDataIds = function () {
    return this.dataIdsCount;
  }, t;
}(),
    co = function () {
  function t() {}

  return t.prototype.time = function (t) {
    return lo("time");
  }, t.prototype.read = function (t) {
    return lo("read");
  }, t.prototype.readSync = function (t) {
    return lo("readSync");
  }, t.prototype.numDataIds = function () {
    return lo("numDataIds");
  }, t.prototype.disposeData = function (t) {
    return lo("disposeData");
  }, t.prototype.fromPixels = function (t, e) {
    return lo("fromPixels");
  }, t.prototype.write = function (t, e, n) {
    return lo("write");
  }, t.prototype.move = function (t, e, n, r) {
    return lo("move");
  }, t.prototype.memory = function () {
    return lo("memory");
  }, t.prototype.floatPrecision = function () {
    return lo("floatPrecision");
  }, t.prototype.epsilon = function () {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, t.prototype.batchMatMul = function (t, e, n, r) {
    return lo("batchMatMul");
  }, t.prototype.fusedBatchMatMul = function (t) {
    t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights;
    return lo("fusedBatchMatMul");
  }, t.prototype.slice = function (t, e, n) {
    return lo("slice");
  }, t.prototype.stridedSlice = function (t, e, n, r) {
    return lo("stridedSlice");
  }, t.prototype.unstack = function (t, e) {
    return lo("unstack");
  }, t.prototype.reverse = function (t, e) {
    return lo("reverse");
  }, t.prototype.concat = function (t, e) {
    return lo("concat");
  }, t.prototype.neg = function (t) {
    return lo("neg");
  }, t.prototype.add = function (t, e) {
    return lo("add");
  }, t.prototype.addN = function (t) {
    return lo("addN");
  }, t.prototype.subtract = function (t, e) {
    return lo("subtract");
  }, t.prototype.multiply = function (t, e) {
    return lo("multiply");
  }, t.prototype.realDivide = function (t, e) {
    return lo("realDivide");
  }, t.prototype.floorDiv = function (t, e) {
    return lo("floorDiv");
  }, t.prototype.sum = function (t, e) {
    return lo("sum");
  }, t.prototype.prod = function (t, e) {
    return lo("prod");
  }, t.prototype.unsortedSegmentSum = function (t, e, n) {
    return lo("unsortedSegmentSum");
  }, t.prototype.argMin = function (t, e) {
    return lo("argMin");
  }, t.prototype.argMax = function (t, e) {
    return lo("argMax");
  }, t.prototype.equal = function (t, e) {
    return lo("equal");
  }, t.prototype.notEqual = function (t, e) {
    return lo("notEqual");
  }, t.prototype.less = function (t, e) {
    return lo("less");
  }, t.prototype.lessEqual = function (t, e) {
    return lo("lessEqual");
  }, t.prototype.greater = function (t, e) {
    return lo("greater");
  }, t.prototype.greaterEqual = function (t, e) {
    return lo("greaterEqual");
  }, t.prototype.logicalNot = function (t) {
    return lo("logicalNot");
  }, t.prototype.logicalAnd = function (t, e) {
    return lo("logicalAnd");
  }, t.prototype.logicalOr = function (t, e) {
    return lo("logicalOr");
  }, t.prototype.where = function (t) {
    return lo("where");
  }, t.prototype.select = function (t, e, n) {
    return lo("select");
  }, t.prototype.topk = function (t, e, n) {
    return lo("topk");
  }, t.prototype.min = function (t, e) {
    return lo("min");
  }, t.prototype.minimum = function (t, e) {
    return lo("minimum");
  }, t.prototype.mod = function (t, e) {
    return lo("mod");
  }, t.prototype.max = function (t, e) {
    return lo("max");
  }, t.prototype.maximum = function (t, e) {
    return lo("maximum");
  }, t.prototype.all = function (t, e) {
    return lo("all");
  }, t.prototype.any = function (t, e) {
    return lo("any");
  }, t.prototype.squaredDifference = function (t, e) {
    return lo("squaredDifference");
  }, t.prototype.ceil = function (t) {
    return lo("ceil");
  }, t.prototype.floor = function (t) {
    return lo("floor");
  }, t.prototype.round = function (t) {
    return lo("round");
  }, t.prototype.sign = function (t) {
    return lo("sign");
  }, t.prototype.isNaN = function (t) {
    return lo("isNaN");
  }, t.prototype.isInf = function (t) {
    return lo("isInf");
  }, t.prototype.isFinite = function (t) {
    return lo("isFinite");
  }, t.prototype.pow = function (t, e) {
    return lo("pow");
  }, t.prototype.exp = function (t) {
    return lo("exp");
  }, t.prototype.expm1 = function (t) {
    return lo("expm1");
  }, t.prototype.log = function (t) {
    return lo("log");
  }, t.prototype.log1p = function (t) {
    return lo("log1p");
  }, t.prototype.sqrt = function (t) {
    return lo("sqrt");
  }, t.prototype.rsqrt = function (t) {
    return lo("rsqrt");
  }, t.prototype.square = function (t) {
    return lo("square");
  }, t.prototype.reciprocal = function (t) {
    return lo("reciprocal");
  }, t.prototype.relu = function (t) {
    return lo("relu");
  }, t.prototype.relu6 = function (t) {
    return lo("relu6");
  }, t.prototype.prelu = function (t, e) {
    return lo("prelu");
  }, t.prototype.elu = function (t) {
    return lo("elu");
  }, t.prototype.eluDer = function (t, e) {
    return lo("eluDer");
  }, t.prototype.selu = function (t) {
    return lo("selu");
  }, t.prototype.int = function (t) {
    return lo("int");
  }, t.prototype.clip = function (t, e, n) {
    return lo("clip");
  }, t.prototype.abs = function (t) {
    return lo("abs");
  }, t.prototype.complexAbs = function (t) {
    return lo("complexAbs");
  }, t.prototype.sigmoid = function (t) {
    return lo("sigmoid");
  }, t.prototype.softplus = function (t) {
    return lo("softplus");
  }, t.prototype.sin = function (t) {
    return lo("sin");
  }, t.prototype.cos = function (t) {
    return lo("cos");
  }, t.prototype.tan = function (t) {
    return lo("tan");
  }, t.prototype.asin = function (t) {
    return lo("asin");
  }, t.prototype.acos = function (t) {
    return lo("acos");
  }, t.prototype.atan = function (t) {
    return lo("atan");
  }, t.prototype.atan2 = function (t, e) {
    return lo("atan2");
  }, t.prototype.sinh = function (t) {
    return lo("sinh");
  }, t.prototype.cosh = function (t) {
    return lo("cosh");
  }, t.prototype.tanh = function (t) {
    return lo("tanh");
  }, t.prototype.asinh = function (t) {
    return lo("asinh");
  }, t.prototype.acosh = function (t) {
    return lo("acosh");
  }, t.prototype.atanh = function (t) {
    return lo("atanh");
  }, t.prototype.erf = function (t) {
    return lo("erf");
  }, t.prototype.step = function (t, e) {
    return lo("step");
  }, t.prototype.fusedConv2d = function (t) {
    t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;
    return lo("fusedConv2d");
  }, t.prototype.conv2d = function (t, e, n) {
    return lo("conv2d");
  }, t.prototype.conv2dDerInput = function (t, e, n) {
    return lo("conv2dDerInput");
  }, t.prototype.conv2dDerFilter = function (t, e, n) {
    return lo("conv2dDerFilter");
  }, t.prototype.fusedDepthwiseConv2D = function (t) {
    t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;
    return lo("fusedDepthwiseConv2D");
  }, t.prototype.depthwiseConv2D = function (t, e, n) {
    return lo("depthwiseConv2D");
  }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    return lo("depthwiseConv2DDerInput");
  }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    return lo("depthwiseConv2DDerFilter");
  }, t.prototype.conv3d = function (t, e, n) {
    return lo("conv3d");
  }, t.prototype.conv3dDerInput = function (t, e, n) {
    return lo("conv3dDerInput");
  }, t.prototype.conv3dDerFilter = function (t, e, n) {
    return lo("conv3dDerFilter");
  }, t.prototype.maxPool = function (t, e) {
    return lo("maxPool");
  }, t.prototype.maxPoolBackprop = function (t, e, n, r) {
    return lo("maxPoolBackprop");
  }, t.prototype.avgPool = function (t, e) {
    return lo("avgPool");
  }, t.prototype.avgPoolBackprop = function (t, e, n) {
    return lo("avgPoolBackprop");
  }, t.prototype.avgPool3d = function (t, e) {
    return lo("avgPool3d");
  }, t.prototype.avgPool3dBackprop = function (t, e, n) {
    return lo("avgPool3dBackprop");
  }, t.prototype.maxPool3d = function (t, e) {
    return lo("maxPool3d");
  }, t.prototype.maxPool3dBackprop = function (t, e, n, r) {
    return lo("maxPool3dBackprop");
  }, t.prototype.reshape = function (t, e) {
    return lo("reshape");
  }, t.prototype.cast = function (t, e) {
    return lo("cast");
  }, t.prototype.tile = function (t, e) {
    return lo("tile");
  }, t.prototype.pad = function (t, e, n) {
    return lo("pad");
  }, t.prototype.transpose = function (t, e) {
    return lo("transpose");
  }, t.prototype.gather = function (t, e, n) {
    return lo("gather");
  }, t.prototype.gatherND = function (t, e) {
    return lo("gatherND");
  }, t.prototype.scatterND = function (t, e, n) {
    return lo("scatterND");
  }, t.prototype.batchToSpaceND = function (t, e, n) {
    return lo("batchToSpaceND");
  }, t.prototype.spaceToBatchND = function (t, e, n) {
    return lo("spaceToBatchND");
  }, t.prototype.resizeBilinear = function (t, e, n, r) {
    return lo("resizeBilinear");
  }, t.prototype.resizeBilinearBackprop = function (t, e, n) {
    return lo("resizeBilinearBackprop");
  }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    return lo("resizeNearestNeighbor");
  }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    return lo("resizeNearestNeighborBackprop");
  }, t.prototype.batchNormalization = function (t, e, n, r, o, a) {
    return lo("batchNormalization");
  }, t.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    return lo("localResponseNormalization4D");
  }, t.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    return lo("LRNGrad");
  }, t.prototype.multinomial = function (t, e, n, r) {
    return lo("multinomial");
  }, t.prototype.oneHot = function (t, e, n, r) {
    return lo("oneHot");
  }, t.prototype.cumsum = function (t, e, n, r) {
    return lo("cumsum");
  }, t.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return lo("nonMaxSuppression");
  }, t.prototype.fft = function (t) {
    return lo("fft");
  }, t.prototype.ifft = function (t) {
    return lo("ifft");
  }, t.prototype.complex = function (t, e) {
    return lo("complex");
  }, t.prototype.real = function (t) {
    return lo("real");
  }, t.prototype.imag = function (t) {
    return lo("imag");
  }, t.prototype.cropAndResize = function (t, e, n, r, o, a) {
    return lo("cropAndResize");
  }, t.prototype.depthToSpace = function (t, e, n) {
    return lo("depthToSpace");
  }, t.prototype.split = function (t, e, n) {
    return lo("split");
  }, t.prototype.sparseToDense = function (t, e, n, r) {
    return lo("sparseToDense");
  }, t.prototype.diag = function (t) {
    return lo("diag");
  }, t.prototype.fill = function (t, e, n) {
    return lo("fill");
  }, t.prototype.onesLike = function (t) {
    return lo("onesLike");
  }, t.prototype.zerosLike = function (t) {
    return lo("zerosLike");
  }, t.prototype.linspace = function (t, e, n) {
    return lo("linspace");
  }, t.prototype.dispose = function () {
    return lo("dispose");
  }, t;
}();

exports.KernelBackend = co;
exports.DataStorage = so;
exports.logSoftmax = uo;
exports.softmax = io;

function lo(t) {
  throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}

function ho(t, e) {
  for (var n = t.length, r = [], o = 0; o < n; o++) {
    var a = n - 1 - o,
        i = t[a] || 1;
    (e[e.length - 1 - o] || 1) > 1 && 1 === i && r.unshift(a);
  }

  return r;
}

function fo(t, e) {
  for (var n = [], r = 0; r < e.length; r++) {
    var o = t[t.length - r - 1],
        a = e.length - r - 1,
        i = e[a];
    (null == o || 1 === o && i > 1) && n.unshift(a);
  }

  return n;
}

function po(t, e) {
  for (var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++) {
    var a = t[t.length - o - 1];
    null == a && (a = 1);
    var i = e[e.length - o - 1];
    if (null == i && (i = 1), 1 === a) n.unshift(i);else if (1 === i) n.unshift(a);else {
      if (a !== i) throw Error("Operands could not be broadcast together with shapes " + t + " and " + e + ".");
      n.unshift(a);
    }
  }

  return n;
}

function vo(t, e, n, r, o, a, i) {
  void 0 === i && (i = "channelsLast");
  var u,
      s = bo(e),
      c = s[0],
      l = s[1];
  if ("channelsLast" === i) u = [c, l, t[3], t[3]];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat " + i);
    u = [c, l, t[1], t[1]];
  }
  return go(t, u, n, r, o, a, !1, i);
}

function mo(t, e, n, r, o, a, i) {
  void 0 === i && (i = "NDHWC");
  var u,
      s,
      c = wo(e),
      l = c[0],
      h = c[1],
      f = c[2];
  if ("NDHWC" === i) s = "channelsLast", u = [l, h, f, t[4], t[4]];else {
    if ("NCDHW" !== i) throw new Error("Unknown dataFormat " + i);
    s = "channelsFirst", u = [l, h, f, t[1], t[1]];
  }
  return yo(t, u, n, r, o, !1, s, a);
}

function go(t, e, n, r, o, a, i, u) {
  void 0 === i && (i = !1), void 0 === u && (u = "channelsLast");
  var s = [-1, -1, -1, -1],
      c = s[0],
      l = s[1],
      h = s[2],
      f = s[3];
  if ("channelsLast" === u) c = t[0], l = t[1], h = t[2], f = t[3];else {
    if ("channelsFirst" !== u) throw new Error("Unknown dataFormat " + u);
    c = t[0], f = t[1], l = t[2], h = t[3];
  }

  var p,
      d = e[0],
      v = e[1],
      m = e[3],
      y = bo(n),
      x = y[0],
      b = y[1],
      w = bo(r),
      C = w[0],
      R = w[1],
      I = Co(d, C),
      k = Co(v, R),
      S = function (t, e, n, r, o, a, i, u) {
    var s, c, l;

    if ("number" == typeof t) {
      var h = 0 === t ? "VALID" : "NUMBER";
      s = {
        top: t,
        bottom: t,
        left: t,
        right: t,
        type: h
      };

      var f = function (t, e, n, r, o) {
        null == r && (r = xo(t, e, n));
        var a = t[0],
            i = t[1],
            u = Eo((a - e + 2 * r) / n + 1, o);
        g(E(u), function () {
          return "The output # of rows (" + u + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var s = Eo((i - e + 2 * r) / n + 1, o);
        return g(E(s), function () {
          return "The output # of columns (" + s + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [u, s];
      }([e, n], a, r, t, u);

      c = f[0], l = f[1];
    } else if ("same" === t) {
      c = Math.ceil(e / r), l = Math.ceil(n / o);
      var p = Math.max(0, (c - 1) * r + a - e),
          d = Math.max(0, (l - 1) * o + i - n),
          v = Math.floor(p / 2),
          m = p - v,
          y = Math.floor(d / 2),
          x = d - y;
      s = {
        top: v,
        bottom: m,
        left: y,
        right: x,
        type: "SAME"
      };
    } else {
      if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
      s = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        type: "VALID"
      }, c = Math.ceil((e - a + 1) / r), l = Math.ceil((n - i + 1) / o);
    }

    return {
      padInfo: s,
      outHeight: c,
      outWidth: l
    };
  }(o, l, h, x, b, I, k, a),
      A = S.padInfo,
      D = S.outHeight,
      T = S.outWidth,
      N = i ? m * f : m;

  return "channelsFirst" === u ? p = [c, N, D, T] : "channelsLast" === u && (p = [c, D, T, N]), {
    batchSize: c,
    dataFormat: u,
    inHeight: l,
    inWidth: h,
    inChannels: f,
    outHeight: D,
    outWidth: T,
    outChannels: N,
    padInfo: A,
    strideHeight: x,
    strideWidth: b,
    filterHeight: d,
    filterWidth: v,
    effectiveFilterHeight: I,
    effectiveFilterWidth: k,
    dilationHeight: C,
    dilationWidth: R,
    inShape: t,
    outShape: p,
    filterShape: e
  };
}

function yo(t, e, n, r, o, a, i, u) {
  void 0 === a && (a = !1), void 0 === i && (i = "channelsLast");
  var s = [-1, -1, -1, -1, -1],
      c = s[0],
      l = s[1],
      h = s[2],
      f = s[3],
      p = s[4];
  if ("channelsLast" === i) c = t[0], l = t[1], h = t[2], f = t[3], p = t[4];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat " + i);
    c = t[0], p = t[1], l = t[2], h = t[3], f = t[4];
  }

  var d,
      v = e[0],
      m = e[1],
      y = e[2],
      x = e[4],
      b = wo(n),
      w = b[0],
      C = b[1],
      R = b[2],
      I = wo(r),
      k = I[0],
      S = I[1],
      A = I[2],
      D = Co(v, k),
      T = Co(m, S),
      N = Co(y, A),
      F = function (t, e, n, r, o, a, i, u, s, c, l) {
    var h, f, p, d;

    if ("number" == typeof t) {
      var v = 0 === t ? "VALID" : "NUMBER";
      h = {
        top: t,
        bottom: t,
        left: t,
        right: t,
        front: t,
        back: t,
        type: v
      };

      var m = function (t, e, n, r, o, a) {
        null == o && (o = xo(t, e, r));
        var i = t[0],
            u = t[1],
            s = t[2],
            c = Eo((i - e + 2 * o) / r + 1, a);
        g(E(c), function () {
          return "The output # of depths (" + c + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var l = Eo((u - e + 2 * o) / r + 1, a);
        g(E(l), function () {
          return "The output # of rows (" + l + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var h = Eo((s - e + 2 * o) / r + 1, a);
        return g(E(h), function () {
          return "The output # of columns (" + h + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [c, l, h, n];
      }([e, n, r, 1], u, 1, o, t, l);

      f = m[0], p = m[1], d = m[2];
    } else if ("same" === t) {
      f = Math.ceil(e / o), p = Math.ceil(n / a), d = Math.ceil(r / i);
      var y = (f - 1) * o + u - e,
          x = (p - 1) * a + s - n,
          b = (d - 1) * i + c - r,
          w = Math.floor(y / 2),
          C = y - w,
          R = Math.floor(x / 2),
          I = x - R,
          k = Math.floor(b / 2),
          S = b - k;
      h = {
        top: R,
        bottom: I,
        left: k,
        right: S,
        front: w,
        back: C,
        type: "SAME"
      };
    } else {
      if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
      h = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      }, f = Math.ceil((e - u + 1) / o), p = Math.ceil((n - s + 1) / a), d = Math.ceil((r - c + 1) / i);
    }

    return {
      padInfo: h,
      outDepth: f,
      outHeight: p,
      outWidth: d
    };
  }(o, l, h, f, w, C, R, D, T, N, u),
      O = F.padInfo,
      _ = F.outDepth,
      M = F.outHeight,
      B = F.outWidth,
      P = a ? x * p : x;

  return "channelsFirst" === i ? d = [c, P, _, M, B] : "channelsLast" === i && (d = [c, _, M, B, P]), {
    batchSize: c,
    dataFormat: i,
    inDepth: l,
    inHeight: h,
    inWidth: f,
    inChannels: p,
    outDepth: _,
    outHeight: M,
    outWidth: B,
    outChannels: P,
    padInfo: O,
    strideDepth: w,
    strideHeight: C,
    strideWidth: R,
    filterDepth: v,
    filterHeight: m,
    filterWidth: y,
    effectiveFilterDepth: D,
    effectiveFilterHeight: T,
    effectiveFilterWidth: N,
    dilationDepth: k,
    dilationHeight: S,
    dilationWidth: A,
    inShape: t,
    outShape: d,
    filterShape: e
  };
}

function xo(t, e, n, r) {
  void 0 === r && (r = 1);
  var o = Co(e, r);
  return Math.floor((t[0] * (n - 1) - n + o) / 2);
}

function bo(t) {
  return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;
}

function wo(t) {
  return "number" == typeof t ? [t, t, t] : t;
}

function Co(t, e) {
  return e <= 1 ? t : t + (t - 1) * (e - 1);
}

function Eo(t, e) {
  if (!e) return t;

  switch (e) {
    case "round":
      return Math.round(t);

    case "ceil":
      return Math.ceil(t);

    case "floor":
      return Math.floor(t);

    default:
      throw new Error("Unknown roundingMode " + e);
  }
}

function Ro(t) {
  var e = bo(t),
      n = e[0],
      r = e[1],
      o = e[2];
  return 1 === n && 1 === r && 1 === o;
}

function Io(t, e) {
  return Ro(t) || Ro(e);
}

function ko(t) {
  if ("NHWC" === t) return "channelsLast";
  if ("NCHW" === t) return "channelsFirst";
  throw new Error("Unknown dataFormat " + t);
}

function So(t, e, n) {
  if ("complex64" === e) {
    if ("complex64" === t.dtype) return t.clone();
    var r = Pn(t.shape),
        o = t.toFloat(),
        a = n.complex(o, r);
    return r.dispose(), o.dispose(), a;
  }

  if (!M(t.dtype, e)) return Nt.makeTensorFromDataId(t.dataId, t.shape, e);

  if ("complex64" === t.dtype) {
    var i = n.real(t);
    a = i.cast(e);
    return i.dispose(), a;
  }

  if ("int32" === e) return n.int(t);

  if ("bool" === e) {
    var u = An(0, t.dtype);
    a = n.notEqual(t, u);
    return u.dispose(), a;
  }

  throw new Error("Error in Cast: failed to cast " + t.dtype + " to " + e);
}

function Ao(t, e) {
  return Nt.makeTensorFromDataId(t.dataId, e, t.dtype);
}

function Do(t, e, n) {
  var r = (e - t) / (n - 1),
      o = $(n, "float32");
  o[0] = t;

  for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + r;

  return Dn(o, "float32");
}

var To = Object.freeze({
  castTensor: So,
  reshapeTensor: Ao,
  linspaceImpl: Do,
  upcastType: Ct,
  axesAreInnerMostDims: fn,
  combineLocations: pn,
  computeOutAndReduceShapes: dn,
  expandShapeToKeepDim: vn,
  assertAxesAreInnerMostDims: mn,
  getAxesPermutation: gn,
  getUndoAxesPermutation: yn,
  getInnerMostAxes: xn,
  getBroadcastDims: ho,
  getReductionAxes: fo,
  assertAndGetBroadcastShape: po,
  assertParamsConsistent: bn,
  computeOutShape: wn,
  computePool2DInfo: vo,
  computePool3DInfo: mo,
  computeConv2DInfo: go,
  computeConv3DInfo: yo,
  computeDefaultPad: xo,
  tupleValuesAreOne: Ro,
  eitherStridesOrDilationsAreOne: Io,
  convertConv2DDataFormat: ko
});
exports.backend_util = To;

function No(t, e) {
  if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t.length + ", imag: " + e.length + ".");

  for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];

  return n;
}

function Fo(t, e) {
  return {
    real: t[2 * e],
    imag: t[2 * e + 1]
  };
}

function Oo(t, e, n, r) {
  t[2 * r] = e, t[2 * r + 1] = n;
}

function _o(t, e, n) {
  var r = (n ? 2 : -2) * Math.PI * (t / e);
  return {
    real: Math.cos(r),
    imag: Math.sin(r)
  };
}

function Mo(t, e, n, r, o) {
  for (var a = Array.from(e).map(function (t, e) {
    return {
      score: t,
      boxIndex: e
    };
  }).filter(function (t) {
    return t.score > o;
  }).sort(function (t, e) {
    return e.score - t.score;
  }), i = [], u = 0; u < a.length; u++) {
    var s = a[u],
        c = s.score,
        l = s.boxIndex;
    if (c < o) break;

    for (var h = !1, f = i.length - 1; f >= 0; --f) {
      if (Bo(t, l, i[f]) >= r) {
        h = !0;
        break;
      }
    }

    if (!h && (i.push(l), i.length >= n)) break;
  }

  return Dn(i, "int32");
}

function Bo(t, e, n) {
  var r = t.subarray(4 * e, 4 * e + 4),
      o = t.subarray(4 * n, 4 * n + 4),
      a = Math.min(r[0], r[2]),
      i = Math.min(r[1], r[3]),
      u = Math.max(r[0], r[2]),
      s = Math.max(r[1], r[3]),
      c = Math.min(o[0], o[2]),
      l = Math.min(o[1], o[3]),
      h = Math.max(o[0], o[2]),
      f = Math.max(o[1], o[3]),
      p = (u - a) * (s - i),
      d = (h - c) * (f - l);
  if (p <= 0 || d <= 0) return 0;
  var v = Math.max(a, c),
      m = Math.max(i, l),
      g = Math.min(u, h),
      y = Math.min(s, f),
      x = Math.max(g - v, 0) * Math.max(y - m, 0);
  return x / (p + d - x);
}

function Po(t, e, n) {
  var r = new Array(t.rank).fill(0),
      o = t.shape.slice();
  return e.map(function (e) {
    o[n] = e;
    var a = t.slice(r, o);
    return r[n] += e, a;
  });
}

function Lo(t, e) {
  for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];

  var o = ur(n, t.dtype);

  for (r = 0; r < o.values.length; ++r) {
    for (var a = o.indexToLoc(r), i = new Array(t.rank), u = 0; u < i.length; u++) i[u] = a[u] % t.shape[u];

    var s = t.locToIndex(i);
    o.values[r] = t.values[s];
  }

  return o.toTensor();
}

function Wo(t, e, n, r, o) {
  for (var a = e[e.length - 1], i = [t.length / a, a], u = i[0], s = i[1], c = N(n, u * r), l = N("int32", u * r), h = 0; h < u; h++) {
    for (var f = h * s, p = t.subarray(f, f + s), d = [], v = 0; v < p.length; v++) d.push({
      value: p[v],
      index: v
    });

    d.sort(function (t, e) {
      return e.value - t.value;
    });
    var m = h * r,
        g = c.subarray(m, m + r),
        y = l.subarray(m, m + r);

    for (v = 0; v < r; v++) g[v] = d[v].value, y[v] = d[v].index;
  }

  var x = e.slice();
  return x[x.length - 1] = r, [kn(c, x, n), kn(l, x, "int32")];
}

function Uo(t, e) {
  for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);

  var o = ur(t, "int32"),
      a = ur([n.length, t.length], "int32");

  for (r = 0; r < n.length; r++) {
    var i = o.indexToLoc(n[r]),
        u = r * t.length;
    a.values.set(i, u);
  }

  return a.toTensor();
}

var Vo = function () {
  return function (t, e) {
    this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function (t, e) {
      return "T" + e;
    });
    var n = [];
    this.variableNames.forEach(function (t) {
      n.push("float v" + t + " = get" + t + "AtOutCoords();");
    });
    var r = this.variableNames.map(function (t) {
      return "v" + t;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    ";
  };
}(),
    zo = function () {
  return function (t, e) {
    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function (t, e) {
      return "T" + e;
    });
    var n = [];
    this.variableNames.forEach(function (t) {
      n.push("vec4 v" + t + " = get" + t + "AtOutCoords();");
    });
    var r = this.variableNames.map(function (t) {
      return "v" + t;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    ";
  };
}(),
    Go = function () {
  return function (t, e, n) {
    this.variableNames = ["A"];
    var r = t.windowSize,
        o = t.batchSize,
        a = t.inSize,
        i = Math.ceil(a / r);
    n || this.variableNames.push("bestIndicesA"), this.outputShape = [o, i];
    var u = "max" === e ? ">" : "<",
        s = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + s + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + u + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
  };
}();

function Ho(t, e) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e).map(function (e) {
    return t + "." + e;
  });
}

function qo(t, e) {
  return 1 === e ? [t] : Ho(t, e);
}

function Ko() {
  var t, e, n, r, o, i, u, s, c, l;
  return 2 === a().getNumber("WEBGL_VERSION") ? (t = "#version 300 es", e = "in", n = "out", r = "in", o = "texture", i = "outputColor", u = "out vec4 outputColor;", s = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c = "", l = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t = "", e = "attribute", n = "varying", r = "varying", o = "texture2D", i = "gl_FragColor", u = "", s = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
    version: t,
    attribute: e,
    varyingVs: n,
    varyingFs: r,
    texture2D: o,
    output: i,
    defineOutput: u,
    defineSpecialNaN: s,
    defineSpecialInf: c,
    defineRound: l
  };
}

function jo(t, e, n) {
  void 0 === n && (n = "index");
  var r = q(e);
  return r.map(function (e, o) {
    return "int " + t[o] + " = " + n + " / " + e + "; " + (o === r.length - 1 ? "int " + t[o + 1] + " = " + n + " - " + t[o] + " * " + e : "index -= " + t[o] + " * " + e) + ";";
  }).join("");
}

function Xo(t) {
  var e = q(t).map(function (t) {
    return t.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e[0] + " + coords.y * " + e[1] + " + coords.z;\n  }\n";
}

var $o = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";

function Yo(t, e, n, r) {
  var o = [];
  t.forEach(function (t) {
    var e = w(t.shapeInfo.logicalShape);
    t.shapeInfo.isUniform ? o.push("uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";") : (o.push("uniform sampler2D " + t.name + ";"), o.push("uniform int offset" + t.name + ";"));
  });

  var a,
      i,
      u = o.join("\n"),
      s = t.map(function (t) {
    return function (t, e, n) {
      void 0 === n && (n = !1);
      var r = "";
      r += n ? Jo(t) : Qo(t);
      var o = t.shapeInfo.logicalShape,
          a = e.logicalShape;
      o.length <= a.length && (r += n ? function (t, e) {
        var n,
            r = t.name,
            o = r.charAt(0).toUpperCase() + r.slice(1),
            a = "get" + o + "AtOutCoords",
            i = t.shapeInfo.logicalShape.length,
            u = e.logicalShape.length,
            s = ho(t.shapeInfo.logicalShape, e.logicalShape),
            c = aa(u),
            l = u - i,
            h = ["x", "y", "z", "w", "u", "v"];
        n = 0 === i ? "" : u < 2 && s.length >= 1 ? "coords = 0;" : s.map(function (t) {
          return "coords." + h[t + l] + " = 0;";
        }).join("\n");
        var f = "";
        f = u < 2 && i > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
          return "coords." + h[e + l];
        }).join(", ");
        var p = "return outputValue;",
            d = 1 === w(t.shapeInfo.logicalShape),
            v = 1 === w(e.logicalShape);

        if (1 !== i || d || v) {
          if (d && !v) p = 1 === u ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";else if (s.length) {
            var m = i - 2,
                g = i - 1;
            s.indexOf(m) > -1 && s.indexOf(g) > -1 ? p = "return vec4(outputValue.x);" : s.indexOf(m) > -1 ? p = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : s.indexOf(g) > -1 && (p = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else p = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";

        return "\n    vec4 " + a + "() {\n      " + c + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + o + "(" + f + ");\n      " + p + "\n    }\n  ";
      }(t, e) : function (t, e) {
        var n = t.name,
            r = n.charAt(0).toUpperCase() + n.slice(1),
            o = "get" + r + "AtOutCoords",
            a = e.texShape,
            i = t.shapeInfo.texShape,
            u = t.shapeInfo.logicalShape.length,
            s = e.logicalShape.length;
        if (!t.shapeInfo.isUniform && u === s && null == t.shapeInfo.flatOffset && C(i, a)) return "\n      float " + o + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
        var c,
            l = aa(s),
            h = ho(t.shapeInfo.logicalShape, e.logicalShape),
            f = s - u,
            p = ["x", "y", "z", "w", "u", "v"];
        c = 0 === u ? "" : s < 2 && h.length >= 1 ? "coords = 0;" : h.map(function (t) {
          return "coords." + p[t + f] + " = 0;";
        }).join("\n");
        var d = "";
        d = s < 2 && u > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
          return "coords." + p[e + f];
        }).join(", ");
        return "\n    float " + o + "() {\n      " + l + " coords = getOutputCoords();\n      " + c + "\n      return get" + r + "(" + d + ");\n    }\n  ";
      }(t, e));
      return r;
    }(t, e, r);
  }).join("\n"),
      c = e.texShape,
      l = Ko(),
      h = function (t) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t.texture2D + "(textureSampler, uv).r;\n    }\n  ";
  }(l),
      f = function (t) {
    return t.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t.varyingFs + " vec2 resultUV;\n    " + t.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t.defineSpecialNaN + "\n    " + t.defineSpecialInf + "\n    " + t.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + Zo + "\n    " + ta + "\n    " + ea + "\n  ";
  }(l);

  return e.isPacked ? (a = function (t, e) {
    switch (t.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (1 === n[0]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    ";
          if (1 === n[1]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  ";
        }(0, e);

      case 2:
        return function (t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (C(t, e)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
          var r = Math.ceil(t[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
        }(t, e);

      case 3:
        return n = t, r = e, o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], a = Math.ceil(n[2] / 2), i = a * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o[0] + ", " + o[1] + "));\n      int index = resTexRC.x * " + o[1] + " + resTexRC.y;\n\n      int b = index / " + i + ";\n      index -= b * " + i + ";\n\n      int r = 2 * (index / " + a + ");\n      int c = imod(index, " + a + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";

      default:
        return function (t, e) {
          for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2), a = o, i = "", u = "b, r, c", s = 2; s < t.length - 1; s++) a *= t[t.length - s - 1], i = "\n      int b" + s + " = index / " + a + ";\n      index -= b" + s + " * " + a + ";\n    " + i, u = "b" + s + ", " + u;

          return "\n    ivec" + t.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + i + "\n\n      int b = index / " + o + ";\n      index -= b * " + o + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + t.length + "(" + u + ");\n    }\n  ";
        }(t, e);
    }

    var n, r, o, a, i;
  }(e.logicalShape, c), i = function (t) {
    return "\n    void setOutput(vec4 val) {\n      " + t.output + " = val;\n    }\n  ";
  }(l)) : (a = function (t, e) {
    switch (t.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (t, e) {
          if (1 === e[0]) return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e[1] + ".0);\n      }\n    ";
          if (1 === e[1]) return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      return resTexRC.x * " + e[1] + " + resTexRC.y;\n    }\n  ";
        }(0, e);

      case 2:
        return function (t, e) {
          if (C(t, e)) return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e[0] + ", " + e[1] + "));\n      }\n    ";
          if (1 === t[1]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
          if (1 === t[0]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      int r = index / " + t[1] + ";\n      int c = index - r * " + t[1] + ";\n      return ivec2(r, c);\n    }\n  ";
        }(t, e);

      case 3:
        return n = e, r = jo(["r", "c", "d"], t), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";

      case 4:
        return function (t, e) {
          var n = jo(["r", "c", "d", "d2"], t);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
        }(t, e);

      case 5:
        return function (t, e) {
          var n = jo(["r", "c", "d", "d2", "d3"], t);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e[0] + ",\n                             " + e[1] + "));\n\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
        }(t, e);

      case 6:
        return function (t, e) {
          var n = jo(["r", "c", "d", "d2", "d3", "d4"], t);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
        }(t, e);

      default:
        throw new Error(t.length + "-D output sampling is not yet supported");
    }

    var n, r;
  }(e.logicalShape, c), i = function (t) {
    return "\n    void setOutput(float val) {\n      " + t.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
  }(l)), r && (f += na), [f, h, i, u, a, s, n].join("\n");
}

function Qo(t) {
  var e = t.shapeInfo.logicalShape;

  switch (e.length) {
    case 0:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
        if (t.shapeInfo.isUniform) return "float " + n + "() {return " + e + ";}";
        var r = t.shapeInfo.texShape,
            o = r[0],
            a = r[1];
        if (1 === o && 1 === a) return "\n      float " + n + "() {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
        var i = t.shapeInfo.texShape,
            u = i[0],
            s = i[1],
            c = ra(e);
        return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + u + ", " + s + ", " + c + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  ";
      }(t);

    case 1:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
        if (t.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + oa(t) + "\n      }\n    ";
        var r = t.shapeInfo.texShape,
            o = r[0],
            a = r[1];
        if (1 === a && 1 === o) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
        var i = ra(e);
        if (1 === a) return "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i + ") + 0.5) / " + o + ".0);\n        return sampleTexture(" + e + ", uv);\n      }\n    ";
        if (1 === o) return "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + i + ") + 0.5) / " + a + ".0, 0.5);\n        return sampleTexture(" + e + ", uv);\n      }\n    ";
        return "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + o + ", " + a + ", index + " + i + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  ";
      }(t);

    case 2:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape;

        if (null != o && C(e, o)) {
          var a = o[0],
              i = o[1];
          return "\n    float " + r + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        }

        var u = T(e),
            s = u.newShape,
            c = u.keptDims,
            l = s;

        if (l.length < e.length) {
          var h = ia(t, l);
          return "\n      " + Qo(h) + "\n      float " + r + "(int row, int col) {\n        return " + r + "(" + ua(["row", "col"], c) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e[1] + ", 1)));\n        " + oa(t) + "\n      }\n    ";
        var f = o[0],
            p = o[1],
            d = ra(n);
        if (1 === p) return "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        if (1 === f) return "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + p + ".0, 0.5);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        return "\n  float " + r + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e[1] + " + col + " + d + ";\n    vec2 uv = uvFromFlat(" + f + ", " + p + ", index);\n    return sampleTexture(" + n + ", uv);\n  }\n";
      }(t);

    case 3:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[1] * e[2],
            a = e[2],
            i = T(e),
            u = i.newShape,
            s = i.keptDims,
            c = u;

        if (c.length < e.length) {
          var l = ia(t, c);
          return "\n        " + Qo(l) + "\n        float " + r + "(int row, int col, int depth) {\n          return " + r + "(" + ua(["row", "col", "depth"], s) + ");\n        }\n      ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o + ", " + a + ", 1)));\n        " + oa(t) + "\n      }\n    ";
        var h = t.shapeInfo.texShape,
            f = h[0],
            p = h[1],
            d = t.shapeInfo.flatOffset;
        if (p === o && null == d) return "\n        float " + r + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + p + ".0, " + f + ".0);\n          return sampleTexture(" + n + ", uv);\n        }\n      ";
        if (p === a && null == d) return "\n    float " + r + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + p + ".0, " + f + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        var v = ra(n);
        return "\n      float " + r + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o + " + col * " + a + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + f + ", " + p + ", index);\n        return sampleTexture(" + n + ", uv);\n      }\n  ";
      }(t);

    case 4:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[3],
            a = e[2] * o,
            i = e[1] * a,
            u = T(e),
            s = u.newShape,
            c = u.keptDims;

        if (s.length < e.length) {
          var l = ia(t, s);
          return "\n      " + Qo(l) + "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        return " + r + "(" + ua(["row", "col", "depth", "depth2"], c) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i + ", " + a + ", " + o + ", 1)));\n        " + oa(t) + "\n      }\n    ";
        var h = t.shapeInfo.flatOffset,
            f = t.shapeInfo.texShape,
            p = f[0],
            d = f[1];
        if (d === i && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a + ", " + o + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + d + ".0, " + p + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (d === o && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e[1] * e[2] + ", " + e[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + d + ".0, " + p + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var v = ra(n);
        return "\n    float " + r + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i + " + col * " + a + " +\n          depth * " + o + " + depth2;\n      vec2 uv = uvFromFlat(" + p + ", " + d + ", index + " + v + ");\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    case 5:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[4],
            a = e[3] * o,
            i = e[2] * a,
            u = e[1] * i,
            s = T(e),
            c = s.newShape,
            l = s.keptDims;

        if (c.length < e.length) {
          var h = ia(t, c);
          return "\n      " + Qo(h) + "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r + "(" + ua(["row", "col", "depth", "depth2", "depth3"], l) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + u + ", " + i + ", " + a + ", " + o + ")) +\n          depth3;\n        " + oa(t) + "\n      }\n    ";
        var f = t.shapeInfo.flatOffset,
            p = t.shapeInfo.texShape,
            d = p[0],
            v = p[1];
        if (v === u && null == f) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i + ", " + a + ", " + o + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (v === o && null == f) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] + ",\n               " + e[2] * e[3] + ", " + e[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var m = ra(n);
        return "\n    float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + u + " + col * " + i + " + depth * " + a + " +\n          depth2 * " + o + " + depth3 + " + m + ";\n      vec2 uv = uvFromFlat(" + d + ", " + v + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    case 6:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = T(e),
            a = o.newShape,
            i = o.keptDims;

        if (a.length < e.length) {
          var u = ia(t, a);
          return "\n      " + Qo(u) + "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r + "(" + ua(["row", "col", "depth", "depth2", "depth3", "depth4"], i) + ");\n      }\n    ";
        }

        var s = e[5],
            c = e[4] * s,
            l = e[3] * c,
            h = e[2] * l,
            f = e[1] * h;
        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f + ", " + h + ", " + l + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + s + ", 1)));\n        " + oa(t) + "\n      }\n    ";
        var p = t.shapeInfo.flatOffset,
            d = t.shapeInfo.texShape,
            v = d[0],
            m = d[1];
        if (m === f && null == p) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + l + ", " + c + ", " + s + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (m === s && null == p) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] * e[4] + ",\n               " + e[2] * e[3] * e[4] + ",\n               " + e[3] * e[4] + ",\n               " + e[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var g = ra(n);
        return "\n    float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f + " + col * " + h + " + depth * " + l + " +\n          depth2 * " + c + " + depth3 * " + s + " + depth4 + " + g + ";\n      vec2 uv = uvFromFlat(" + v + ", " + m + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    default:
      throw new Error(e.length + "-D input sampling is not yet supported");
  }
}

function Jo(t) {
  var e, n, r;

  switch (t.shapeInfo.logicalShape.length) {
    case 0:
      return e = t.name, n = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = Ko(), "\n    vec4 " + n + "() {\n      return " + r.texture2D + "(" + e + ", halfCR);\n    }\n  ";

    case 1:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1),
            r = t.shapeInfo.texShape,
            o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
            a = Ko();
        return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o[0] + ", " + o[1] + ", index);\n      return " + a.texture2D + "(" + e + ", uv);\n    }\n  ";
      }(t);

    case 2:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape,
            a = o[0],
            i = o[1],
            u = Ko();
        if (null != o && C(e, o)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n\n        return " + u.texture2D + "(" + n + ", uv);\n      }\n    ";
        var s = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
            c = Math.ceil(e[1] / 2);
        return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c + ", " + s[0] + ", " + s[1] + ", row, col);\n      return " + u.texture2D + "(" + n + ", uv);\n    }\n  ";
      }(t);

    case 3:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape,
            a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];

        if (1 === e[0]) {
          var i = e.slice(1),
              u = ia(t, i);
          return "\n        " + Jo(u) + "\n        vec4 " + r + "(int b, int row, int col) {\n          return " + r + "(" + ua(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
        }

        var s = a[0],
            c = a[1],
            l = Math.ceil(e[2] / 2),
            h = l * Math.ceil(e[1] / 2),
            f = Ko();
        return "\n    vec4 " + r + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + s + ", " + c + ", " + h + ", " + l + ", b, row, col);\n      return " + f.texture2D + "(" + n + ", uv);\n    }\n  ";
      }(t);

    default:
      return function (t) {
        for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, o = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = t.shapeInfo.texShape, i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)], u = i[0], s = i[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = "int b, int row, int col", f = "b * " + l + " + (row / 2) * " + c + " + (col / 2)", p = 2; p < n - 1; p++) h = "int b" + p + ", " + h, l *= e[n - p - 1], f = "b" + p + " * " + l + " + " + f;

        var d = Ko();
        return "\n    vec4 " + o + "(" + h + ") {\n      int index = " + f + ";\n      int texR = index / " + s + ";\n      int texC = index - texR * " + s + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + s + ", " + u + ");\n      return " + d.texture2D + "(" + r + ", uv);\n    }\n  ";
      }(t);
  }
}

var Zo = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ta = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ea = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    na = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

function ra(t) {
  return "offset" + t;
}

function oa(t) {
  var e = t.name,
      n = w(t.shapeInfo.logicalShape);
  return n < 2 ? "return " + e + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + e + "[i];\n      }\n    }\n  ";
}

function aa(t) {
  if (t <= 1) return "int";
  if (2 === t) return "ivec2";
  if (3 === t) return "ivec3";
  if (4 === t) return "ivec4";
  if (5 === t) return "ivec5";
  if (6 === t) return "ivec6";
  throw Error("GPU for rank " + t + " is not yet supported");
}

function ia(t, e) {
  var n = JSON.parse(JSON.stringify(t));
  return n.shapeInfo.logicalShape = e, n;
}

function ua(t, e) {
  return e.map(function (e) {
    return t[e];
  }).join(", ");
}

var sa = function () {
  return function (t, e, n, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, g(t.length > 2, function () {
      return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2.";
    });
    var o = t[t.length - 1],
        a = Math.ceil(o / e);
    this.outputShape = t.slice(0, -1), a > 1 && this.outputShape.push(a), r || this.variableNames.push("bestIndicesA");
    var i,
        u,
        s = this.outputShape,
        c = s.length,
        l = aa(c),
        h = qo("coords", c);

    if (1 === a) {
      var f = aa(u = c + 1);
      i = "\n        " + f + " sourceLocR = " + f + "(" + h.join() + ", 0);\n        ++" + h[c - 1] + ";\n        " + f + " sourceLocG = " + f + "(" + h.join() + ", 0);\n        ++" + h[c - 2] + ";\n        " + f + " sourceLocA = " + f + "(" + h.join() + ", 0);\n        --" + h[c - 1] + ";\n        " + f + " sourceLocB = " + f + "(" + h.join() + ", 0);\n        --" + h[c - 2] + ";";
    } else u = c, i = "\n        " + l + " sourceLocR = coords;\n        ++" + h[c - 1] + ";\n        " + l + " sourceLocG = coords;\n        ++" + h[c - 2] + ";\n        " + l + " sourceLocA = coords;\n        --" + h[c - 1] + ";\n        " + l + " sourceLocB = coords;\n        --" + h[c - 2] + ";";

    var p = ["x", "y", "z", "w", "u", "v"].slice(0, u),
        d = "." + p[u - 1],
        v = p.map(function (t) {
      return "int " + t;
    }),
        m = qo("sourceLocR", u - 1).concat("inIdx.r"),
        y = qo("sourceLocG", u - 1).concat("inIdx.g"),
        x = qo("sourceLocB", u - 1).concat("inIdx.b"),
        b = qo("sourceLocA", u - 1).concat("inIdx.a"),
        w = "max" === n ? "greaterThan" : "lessThan",
        C = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + x.join() + "),\n                             getBestIndicesAChannel(" + b.join() + ")));",
        E = "vec4(\n            getAChannel(" + m.join() + "),\n            hasNextCol ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + x.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b.join() + ") : 0.)",
        R = r ? "" : "\n      float getBestIndicesAChannel(" + v.join() + ") {\n        return getChannel(getBestIndicesA(" + p.join() + "),\n                                          vec2(" + p.slice(-2).join() + "));\n      }";
    this.userCode = "\n      float getAChannel(" + v.join() + ") {\n        return getChannel(getA(" + p.join() + "),\n                               vec2(" + p.slice(-2).join() + "));\n      }\n      " + R + "\n      void main() {\n        " + l + " coords = getOutputCoords();\n        bool hasNextCol = " + h[c - 1] + " < " + (s[c - 1] - 1) + ";\n        bool hasNextRow = " + h[c - 2] + " < " + (s[c - 2] - 1) + ";\n        " + i + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d + ", sourceLocG" + d + ",\n          sourceLocB" + d + ", sourceLocA" + d + ") * " + e + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E + ";\n\n        for (int i = 0; i < " + e + "; i++) {\n          inIdx = srcIdx;\n          " + C + "\n          vec4 candidate = " + E + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + w + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
  };
}(),
    ca = function () {
  return function (t) {
    this.variableNames = ["dy"], this.outputShape = t.inShape;
    var e = t.filterHeight,
        n = t.filterWidth,
        r = t.strideHeight,
        o = t.strideWidth,
        a = t.dilationHeight,
        i = t.dilationWidth,
        u = t.effectiveFilterHeight,
        s = t.effectiveFilterWidth,
        c = u - 1 - t.padInfo.top,
        l = s - 1 - t.padInfo.left,
        h = 1 / (e * n);
    this.userCode = "\n      const ivec2 pads = ivec2(" + c + ", " + l + ");\n      const float avgMultiplier = float(" + h + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + u + ";\n            wR += " + a + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + s + ";\n            wC+= " + i + ") {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    la = function () {
  return function (t) {
    this.variableNames = ["dy"], this.outputShape = t.inShape;
    var e = t.filterDepth,
        n = t.filterHeight,
        r = t.filterWidth,
        o = t.strideDepth,
        a = t.strideHeight,
        i = t.strideWidth,
        u = t.dilationDepth,
        s = t.dilationHeight,
        c = t.dilationWidth,
        l = t.effectiveFilterDepth,
        h = t.effectiveFilterHeight,
        f = t.effectiveFilterWidth,
        p = l - 1 - t.padInfo.front,
        d = h - 1 - t.padInfo.top,
        v = f - 1 - t.padInfo.left,
        m = 1 / (e * n * r);
    this.userCode = "\n      const ivec3 pads = ivec3(" + p + ", " + d + ", " + v + ");\n      const float avgMultiplier = float(" + m + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + u + ") {\n          float dyD = float(dyDCorner + wD) / " + o + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h + ";\n              wR += " + s + ") {\n            float dyR = float(dyRCorner + wR) / " + a + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f + ";\n                wC += " + c + ") {\n              float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    ha = function () {
  return function (t, e, n, r, o, a) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], po(t, e), po(t, n);
    var i = "0.0";
    null != r && (po(t, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
    var u = "1.0";
    null != o && (po(t, o), this.variableNames.push("scale"), u = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i + ";\n        float scale = " + u + ";\n        float inv = scale * inversesqrt(variance + float(" + a + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
  };
}(),
    fa = function () {
  return function (t, e, n, r, o, a) {
    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], po(t, e), po(t, n);
    var i = "vec4(0.0)";
    null != r && (po(t, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
    var u = "vec4(1.0)";
    null != o && (po(t, o), this.variableNames.push("scale"), u = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = " + i + ";\n        vec4 scale = " + u + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
  };
}(),
    pa = "return areal * breal - aimag * bimag;",
    da = "return areal * bimag + aimag * breal;",
    va = function () {
  return function (t, e, n) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = po(e, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
  };
}(),
    ma = "return a + b;",
    ga = "return a - b;",
    ya = "return a * b;",
    xa = "return (a < 0.) ? b * a : a;",
    ba = function () {
  return function (t, e, n) {
    this.variableNames = ["A", "B"], this.outputShape = po(e, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
  };
}(),
    wa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    Ca = function () {
  return function (t, e, n, r) {
    void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = po(e, n);
    var o = this.outputShape.length,
        a = "";
    if (r) if (0 === o || 1 === w(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if (a = "\n          " + aa(o) + " coords = getOutputCoords();\n        ", 1 === o) a += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else {
      var i = qo("coords", o);
      a += "\n            bool nextRowOutOfBounds =\n              (" + i[o - 2] + " + 1) >= " + this.outputShape[o - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i[o - 1] + " + 1) >= " + this.outputShape[o - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
    }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a + "\n\n        setOutput(result);\n      }\n    ";
  };
}(),
    Ea = function () {
  function t(t) {
    this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t, e) {
    var n = this;
    return function (r, o) {
      null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(o, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);
    };
  }, t;
}(),
    Ra = function () {
  function t(t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t, e) {
    var n = this;
    return function (r, o) {
      null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(o, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);
    };
  }, t;
}(),
    Ia = function () {
  return function (t) {
    this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  };
}(),
    ka = function () {
  return function (t) {
    this.outputShape = [], this.outputShape = wn(t, 1), this.variableNames = t.map(function (t, e) {
      return "T" + e;
    });
    var e = new Array(t.length - 1);
    e[0] = t[0][1];

    for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];

    var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];

    for (n = 1; n < e.length; n++) {
      var o = e[n - 1];
      r.push("else if (yC < " + e[n] + ") setOutput(getT" + n + "(yR, yC-" + o + "));");
    }

    var a = e.length,
        i = e[e.length - 1];
    r.push("else setOutput(getT" + a + "(yR, yC-" + i + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    ";
  };
}(),
    Sa = function () {
  return function (t, e) {
    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = wn(t, e);
    var n = this.outputShape,
        r = n.length,
        o = aa(r),
        a = qo("coords", r),
        i = ["x", "y", "z", "w", "u", "v"].slice(0, r);
    this.variableNames = t.map(function (t, e) {
      return "T" + e;
    });
    var u = new Array(t.length - 1);
    u[0] = t[0][e];

    for (var s = 1; s < u.length; s++) u[s] = u[s - 1] + t[s][e];

    var c = i[e],
        l = i.slice(-2),
        h = i.join(),
        f = "if (" + c + " < " + u[0] + ") {\n        return getChannel(\n            getT0(" + h + "), vec2(" + l.join() + "));\n        }";

    for (s = 1; s < u.length; s++) {
      var p = u[s - 1];
      f += "\n        if (" + c + " < " + u[s] + "  && " + c + " >= " + u[s - 1] + ") {\n          return getChannel(\n            getT" + s + "(" + Aa(i, c, p) + "),\n            vec2(" + Aa(l, c, p) + "));\n        }";
    }

    var d = u.length,
        v = u[u.length - 1];
    f += "\n        return getChannel(\n          getT" + d + "(" + Aa(i, c, v) + "),\n          vec2(" + Aa(l, c, v) + "));", this.userCode = "\n      float getValue(" + i.map(function (t) {
      return "int " + t;
    }) + ") {\n        " + f + "\n      }\n\n      void main() {\n        " + o + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a + "), 0., 0., 0.);\n\n        " + a[r - 1] + " = " + a[r - 1] + " + 1;\n        if (" + a[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + a + ");\n        }\n\n        " + a[r - 2] + " = " + a[r - 2] + " + 1;\n        if (" + a[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + a + ");\n        }\n\n        " + a[r - 1] + " = " + a[r - 1] + " - 1;\n        if (" + a[r - 2] + " < " + n[r - 2] + " &&\n            " + a[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + a + ");\n        }\n        setOutput(result);\n      }\n    ";
  };
}();

function Aa(t, e, n) {
  var r = t.indexOf(e);
  return t.map(function (t, e) {
    return e === r ? t + " - " + n : t;
  }).join();
}

var Da = function () {
  return function (t) {
    this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
    var e = t.strideHeight,
        n = t.strideWidth,
        r = t.padInfo.top,
        o = t.padInfo.left,
        a = "channelsLast" === t.dataFormat;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + o + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              if (" + a + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Ta = function () {
  return function (t) {
    this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
    var e = t.filterHeight,
        n = t.filterWidth,
        r = t.strideHeight,
        o = t.strideWidth,
        a = "channelsLast" === t.dataFormat,
        i = e - 1 - t.padInfo.top,
        u = n - 1 - t.padInfo.left,
        s = a ? 1 : 2,
        c = a ? 2 : 3,
        l = a ? 3 : 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + u + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l + "];\n\n        ivec2 dyCorner = ivec2(coords[" + s + "], coords[" + c + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n\n              if (" + a + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Na = function () {
  return function (t) {
    this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
    var e = t.strideDepth,
        n = t.strideHeight,
        r = t.strideWidth,
        o = t.padInfo.front,
        a = t.padInfo.top,
        i = t.padInfo.left;
    this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t.outDepth + "; yF++) {\n            int xF = wF + yF * " + e + " - " + o + ";\n\n            if (xF < 0 || xF >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + a + ";\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + i + ";\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Fa = function () {
  return function (t) {
    this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
    var e = t.filterDepth,
        n = t.filterHeight,
        r = t.filterWidth,
        o = t.strideDepth,
        a = t.strideHeight,
        i = t.strideWidth,
        u = e - 1 - t.padInfo.front,
        s = n - 1 - t.padInfo.top,
        c = r - 1 - t.padInfo.left;
    this.userCode = "\n      const ivec3 pads = ivec3(" + u + ", " + s + ", " + c + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Oa = function () {
  return function (t) {
    this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
    var e = t.strideHeight,
        n = t.strideWidth,
        r = t.padInfo.top,
        o = t.padInfo.left,
        a = t.outChannels / t.inChannels;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + o + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    _a = function () {
  return function (t) {
    this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
    var e = t.filterHeight,
        n = t.filterWidth,
        r = t.strideHeight,
        o = t.strideWidth,
        a = e - 1 - t.padInfo.top,
        i = n - 1 - t.padInfo.left,
        u = t.outChannels / t.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + i + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + u + "; dm++) {\n              int d2 = d1 * " + u + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Ma = function () {
  return function (t, e, n, r) {
    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
    var o = t.padInfo.top,
        a = t.padInfo.left,
        i = t.strideHeight,
        u = t.strideWidth,
        s = t.dilationHeight,
        c = t.dilationWidth,
        l = t.filterHeight,
        h = t.filterWidth,
        f = 4 * Math.floor(t.inChannels / 4),
        p = t.inChannels % 4,
        d = "channelsLast" === t.dataFormat,
        v = d ? 1 : 2,
        m = d ? 2 : 3,
        g = d ? 3 : 1,
        y = "",
        x = "";
    n && (y = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", x = "result = activation(result);");
    var b = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y + "\n\n      const ivec2 strides = ivec2(" + i + ", " + u + ");\n      const ivec2 pads = ivec2(" + o + ", " + a + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + m + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l + "; wR++) {\n          int xR = xRCorner + wR * " + s + ";\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c + ";\n\n            if (xC < 0 || xC >= " + t.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === p) + ") {\n\n              if (" + d + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f + ") *\n                    getW(wR, wC, " + f + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f + ", xR, xC) *\n                    getW(wR, wC, " + f + ", d2);\n              }\n\n            } else if (" + (2 === p) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2)\n              );\n\n              if (" + d + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === p) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2),\n                getW(wR, wC, " + f + " + 2, d2)\n              );\n\n              if (" + d + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1),\n                  getX(batch, xR, xC, " + f + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC),\n                  getX(batch, " + f + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b + "\n        " + x + "\n        setOutput(result);\n      }\n    ";
  };
}(),
    Ba = function () {
  return function (t) {
    this.variableNames = ["x", "W"], this.outputShape = t.outShape;
    var e = t.padInfo.front,
        n = t.padInfo.top,
        r = t.padInfo.left,
        o = t.strideDepth,
        a = t.strideHeight,
        i = t.strideWidth,
        u = t.dilationDepth,
        s = t.dilationHeight,
        c = t.dilationWidth,
        l = t.filterDepth,
        h = t.filterHeight,
        f = t.filterWidth,
        p = 4 * Math.floor(t.inChannels / 4),
        d = t.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(" + o + ", " + a + ", " + i + ");\n      const ivec3 pads = ivec3(" + e + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l + "; wF++) {\n          int xF = xFCorner + wF * " + u + ";\n\n          if (xF < 0 || xF >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + "; wR++) {\n            int xR = xRCorner + wR * " + s + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f + "; wC++) {\n              int xC = xCCorner + wC * " + c + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + p + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + p + ") *\n                  getW(wF, wR, wC, " + p + ", d2);\n              } else if (" + (2 === d) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + p + "),\n                  getX(batch, xF, xR, xC, " + p + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + p + ", d2),\n                  getW(wF, wR, wC, " + p + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + p + "),\n                  getX(batch, xF, xR, xC, " + p + " + 1),\n                  getX(batch, xF, xR, xC, " + p + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + p + ", d2),\n                  getW(wF, wR, wC, " + p + " + 1, d2),\n                  getW(wF, wR, wC, " + p + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Pa = function () {
  return function (t, e, n, r) {
    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
    var o = t.inHeight,
        a = t.inWidth,
        i = t.padInfo.top,
        u = t.padInfo.left,
        s = t.strideHeight,
        c = t.strideWidth,
        l = t.dilationHeight,
        h = t.dilationWidth,
        f = t.filterHeight,
        p = t.filterWidth,
        d = t.outChannels / t.inChannels,
        v = "",
        m = "";
    n && (v = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", m = "result = activation(result);");
    var g = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + s + ", " + c + ");\n      const ivec2 pads = ivec2(" + i + ", " + u + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d + ";\n        int q = d2 - d1 * " + d + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f + "; wR++) {\n          int xR = xRCorner + wR * " + l + ";\n\n          if (xR < 0 || xR >= " + o + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + p + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + a + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g + "\n        " + m + "\n        setOutput(result);\n      }\n    ";
  };
}(),
    La = function () {
  return function (t, e, n, r) {
    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;

    for (var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, u = t.padInfo.left, s = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, p = t.filterWidth, d = p, m = "int xR; int xC; int xCOffset;", g = 0; g < f; g++) for (var y = 0; y < p; y++) m += "\n          vec4 xTexelR" + g + "C" + 2 * y + " = vec4(0.);\n          vec4 wR" + g + "C" + y + " = vec4(0.);\n          vec4 xR" + g + "C" + y + " = vec4(0.);";

    for (g = 0; g < f; g++) for (var x = 0; x < d; x++) {
      if (m += "\n          xR = xRCorner + " + g * l + ";\n          xC = xCCorner + " + (y = 2 * x) * h + ";\n        ", 1 === c) {
        if (y < p && (m += u % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o + " && xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o + " && xCOffset >= 0 && xCOffset < " + a + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + g + "C" + y + " = vec4(previous.zw, xTexelR" + g + "C" + y + ".xy);\n                } else {\n                  xR" + g + "C" + y + " = vec4(0, 0, xTexelR" + g + "C" + y + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o + " && xC >= 0 && xC < " + a + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                xR" + g + "C" + y + " = xTexelR" + g + "C" + y + ";\n              ", y + 1 < p)) {
          var b = u % 2 == 0 ? v(h) : h;
          h % 2 == 0 && u % 2 == 1 || h % 2 != 0 && u % 2 != 1 ? (m += "\n                  xCOffset = xC + " + u % 2 + " + " + b + ";\n\n                  if(xR >= 0 && xR < " + o + " &&\n                    xCOffset >= 0 && xCOffset < " + a + ") {\n                    xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (m += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o + " &&\n                      xCOffset >= 0 && xCOffset < " + a + ") {\n                      xTexelR" + g + "C" + y + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + g + "C" + y + " = vec4(0.);\n                    }\n                  "), m += "\n                  xR" + g + "C" + (y + 1) + " = vec4(\n                    xTexelR" + g + "C" + y + ".zw, xTexelR" + g + "C" + (y + 2) + ".xy);\n                ") : m += "\n                  xCOffset = xC + " + b + ";\n\n                  if(xR >= 0 && xR < " + o + " &&\n                    xCOffset >= 0 && xCOffset < " + a + ") {\n                    xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + g + "C" + (y + 1) + " = xTexelR" + g + "C" + (y + 2) + ";\n                ";
        }
      } else y < p && (m += "\n              if(xR >= 0 && xR < " + o + ") {\n            ", u % 2 == 1 ? (m += "\n                xCOffset = xC + 1 - " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a + ") {\n                  xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + g + "C" + (y + 2) + " = vec4(0.);\n                }\n\n                xR" + g + "C" + y + " = vec4(\n                  xTexelR" + g + "C" + y + ".zw, xTexelR" + g + "C" + (y + 2) + ".zw);\n              ", y + 1 < p && (m += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c + ";\n                  if(xCOffset >= 0 && xCOffset < " + a + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + g + "C" + (y + 1) + " = vec4(xTexelR" + g + "C" + (y + 2) + ".xy, final.xy);\n                ")) : (m += "\n                if(xC >= 0 && xC < " + a + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g + "C" + (y + 2) + " = vec4(0.);\n                }\n\n                xR" + g + "C" + y + " = vec4(\n                  xTexelR" + g + "C" + y + ".xy, xTexelR" + g + "C" + (y + 2) + ".xy);\n              ", y + 1 < p && (m += "\n                  xR" + g + "C" + (y + 1) + " = vec4(\n                    xTexelR" + g + "C" + y + ".zw, xTexelR" + g + "C" + (y + 2) + ".zw);\n                ")), m += "}");

      y < p && (m += "\n            vec4 wTexelR" + g + "C" + y + " = getW(" + g + ", " + y + ", d1, q);\n            wR" + g + "C" + y + " = vec4(wTexelR" + g + "C" + y + ".xz, wTexelR" + g + "C" + y + ".xz);\n          ", y + 1 < p && (m += "\n              vec4 wTexelR" + g + "C" + (y + 1) + " = getW(" + g + ", " + (y + 1) + ", d1, q);\n              wR" + g + "C" + (y + 1) + " =\n                vec4(wTexelR" + g + "C" + (y + 1) + ".xz, wTexelR" + g + "C" + (y + 1) + ".xz);"));
    }

    for (g = 0; g < f; g++) for (y = 0; y < p; y++) m += "dotProd += xR" + g + "C" + y + " * wR" + g + "C" + y + ";";

    var w = "",
        C = "";
    n && (w = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", C = "result = activation(result);");
    var E = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w + "\n\n      const ivec2 strides = ivec2(" + s + ", " + c + ");\n      const ivec2 pads = ivec2(" + i + ", " + u + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + m + "\n\n        vec4 result = dotProd;\n        " + E + "\n        " + C + "\n        setOutput(result);\n      }\n    ";
  };
}(),
    Wa = function () {
  return function (t, e, n, r, o) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    var a = t[0],
        i = t[1],
        u = t[2],
        s = t[3],
        c = e[0],
        l = n[0],
        h = n[1];
    this.outputShape = [c, l, h, s];
    var f = "bilinear" === r ? 1 : 0,
        p = [i - 1 + ".0", u - 1 + ".0"],
        d = p[0],
        v = p[1],
        m = l > 1 ? ["" + (i - 1) / (l - 1), "(y2-y1) * height_ratio", "y1*" + d + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d],
        g = m[0],
        y = m[1],
        x = m[2],
        b = h > 1 ? ["" + (u - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + v + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v],
        w = b[0],
        C = b[1],
        E = b[2];
    this.userCode = "\n      const float height_ratio = float(" + g + ");\n      const float width_ratio = float(" + w + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a + ") {\n          return;\n        }\n\n        float height_scale = " + y + ";\n        float width_scale = " + C + ";\n\n        float in_y = " + x + ";\n        if( in_y < 0.0 || in_y > " + d + " ) {\n          setOutput(float(" + o + "));\n          return;\n        }\n        float in_x = " + E + ";\n        if( in_x < 0.0 || in_x > " + v + " ) {\n          setOutput(float(" + o + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
  };
}(),
    Ua = function () {
  return function (t, e, n) {
    this.variableNames = ["x"], this.outputShape = t;
    var r = t.length,
        o = t[t.length - 1],
        a = n ? "<" : ">";

    this.userCode = "\n      int getIndex(int i) {\n        " + (n ? "return " + o + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + aa(r) + " coords = getOutputCoords();\n        int end = " + Va(r, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a + " end) {\n            continue;\n          }\n          if (idx == end && " + e + ") {\n            continue;\n          }\n          " + Va(r, "coords") + " = idx;\n          val += getX(" + function (t, e) {
      if (1 === t) return "" + e;
      if (2 === t) return e + ".x, " + e + ".y";
      if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
      if (4 === t) return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
      throw Error("Cumulative sum for rank " + t + " is not yet supported");
    }(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
  };
}();

function Va(t, e) {
  if (1 === t) return "" + e;
  if (2 === t) return e + ".y";
  if (3 === t) return e + ".z";
  if (4 === t) return e + ".w";
  throw Error("Cumulative sum for rank " + t + " is not yet supported");
}

var za = function () {
  return function (t) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = _t.DENSE;
    var e = Gt(t),
        n = Ko();
    this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    ";
  };
}(),
    Ga = function () {
  return function (t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = _t.DENSE;
    var e = Gt(t),
        n = Ko();
    this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    ";
  };
}(),
    Ha = function () {
  function t(t, e, n) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e + ";\n      int offset_h = imod(h, " + e + ");\n      int in_w = w / " + e + ";\n      int offset_w = imod(w, " + e + ");\n      int offset_d = (offset_h * " + e + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
  }

  return t.prototype.getHeightCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }, t.prototype.getWidthCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }, t.prototype.getDepthCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }, t.prototype.getOutputDepthSize = function () {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }, t.prototype.getInputSamplingString = function () {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, t;
}(),
    qa = function () {
  return function (t) {
    this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  };
}(),
    Ka = function () {
  return function (t) {
    this.variableNames = ["A"], this.outTexUsage = Mt.DOWNLOAD;
    var e = Ko();
    this.outputShape = t, this.userCode = "\n      " + $o + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e.output + " = encode_float(x);\n      }\n    ";
  };
}(),
    ja = function () {
  return function (t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = Mt.DOWNLOAD;
    var e = Ko();
    this.outputShape = t, this.userCode = "\n      " + $o + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e.output + " = encode_float(x);\n      }\n    ";
  };
}(),
    Xa = function () {
  return function (t, e, n) {
    void 0 === n && (n = !1), this.variableNames = ["A"];
    var r = Ko(),
        o = e[0],
        a = e[1];
    this.outputShape = t;
    var i = "result";
    n && (i = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Xo(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a + ";\n        int c = imod(flatIndex, " + a + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + i + ", 0., 0., 0.);\n      }\n    ";
  };
}(),
    $a = function () {
  return function (t, e, n) {
    void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
    var r = Ko(),
        o = e[0],
        a = e[1];
    this.outputShape = t;
    var i = "",
        u = "result";
    n && (u = "floor(result * 255. + 0.5)");

    for (var s = 0; s <= 1; s++) for (var c = 0; c <= 1; c++) {
      var l = 2 * s + c;
      i += "\n          localCoords = coords;\n          if(localCoords[2] + " + c + " < " + t[2] + ") {\n            localCoords[2] += " + c + ";\n            if(localCoords[1] + " + s + " < " + t[1] + ") {\n              localCoords[1] += " + s + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a + ";\n              c = imod(flatIndex, " + a + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l + "] = values[2];\n              } else {\n                result[" + l + "] = values[3];\n              }\n            }\n          }\n        ";
    }

    this.userCode = "\n      " + Xo(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i + "\n\n        " + r.output + " = " + u + ";\n      }\n    ";
  };
}(),
    Ya = "return real * expR - imag * expI;",
    Qa = "return real * expI + imag * expR;",
    Ja = function () {
  return function (t, e, n) {
    this.variableNames = ["real", "imag"];
    var r = e[1];
    this.outputShape = e;
    var o = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
        a = n ? r + ".0" : "1.0";
    this.userCode = "\n      const float exponentMultiplier = " + o + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
  };
}(),
    Za = function () {
  function t(t, e) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    return function (n, r) {
      null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(e.valueLoc, t);
    };
  }, t;
}(),
    ti = function () {
  return function (t) {
    this.variableNames = ["A"];
    var e = Ko(),
        n = t[0],
        r = t[1];
    this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + e.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
  };
}(),
    ei = function () {
  return function (t) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
    var e = Ko(),
        n = t[0],
        r = t[1];
    this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + e.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e.output + " = result;\n      }\n    ";
  };
}(),
    ni = function () {
  return function (t, e, n) {
    this.variableNames = ["A", "indices"];
    var r = t.slice();
    r[n] = e, this.outputShape = r, this.rank = r.length;

    var o = aa(this.rank),
        a = function (t, e) {
      var n = t.length;
      if (n > 4) throw Error("Gather for rank " + n + " is not yet supported");
      if (1 === n) return "int(getIndices(resRC))";

      for (var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o = [], a = 0; a < t.length; a++) a === e ? o.push("int(getIndices(" + r[a] + "))") : o.push("" + r[a]);

      return o.join();
    }(t, n);

    this.userCode = "\n      void main() {\n        " + o + " resRC = getOutputCoords();\n        setOutput(getA(" + a + "));\n      }\n    ";
  };
}();

var ri = function () {
  return function (t, e, n) {
    this.sliceDim = t, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = n;
    var r = aa(e.length),
        o = aa(n.length),
        a = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + o + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
  };
}();

function oi(t, e) {
  var n = Ko();
  return Jt(t, e, n.version + "\n    precision highp float;\n    " + n.attribute + " vec3 clipSpacePos;\n    " + n.attribute + " vec2 uv;\n    " + n.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}

function ai(t, e) {
  return ie(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}

function ii(t, e) {
  return ue(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]));
}

function ui(t, e, n, r, o, a, i) {
  ce(n, r);
  var u = se(t, e),
      s = t.TEXTURE_2D;
  return Kt(t, e, function () {
    return t.bindTexture(s, u);
  }), Kt(t, e, function () {
    return t.texParameteri(s, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);
  }), Kt(t, e, function () {
    return t.texParameteri(s, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
  }), Kt(t, e, function () {
    return t.texParameteri(s, t.TEXTURE_MIN_FILTER, t.NEAREST);
  }), Kt(t, e, function () {
    return t.texParameteri(s, t.TEXTURE_MAG_FILTER, t.NEAREST);
  }), Kt(t, e, function () {
    return t.texImage2D(s, 0, o, n, r, 0, a, i, null);
  }), Kt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  }), u;
}

function si(t, e, n, r, o) {
  var a = zt(n, r);
  return ui(t, e, a[0], a[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT);
}

function ci(t, e, n, r, o) {
  var a = zt(n, r);
  return ui(t, e, a[0], a[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);
}

function li(t, e, n, r, o) {
  var a = zt(n, r);
  return ui(t, e, a[0], a[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);
}

function hi(t, e, n, r, o) {
  var a = Ht(n, r);
  return ui(t, e, a[0], a[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT);
}

function fi(t, e, n, r, o) {
  var a = Ht(n, r);
  return ui(t, e, a[0], a[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat);
}

function pi(t, e, n, r) {
  return Kt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, r);
  }), he(t, e, n, "clipSpacePos", r, 3, 20, 0) && he(t, e, n, "uv", r, 2, 20, 12);
}

function di(t, e, n, r, o, a, i) {
  var u, s, c;
  Kt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  }), a instanceof Uint8Array ? (u = new Uint8Array(r * o * 4), s = t.UNSIGNED_BYTE, c = t.RGBA) : (u = new Float32Array(r * o * 4), s = t.FLOAT, c = i.internalFormatPackedFloat), u.set(a), Kt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, s, u);
  }), Kt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  });
}

function vi(t, e, n, r) {
  Kt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  }), r.data instanceof Uint8Array ? Kt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data);
  }) : Kt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r);
  }), Kt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  });
}

function mi(t, e, n, r, o) {
  var a = t.createBuffer();
  Kt(t, e, function () {
    return t.bindBuffer(t.PIXEL_PACK_BUFFER, a);
  });
  var i = 16 * n * r;
  return Kt(t, e, function () {
    return t.bufferData(t.PIXEL_PACK_BUFFER, i, t.STREAM_READ);
  }), Kt(t, e, function () {
    return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);
  }), Kt(t, e, function () {
    return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
  }), a;
}

function gi(t, e, n) {
  var r = t,
      o = new Float32Array(n);
  return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;
}

function yi(t, e, n, r, o) {
  var a = zt(n, r),
      i = a[0],
      u = a[1],
      s = new Uint8Array(n * r * 4);
  return Kt(t, e, function () {
    return t.readPixels(0, 0, i, u, o.downloadTextureFormat, t.UNSIGNED_BYTE, s);
  }), new Float32Array(s.buffer);
}

function xi(t, e, n, r, o, a, i, u) {
  var s = t,
      c = new Float32Array(function (t, e) {
    var n = Ht(t, e);
    return n[0] * n[1] * 4;
  }(a, i));
  return s.bindBuffer(s.PIXEL_PACK_BUFFER, e), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, c), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), c;
}

function bi(t, e, n, r) {
  var o = new Float32Array(n * r * 4);
  return Kt(t, e, function () {
    return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o);
  }), o;
}

var wi = Object.freeze({
  createVertexShader: oi,
  createVertexBuffer: ai,
  createIndexBuffer: ii,
  createFloat32MatrixTexture: si,
  createFloat16MatrixTexture: ci,
  createUnsignedBytesMatrixTexture: li,
  createPackedMatrixTexture: hi,
  createFloat16PackedMatrixTexture: fi,
  bindVertexProgramAttributeStreams: pi,
  uploadDenseMatrixToTexture: di,
  uploadPixelDataToTexture: vi,
  createBufferFromOutputTexture: mi,
  downloadFloat32MatrixFromBuffer: gi,
  downloadByteEncodedFloatMatrixFromOutputTexture: yi,
  downloadPackedMatrixFromBuffer: xi,
  downloadMatrixFromPackedOutputTexture: bi
}),
    Ci = function () {
  function t(t) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var e = a().getNumber("WEBGL_VERSION");
    if (null != t ? (this.gl = t, Wt(e, t)) : this.gl = Ut(e), 1 === a().getNumber("WEBGL_VERSION")) this.textureFloatExtension = Qt(this.gl, this.debug, "OES_texture_float"), this.colorBufferFloatExtension = this.gl.getExtension("WEBGL_color_buffer_float"), this.textureHalfFloatExtension = Qt(this.gl, this.debug, "OES_texture_half_float"), this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");else {
      if (Ne(this.gl, "EXT_color_buffer_float")) this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");else {
        if (!Ne(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
        this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
      }
    }
    this.vertexBuffer = ai(this.gl, this.debug), this.indexBuffer = ii(this.gl, this.debug), this.framebuffer = le(this.gl, this.debug), this.textureConfig = qt(this.gl, this.textureHalfFloatExtension);
  }

  return Object.defineProperty(t.prototype, "debug", {
    get: function () {
      return a().getBool("DEBUG");
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.dispose = function () {
    var t = this;

    if (!this.disposed) {
      null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var e = this.gl;
      Kt(e, this.debug, function () {
        return e.finish();
      }), Kt(e, this.debug, function () {
        return e.bindFramebuffer(e.FRAMEBUFFER, null);
      }), Kt(e, this.debug, function () {
        return e.deleteFramebuffer(t.framebuffer);
      }), Kt(e, this.debug, function () {
        return e.bindBuffer(e.ARRAY_BUFFER, null);
      }), Kt(e, this.debug, function () {
        return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);
      }), Kt(e, this.debug, function () {
        return e.deleteBuffer(t.indexBuffer);
      }), this.disposed = !0;
    }
  }, t.prototype.createFloat32MatrixTexture = function (t, e) {
    return this.throwIfDisposed(), si(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createFloat16MatrixTexture = function (t, e) {
    return this.throwIfDisposed(), ci(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createUnsignedBytesMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), li(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.uploadPixelDataToTexture = function (t, e) {
    this.throwIfDisposed(), vi(this.gl, this.debug, t, e);
  }, t.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {
    this.throwIfDisposed(), di(this.gl, this.debug, t, e, n, r, this.textureConfig);
  }, t.prototype.createFloat16PackedMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), fi(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createPackedMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), hi(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.deleteMatrixTexture = function (t) {
    var e = this;
    this.throwIfDisposed(), this.outputTexture === t && (ge(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Kt(this.gl, this.debug, function () {
      return e.gl.deleteTexture(t);
    });
  }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {
    var r = this;
    return this.downloadMatrixDriver(t, function () {
      return yi(r.gl, r.debug, e, n, r.textureConfig);
    });
  }, t.prototype.downloadPackedMatrixFromBuffer = function (t, e, n, r, o, a) {
    return xi(this.gl, t, 0, 0, 0, o, a, this.textureConfig);
  }, t.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {
    return gi(this.gl, t, e);
  }, t.prototype.createBufferFromTexture = function (t, e, n) {
    this.bindTextureToFrameBuffer(t);
    var r = mi(this.gl, this.debug, e, n, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), r;
  }, t.prototype.createAndWaitForFence = function () {
    var t = this.createFence(this.gl);
    return this.pollFence(t);
  }, t.prototype.createFence = function (t) {
    var e,
        n,
        r = this;

    if (a().getBool("WEBGL_FENCE_API_ENABLED")) {
      var o = t,
          i = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t.flush(), n = function () {
        var t = o.clientWaitSync(i, 0, 0);
        return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;
      }, e = i;
    } else a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function () {
      return r.isQueryAvailable(e, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }) : n = function () {
      return !0;
    };

    return {
      query: e,
      isFencePassed: n
    };
  }, t.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {
    var r = this;
    return this.downloadMatrixDriver(t, function () {
      return bi(r.gl, r.debug, e, n);
    });
  }, t.prototype.createProgram = function (t) {
    this.throwIfDisposed();
    var e = this.gl,
        n = Zt(e, this.debug, t),
        r = oi(e, this.debug),
        o = re(e, this.debug);
    return Kt(e, this.debug, function () {
      return e.attachShader(o, r);
    }), Kt(e, this.debug, function () {
      return e.attachShader(o, n);
    }), oe(e, this.debug, o), this.debug && ae(e, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = pi(e, this.debug, this.program, this.vertexBuffer)), o;
  }, t.prototype.deleteProgram = function (t) {
    var e = this;
    this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Kt(this.gl, this.debug, function () {
      return e.gl.deleteProgram(t);
    });
  }, t.prototype.setProgram = function (t) {
    var e = this;
    this.throwIfDisposed(), this.program = t, null != this.program && this.debug && ae(this.gl, this.debug, this.program), Kt(this.gl, this.debug, function () {
      return e.gl.useProgram(t);
    });
  }, t.prototype.getUniformLocation = function (t, e, n) {
    return void 0 === n && (n = !0), this.throwIfDisposed(), n ? pe(this.gl, this.debug, t, e) : de(this.gl, t, e);
  }, t.prototype.getAttributeLocation = function (t, e) {
    var n = this;
    return this.throwIfDisposed(), Kt(this.gl, this.debug, function () {
      return n.gl.getAttribLocation(t, e);
    });
  }, t.prototype.getUniformLocationNoThrow = function (t, e) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);
  }, t.prototype.setInputMatrixTexture = function (t, e, n) {
    this.throwIfDisposed(), this.throwIfNoProgram(), ve(this.gl, this.debug, this.program, t, e, n);
  }, t.prototype.setOutputMatrixTexture = function (t, e, n) {
    this.setOutputMatrixTextureDriver(t, n, e);
  }, t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
    this.throwIfDisposed();
    var r = Ht(e, n),
        o = r[0],
        a = r[1];
    this.setOutputMatrixTextureDriver(t, o, a);
  }, t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {
    this.setOutputMatrixWriteRegionDriver(n, t, r, e);
  }, t.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, t.prototype.debugValidate = function () {
    null != this.program && ae(this.gl, this.debug, this.program), ye(this.gl);
  }, t.prototype.executeProgram = function () {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var t = this.gl;
    this.debug && this.debugValidate(), Kt(t, this.debug, function () {
      return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);
    });
  }, t.prototype.blockUntilAllProgramsCompleted = function () {
    var t = this;
    this.throwIfDisposed(), Kt(this.gl, this.debug, function () {
      return t.gl.finish();
    });
  }, t.prototype.getQueryTimerExtension = function () {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Qt(this.gl, this.debug, 2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, t.prototype.getQueryTimerExtensionWebGL2 = function () {
    return this.getQueryTimerExtension();
  }, t.prototype.getQueryTimerExtensionWebGL1 = function () {
    return this.getQueryTimerExtension();
  }, t.prototype.beginQuery = function () {
    if (2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t = this.gl,
          e = this.getQueryTimerExtensionWebGL2(),
          n = t.createQuery();
      return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;
    }

    var r = this.getQueryTimerExtensionWebGL1(),
        o = r.createQueryEXT();
    return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;
  }, t.prototype.endQuery = function () {
    if (2 !== a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t = this.getQueryTimerExtensionWebGL1();
      t.endQueryEXT(t.TIME_ELAPSED_EXT);
    } else {
      var e = this.gl,
          n = this.getQueryTimerExtensionWebGL2();
      e.endQuery(n.TIME_ELAPSED_EXT);
    }
  }, t.prototype.waitForQueryAndGetTime = function (t) {
    return n(this, void 0, void 0, function () {
      var e = this;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, S(function () {
              return e.disposed || e.isQueryAvailable(t, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];

          case 1:
            return n.sent(), [2, this.getQueryTime(t, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, t.prototype.getQueryTime = function (t, e) {
    if (0 === e) return null;

    if (2 === e) {
      var n = this.gl;
      return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
    }

    var r = this.getQueryTimerExtensionWebGL1();
    return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;
  }, t.prototype.isQueryAvailable = function (t, e) {
    if (0 === e) return !0;

    if (2 === e) {
      var n = this.gl,
          r = this.getQueryTimerExtensionWebGL2(),
          o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
    }

    o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT);
    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
  }, t.prototype.pollFence = function (t) {
    var e = this;
    return new Promise(function (n) {
      e.addItemToPoll(function () {
        return t.isFencePassed();
      }, function () {
        return n();
      });
    });
  }, t.prototype.pollItems = function () {
    for (var t = function (t) {
      for (var e = 0; e < t.length; ++e) {
        var n = t[e]();
        if (!n) break;
      }

      return e - 1;
    }(this.itemsToPoll.map(function (t) {
      return t.isDoneFn;
    })), e = 0; e <= t; ++e) {
      (0, this.itemsToPoll[e].resolveFn)();
    }

    this.itemsToPoll = this.itemsToPoll.slice(t + 1);
  }, t.prototype.addItemToPoll = function (t, e) {
    var n = this;
    this.itemsToPoll.push({
      isDoneFn: t,
      resolveFn: e
    }), this.itemsToPoll.length > 1 || S(function () {
      return n.pollItems(), 0 === n.itemsToPoll.length;
    });
  }, t.prototype.bindTextureToFrameBuffer = function (t) {
    this.throwIfDisposed(), me(this.gl, this.debug, t, this.framebuffer), this.debug && ye(this.gl);
  }, t.prototype.unbindTextureToFrameBuffer = function () {
    null != this.outputTexture ? (me(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && ye(this.gl)) : ge(this.gl, this.debug, this.framebuffer);
  }, t.prototype.downloadMatrixDriver = function (t, e) {
    this.bindTextureToFrameBuffer(t);
    var n = e();
    return this.unbindTextureToFrameBuffer(), n;
  }, t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
    this.throwIfDisposed();
    var r = this.gl;
    me(r, this.debug, t, this.framebuffer), this.debug && ye(r), this.outputTexture = t, Kt(r, this.debug, function () {
      return r.viewport(0, 0, e, n);
    }), Kt(r, this.debug, function () {
      return r.scissor(0, 0, e, n);
    });
  }, t.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {
    var o = this;
    this.throwIfDisposed(), Kt(this.gl, this.debug, function () {
      return o.gl.scissor(t, e, n, r);
    });
  }, t.prototype.throwIfDisposed = function () {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }, t.prototype.throwIfNoProgram = function () {
    if (null == this.program) throw new Error("No GPU program is currently set.");
  }, t;
}();

function Ei(t, e) {
  if (t.length !== e.length) throw Error("Binary was compiled with " + t.length + " inputs, but was executed with " + e.length + " inputs");
  t.forEach(function (t, n) {
    var r = t.logicalShape,
        o = e[n],
        a = o.shape;
    if (!C(r, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + a + " must match");

    if (!t.isUniform || !o.isUniform) {
      var i = t.texShape,
          u = o.isUniform ? null : o.texData.texShape;
      if (!C(i, u)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i + " and " + u + " must match");
    }
  });
}

var Ri = function () {
  return function (t, e, n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;

    for (var r = n.filterWidth, o = n.inChannels, a = n.strideWidth, i = n.strideHeight, u = n.padInfo, s = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, f = u.left, p = u.top, d = o * r, v = Ko(), m = "channelsLast" === h, g = m ? 0 : 1, y = m ? 1 : 2, x = "", b = 0; b <= 1; b++) for (var w = 0; w <= 1; w++) x += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + b + ";\n\n          if(blockIndex < " + t[1] + " && pos < " + t[0] + ") {\n            offsetY = int(blockIndex / (" + s + ")) * " + i + " - " + p + ";\n            d0 = offsetY + " + l + " * (pos / " + d + ");\n\n            if(d0 < " + e[g] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + s + ".) * " + a + ". - " + f + ".);\n              d1 = offsetX + " + c + " * (int(mod(float(pos), " + d + ".) / " + o + ".));\n\n              if(d1 < " + e[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o + ".));\n\n                if (" + m + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";

    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x + "\n\n        " + v.output + " = result;\n      }\n    ";
  };
}(),
    Ii = function () {
  return function (t, e, n, r, o) {
    this.variableNames = ["x"], this.outputShape = [];
    var a,
        i = e,
        u = t[3] - 1;
    this.outputShape = t;
    var s = "float(" + n + ") + float(" + r + ") * sum";
    a = .5 === o ? "inversesqrt(" + s + ")" : 1 === o ? "1.0/(" + s + ")" : "exp(log(" + s + ") * float(-" + o + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i + "; j <= " + i + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + u + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a + ";\n        setOutput(val);\n      }\n    ";
  };
}(),
    ki = function () {
  return function (t, e, n, r, o) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + o + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
  };
}(),
    Si = function () {
  return function (t, e, n, r, o) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
    var a,
        i = e,
        u = t[3] - 1;
    this.outputShape = t;
    var s = "float(" + n + ") + float(" + r + ") * sum";
    a = .5 === o ? "inversesqrt(" + s + ")" : 1 === o ? "1.0/(" + s + ")" : "exp(log(" + s + ") * float(-" + o + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i + "; j <= " + i + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + u + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a + ";\n        setOutput(result);\n      }\n    ";
  };
}(),
    Ai = function () {
  return function (t) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
    var e = t.strideHeight,
        n = t.strideWidth,
        r = t.dilationHeight,
        o = t.effectiveFilterHeight,
        a = t.effectiveFilterWidth,
        i = o - 1 - t.padInfo.top,
        u = a - 1 - t.padInfo.left,
        s = o * a - 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + u + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + e + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + s + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Di = function () {
  return function (t) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
    var e = t.strideDepth,
        n = t.strideHeight,
        r = t.strideWidth,
        o = t.dilationDepth,
        a = t.dilationHeight,
        i = t.dilationWidth,
        u = t.effectiveFilterDepth,
        s = t.effectiveFilterHeight,
        c = t.effectiveFilterWidth,
        l = u - 1 - t.padInfo.front,
        h = s - 1 - t.padInfo.top,
        f = c - 1 - t.padInfo.left,
        p = u * s * c - 1;
    this.userCode = "\n      const ivec3 pads = ivec3(" + l + ", " + h + ", " + f + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + u + ";\n           wD += " + o + ") {\n          float dyD = float(dyDCorner + wD) / " + e + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + s + ";\n              wR += " + a + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + i + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + p + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + s + " * " + c + " +\n                  wR * " + c + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}(),
    Ti = function () {
  return function (t, e, n, r, o, a, i) {
    void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === i && (i = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
    var u = n ? t[1] : t[2],
        s = Math.ceil(u / 2),
        c = n ? "i * 2, rc.y" : "rc.y, i * 2",
        l = r ? "rc.z, i * 2" : "i * 2, rc.z",
        h = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
        f = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
        p = "",
        d = "";
    a && (p = i ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a + "\n        }" : "vec4 activation(vec4 x) {\n          " + a + "\n        }", d = "result = activation(result);");
    var v = o ? "result += getBiasAtOutCoords();" : "";
    o && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + p + "\n\n      const float sharedDimension = " + s + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + s + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c + ");\n          vec4 b = getMatrixB(rc.x, " + l + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h[0] + " * " + f[0] + ");\n          result += (" + h[1] + " * " + f[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v + "\n\n        " + d + "\n\n        setOutput(result);\n      }\n    ";
  };
}(),
    Ni = function () {
  function t(t, e, n) {
    this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e - 1) + "));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    return function (n, r) {
      null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(e.seedLoc, t);
    };
  }, t;
}(),
    Fi = function () {
  return function (t, e, n, r) {
    this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    ";
  };
}(),
    Oi = function () {
  return function (t) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;
    var e = t.length;
    if (0 === e) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else {
      var n = qo("rc", e),
          r = aa(e),
          o = function (t, e, n) {
        if (1 === t) return "rc > " + e[0];

        for (var r = "", o = t - 2; o < t; o++) r += n[o] + " >= " + e[o], o < t - 1 && (r += "||");

        return r;
      }(e, t, n),
          a = function (t, e, n, r) {
        if (1 === t) return "";
        var o = r.slice(-2);
        return "\n    int r = " + o[0] + ";\n    int c = " + o[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e + ";\n    bool rEdge = rp1 >= " + n + ";\n  ";
      }(e, t[t.length - 1], t[t.length - 2], n),
          i = function (t, e) {
        var n = t.length,
            r = function (t, e) {
          for (var n = [], r = 0; r <= 1; r++) for (var o = 0; o <= 1; o++) {
            for (var a = (0 === r ? "r" : "rp1") + ", " + (0 === o ? "c" : "cp1"), i = 2; i < t; i++) a = e[e.length - 1 - i] + "," + a;

            n.push(a);
          }

          return n;
        }(n, e);

        return 1 === n ? "getA(rc),\n            rc + 1 >= " + t[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")";
      }(t, n);

      this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + o + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a + "\n\n            setOutput(vec4(" + i + "));\n          }\n        }\n      ";
    }
  };
}();

var _i = function () {
  return function (t, e, n) {
    this.variableNames = ["x"], this.outputShape = e.map(function (e, n) {
      return e[0] + t[n] + e[1];
    });
    var r = t.length,
        o = aa(r),
        a = e.map(function (t) {
      return t[0];
    }).join(","),
        i = e.map(function (e, n) {
      return e[0] + t[n];
    }).join(","),
        u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
    this.userCode = 1 !== r ? "\n      " + o + " start = " + o + "(" + a + ");\n      " + o + " end = " + o + "(" + i + ");\n\n      void main() {\n        " + o + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n + "));\n        } else {\n          " + o + " coords = outC - start;\n          setOutput(getX(" + u + "));\n        }\n      }\n    " : "\n        int start = " + a + ";\n        int end = " + i + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
  };
}(),
    Mi = function () {
  return function (t, e, n) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function (e, n) {
      return e[0] + t[n] + e[1];
    });

    for (var r = t.length, o = aa(r), a = e.map(function (t) {
      return t[0];
    }).join(","), i = e.map(function (e, n) {
      return e[0] + t[n];
    }).join(","), u = qo("rc", r), s = qo("source", r), c = u[r - 1] + " < " + this.outputShape[r - 1], l = 1 === r ? "source" : "vec2(" + s.slice(-2).join() + ")", h = [o + " rc = outputLoc;", u[r - 1] + " += 1;\n       if(" + c + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + u[r - 2] + " += 1;\n       if(" + u[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + u[r - 1] + " += 1;\n         if(" + c + ") {"], f = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p = "", d = 0, v = 1 === r ? 2 : 4; d < v; d++) p += "\n        " + h[d] + "\n        if (" + f + ") {\n          result[" + d + "] = float(" + n + ");\n        } else {\n          " + o + " source = rc - start;\n          result[" + d + "] = getChannel(getX(" + s.join() + "), " + l + ");\n        }\n      ";

    p += 1 === r ? "} " : "}}", this.userCode = "\n      const " + o + " start = " + o + "(" + a + ");\n      const " + o + " end = " + o + "(" + i + ");\n\n      void main() {\n        " + o + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + p + "\n        setOutput(result);\n      }\n    ";
  };
}(),
    Bi = function () {
  return function (t, e, n) {
    if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
    var r = t.filterWidth,
        o = t.strideHeight,
        a = t.strideWidth,
        i = t.dilationHeight,
        u = t.dilationWidth,
        s = t.effectiveFilterHeight,
        c = t.effectiveFilterWidth,
        l = t.padInfo.top,
        h = t.padInfo.left;
    this.outputShape = t.outShape;
    var f = "avg" === e,
        p = "0.0";
    if (f || (p = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + o + ", " + a + ");\n        const ivec2 pads = ivec2(" + l + ", " + h + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + s + ";\n              wR += " + i + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + u + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else {
      var d = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "avg" === e && (d = "avgValue / count");
      var v = 4 * Math.floor(r / 4),
          m = r % 4,
          g = "\n      if (" + f + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
      this.userCode = "\n      const ivec2 strides = ivec2(" + o + ", " + a + ");\n      const ivec2 pads = ivec2(" + l + ", " + h + ");\n      const float initializationValue = " + p + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + p + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + s + ";\n            wR += " + i + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v + "; wC += 4) {\n            int xC = xCCorner + wC * " + u + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u + ", d),\n              getValue(batch, xR, xC + 2 * " + u + ", d),\n              getValue(batch, xR, xC + 3 * " + u + ", d)\n            );\n\n            " + g + "\n          }\n\n          int xC = xCCorner + " + v + ";\n          if (" + (1 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (2 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (3 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u + ", d),\n              getValue(batch, xR, xC + 2 * " + u + ", d),\n              initializationValue\n            );\n\n            " + g + "\n          }\n        }\n        setOutput(" + d + ");\n      }\n    ";
    }
  };
}(),
    Pi = function () {
  return function (t, e, n) {
    if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
    var r = t.filterWidth,
        o = t.strideDepth,
        a = t.strideHeight,
        i = t.strideWidth,
        u = t.dilationDepth,
        s = t.dilationHeight,
        c = t.dilationWidth,
        l = t.effectiveFilterDepth,
        h = t.effectiveFilterHeight,
        f = t.effectiveFilterWidth,
        p = t.padInfo.front,
        d = t.padInfo.top,
        v = t.padInfo.left;
    this.outputShape = t.outShape;
    var m = "avg" === e,
        g = "0.0";
    if (m || (g = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o + ", " + a + ", " + i + ");\n        const ivec3 pads = ivec3(" + p + ", " + d + ", " + v + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l + ";\n              wD += " + u + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h + ";\n                wR += " + s + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f + ";\n                  wC += " + c + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h + " * " + f + " +\n                      wR * " + f + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else {
      var y = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "avg" === e && (y = "avgValue / count");
      var x = 4 * Math.floor(r / 4),
          b = r % 4,
          w = "\n      if (" + m + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
      this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o + ", " + a + ", " + i + ");\n      const ivec3 pads = ivec3(" + p + ", " + d + ", " + v + ");\n      const float initializationValue = " + g + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + u + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + ";\n            wR += " + s + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x + "; wC += 4) {\n              int xC = xCCorner + wC * " + c + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c + ", ch)\n              );\n\n              " + w + "\n            }\n\n            int xC = xCCorner + " + x + ";\n            if (" + (1 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (2 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (3 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                initializationValue\n              );\n\n              " + w + "\n            }\n          }\n          setOutput(" + y + ");\n        }\n      }\n    ";
    }
  };
}(),
    Li = function () {
  return function (t, e) {
    this.variableNames = ["x"];
    var n = t.windowSize,
        r = t.batchSize,
        o = t.inSize,
        a = Math.ceil(o / n);
    this.outputShape = [r, a];
    var i = "0.0",
        u = "";
    "prod" === e ? i = "1.0" : "min" === e ? (i = "1.0 / 1e-20", u = "min") : "max" === e && (i = "-1.0 / 1e-20", u = "max");
    var s = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "sum" === e ? s = "sumValue" : "prod" === e ? s = "prodValue" : "all" === e ? s = "allValue" : "any" === e && (s = "anyValue");
    var c = 4 * Math.floor(n / 4),
        l = n % 4,
        h = "\n      if (" + ("sum" === e) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + u + "(values, minMaxValue);\n      }\n    ",
        f = "vec4";
    "all" === e ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f = "bvec4") : "any" === e && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f = "bvec4");
    var p = "";
    o % n > 0 && (p = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + p + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + i + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h + "\n        }\n\n        int inIdx = inOffset + " + c + ";\n        if (" + (1 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (2 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (3 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h + "\n        }\n        setOutput(" + s + ");\n      }\n    ";
  };
}(),
    Wi = function () {
  return function (t, e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;

    for (var n = "", r = 0; r < 4; r++) {
      var o = "thisRC = rc;";
      r % 2 == 1 && (o += "thisRC.z += 1;"), r > 1 && (o += "thisRC.y += 1;"), n += "\n        " + o + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      ";
    }

    this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + jo(["r", "c", "d"], e) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Xo(t) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t[1] + ";\n        int cols = " + t[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    ";
  };
}();

var Ui = function () {
  return function (t, e, n) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
    var r = e.shape,
        o = r[1],
        a = r[2],
        i = t.shape,
        u = i[1],
        s = i[2],
        c = [n && u > 1 ? o - 1 : o, n && s > 1 ? a - 1 : a],
        l = [n && u > 1 ? u - 1 : u, n && s > 1 ? s - 1 : s],
        h = c[0] / l[0],
        f = c[1] / l[1],
        p = 1 / h,
        d = 1 / f,
        v = 2 * Math.ceil(p) + 2,
        m = 2 * Math.ceil(d) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f + ");\n\n        const float invHeightScale = float(" + p + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
  };
}(),
    Vi = function () {
  return function (t, e, n, r) {
    this.variableNames = ["A"], this.outputShape = [];
    var o = t[0],
        a = t[1],
        i = t[2],
        u = t[3];
    this.outputShape = [o, e, n, u];
    var s = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
        c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s[0] / c[0] + ",\n          " + s[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + a + ".0, " + i + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
  };
}(),
    zi = function () {
  return function (t, e, n, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var o = t[0],
        a = t[1],
        i = t[2],
        u = t[3];
    this.outputShape = [o, e, n, u];
    var s = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
        c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
    this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + s[0] / c[0] + ",\n          " + s[1] / c[1] + ",\n          " + s[1] / c[1] + ");\n      const vec3 inputShapeRC = vec3(" + a + ".0, " + i + ".0,\n                                     " + i + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (u - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
  };
}(),
    Gi = function () {
  return function (t, e, n) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
    var r = e.shape,
        o = r[1],
        a = r[2],
        i = t.shape,
        u = i[1],
        s = i[2],
        c = [n && u > 1 ? o - 1 : o, n && s > 1 ? a - 1 : a],
        l = [n && u > 1 ? u - 1 : u, n && s > 1 ? s - 1 : s],
        h = c[0] / l[0],
        f = c[1] / l[1],
        p = 1 / h,
        d = 1 / f,
        v = 2 * Math.ceil(p) + 2,
        m = 2 * Math.ceil(d) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f + ");\n\n        const float invHeightScale = float(" + p + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c[0] + ") *\n                (float(dyR) / float(" + l[0] + "));\n\n            float sourceFracCol =\n                float(" + c[1] + ") *\n                  (float(dyC) / float(" + l[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
  };
}(),
    Hi = function () {
  return function (t, e, n, r) {
    this.variableNames = ["A"], this.outputShape = [];
    var o = t[0],
        a = t[1],
        i = t[2],
        u = t[3];
    this.outputShape = [o, e, n, u];
    var s = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
        c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
        l = r ? "0.5" : "0.0";
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s[0] / c[0] + ",\n          " + s[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + a + ".0, " + i + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
  };
}(),
    qi = function () {
  return function (t, e) {
    this.variableNames = ["x"];
    var n = t.length;
    if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");

    if (this.outputShape = t, 1 !== n) {
      var r = t.map(function (n, r) {
        return function (n) {
          return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]";
        }(r);
      }).join(","),
          o = aa(n);
      this.userCode = "\n      void main() {\n        " + o + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    ";
    } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t[0] + " - coord - 1));\n        }\n      ";
  };
}(),
    Ki = function () {
  return function (t, e) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
    var n = t.length;
    if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
    this.outputShape = t;
    var r = qo("rc", n),
        o = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
        a = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
        i = aa(n);

    function u(n) {
      var r = t.map(function (r, o) {
        return function (n, r) {
          return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - " + r[n] + " - 1" : "" + r[n];
        }(o, n);
      });
      return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))";
    }

    this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t[0] + " - rc - 1),\n            " + t[0] + " - rc - 1);\n          if(" + o + "){\n              result.g = getChannel(getX(" + t[0] + " - (rc  + 1) - 1),\n                " + t[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function (t) {
      return u(t);
    }(r.slice()) + ";\n          if(" + o + "){\n            result.g = " + function (t) {
      return t[n - 1] = "(" + t[n - 1] + " + 1)", u(t);
    }(r.slice()) + ";\n          }\n          if(" + a + ") {\n            result.b = " + function (t) {
      return t[n - 2] = "(" + t[n - 2] + " + 1)", u(t);
    }(r.slice()) + ";\n            if(" + o + ") {\n              result.a = " + function (t) {
      return t[n - 1] = "(" + t[n - 1] + " + 1)", t[n - 2] = "(" + t[n - 2] + " + 1)", u(t);
    }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
  };
}(),
    ji = function () {
  return function (t, e, n, r, o, a, i) {
    void 0 === i && (i = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
    var u = aa(o.length),
        s = aa(a.length),
        c = "";
    1 === n ? c = "i" : 2 === n && (c = "i, j");
    var l = "getIndices(" + c + ")",
        h = "";
    1 === r ? h = "i" : 2 === r && (h = "i, coords[1]");
    var f = "getUpdates(" + h + ")",
        p = e > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + u + " strides = " + u + "(" + o + ");\n\n        void main() {\n          " + s + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e + "; j++) {\n              int index = round(" + l + ");\n              flattenedIndex += index * " + p + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
  };
}(),
    Xi = function () {
  return function (t, e) {
    this.variableNames = ["x", "segmentIds"];
    var n = t.windowSize,
        r = t.batchSize,
        o = t.inSize,
        a = t.numSegments,
        i = a * Math.ceil(o / n);
    this.outputShape = [r, i];
    var u = 4 * Math.floor(n / 4),
        s = n % 4,
        c = "\n        sumValue += dot(values, segFilter);\n    ",
        l = "";
    o % n > 0 && (l = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return initializationValue;\n        }\n      ");
    var h = "";
    o % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + u + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c + "\n        }\n\n        int inIdx = inOffset + " + u + ";\n        if (" + (1 === s) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c + "\n        } else if (" + (2 === s) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c + "\n        } else if (" + (3 === s) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c + "\n        }\n        setOutput(sumValue);\n      }\n    ";
  };
}(),
    $i = function () {
  return function (t, e, n) {
    var r, o;
    if (this.variableNames = ["c", "a", "b"], this.outputShape = e, n > 4) throw Error("Where for rank " + n + " is not yet supported");
    if (1 === n) o = "resRC", r = "resRC";else {
      for (var a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i = [], u = [], s = 0; s < e.length; s++) u.push("" + a[s]), s < t && i.push("" + a[s]);

      r = i.join(), o = u.join();
    }
    var c = aa(n);
    this.userCode = "\n      void main() {\n        " + c + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o + "));\n        } else {\n          setOutput(getB(" + o + "));\n        }\n      }\n    ";
  };
}(),
    Yi = function () {
  function t(t) {
    this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;

    var e,
        n = aa(this.rank),
        r = "uniform int start[" + this.rank + "];",
        o = function (t) {
      if (1 === t) return "sourceLoc";
      if (t <= 6) return Qi.slice(0, t).map(function (t) {
        return "sourceLoc." + t;
      }).join(",");
      throw Error("Slicing for rank " + t + " is not yet supported");
    }(this.rank);

    e = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + t.map(function (t, e) {
      return "sourceLoc." + Qi[e] + " = start[" + e + "] + coords." + Qi[e] + ";";
    }).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + e + "\n        setOutput(getSource(" + o + "));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
    return function (n, r) {
      null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);
    };
  }, t;
}(),
    Qi = ["x", "y", "z", "w", "u", "v"];

var Ji = function () {
  function t(t) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;
    var e = aa(this.rank),
        n = qo("coords", this.rank),
        r = qo("sourceLoc", this.rank),
        o = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
        a = "getChannel(getSource(" + r.join() + "), " + o + ")",
        i = "\n      result.x = " + a + ";\n      if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + a + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
        u = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + t[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + a + ";\n        if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + a + ";\n        }\n      }\n    ",
        s = this.rank <= 4 ? "sourceLoc = coords +\n            " + e + "(" + t.map(function (t, e) {
      return "start[" + e + "]";
    }).join() + ");" : t.map(function (t, e) {
      return r[e] + " = " + n[e] + " + start[" + e + "];";
    }).join("\n");
    this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e + " coords = getOutputCoords();\n        " + e + " sourceLoc;\n        " + s + "\n        vec4 result = vec4(0.);\n        " + i + "\n        " + u + "\n        setOutput(result);\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
    return function (n, r) {
      null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);
    };
  }, t;
}(),
    Zi = function () {
  return function (t, e, n) {
    this.variableNames = ["x"], this.outputShape = n;
    var r = n.length,
        o = aa(n.length),
        a = aa(n.length),
        i = "";
    if (1 === r) i = "coords * strides + begin";else {
      var u = 0;
      i = n.map(function (t, e) {
        return u++, 1 === n.length ? "coords * strides[" + e + "] + begin[" + e + "]" : "coords[" + (u - 1) + "] * strides[" + e + "] + begin[" + e + "]";
      }).join(",");
    }
    this.userCode = "\n      " + o + " begin = " + o + "(" + t + ");\n      " + o + " strides = " + o + "(" + e + ");\n\n      void main() {\n        " + a + " coords = getOutputCoords();\n        setOutput(getX(" + i + "));\n      }\n    ";
  };
}(),
    tu = function () {
  function t(t) {
    this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }

  return t.prototype.acquireTexture = function (t, e, n) {
    var r,
        o = eu(e, n),
        a = nu(t, o, n);

    if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var i = this.freeTextures[a].shift();
      return this.usedTextures[a].push(i), i;
    }

    return this.numUsedTextures++, this.log(), o === Bt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Bt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Bt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Bt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Bt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[a].push(r), r;
  }, t.prototype.releaseTexture = function (t, e, n, r) {
    if (null != this.freeTextures) {
      var o = nu(e, eu(n, r), r);
      o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--;
      var a = this.usedTextures[o],
          i = a.indexOf(t);
      if (i < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      a.splice(i, 1), this.log();
    }
  }, t.prototype.log = function () {
    if (this.logEnabled) {
      var t = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t + ")");
    }
  }, t.prototype.getNumUsedTextures = function () {
    return this.numUsedTextures;
  }, t.prototype.getNumFreeTextures = function () {
    return this.numFreeTextures;
  }, t.prototype.dispose = function () {
    var t = this;

    if (null != this.freeTextures) {
      for (var e in this.freeTextures) this.freeTextures[e].forEach(function (e) {
        t.gpgpu.deleteMatrixTexture(e);
      });

      for (var e in this.usedTextures) this.usedTextures[e].forEach(function (e) {
        t.gpgpu.deleteMatrixTexture(e);
      });

      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, t;
}();

function eu(t, e) {
  if (t === Mt.UPLOAD) return Bt.PACKED_2X2_FLOAT32;
  if (t === Mt.RENDER || null == t) return function (t) {
    return a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? Bt.PACKED_2X2_FLOAT32 : Bt.UNPACKED_FLOAT32 : t ? Bt.PACKED_2X2_FLOAT16 : Bt.UNPACKED_FLOAT16;
  }(e);
  if (t === Mt.DOWNLOAD || t === Mt.PIXELS) return Bt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + t);
}

function nu(t, e, n) {
  return t[0] + "_" + t[1] + "_" + e + "_" + n;
}

var ru = function () {
  return function (t, e) {
    this.variableNames = ["A"];

    for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];

    this.outputShape = n, this.rank = n.length;

    var o = aa(this.rank),
        a = function (t) {
      var e = t.length;
      if (e > 5) throw Error("Tile for rank " + e + " is not yet supported");
      if (1 === e) return "imod(resRC, " + t[0] + ")";

      for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], o = 0; o < t.length; o++) r.push("imod(" + n[o] + ", " + t[o] + ")");

      return r.join();
    }(t);

    this.userCode = "\n      void main() {\n        " + o + " resRC = getOutputCoords();\n        setOutput(getA(" + a + "));\n      }\n    ";
  };
}();

var ou = function () {
  return function (t, e) {
    this.variableNames = ["A"];

    for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];

    this.outputShape = n, this.rank = n.length;

    var o = aa(this.rank),
        a = function (t) {
      var e = t.length;
      if (e > 6) throw Error("Transpose for rank " + e + " is not yet supported");

      for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(e), o = 0; o < t.length; o++) r[t[o]] = n[o];

      return r.join();
    }(e);

    this.userCode = "\n    void main() {\n      " + o + " resRC = getOutputCoords();\n      setOutput(getA(" + a + "));\n    }\n    ";
  };
}();

var au = function () {
  return function (t, e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;

    for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];

    if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
    var o = aa(this.rank),
        a = Ho("rc", this.rank),
        i = new Array(this.rank);

    for (r = 0; r < e.length; r++) i[e[r]] = a[r];

    var u = "vec2(" + i.slice(-2).join() + ")",
        s = "++" + a[this.rank - 1] + " < " + n[this.rank - 1],
        c = "getChannel(getA(" + i.join() + "), " + u + ")";
    this.userCode = "\n    void main() {\n      " + o + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c + ";\n      if(" + s + ") {\n        result[1] = " + c + ";\n      }\n      --" + a[this.rank - 1] + ";\n      if(++" + a[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + c + ";\n        if(" + s + ") {\n          result[3] = " + c + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
  };
}(),
    iu = 1.7580993408473768,
    uu = 1.0507009873554805,
    su = function () {
  return function (t, e) {
    this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      float unaryOperation(float x) {\n        " + e + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  };
}(),
    cu = "if (isnan(x)) return x;",
    lu = "return x;",
    hu = "return abs(x);",
    fu = cu + "\n  return (x < 0.0) ? 0.0 : x;\n",
    pu = cu + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    du = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    vu = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + iu + ";\n  float scale = " + uu + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";

var mu = "return -x;",
    gu = "return ceil(x);",
    yu = "return floor(x);",
    xu = "return exp(x);",
    bu = "return exp(x) - 1.0;",
    wu = cu + "\n  return sin(x);\n",
    Cu = cu + "\n  return cos(x);\n",
    Eu = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",
    Ru = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",
    Iu = cu + "\n  return atan(x);\n",
    ku = cu + "return log(x + sqrt(x * x + 1.0));",
    Su = cu + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",
    Au = cu + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",
    Du = "return x;",
    Tu = "return x;",
    Nu = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    Fu = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    Ou = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
    _u = function () {
  return function (t, e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  };
}(),
    Mu = function () {
  return function (t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;

    var e = t.length,
        n = qo("rc", e),
        r = aa(e),
        o = function (t, e) {
      if (1 === t) return "rc";

      for (var n = "", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += ",");

      return n;
    }(e, n),
        a = n.slice(-2),
        i = e <= 1 ? "rc" : "vec2(" + a.join(",") + ")";

    this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o + ");\n\n        setOutput(getChannel(packedInput, " + i + "));\n      }\n    ";
  };
}(),
    Bu = {};

function Pu(t, e) {
  if (void 0 === e && (e = !1), "linear" === t) return e ? Tu : lu;
  if ("relu" === t) return e ? Nu : fu;
  if ("elu" === t) return e ? Ou : du;
  if ("relu6" === t) return e ? Fu : pu;
  if ("prelu" === t) return e ? wa : xa;
  throw new Error("Activation " + t + " has not been implemented for the WebGL backend.");
}

var Lu = 600;

var Wu = function (t) {
  function o(e) {
    var n,
        r = t.call(this) || this;
    if (r.gpgpu = e, r.pendingRead = new WeakMap(), r.pendingDisposal = new WeakSet(), r.dataRefCount = new WeakMap(), r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !a().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");

    if (null == e) {
      var o = Ut(a().getNumber("WEBGL_VERSION"));
      r.binaryCache = (n = a().getNumber("WEBGL_VERSION")) in Bu ? Bu[n] : (Bu[n] = {}, Bu[n]), r.gpgpu = new Ci(o), r.canvas = o.canvas, r.gpgpuCreatedLocally = !0;
    } else r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;

    return r.textureManager = new tu(r.gpgpu), r.numMBBeforeWarning = null == a().global.screen ? 1024 : a().global.screen.height * a().global.screen.width * window.devicePixelRatio * Lu / 1024 / 1024, r.texData = new so(r, Nt), r;
  }

  return e(o, t), o.prototype.numDataIds = function () {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, o.prototype.fromPixels = function (t, e) {
    if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n = "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement,
        r = t.data instanceof Uint8Array,
        o = "undefined" != typeof ImageData && t instanceof ImageData,
        i = "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement,
        u = "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement,
        s = i ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
        c = s[0],
        l = s[1],
        h = [l, c],
        f = [l, c, e];
    if (!(n || r || o || i || u)) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
    (u || i) && (null == this.fromPixels2DContext && (this.fromPixels2DContext = Vt(a().getNumber("WEBGL_VERSION")).getContext("2d")), this.fromPixels2DContext.canvas.width = c, this.fromPixels2DContext.canvas.height = l, this.fromPixels2DContext.drawImage(t, 0, 0, c, l), t = this.fromPixels2DContext.canvas);
    var p,
        d,
        v = this.makeTensorInfo(h, "int32");
    return this.texData.get(v.dataId).usage = Mt.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(v.dataId), t), a().getBool("WEBGL_PACK") ? (p = new ei(f), d = this.compileAndRun(p, [v])) : (p = new ti(f), d = this.compileAndRun(p, [v])), this.disposeData(v.dataId), d;
  }, o.prototype.write = function (t, e, n) {
    if (a().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === n && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var r = {};
    return this.texData.set(r, {
      shape: e,
      dtype: n,
      values: t,
      usage: Mt.UPLOAD
    }), r;
  }, o.prototype.move = function (t, e, n, r) {
    if (a().getBool("DEBUG") && this.checkNumericalProblems(e), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t, {
      shape: n,
      dtype: r,
      values: e,
      usage: Mt.UPLOAD
    });
  }, o.prototype.readSync = function (t) {
    var e = this.texData.get(t),
        n = e.values,
        r = e.dtype,
        o = e.complexTensors,
        a = e.slice,
        i = e.shape,
        u = e.isPacked;

    if (null != a) {
      var s = void 0;
      s = u ? new _u(i, Du) : new su(i, Du);
      var c = this.runWebGLProgram(s, [{
        dataId: t,
        shape: i,
        dtype: r
      }], r),
          l = this.readSync(c.dataId);
      return this.disposeData(c.dataId), l;
    }

    if (null != n) return this.convertAndCacheOnCPU(t);
    if ("string" === r) return n;
    var h,
        f,
        p = null != this.activeTimers;
    (p && (h = Y()), "complex64" === r) ? f = No(o.real.dataSync(), o.imag.dataSync()) : f = this.getValuesFromTexture(t);
    return p && (this.downloadWaitMs += Y() - h), this.convertAndCacheOnCPU(t, f);
  }, o.prototype.read = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, i, u, s, c, l, h, f, p, d, v, m, g, y, x, b, C, E, R, I;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise(function (t) {
              return e.push(t);
            })];
            if (n = this.texData.get(t), o = n.values, i = n.shape, u = n.slice, s = n.dtype, c = n.complexTensors, l = n.isPacked, null != u) return h = void 0, h = l ? new _u(i, Du) : new su(i, Du), f = this.runWebGLProgram(h, [{
              dataId: t,
              shape: i,
              dtype: s
            }], s), p = this.read(f.dataId), this.disposeData(f.dataId), [2, p];
            if (null != o) return [2, this.convertAndCacheOnCPU(t)];
            if (!a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === a().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return d = null, "complex64" !== s && a().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t), m = this.texData.get(v.dataId), d = (I = this.gpgpu).createBufferFromTexture.apply(I, [m.texture].concat(Gt(i)))), this.pendingRead.set(t, []), "complex64" === s ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];

          case 1:
            r.sent(), r.label = 2;

          case 2:
            return "complex64" !== s ? [3, 4] : [4, Promise.all([c.real.data(), c.imag.data()])];

          case 3:
            return y = r.sent(), x = y[0], b = y[1], g = No(x, b), [3, 5];

          case 4:
            null == d ? g = this.getValuesFromTexture(t) : (C = w(i), g = this.gpgpu.downloadFloat32MatrixFromBuffer(d, C)), r.label = 5;

          case 5:
            return null != v && this.disposeData(v.dataId), E = this.convertAndCacheOnCPU(t, g), R = this.pendingRead.get(t), this.pendingRead.delete(t), R.forEach(function (t) {
              return t(E);
            }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, E];
        }
      });
    });
  }, o.prototype.checkNumericalProblems = function (t) {
    if (null != t) for (var e = 0; e < t.length; e++) {
      var n = t[e];

      if (!$t(n)) {
        if (a().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
        throw Error("The value " + n + " cannot be represented on this device.");
      }
    }
  }, o.prototype.getValuesFromTexture = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.shape,
        o = n.dtype,
        i = n.isPacked,
        u = w(r);

    if (a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var s = this.decode(t),
          c = this.texData.get(s.dataId),
          l = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [c.texture].concat(Gt(r))).subarray(0, u);
      return this.disposeData(s.dataId), l;
    }

    var h = a().getBool("WEBGL_PACK") && !0 === i,
        f = h ? Re(r) : r,
        p = h ? new ja(f) : new Ka(f),
        d = this.runWebGLProgram(p, [{
      shape: f,
      dtype: o,
      dataId: t
    }], "float32"),
        v = this.texData.get(d.dataId),
        m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, u);
    return this.disposeData(d.dataId), m;
  }, o.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, u, s;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return e = this.activeTimers, n = [], o = !1, null == this.programTimersStack ? (this.programTimersStack = n, o = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), a = b(this.activeTimers.map(function (t) {
              return t.query;
            })).filter(function (t) {
              return null != t;
            }), i = b(this.activeTimers.map(function (t) {
              return t.name;
            })).filter(function (t) {
              return null != t;
            }), this.activeTimers = e, o && (this.programTimersStack = null), [4, Promise.all(a)];

          case 1:
            return u = r.sent(), s = {
              uploadWaitMs: this.uploadWaitMs,
              downloadWaitMs: this.downloadWaitMs,
              kernelMs: m(u),
              getExtraProfileInfo: function () {
                return u.map(function (t, e) {
                  return {
                    name: i[e],
                    ms: t
                  };
                }).map(function (t) {
                  return t.name + ": " + t.ms;
                }).join(", ");
              },
              wallMs: null
            }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s];
        }
      });
    });
  }, o.prototype.memory = function () {
    return {
      unreliable: !1,
      numBytesInGPU: this.numBytesInGPU
    };
  }, o.prototype.startTimer = function () {
    return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : {
      startMs: Y(),
      endMs: null
    };
  }, o.prototype.endTimer = function (t) {
    return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = Y(), t);
  }, o.prototype.getQueryTime = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs];
      });
    });
  }, o.prototype.disposeData = function (t) {
    if (!this.pendingDisposal.has(t)) {
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;

      if (this.texData.has(t)) {
        this.releaseGPUData(t);
        var e = this.texData.get(t).complexTensors;
        null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t);
      }
    }
  }, o.prototype.releaseGPUData = function (t) {
    var e = this.texData.get(t),
        n = e.texture,
        r = e.dtype,
        o = e.texShape,
        a = e.usage,
        i = e.isPacked,
        u = e.slice,
        s = u && u.origDataId || t,
        c = this.dataRefCount.get(s);
    c > 1 ? this.dataRefCount.set(s, c - 1) : (this.dataRefCount.delete(s), null != n && (this.numBytesInGPU -= this.computeBytes(o, r), this.textureManager.releaseTexture(n, o, a, i)));
    var l = this.texData.get(t);
    l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null;
  }, o.prototype.getTexture = function (t) {
    return this.uploadToGPU(t), this.texData.get(t).texture;
  }, o.prototype.getDataInfo = function (t) {
    return this.texData.get(t);
  }, o.prototype.getCPUBackend = function () {
    return a().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Nt.findBackend("cpu")), this.cpuBackend) : null;
  }, o.prototype.shouldExecuteOnCPU = function (t, e) {
    var n = this;
    return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function (t) {
      return null == n.texData.get(t.dataId).texture && t.size < e;
    });
  }, o.prototype.getGPGPUContext = function () {
    return this.gpgpu;
  }, o.prototype.complex = function (t, e) {
    var n = this.makeOutput(t.shape, "complex64");
    return this.texData.get(n.dataId).complexTensors = {
      real: Nt.keep(t.clone()),
      imag: Nt.keep(e.clone())
    }, n;
  }, o.prototype.real = function (t) {
    return this.texData.get(t.dataId).complexTensors.real.clone();
  }, o.prototype.imag = function (t) {
    return this.texData.get(t.dataId).complexTensors.imag.clone();
  }, o.prototype.slice = function (t, e, n) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);
    if (0 === w(n)) return kn([], n, t.dtype);
    var r = this.texData.get(t.dataId).isPacked,
        o = Yr(t.shape, e, n);

    if (r || !o) {
      var i = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ji(n) : new Yi(n),
          u = i.getCustomSetupFunc(e);
      return this.compileAndRun(i, [t], null, u);
    }

    return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);
  }, o.prototype.shallowSlice = function (t, e, n) {
    var r = this.texData.get(t.dataId),
        o = this.makeOutput(n, t.dtype),
        a = this.texData.get(o.dataId);
    Object.assign(a, r), a.shape = n, a.dtype = t.dtype;
    var i = Qr(e, t.strides);
    r.slice && (i += r.slice.flatOffset), a.slice = {
      flatOffset: i,
      origDataId: r.slice && r.slice.origDataId || t.dataId
    };
    var u = this.dataRefCount.get(a.slice.origDataId) || 1;
    return this.dataRefCount.set(a.slice.origDataId, u + 1), o;
  }, o.prototype.stridedSlice = function (t, e, n, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);
    var o = jr(e, n, r);
    if (o.some(function (t) {
      return 0 === t;
    })) return kn([], o);
    var a = new Zi(e, r, o);
    return this.compileAndRun(a, [t]);
  }, o.prototype.reverse = function (t, e) {
    var n = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ki(t.shape, e) : new qi(t.shape, e);
    return this.compileAndRun(n, [t]);
  }, o.prototype.concat = function (t, e) {
    if ("complex64" === t[0].dtype) {
      var n = t.map(function (t) {
        return Rn(t);
      }),
          r = t.map(function (t) {
        return In(t);
      });
      return En(this.concat(n, e), this.concat(r, e));
    }

    if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
    if (1 === t.length) return t[0];

    if (t.length > a().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var o = Math.floor(t.length / 2),
          i = this.concat(t.slice(0, o), e),
          u = this.concat(t.slice(o), e);
      return this.concat([i, u], e);
    }

    if (a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
      var s = new Sa(t.map(function (t) {
        return t.shape;
      }), e);
      return this.compileAndRun(s, t);
    }

    var c = wn(t.map(function (t) {
      return t.shape;
    }), e),
        l = t.map(function (t) {
      return t.as2D(-1, w(t.shape.slice(e)));
    }),
        h = new ka(l.map(function (t) {
      return t.shape;
    }));
    return this.compileAndRun(h, l).reshape(c);
  }, o.prototype.neg = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, mu, t.dtype);
    var e = new su(t.shape, mu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.batchMatMul = function (t, e, n, r) {
    var o = n ? t.shape[2] : t.shape[1],
        a = r ? e.shape[1] : e.shape[2],
        i = n ? t.shape[1] : t.shape[2],
        u = t.shape[0];

    if ((1 === o || 1 === a) && i > 1e3) {
      n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));
      var s = 1 === a ? t : t.as3D(u, i, 1),
          c = 1 === a ? 2 : 1,
          l = 1 === a ? e.as3D(u, 1, i) : e;
      return this.multiply(s, l).sum(c, !0);
    }

    var h = Ct(t.dtype, e.dtype),
        f = new Ti(t.shape, [u, o, a], n, r);
    return this.compileAndRun(f, [t, e], h);
  }, o.prototype.fusedBatchMatMul = function (t) {
    var e = t.a,
        n = t.b,
        r = t.transposeA,
        o = t.transposeB,
        a = t.bias,
        i = t.activation,
        u = t.preluActivationWeights,
        s = r ? e.shape[2] : e.shape[1],
        c = o ? n.shape[1] : n.shape[2],
        l = e.shape[0],
        h = Ct(e.dtype, n.dtype),
        f = null != a,
        p = null != u,
        d = i ? Pu(i, !0) : null,
        v = new Ti(e.shape, [l, s, c], r, o, f, d, p),
        m = [e, n];
    return a && m.push(a), u && m.push(u), this.compileAndRun(v, m, h);
  }, o.prototype.multiply = function (t, e) {
    if ("complex64" === t.dtype) {
      var n = this.texData.get(t.dataId),
          r = this.texData.get(e.dataId),
          o = new va(pa, t.shape, e.shape),
          i = new va(da, t.shape, e.shape),
          u = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],
          s = this.compileAndRun(o, u),
          c = this.compileAndRun(i, u),
          l = this.complex(s, c);
      return s.dispose(), c.dispose(), l;
    }

    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, ya, t.dtype);
    var h = new ba(ya, t.shape, e.shape);
    return this.compileAndRun(h, [t, e], t.dtype);
  }, o.prototype.batchNormalization = function (t, e, n, r, o, i) {
    var u = [t, e, n],
        s = null;
    null != i && (s = i.shape, u.push(i));
    var c = null;

    if (null != o && (c = o.shape, u.push(o)), a().getBool("WEBGL_PACK_NORMALIZATION")) {
      var l = new fa(t.shape, e.shape, n.shape, s, c, r);
      return this.compileAndRun(l, u);
    }

    var h = new ha(t.shape, e.shape, n.shape, s, c, r);
    return this.compileAndRun(h, u);
  }, o.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    var i = a().getBool("WEBGL_PACK_NORMALIZATION") ? new Si(t.shape, e, n, r, o) : new Ii(t.shape, e, n, r, o);
    return this.compileAndRun(i, [t]);
  }, o.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    var u = new ki(e.shape, r, o, a, i);
    return this.compileAndRun(u, [e, n, t]);
  }, o.prototype.tile = function (t, e) {
    if ("string" === t.dtype) {
      var n = this.readSync(t.dataId).map(function (t) {
        return Z(t);
      });
      return Lo(ur(t.shape, t.dtype, n), e);
    }

    var r = new ru(t.shape, e);
    return this.compileAndRun(r, [t]);
  }, o.prototype.pad = function (t, e, n) {
    var r = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Mi(t.shape, e, n) : new _i(t.shape, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.transpose = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);
    var n = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new au(t.shape, e) : new ou(t.shape, e);
    return this.compileAndRun(n, [t]);
  }, o.prototype.gather = function (t, e, n) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);
    var r = new ni(t.shape, e.size, n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.batchToSpaceND = function (t, e, n) {
    g(t.rank <= 4, function () {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = Mr(t.shape, e, r),
        a = Br(o.length, e.length),
        i = Pr(t.shape, e, r),
        u = Lr(n, e.length),
        s = Wr(i, n, e.length);
    return t.reshape(o).transpose(a).reshape(i).slice(u, s);
  }, o.prototype.spaceToBatchND = function (t, e, n) {
    g(t.rank <= 4, function () {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = [[0, 0]];
    o.push.apply(o, n);

    for (var a = 1 + e.length; a < t.shape.length; ++a) o.push([0, 0]);

    var i = t.pad(o),
        u = Mr(i.shape, e, r, !1),
        s = Br(u.length, e.length, !1),
        c = Pr(i.shape, e, r, !1);
    return i.reshape(u).transpose(s).reshape(c);
  }, o.prototype.reduce = function (t, e, n) {
    var r = t.shape[0],
        o = t.shape[1],
        a = zr(o),
        i = new Li({
      windowSize: a,
      inSize: o,
      batchSize: r
    }, e),
        u = this.compileAndRun(i, [t], n);
    return 1 === u.shape[1] ? u : this.reduce(u, e, n);
  }, o.prototype.argReduce = function (t, e, n) {
    void 0 === n && (n = null);
    var r = t.shape[0],
        o = t.shape[1];
    null != n && (r = n.shape[0], o = n.shape[1]);
    var a = zr(o),
        i = new Go({
      windowSize: a,
      inSize: o,
      batchSize: r
    }, e, null == n),
        u = [t];
    null != n && u.push(n);
    var s = this.compileAndRun(i, u, "int32");
    return 1 === s.shape[1] ? s : this.argReduce(t, e, s);
  }, o.prototype.argReducePacked = function (t, e, n) {
    void 0 === n && (n = null);
    var r = null != n ? n.shape : t.shape,
        o = zr(r[r.length - 1]),
        a = new sa(r, o, e, null == n),
        i = null == n ? [t] : [t, n],
        u = this.compileAndRun(a, i, "int32");
    return u.rank === t.rank ? this.argReducePacked(t, e, u) : u;
  }, o.prototype.sum = function (t, e) {
    mn("sum", e, t.rank);
    var n = dn(t.shape, e),
        r = n[0],
        o = w(n[1]),
        a = t.as2D(-1, o),
        i = Et(t.dtype);
    return this.reduce(a, "sum", i).reshape(r);
  }, o.prototype.prod = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
    var n = dn(t.shape, e),
        r = n[0],
        o = w(n[1]),
        a = t.as2D(-1, o),
        i = Et(t.dtype);
    return this.reduce(a, "prod", i).reshape(r);
  }, o.prototype.unsortedSegmentSum = function (t, e, n) {
    var r = 0,
        o = gn([r], t.rank),
        a = t;
    null != o && (a = t.transpose(o), r = xn(1, t.rank)[0]);

    var i = function (t, e, n) {
      for (var r = [], o = t.length, a = 0; a < o; a++) a !== e ? r.push(t[a]) : r.push(n);

      return r;
    }(a.shape, r, n),
        u = w([a.shape[r]]),
        s = a.as2D(-1, u),
        c = Et(t.dtype),
        l = this.segOpCompute(s, "unsortedSegmentSum", e, c, n).reshape(i);

    return null != o && (l = l.transpose(yn(o))), l;
  }, o.prototype.segOpCompute = function (t, e, n, r, o) {
    var a = t.shape[0],
        i = t.shape[1],
        u = function (t, e) {
      var n,
          r = !1;

      for (t <= Vr ? (n = t, r = !0) : n = H(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = H(t, n + 1);

      return n;
    }(i, o),
        s = new Xi({
      windowSize: u,
      inSize: i,
      batchSize: a,
      numSegments: o
    }, e),
        c = this.compileAndRun(s, [t, n], r);

    return c.shape[1] === o ? c : (n = Un(0, o).tile([i / u]), this.segOpCompute(c, e, n, r, o));
  }, o.prototype.argMinMaxReduce = function (t, e, n) {
    var r = [e];

    if (mn("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !a().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
      var o = dn(t.shape, r),
          i = o[0],
          u = w(o[1]),
          s = t.as2D(-1, u);
      return this.argReduce(s, n).reshape(i);
    }

    return this.argReducePacked(t, n);
  }, o.prototype.argMin = function (t, e) {
    return this.argMinMaxReduce(t, e, "min");
  }, o.prototype.argMax = function (t, e) {
    return this.argMinMaxReduce(t, e, "max");
  }, o.prototype.cumsum = function (t, e, n, r) {
    if (e !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
    var o = new Ua(t.shape, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.equal = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(equal(a, b));\n", "bool");
    var n = new ba("return float(a == b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.notEqual = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(notEqual(a, b));\n", "bool");
    var n = new ba("return float(a != b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.less = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThan(a, b));\n", "bool");
    var n = new ba("return float(a < b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.lessEqual = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
    var n = new ba("return float(a <= b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.greater = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThan(a, b));\n", "bool");
    var n = new ba("return float(a > b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.greaterEqual = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
    var n = new ba("return float(a >= b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.logicalNot = function (t) {
    var e = new su(t.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(e, [t]);
  }, o.prototype.logicalAnd = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
    var n = new ba("return float(a >= 1.0 && b >= 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.logicalOr = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
    var n = new ba("return float(a >= 1.0 || b >= 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.select = function (t, e, n) {
    var r = new $i(t.rank, e.shape, e.rank);
    return this.compileAndRun(r, [t, e, n], Ct(e.dtype, n.dtype));
  }, o.prototype.where = function (t) {
    un("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var e = t.dataSync();
    return Uo(t.shape, e);
  }, o.prototype.topk = function (t, e, n) {
    return Wo(t.dataSync(), t.shape, t.dtype, e);
  }, o.prototype.min = function (t, e) {
    mn("min", e, t.rank);
    var n = dn(t.shape, e),
        r = n[0],
        o = w(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "min", a.dtype).reshape(r);
  }, o.prototype.minimum = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.mod = function (t, e) {
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.max = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
    mn("max", e, t.rank);
    var n = dn(t.shape, e),
        r = n[0],
        o = w(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "max", a.dtype).reshape(r);
  }, o.prototype.maximum = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.all = function (t, e) {
    mn("all", e, t.rank);
    var n = dn(t.shape, e),
        r = n[0],
        o = w(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "all", a.dtype).reshape(r);
  }, o.prototype.any = function (t, e) {
    mn("any", e, t.rank);
    var n = dn(t.shape, e),
        r = n[0],
        o = w(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "any", a.dtype).reshape(r);
  }, o.prototype.squaredDifference = function (t, e) {
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("return (a - b) * (a - b);", t.shape, e.shape) : new ba("return (a - b) * (a - b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.realDivide = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      return this.packedBinaryOp(t, e, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", !0);
    }

    var n = new ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "float32");
  }, o.prototype.floorDiv = function (t, e) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
    var n = new ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "int32");
  }, o.prototype.add = function (t, e) {
    if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, ma);
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);
    var n = Ct(t.dtype, e.dtype);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, ma, n);
    var r = new ba(ma, t.shape, e.shape);
    return this.compileAndRun(r, [t, e], n);
  }, o.prototype.packedUnaryOp = function (t, e, n) {
    var r = new _u(t.shape, e);
    return this.compileAndRun(r, [t], n);
  }, o.prototype.packedBinaryOp = function (t, e, n, r, o) {
    void 0 === o && (o = !1);
    var a = new Ca(n, t.shape, e.shape, o);
    return this.compileAndRun(a, [t, e], r);
  }, o.prototype.complexSeparableBinaryOp = function (t, e, n) {
    var r = this,
        o = this.texData.get(t.dataId),
        a = this.texData.get(e.dataId),
        i = [[o.complexTensors.real, a.complexTensors.real], [o.complexTensors.imag, a.complexTensors.imag]].map(function (o) {
      var a = o[0],
          i = o[1],
          u = r.makeComplexComponentTensorInfo(t, a),
          s = r.makeComplexComponentTensorInfo(e, i),
          c = new ba(n, t.shape, e.shape);
      return r.compileAndRun(c, [u, s], Ct(a.dtype, i.dtype));
    }),
        u = i[0],
        s = i[1],
        c = this.complex(u, s);
    return u.dispose(), s.dispose(), c;
  }, o.prototype.makeComplexComponentTensorInfo = function (t, e) {
    return {
      dataId: e.dataId,
      dtype: e.dtype,
      shape: t.shape
    };
  }, o.prototype.addN = function (t) {
    if (1 === t.length) return t[0];

    if (t.length > a().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var e = Math.floor(t.length / 2),
          n = this.addN(t.slice(0, e)),
          r = this.addN(t.slice(e));
      return this.addN([n, r]);
    }

    var o = t.map(function (t) {
      return t.dtype;
    }).reduce(function (t, e) {
      return Ct(t, e);
    }),
        i = t.map(function (t) {
      return t.shape;
    }),
        u = a().getBool("WEBGL_PACK") ? new zo(t[0].shape, i) : new Vo(t[0].shape, i);
    return this.compileAndRun(u, t, o);
  }, o.prototype.subtract = function (t, e) {
    if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, ga);
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);
    var n = Ct(t.dtype, e.dtype);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, ga, t.dtype);
    var r = new ba(ga, t.shape, e.shape);
    return this.compileAndRun(r, [t, e], n);
  }, o.prototype.pow = function (t, e) {
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t.shape, e.shape),
        r = Ct(t.dtype, e.dtype);
    return this.compileAndRun(n, [t, e], r);
  }, o.prototype.ceil = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, gu, t.dtype);
    var e = new su(t.shape, gu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.floor = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, yu, t.dtype);
    var e = new su(t.shape, yu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.sign = function (t) {
    var e = new su(t.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.isNaN = function (t) {
    var e = new su(t.shape, "return float(isnan(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.isInf = function (t) {
    var e = new su(t.shape, "return float(isinf(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.isFinite = function (t) {
    var e = new su(t.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.round = function (t) {
    var e = new su(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.exp = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, xu, t.dtype);
    var e = new su(t.shape, xu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.expm1 = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, bu, t.dtype);
    var e = new su(t.shape, bu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.log = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t.dtype);
    var e = new su(t.shape, "if (x < 0.0) return NAN;\n  return log(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.log1p = function (t) {
    var e = new su(t.shape, "return log(1.0 + x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.sqrt = function (t) {
    var e = new su(t.shape, "return sqrt(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.rsqrt = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
    var e = new su(t.shape, "return inversesqrt(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.reciprocal = function (t) {
    var e = new su(t.shape, "return 1.0 / x;");
    return this.compileAndRun(e, [t]);
  }, o.prototype.relu = function (t) {
    var e;
    return e = a().getBool("WEBGL_PACK") ? new _u(t.shape, Nu) : new su(t.shape, fu), this.compileAndRun(e, [t]);
  }, o.prototype.relu6 = function (t) {
    var e;
    return e = a().getBool("WEBGL_PACK") ? new _u(t.shape, Fu) : new su(t.shape, pu), this.compileAndRun(e, [t]);
  }, o.prototype.prelu = function (t, e) {
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca(wa, t.shape, e.shape) : new ba(xa, t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.elu = function (t) {
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ou, t.dtype);
    var e = new su(t.shape, du);
    return this.compileAndRun(e, [t]);
  }, o.prototype.eluDer = function (t, e) {
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t.shape, e.shape) : new ba("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.selu = function (t) {
    var e = new su(t.shape, vu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.int = function (t) {
    var e = new su(t.shape, "return float(int(x));");
    return this.compileAndRun(e, [t], "int32");
  }, o.prototype.clip = function (t, e, n) {
    var r,
        o = (r = a().getBool("WEBGL_PACK_CLIP") ? new Ra(t.shape) : new Ea(t.shape)).getCustomSetupFunc(e, n);
    return this.compileAndRun(r, [t], null, o);
  }, o.prototype.abs = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, hu, t.dtype);
    var e = new su(t.shape, hu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.complexAbs = function (t) {
    var e = this.texData.get(t.dataId),
        n = new Ia(t.shape),
        r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];
    return this.compileAndRun(n, r);
  }, o.prototype.sigmoid = function (t) {
    var e = new su(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(e, [t]);
  }, o.prototype.softplus = function (t) {
    var e = new su(t.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.sin = function (t) {
    var e = new su(t.shape, wu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.cos = function (t) {
    var e = new su(t.shape, Cu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.tan = function (t) {
    var e = new su(t.shape, "return tan(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.asin = function (t) {
    var e = new su(t.shape, Eu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.acos = function (t) {
    var e = new su(t.shape, Ru);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atan = function (t) {
    var e = new su(t.shape, Iu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atan2 = function (t, e) {
    var n = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.sinh = function (t) {
    var e = new su(t.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.cosh = function (t) {
    var e = new su(t.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.tanh = function (t) {
    var e = new su(t.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.asinh = function (t) {
    var e = new su(t.shape, ku);
    return this.compileAndRun(e, [t]);
  }, o.prototype.acosh = function (t) {
    var e = new su(t.shape, Su);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atanh = function (t) {
    var e = new su(t.shape, Au);
    return this.compileAndRun(e, [t]);
  }, o.prototype.erf = function (t) {
    var e = new su(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
    return this.compileAndRun(e, [t]);
  }, o.prototype.step = function (t, e) {
    var n = new su(t.shape, function (t) {
      return void 0 === t && (t = 0), cu + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  ";
    }(e));
    return this.compileAndRun(n, [t]);
  }, o.prototype.conv2dByMatMul = function (t, e, n, r, o, i) {
    var u = t.shape,
        s = this.texData.get(t.dataId),
        c = n.inChannels,
        l = u[0] * u[1] * u[2],
        h = n.outChannels,
        f = "channelsLast" === n.dataFormat,
        p = (1 === l || 1 === h) && c > 1e3,
        d = u[2] % 2 != 0 && !!s.isPacked;

    if (p || !a().getBool("WEBGL_LAZILY_UNPACK") || !a().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d) {
      var v = f ? u[0] * u[1] * u[2] : u[0] * u[2] * u[3],
          m = this.reshape(t, [1, v, n.inChannels]),
          y = this.reshape(e, [1, n.inChannels, n.outChannels]);
      return this.reshape(this.fusedBatchMatMul({
        a: m,
        b: y,
        transposeA: !1,
        transposeB: !1,
        bias: r,
        activation: o,
        preluActivationWeights: i
      }), n.outShape);
    }

    var x = f ? u[0] * u[1] * (u[2] + 1) : u[0] * u[2] * (u[3] + 1),
        b = {
      dataId: t.dataId,
      shape: [1, x, n.inChannels],
      dtype: t.dtype
    },
        w = s.shape;
    s.shape = s.shape.slice(), s.shape[s.shape.length - 2]++, g(Se(s.shape, b.shape), function () {
      return "packed reshape " + s.shape + " to " + b.shape + " isn't free";
    });
    var C = this.reshape(e, [1, n.inChannels, n.outChannels]),
        E = this.fusedBatchMatMul({
      a: b,
      b: C,
      transposeA: !1,
      transposeB: !1,
      bias: r,
      activation: o,
      preluActivationWeights: i
    }),
        R = this.texData.get(E.dataId);
    return g(R.isPacked, function () {
      return "batchMatMul result is expected to be packed";
    }), s.shape = w, R.shape = n.outShape, Nt.makeTensorFromDataId(E.dataId, n.outShape, E.dtype);
  }, o.prototype.conv2dWithIm2Row = function (t, e, n, r, o, a) {
    var i = n.filterWidth,
        u = n.filterHeight,
        s = n.inChannels,
        c = n.outWidth,
        l = n.outHeight,
        h = "channelsLast" === n.dataFormat,
        f = i * u * s,
        p = l * c,
        d = [f, p],
        v = t.squeeze([0]),
        m = e.reshape([1, f, -1]),
        g = new Ri(d, v.shape, n),
        y = this.compileAndRun(g, [v]).reshape([1, d[0], d[1]]),
        x = null != r,
        b = null != a,
        w = o ? Pu(o, !0) : null,
        C = new Ti(y.shape, [1, p, n.outChannels], !0, !1, x, w, b),
        E = [y, m];
    r && E.push(r), b && E.push(a);
    var R = this.compileAndRun(C, E);
    return h ? R.reshape([1, l, c, n.outChannels]) : R.reshape([1, n.outChannels, l, c]);
  }, o.prototype.fusedConv2d = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        i = t.activation,
        u = t.preluActivationWeights;
    if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, o, i, u);
    if (a().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, i, u);
    var s = null != o,
        c = null != u,
        l = i ? Pu(i, !1) : null,
        h = new Ma(r, s, l, c),
        f = [e, n];
    return o && f.push(o), u && f.push(u), this.compileAndRun(h, f);
  }, o.prototype.conv2d = function (t, e, n) {
    if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);
    if (a().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);
    var r = new Ma(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv2dDerInput = function (t, e, n) {
    var r = new Ta(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv2dDerFilter = function (t, e, n) {
    var r = new Da(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.fusedDepthwiseConv2D = function (t) {
    var e,
        n = t.input,
        r = t.filter,
        o = t.convInfo,
        i = t.bias,
        u = t.activation,
        s = t.preluActivationWeights,
        c = a().getBool("WEBGL_PACK_DEPTHWISECONV") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1,
        l = u ? Pu(u, c) : null,
        h = [n, r],
        f = null != i,
        p = null != s;
    return f && h.push(i), p && h.push(s), c ? (e = new La(o, f, l, p), this.compileAndRun(e, h)) : (e = new Pa(o, f, l, p), this.compileAndRun(e, h));
  }, o.prototype.depthwiseConv2D = function (t, e, n) {
    var r;
    return a().getBool("WEBGL_PACK_DEPTHWISECONV") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new La(n), this.compileAndRun(r, [t, e])) : (r = new Pa(n), this.compileAndRun(r, [t, e]));
  }, o.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    var r = new _a(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    var r = new Oa(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3d = function (t, e, n) {
    var r = new Ba(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3dDerInput = function (t, e, n) {
    var r = new Fa(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3dDerFilter = function (t, e, n) {
    var r = new Na(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.maxPool = function (t, e) {
    var n = new Bi(e, "max", !1);
    return this.compileAndRun(n, [t]);
  }, o.prototype.avgPool = function (t, e) {
    var n = new Bi(e, "avg", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.maxPoolBackprop = function (t, e, n, r) {
    var o = new Bi(r, "max", !0),
        a = this.compileAndRun(o, [e]),
        i = new Ai(r),
        u = this.compileAndRun(i, [t, a], e.dtype);
    return a.dispose(), u;
  }, o.prototype.avgPoolBackprop = function (t, e, n) {
    var r = new ca(n);
    return this.compileAndRun(r, [t], e.dtype);
  }, o.prototype.cast = function (t, e) {
    return So(t, e, this);
  }, o.prototype.unstack = function (t, e) {
    for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++) a !== e && (r[o++] = t.shape[a]);

    var i = new Array(t.rank).fill(0),
        u = t.shape.slice();
    u[e] = 1;
    var s = new Array(n);

    for (a = 0; a < s.length; a++) i[e] = a, s[a] = this.slice(t, i, u).reshape(r);

    return s;
  }, o.prototype.avgPool3d = function (t, e) {
    var n = new Pi(e, "avg", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.avgPool3dBackprop = function (t, e, n) {
    var r = new la(n);
    return this.compileAndRun(r, [t], e.dtype);
  }, o.prototype.maxPool3d = function (t, e) {
    var n = new Pi(e, "max", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.maxPool3dBackprop = function (t, e, n, r) {
    var o = new Pi(r, "max", !0),
        a = this.compileAndRun(o, [e]),
        i = new Di(r),
        u = this.compileAndRun(i, [t, a], e.dtype);
    return a.dispose(), u;
  }, o.prototype.reshape = function (t, e) {
    var n = this.texData.get(t.dataId);

    if (n.isPacked && !Se(t.shape, e) && (null === n.texture || !Se(n.shape, e))) {
      var r = this.packedReshape(t, e);
      return Nt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);
    }

    return Ao(t, e);
  }, o.prototype.resizeBilinear = function (t, e, n, r) {
    var o = a().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new zi(t.shape, e, n, r) : new Vi(t.shape, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.resizeBilinearBackprop = function (t, e, n) {
    var r = new Ui(t, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    var o = new Hi(t.shape, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    var r = new Gi(t, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.multinomial = function (t, e, n, r) {
    var o = e ? t : io(t),
        a = o.shape[0],
        i = o.shape[1],
        u = new Ni(a, i, n),
        s = u.getCustomSetupFunc(r);
    return this.compileAndRun(u, [o], "int32", s);
  }, o.prototype.oneHot = function (t, e, n, r) {
    var o = new Fi(t.size, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.diag = function (t) {
    var e = new qa(t.size);
    return this.compileAndRun(e, [t]);
  }, o.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return un("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Mo(t.dataSync(), e.dataSync(), n, r, o);
  }, o.prototype.cropAndResize = function (t, e, n, r, o, a) {
    var i = new Wa(t.shape, e.shape, r, o, a);
    return this.compileAndRun(i, [t, e, n]);
  }, o.prototype.depthToSpace = function (t, e, n) {
    g(e > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: " + e;
    });
    var r = t.shape[0],
        o = "NHWC" === n ? t.shape[1] : t.shape[2],
        a = "NHWC" === n ? t.shape[2] : t.shape[3],
        i = "NHWC" === n ? t.shape[3] : t.shape[1],
        u = o * e,
        s = a * e,
        c = i / (e * e),
        l = new Ha("NHWC" === n ? [r, u, s, c] : [r, c, u, s], e, n);
    return this.compileAndRun(l, [t]);
  }, o.prototype.split = function (t, e, n) {
    return Po(t, e, n);
  }, o.prototype.scatterND = function (t, e, n) {
    var r = Hr(0, t, n),
        o = r.sliceRank,
        a = r.numUpdates,
        i = r.sliceSize,
        u = r.strides,
        s = r.outputSize,
        c = [s / i, i],
        l = t.reshape([a, o]),
        h = e.reshape([a, i]);
    if (0 === s) return Ao(kn([]), n);
    var f = An(0),
        p = new ji(a, o, l.rank, h.rank, u, c);
    return this.compileAndRun(p, [h, l, f]).reshape(n);
  }, o.prototype.sparseToDense = function (t, e, n, r) {
    var o = Hr(0, t, n),
        a = o.sliceRank,
        i = o.numUpdates,
        u = o.strides,
        s = o.outputSize,
        c = new ji(i, a, t.rank, e.rank, u, [s, 1], !1);
    return this.compileAndRun(c, [e, t, r]).reshape(n);
  }, o.prototype.fft = function (t) {
    return this.fftImpl(t, !1);
  }, o.prototype.ifft = function (t) {
    return this.fftImpl(t, !0);
  }, o.prototype.fftImpl = function (t, e) {
    var n = this.texData.get(t.dataId),
        r = new Ja(Ya, t.shape, e),
        o = new Ja(Qa, t.shape, e),
        a = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],
        i = this.compileAndRun(r, a),
        u = this.compileAndRun(o, a),
        s = this.complex(i, u).as2D(t.shape[0], t.shape[1]);
    return i.dispose(), u.dispose(), s;
  }, o.prototype.gatherND = function (t, e) {
    var n = e.shape,
        r = n[n.length - 1],
        o = Ur(t, e),
        a = o[0],
        i = o[1],
        u = o[2],
        s = o[3],
        c = e.reshape([i, r]),
        l = t.reshape([t.size / u, u]),
        h = new ri(r, s, [i, u]);
    return this.compileAndRun(h, [l, c]).reshape(a);
  }, o.prototype.fill = function (t, e, n) {
    if ("string" === (n = n || z(e))) {
      var r = F(n, w(t));
      return r.fill(e), Nt.makeTensor(r, t, n, this);
    }

    var o = new Za(t, e),
        a = o.getCustomSetupFunc(e);
    return this.compileAndRun(o, [], n, a);
  }, o.prototype.onesLike = function (t) {
    if ("string" === t.dtype) throw new Error("onesLike is not supported under string dtype");
    return this.fill(t.shape, 1, t.dtype);
  }, o.prototype.zerosLike = function (t) {
    return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype);
  }, o.prototype.linspace = function (t, e, n) {
    return Do(t, e, n);
  }, o.prototype.makeTensorInfo = function (t, e) {
    var n = this.write(null, t, e);
    return this.texData.get(n).usage = null, {
      dataId: n,
      shape: t,
      dtype: e
    };
  }, o.prototype.makeOutput = function (t, e) {
    var n = this.makeTensorInfo(t, e).dataId;
    return Nt.makeTensorFromDataId(n, t, e, this);
  }, o.prototype.unpackTensor = function (t) {
    var e = new Mu(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype);
  }, o.prototype.packTensor = function (t) {
    var e = new Oi(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype, null, !0);
  }, o.prototype.packedReshape = function (t, e) {
    var n = [Ce(t.shape)].concat(Ee(t.shape)),
        r = {
      dtype: t.dtype,
      shape: n,
      dataId: t.dataId
    },
        o = [Ce(e)].concat(Ee(e)),
        a = new Wi(o, n),
        i = this.runWebGLProgram(a, [r], t.dtype, null, !0);
    return {
      dataId: i.dataId,
      shape: e,
      dtype: i.dtype
    };
  }, o.prototype.decode = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.isPacked,
        o = n.shape,
        a = n.dtype,
        i = Re(o);
    e = r ? new Ga(i) : new za(i);
    return {
      dtype: a,
      shape: o,
      dataId: this.runWebGLProgram(e, [{
        shape: i,
        dtype: a,
        dataId: t
      }], a, null, !0).dataId
    };
  }, o.prototype.runWebGLProgram = function (t, e, n, r, o) {
    var i = this;
    void 0 === o && (o = !1);
    var u = this.makeTensorInfo(t.outputShape, n),
        s = this.texData.get(u.dataId);

    if (t.packedOutput && (s.isPacked = !0), t.outPackingScheme === _t.DENSE) {
      var c = Gt(t.outputShape);
      s.texShape = c.map(function (t) {
        return 2 * t;
      });
    }

    if (null != t.outTexUsage && (s.usage = t.outTexUsage), 0 === w(u.shape)) return s.values = N(u.dtype, 0), u;
    var l = [],
        h = e.map(function (e) {
      if ("complex64" === e.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n = i.texData.get(e.dataId);

      if (null == n.texture) {
        if (!t.packedInputs && w(e.shape) <= a().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
          shape: e.shape,
          texData: null,
          isUniform: !0,
          uniformValues: n.values
        };
        t.packedInputs && (n.isPacked = !0, n.shape = e.shape);
      } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? i.unpackTensor(e) : i.packTensor(e), l.push(e), n = i.texData.get(e.dataId);else if (n.isPacked && !Se(n.shape, e.shape)) {
        var r = e,
            o = e.shape;
        e.shape = n.shape, e = i.packedReshape(e, o), l.push(e), n = i.texData.get(e.dataId), r.shape = o;
      }

      return i.uploadToGPU(e.dataId), {
        shape: e.shape,
        texData: n,
        isUniform: !1
      };
    });
    this.uploadToGPU(u.dataId);

    var f,
        p = {
      shape: u.shape,
      texData: s,
      isUniform: !1
    },
        d = function (t, e, n) {
      var r = "";
      e.concat(n).forEach(function (t) {
        var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,
            n = t.isUniform ? "uniform" : t.texData.texShape;
        r += t.shape + "_" + n + "_" + e;
      });
      var o = t.userCode,
          a = t.constructor.name;
      return a += "_" + r + "_" + o;
    }(t, h, p),
        v = this.getAndSaveBinary(d, function () {
      return function (t, e, n, r) {
        var o = e.userCode,
            i = n.map(function (t, n) {
          var r = {
            logicalShape: t.shape,
            texShape: t.isUniform ? null : t.texData.texShape,
            isUniform: t.isUniform,
            isPacked: !t.isUniform && t.texData.isPacked,
            flatOffset: null
          };
          return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {
            name: e.variableNames[n],
            shapeInfo: r
          };
        }),
            u = i.map(function (t) {
          return t.shapeInfo;
        }),
            s = {
          logicalShape: r.shape,
          texShape: r.texData.texShape,
          isUniform: !1,
          isPacked: r.texData.isPacked,
          flatOffset: null
        },
            c = Yo(i, s, o, e.packedInputs),
            l = t.createProgram(c),
            h = null,
            f = t.getUniformLocation(l, "NAN", !1);
        1 === a().getNumber("WEBGL_VERSION") && (h = t.getUniformLocation(l, "INFINITY", !1));

        for (var p = {}, d = 0; d < e.variableNames.length; d++) {
          var v = e.variableNames[d];
          p[v] = t.getUniformLocation(l, v, !1), p["offset" + v] = t.getUniformLocation(l, "offset" + v, !1);
        }

        return {
          program: e,
          source: c,
          webGLProgram: l,
          uniformLocations: p,
          inShapeInfos: u,
          outShapeInfo: s,
          infLoc: h,
          nanLoc: f
        };
      }(i.gpgpu, t, h, p);
    }),
        m = null != this.activeTimers;

    if (m && (f = this.startTimer()), function (t, e, n, r, o) {
      Ei(e.inShapeInfos, n), Ei([e.outShapeInfo], [r]);
      var i = r.texData.texture,
          u = r.texData.texShape;
      r.texData.isPacked ? t.setOutputPackedMatrixTexture(i, u[0], u[1]) : t.setOutputMatrixTexture(i, u[0], u[1]), t.setProgram(e.webGLProgram), 1 === a().getNumber("WEBGL_VERSION") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function (n, r) {
        var o = e.program.variableNames[r],
            a = e.uniformLocations[o],
            i = e.uniformLocations["offset" + o];
        if (null != a) if (n.isUniform) {
          if (w(n.shape) < 2) t.gl.uniform1f(a, n.uniformValues[0]);else {
            var u = n.uniformValues;
            u instanceof Float32Array || (u = new Float32Array(u)), t.gl.uniform1fv(a, u);
          }
        } else null != n.texData.slice && null != i && t.gl.uniform1i(i, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, a, r);
      }), null != o && o(t, e.webGLProgram), t.executeProgram();
    }(this.gpgpu, v, h, p, r), l.forEach(function (t) {
      return i.disposeData(t.dataId);
    }), m && (f = this.endTimer(f), this.activeTimers.push({
      name: t.constructor.name,
      query: this.getQueryTime(f)
    })), !a().getBool("WEBGL_LAZILY_UNPACK") && s.isPacked && !1 === o) {
      var g = this.unpackTensor(u);
      return this.disposeData(u.dataId), g;
    }

    return u;
  }, o.prototype.compileAndRun = function (t, e, n, r, o) {
    void 0 === o && (o = !1), n = n || e[0].dtype;
    var a = this.runWebGLProgram(t, e, n, r, o);
    return Nt.makeTensorFromDataId(a.dataId, a.shape, a.dtype);
  }, o.prototype.getAndSaveBinary = function (t, e) {
    return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];
  }, o.prototype.getTextureManager = function () {
    return this.textureManager;
  }, o.prototype.dispose = function () {
    this.disposed || (this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, null != this.fromPixels2DContext && this.fromPixels2DContext.canvas.remove && this.fromPixels2DContext.canvas.remove(), this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
  }, o.prototype.floatPrecision = function () {
    var t = this;
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = je(function () {
      if (!a().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var e = a().getBool("DEBUG");
        a().set("DEBUG", !1);
        var n = t.abs(An(1e-8)).dataSync()[0];
        if (a().set("DEBUG", e), n > 0) return 32;
      }

      return 16;
    })), this.floatPrecisionValue;
  }, o.prototype.epsilon = function () {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, o.prototype.uploadToGPU = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.shape,
        o = n.dtype,
        a = n.values,
        i = n.texture,
        u = n.usage,
        s = n.isPacked;

    if (null == i) {
      var c,
          l = null != this.activeTimers;
      l && (c = Y());
      var h = n.texShape;

      if (null == h && (h = Ie(r, s), n.texShape = h), null != a) {
        var f = Re(r),
            p = void 0,
            d = h[1],
            v = h[0],
            m = a instanceof Uint8Array;
        s ? (d = (e = Ht(h[0], h[1]))[0], v = e[1], p = new $a(f, [v, d], m)) : p = new Xa(f, [v, d], m);
        var g = this.makeTensorInfo([v, d], o);
        this.texData.get(g.dataId).usage = m ? Mt.PIXELS : Mt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), d, v, a);
        var y = this.runWebGLProgram(p, [g], o, null, !0),
            x = this.texData.get(y.dataId);
        n.texture = x.texture, n.texShape = x.texShape, n.isPacked = x.isPacked, n.usage = x.usage, this.disposeData(g.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += Y() - c);
      } else {
        var b = this.acquireTexture(h, u, o, s);
        n.texture = b;
      }
    }
  }, o.prototype.convertAndCacheOnCPU = function (t, e) {
    var n = this.texData.get(t),
        r = n.dtype;
    return this.releaseGPUData(t), null != e && (n.values = function (t, e) {
      if ("float32" === e || "complex64" === e) return t;

      if ("int32" === e || "bool" === e) {
        for (var n = "int32" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);

        return n;
      }

      throw new Error("Unknown dtype " + e);
    }(e, r)), n.values;
  }, o.prototype.acquireTexture = function (t, e, n, r) {
    if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var o = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + o + " MB, most likely due to a memory leak");
    }

    return this.textureManager.acquireTexture(t, e, r);
  }, o.prototype.computeBytes = function (t, e) {
    return t[0] * t[1] * P(e);
  }, o;
}(co);

Ft() && Nt.registerBackend("webgl", function () {
  return new Wu();
}, 2);
var Uu = Cn({
  square_: function (t) {
    var e = ln(t, "x", "square"),
        n = [e];
    return Nt.runKernelFunc(function (t, n) {
      return n([e]), t.square(e);
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.toFloat().mul(2));
        }
      };
    }, "Square", {}, n, []);
  }
});
exports.square = Uu;
var Vu = Cn({
  abs_: function (t) {
    var e = ln(t, "x", "abs");
    return "complex64" === e.dtype ? Nt.runKernelFunc(function (t) {
      return t.complexAbs(e);
    }, {
      $x: e
    }) : Nt.runKernelFunc(function (t, n) {
      var r = t.abs(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.toFloat().step(-1));
        }
      };
    }, "Abs");
  }
}),
    zu = Cn({
  acos_: function (t) {
    var e = ln(t, "x", "acos");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.acos(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(An(1).sub(n.toFloat().square()).sqrt()).neg();
        }
      };
    });
  }
}),
    Gu = Cn({
  acosh_: function (t) {
    var e = ln(t, "x", "acosh");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.acosh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(n.toFloat().square().sub(1).sqrt());
        }
      };
    });
  }
}),
    Hu = Cn({
  asin_: function (t) {
    var e = ln(t, "x", "asin");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.asin(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(An(1).sub(n.toFloat().square()).sqrt());
        }
      };
    });
  }
}),
    qu = Cn({
  asinh_: function (t) {
    var e = ln(t, "x", "asinh");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.asinh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(An(1).add(n.toFloat().square()).sqrt());
        }
      };
    });
  }
}),
    Ku = Cn({
  atan_: function (t) {
    var e = ln(t, "x", "atan");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.atan(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat().square().add(1));
        }
      };
    });
  }
}),
    ju = Cn({
  atanh_: function (t) {
    var e = ln(t, "x", "atanh");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.atanh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(An(1).sub(n.toFloat().square()));
        }
      };
    });
  }
}),
    Xu = Cn({
  ceil_: function (t) {
    var e = ln(t, "x", "ceil");
    return Nt.runKernelFunc(function (t) {
      return t.ceil(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    $u = Cn({
  clipByValue_: function (t, e, n) {
    var r = ln(t, "x", "clipByValue");
    return g(e <= n, function () {
      return "Error in clip: min (" + e + ") must be less than or equal to max (" + n + ").";
    }), Nt.runKernelFunc(function (t, o) {
      var a = t.clip(r, e, n);
      return o([r]), a;
    }, {
      $x: r
    }, function (t, r) {
      var o = r[0];
      return {
        $x: function () {
          return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)), zn(t));
        }
      };
    });
  }
}),
    Yu = Cn({
  cos_: function (t) {
    var e = ln(t, "x", "cos");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.cos(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().sin().neg().mul(t);
        }
      };
    });
  }
}),
    Qu = Cn({
  cosh_: function (t) {
    var e = ln(t, "x", "cosh");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.cosh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().sinh().mulStrict(t);
        }
      };
    });
  }
}),
    Ju = Cn({
  erf_: function (t) {
    var e = ln(t, "x", "erf");
    return g("int32" === e.dtype || "float32" === e.dtype, function () {
      return "Input dtype must be `int32` or `float32`.";
    }), "int32" === e.dtype && (e = e.toFloat()), Nt.runKernelFunc(function (t, n) {
      var r = t.erf(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
        }
      };
    });
  }
}),
    Zu = Cn({
  exp_: function (t) {
    var e = ln(t, "x", "exp");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.exp(e);
      return n([r]), r;
    }, {
      $x: e
    }, function (t, e) {
      return {
        $x: function () {
          return t.mulStrict(e[0]);
        }
      };
    });
  }
}),
    ts = Cn({
  expm1_: function (t) {
    var e = ln(t, "x", "expm1");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.expm1(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.exp());
        }
      };
    });
  }
}),
    es = Cn({
  floor_: function (t) {
    var e = ln(t, "x", "floor");
    return Nt.runKernelFunc(function (t) {
      return t.floor(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    ns = Cn({
  log_: function (t) {
    var e = ln(t, "x", "log");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.log(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat());
        }
      };
    });
  }
}),
    rs = Cn({
  log1p_: function (t) {
    var e = ln(t, "x", "log1p");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.log1p(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.add(1));
        }
      };
    });
  }
}),
    os = Cn({
  logSigmoid_: function (t) {
    var e = ln(t, "x", "logSigmoid");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.softplus(e.neg()).neg();
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.neg().sigmoid());
        }
      };
    });
  }
}),
    as = Cn({
  neg_: function (t) {
    var e = ln(t, "x", "neg");
    return Nt.runKernelFunc(function (t) {
      return t.neg(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return t.neg();
        }
      };
    });
  }
}),
    is = Cn({
  reciprocal_: function (t) {
    var e = ln(t, "x", "reciprocal");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.reciprocal(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.square().neg());
        }
      };
    });
  }
}),
    us = Cn({
  round_: function (t) {
    var e = ln(t, "x", "round");
    return Nt.runKernelFunc(function (t) {
      return t.round(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    ss = Cn({
  rsqrt_: function (t) {
    var e = ln(t, "x", "rsqrt");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.rsqrt(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.pow(1.5).mul(2)).neg();
        }
      };
    });
  }
}),
    cs = Cn({
  sigmoid_: function (t) {
    var e = ln(t, "x", "sigmoid");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.sigmoid(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.mul(An(1).sub(n)));
        }
      };
    }, "Sigmoid");
  }
}),
    ls = Cn({
  sign_: function (t) {
    var e = ln(t, "x", "sign");
    return Nt.runKernelFunc(function (t) {
      return t.sign(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    hs = Cn({
  isNaN_: function (t) {
    var e = ln(t, "x", "isNaN");
    return Nt.runKernelFunc(function (t) {
      return t.isNaN(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    fs = Cn({
  isInf_: function (t) {
    var e = ln(t, "x", "isInf");
    return Nt.runKernelFunc(function (t) {
      return t.isInf(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    ps = Cn({
  isFinite_: function (t) {
    var e = ln(t, "x", "isFinite");
    return Nt.runKernelFunc(function (t) {
      return t.isFinite(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    ds = Cn({
  sin_: function (t) {
    var e = ln(t, "x", "sin");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.sin(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().cos().mul(t);
        }
      };
    });
  }
}),
    vs = Cn({
  sinh_: function (t) {
    var e = ln(t, "x", "sinh");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.sinh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().cosh().mulStrict(t);
        }
      };
    });
  }
}),
    ms = Cn({
  softplus_: function (t) {
    var e = ln(t, "x", "softplus");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.softplus(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.sigmoid());
        }
      };
    });
  }
}),
    gs = Cn({
  sqrt_: function (t) {
    var e = ln(t, "x", "sqrt");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.sqrt(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat().sqrt().mul(2));
        }
      };
    });
  }
}),
    ys = Cn({
  step_: function (t, e) {
    void 0 === e && (e = 0);
    var n = ln(t, "x", "step");
    return Nt.runKernelFunc(function (t) {
      return t.step(n, e);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return zn(t);
        }
      };
    });
  }
}),
    xs = Cn({
  tan_: function (t) {
    var e = ln(t, "x", "tan");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.tan(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.cos().square());
        }
      };
    });
  }
}),
    bs = Cn({
  tanh_: function (t) {
    var e = ln(t, "x", "tanh");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.tanh(e);
      return n([r]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return An(1).sub(n.square()).mulStrict(t);
        }
      };
    });
  }
});
exports.tanh = bs;
exports.tan = xs;
exports.step = ys;
exports.sqrt = gs;
exports.softplus = ms;
exports.sinh = vs;
exports.sin = ds;
exports.isFinite = ps;
exports.isInf = fs;
exports.isNaN = hs;
exports.sign = ls;
exports.sigmoid = cs;
exports.rsqrt = ss;
exports.round = us;
exports.reciprocal = is;
exports.neg = as;
exports.logSigmoid = os;
exports.log1p = rs;
exports.log = ns;
exports.floor = es;
exports.expm1 = ts;
exports.exp = Zu;
exports.erf = Ju;
exports.cosh = Qu;
exports.cos = Yu;
exports.clipByValue = $u;
exports.ceil = Xu;
exports.atanh = ju;
exports.atan = Ku;
exports.asinh = qu;
exports.asin = Hu;
exports.acosh = Gu;
exports.acos = zu;
exports.abs = Vu;

function ws(t, e, n, r, o, a) {
  var i,
      u,
      s = ln(t, "x", "batchNorm"),
      c = ln(e, "mean", "batchNorm"),
      l = ln(n, "variance", "batchNorm");
  return null != o && (i = ln(o, "scale", "batchNorm")), null != r && (u = ln(r, "offset", "batchNorm")), g(2 === s.rank, function () {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + s.rank + ".";
  }), g(2 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c.rank + ".";
  }), g(2 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l.rank + ".";
  }), null != i && g(2 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i.rank + ".";
  }), null != u && g(2 === u.rank || 1 === u.rank, function () {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + u.rank + ".";
  }), Rs(s, c, l, u, i, a);
}

function Cs(t, e, n, r, o, a) {
  var i,
      u,
      s = ln(t, "x", "batchNorm"),
      c = ln(e, "mean", "batchNorm"),
      l = ln(n, "variance", "batchNorm");
  return null != o && (i = ln(o, "scale", "batchNorm")), null != r && (u = ln(r, "offset", "batchNorm")), g(3 === s.rank, function () {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + s.rank + ".";
  }), g(3 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c.rank + ".";
  }), g(3 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l.rank + ".";
  }), null != i && g(3 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i.rank + ".";
  }), null != u && g(3 === u.rank || 1 === u.rank, function () {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + u.rank + ".";
  }), Rs(s, c, l, u, i, a);
}

function Es(t, e, n, r, o, a) {
  var i,
      u,
      s = ln(t, "x", "batchNorm"),
      c = ln(e, "mean", "batchNorm"),
      l = ln(n, "variance", "batchNorm");
  return null != o && (i = ln(o, "scale", "batchNorm")), null != r && (u = ln(r, "offset", "batchNorm")), g(4 === s.rank, function () {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + s.rank + ".";
  }), g(4 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c.rank + ".";
  }), g(4 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l.rank + ".";
  }), null != i && g(4 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i.rank + ".";
  }), null != u && g(4 === u.rank || 1 === u.rank, function () {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + u.rank + ".";
  }), Rs(s, c, l, u, i, a);
}

function Rs(t, e, n, r, o, a) {
  null == a && (a = .001);
  var i,
      u,
      s,
      c = ln(t, "x", "batchNorm"),
      l = ln(e, "mean", "batchNorm"),
      h = ln(n, "variance", "batchNorm");
  null != o && (i = ln(o, "scale", "batchNorm")), null != r && (u = ln(r, "offset", "batchNorm")), g(l.rank === h.rank, function () {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), g(null == u || l.rank === u.rank, function () {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), g(null == i || l.rank === i.rank, function () {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), s = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;
  var f = [c, l, h, i];
  return Nt.runKernelFunc(function (t, e) {
    var n = t.batchNormalization(s, Is(l), Is(h), a, Is(i), Is(u));
    return e([c, l, h, i]), n;
  }, {
    x: c,
    mean: l,
    variance: h,
    scale: i,
    offset: u
  }, function (t, e) {
    var n = e,
        r = n[0],
        o = n[1],
        i = n[2],
        u = n[3],
        c = null == u ? An(1) : u,
        l = fo(o.shape, s.shape),
        h = [];

    if (1 === o.rank) {
      for (var f = 0; f < s.shape.length - 1; ++f) h.push(s.shape[f]);

      h.push(1);
    }

    var p = r.sub(o),
        d = t.mul(c),
        v = ss(i.add(An(a))),
        m = v.mul(v).mul(v).mul(An(-.5));
    return {
      x: function () {
        return 1 === o.rank ? t.mul(Nr(v.as4D(1, 1, 1, o.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(v).mul(c).reshape(r.shape);
      },
      mean: function () {
        var t = v.mul(An(-1)).mul(d);
        return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);
      },
      variance: function () {
        var t = m.mul(p).mul(d);
        return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);
      },
      scale: function () {
        var e = p.mul(v),
            n = t.mul(e);
        return 1 === o.rank && (n = n.sum(l)), n.reshape(o.shape);
      },
      offset: function () {
        var e = t;
        return 1 === o.rank && (e = e.sum(l)), e.reshape(o.shape);
      }
    };
  }, "BatchNormalization", {
    varianceEpsilon: a
  }, f).reshape(c.shape);
}

function Is(t) {
  return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;
}

function ks() {
  ze("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}

var Ss = Cn({
  batchNormalization2d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), ks(), ws(t, e, n, a, o, r);
  }
}),
    As = Cn({
  batchNormalization3d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), ks(), Cs(t, e, n, a, o, r);
  }
}),
    Ds = Cn({
  batchNormalization4d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), ks(), Es(t, e, n, a, o, r);
  }
}),
    Ts = Cn({
  batchNormalization_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), ks(), Rs(t, e, n, a, o, r);
  }
}),
    Ns = Cn({
  batchNorm_: Rs
}),
    Fs = Cn({
  batchNorm2d_: ws
}),
    Os = Cn({
  batchNorm3d_: Cs
}),
    _s = Cn({
  batchNorm4d_: Es
});

exports.batchNorm4d = _s;
exports.batchNorm3d = Os;
exports.batchNorm2d = Fs;
exports.batchNorm = Ns;
exports.batchNormalization = Ts;
exports.batchNormalization4d = Ds;
exports.batchNormalization3d = As;
exports.batchNormalization2d = Ss;

var Ms = Cn({
  logicalAnd_: function (t, e) {
    var n = ln(t, "a", "logicalAnd", "bool"),
        r = ln(e, "b", "logicalAnd", "bool");
    return po(n.shape, r.shape), Nt.runKernelFunc(function (t) {
      return t.logicalAnd(n, r);
    }, {
      $a: n,
      $b: r
    });
  }
}),
    Bs = Cn({
  logicalNot_: function (t) {
    var e = ln(t, "x", "logicalNot", "bool");
    return Nt.runKernelFunc(function (t) {
      return t.logicalNot(e);
    }, {
      $x: e
    });
  }
}),
    Ps = Cn({
  logicalOr_: function (t, e) {
    var n = ln(t, "a", "logicalOr", "bool"),
        r = ln(e, "b", "logicalOr", "bool");
    return po(n.shape, r.shape), Nt.runKernelFunc(function (t) {
      return t.logicalOr(n, r);
    }, {
      $a: n,
      $b: r
    });
  }
}),
    Ls = Cn({
  logicalXor_: function (t, e) {
    var n = ln(t, "a", "logicalXor", "bool"),
        r = ln(e, "b", "logicalXor", "bool");
    return po(n.shape, r.shape), Ps(t, e).logicalAnd(Ms(t, e).logicalNot());
  }
}),
    Ws = Cn({
  where_: function (t, e, n) {
    var r = ln(e, "a", "where"),
        o = ln(n, "b", "where"),
        a = ln(t, "condition", "where", "bool");
    return y(r.shape, o.shape, "Error in where: "), 1 === a.rank ? g(a.shape[0] === r.shape[0], function () {
      return "The first dimension of `a` must match the size of `condition`.";
    }) : y(a.shape, o.shape, "Error in where: "), Nt.runKernelFunc(function (t, e) {
      var n = t.select(a, r, o);
      return e([a]), n;
    }, {
      $condition: a,
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0];
      return {
        $condition: function () {
          return zn(n).toFloat();
        },
        $a: function () {
          return t.mul(n.cast(t.dtype));
        },
        $b: function () {
          return t.mul(n.logicalNot().cast(t.dtype));
        }
      };
    });
  }
}),
    Us = function (t) {
  return n(this, void 0, void 0, function () {
    var e, n, o;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return [4, (e = ln(t, "condition", "whereAsync", "bool")).data()];

        case 1:
          return n = r.sent(), o = Uo(e.shape, n), t !== e && e.dispose(), [2, o];
      }
    });
  });
};

exports.whereAsync = Us;
exports.where = Ws;
exports.logicalXor = Ls;
exports.logicalOr = Ps;
exports.logicalNot = Bs;
exports.logicalAnd = Ms;
var Vs = Cn({
  add_: function (t, e) {
    var n,
        r = ln(t, "a", "add"),
        o = ln(e, "b", "add");
    n = Rt(r, o), r = n[0], o = n[1];
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t) {
      return t.add(r, o);
    }, {
      a: r,
      b: o
    }, function (t) {
      return {
        a: function () {
          var e = t,
              n = fo(r.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
        },
        b: function () {
          var e = t,
              n = fo(o.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(o.shape);
        }
      };
    }, "Add");
  }
}),
    zs = Cn({
  addN_: function (t) {
    g(Array.isArray(t), function () {
      return "The argument passed to tf.addN() must be a list of tensors";
    }), g(t.length >= 1, function () {
      return "Must pass at least one tensor to tf.addN(), but got " + t.length;
    });
    var e = t.map(function (t, e) {
      return ln(t, "tensors" + e, "addN");
    }),
        n = e[0];
    e.forEach(function (t) {
      if (t.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }), e.forEach(function (t) {
      if (!C(t.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
    });
    var r = e;
    return Nt.runKernelFunc(function (t) {
      return t.addN(e);
    }, r, function (t) {
      var n = {};
      return e.forEach(function (e, r) {
        n[r] = function () {
          return t.clone();
        };
      }), n;
    });
  }
}),
    Gs = Cn({
  addStrict_: function (t, e) {
    var n = ln(t, "a", "addStrict"),
        r = ln(e, "b", "addStrict");
    return y(n.shape, r.shape, "Error in addStrict: "), n.add(r);
  }
}),
    Hs = Cn({
  atan2_: function (t, e) {
    var n,
        r = ln(t, "a", "atan2"),
        o = ln(e, "b", "atan2");
    n = Rt(r, o), r = n[0], o = n[1];
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t, e) {
      var n = t.atan2(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = Vs(n.square(), r.square()),
              o = t.mul(r.div(e)),
              i = fo(n.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);
        },
        $b: function () {
          var e = Vs(n.square(), r.square()),
              o = as(t.mul(n.div(e))),
              i = fo(r.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(r.shape);
        }
      };
    });
  }
}),
    qs = Cn({
  div_: function (t, e) {
    var n,
        r = ln(t, "a", "div"),
        o = ln(e, "b", "div");
    if (n = Rt(r, o), r = n[0], o = n[1], "int32" === r.dtype && "int32" === o.dtype) return Xs(r, o);
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t, e) {
      var n = t.realDivide(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.div(r.toFloat()),
              o = fo(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = fo(r.shape, a);
          o.length > 0 && (e = e.sum(o).reshape(r.shape));
          var i = r.square();
          return e.div(i.toFloat()).neg();
        }
      };
    }, "Div");
  }
}),
    Ks = Cn({
  divNoNan_: function (t, e) {
    var n,
        r = ln(t, "a", "div"),
        o = ln(e, "b", "div");
    r = (n = Rt(r, o))[0], o = n[1];
    var a = qs(r, o),
        i = zn(a),
        u = o.equal(i);
    return Ws(u, i, a);
  }
}),
    js = Cn({
  divStrict_: function (t, e) {
    var n = ln(t, "a", "div"),
        r = ln(e, "b", "div");
    return y(n.shape, r.shape, "Error in divideStrict: "), n.div(r);
  }
}),
    Xs = Cn({
  floorDiv_: function (t, e) {
    var n,
        r = ln(t, "a", "floorDiv"),
        o = ln(e, "b", "floorDiv");
    n = Rt(r, o), r = n[0], o = n[1];
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t, e) {
      var n = t.floorDiv(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = t.div(r.toFloat()),
              o = fo(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        $b: function () {
          var e = t.mul(n.toFloat()),
              o = fo(r.shape, a);
          o.length > 0 && (e = e.sum(o).reshape(r.shape));
          var i = r.square();
          return e.div(i.toFloat()).neg();
        }
      };
    });
  }
}),
    $s = Cn({
  maximum_: function (t, e) {
    var n,
        r = ln(t, "a", "maximum"),
        o = ln(e, "b", "maximum");
    return n = Rt(r, o), r = n[0], o = n[1], "bool" === r.dtype && (r = r.toInt(), o = o.toInt()), po(r.shape, o.shape), Nt.runKernelFunc(function (t, e) {
      var n = t.maximum(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          return t.mul(n.greaterEqual(r).toFloat());
        },
        $b: function () {
          return t.mul(n.less(r).toFloat());
        }
      };
    });
  }
}),
    Ys = Cn({
  maximumStrict_: function (t, e) {
    var n = ln(t, "a", "maximumStrict"),
        r = ln(e, "b", "maximumStrict");
    return y(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r);
  }
}),
    Qs = Cn({
  minimum_: function (t, e) {
    var n,
        r = ln(t, "a", "minimum"),
        o = ln(e, "b", "minimum");
    return n = Rt(r, o), r = n[0], o = n[1], "bool" === r.dtype && (r = r.toInt(), o = o.toInt()), po(r.shape, o.shape), Nt.runKernelFunc(function (t, e) {
      var n = t.minimum(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          return t.mul(n.lessEqual(r).toFloat());
        },
        $b: function () {
          return t.mul(n.greater(r).toFloat());
        }
      };
    });
  }
}),
    Js = Cn({
  minimumStrict_: function (t, e) {
    var n = ln(t, "a", "minimumStrict"),
        r = ln(e, "b", "minimumStrict");
    return y(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r);
  }
}),
    Zs = Cn({
  mod_: function (t, e) {
    var n,
        r = ln(t, "a", "mod"),
        o = ln(e, "b", "mod");
    n = Rt(r, o), r = n[0], o = n[1];
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t, e) {
      var n = t.mod(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = fo(n.shape, a);
          return e.length > 0 ? t.sum(e).reshape(n.shape) : t;
        },
        $b: function () {
          var e = t.mul(n.div(r).floor().neg()),
              o = fo(r.shape, a);
          return o.length > 0 ? e.sum(o).reshape(r.shape) : e;
        }
      };
    });
  }
}),
    tc = Cn({
  modStrict_: function (t, e) {
    var n = ln(t, "a", "modStrict"),
        r = ln(e, "b", "modStrict");
    return y(n.shape, r.shape, "Error in modStrict: "), n.mod(r);
  }
}),
    ec = Cn({
  mul_: function (t, e) {
    var n,
        r = ln(t, "a", "mul"),
        o = ln(e, "b", "mul");
    n = Rt(r, o), r = n[0], o = n[1];
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t, e) {
      var n = t.multiply(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.mul(r.toFloat()),
              o = fo(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = fo(r.shape, a);
          return o.length > 0 ? e.sum(o).reshape(r.shape) : e;
        }
      };
    }, "Mul");
  }
}),
    nc = Cn({
  mulStrict_: function (t, e) {
    var n = ln(t, "a", "mul"),
        r = ln(e, "b", "mul");
    return y(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r);
  }
}),
    rc = Cn({
  pow_: function (t, e) {
    var n = ln(t, "base", "pow"),
        r = ln(e, "exp", "pow"),
        o = po(n.shape, r.shape);
    return t = n.cast(Ct(n.dtype, r.dtype)), e = r.cast(Ct(n.dtype, r.dtype)), Nt.runKernelFunc(function (t, e) {
      var o = t.pow(n, r);
      return e([n, r, o]), o;
    }, {
      $base: n,
      $exp: r
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          a = e[2];
      return {
        $base: function () {
          var e = r.toFloat(),
              a = t.mul(e.mul(n.pow(e.sub(An(1))))),
              i = fo(n.shape, o);
          return i.length > 0 && (a = a.sum(i)), a.reshape(n.shape);
        },
        $exp: function () {
          var e = n.greater(0),
              i = n.log().where(e, zn(n)),
              u = t.mul(a.mul(i)),
              s = fo(r.shape, o);
          return s.length > 0 && (u = u.sum(s)), u.reshape(r.shape);
        }
      };
    });
  }
}),
    oc = Cn({
  powStrict_: function (t, e) {
    return y(t.shape, e.shape, "Error in powStrict: "), t.pow(e);
  }
}),
    ac = Cn({
  squaredDifference_: function (t, e) {
    var n,
        r = ln(t, "a", "squaredDifference"),
        o = ln(e, "b", "squaredDifference");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t, e) {
      var n = t.squaredDifference(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          o = An(2);
      return {
        $a: function () {
          return t.mul(n.sub(r).mul(o));
        },
        $b: function () {
          return t.mul(r.sub(n).mul(o));
        }
      };
    });
  }
}),
    ic = Cn({
  squaredDifferenceStrict_: function (t, e) {
    var n = ln(t, "a", "squaredDifferenceStrict"),
        r = ln(e, "b", "squaredDifferenceStrict");
    return y(n.shape, r.shape, "Error in squaredDifferenceStrict: "), n.squaredDifference(r);
  }
}),
    uc = Cn({
  sub_: function (t, e) {
    var n,
        r = ln(t, "a", "sub"),
        o = ln(e, "b", "sub");
    n = Rt(r, o), r = n[0], o = n[1];
    var a = po(r.shape, o.shape);
    return Nt.runKernelFunc(function (t) {
      return t.subtract(r, o);
    }, {
      a: r,
      b: o
    }, function (t) {
      return {
        a: function () {
          var e = t,
              n = fo(r.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
        },
        b: function () {
          var e = t,
              n = fo(o.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.neg().reshape(o.shape);
        }
      };
    }, "Sub");
  }
}),
    sc = Cn({
  subStrict_: function (t, e) {
    var n = ln(t, "a", "subStrict"),
        r = ln(e, "b", "subStrict");
    return y(n.shape, r.shape, "Error in subStrict: "), n.sub(r);
  }
});
exports.subStrict = sc;
exports.sub = uc;
exports.squaredDifferenceStrict = ic;
exports.squaredDifference = ac;
exports.powStrict = oc;
exports.pow = rc;
exports.mulStrict = nc;
exports.mul = ec;
exports.modStrict = tc;
exports.mod = Zs;
exports.minimumStrict = Js;
exports.minimum = Qs;
exports.maximumStrict = Ys;
exports.maximum = $s;
exports.floorDiv = Xs;
exports.divStrict = js;
exports.divNoNan = Ks;
exports.div = qs;
exports.atan2 = Hs;
exports.addStrict = Gs;
exports.addN = zs;
exports.add = Vs;
var cc = Cn({
  equal_: function (t, e) {
    var n,
        r = ln(t, "a", "equal"),
        o = ln(e, "b", "equal");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t) {
      return t.equal(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    lc = Cn({
  equalStrict_: function (t, e) {
    var n = ln(t, "a", "equalStrict"),
        r = ln(e, "b", "equalStrict");
    return y(n.shape, r.shape, "Error in equalStrict: "), n.equal(r);
  }
}),
    hc = Cn({
  greater_: function (t, e) {
    var n,
        r = ln(t, "a", "greater"),
        o = ln(e, "b", "greater");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t) {
      return t.greater(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    fc = Cn({
  greaterEqual_: function (t, e) {
    var n,
        r = ln(t, "a", "greaterEqual"),
        o = ln(e, "b", "greaterEqual");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t, e) {
      var n = t.greaterEqual(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          return zn(n);
        },
        $b: function () {
          return zn(r);
        }
      };
    });
  }
}),
    pc = Cn({
  greaterEqualStrict_: function (t, e) {
    var n = ln(t, "a", "greaterEqualStrict"),
        r = ln(e, "b", "greaterEqualStrict");
    return y(n.shape, r.shape, "Error in greaterEqualStrict: "), n.greaterEqual(r);
  }
}),
    dc = Cn({
  greaterStrict_: function (t, e) {
    var n = ln(t, "a", "greaterStrict"),
        r = ln(e, "b", "greaterStrict");
    return y(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r);
  }
}),
    vc = Cn({
  less_: function (t, e) {
    var n,
        r = ln(t, "a", "less"),
        o = ln(e, "b", "less");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t) {
      return t.less(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    mc = Cn({
  lessEqual_: function (t, e) {
    var n,
        r = ln(t, "a", "lessEqual"),
        o = ln(e, "b", "lessEqual");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t) {
      return t.lessEqual(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    gc = Cn({
  lessEqualStrict_: function (t, e) {
    var n = ln(t, "a", "lessEqualStrict"),
        r = ln(e, "b", "lessEqualStrict");
    return y(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r);
  }
}),
    yc = Cn({
  lessStrict_: function (t, e) {
    var n = ln(t, "a", "lessStrict"),
        r = ln(e, "b", "lessStrict");
    return y(n.shape, r.shape, "Error in lessStrict: "), n.less(r);
  }
}),
    xc = Cn({
  notEqual_: function (t, e) {
    var n,
        r = ln(t, "a", "notEqual"),
        o = ln(e, "b", "notEqual");
    return n = Rt(r, o), r = n[0], o = n[1], po(r.shape, o.shape), Nt.runKernelFunc(function (t) {
      return t.notEqual(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    bc = Cn({
  notEqualStrict_: function (t, e) {
    var n = ln(t, "a", "notEqualStrict"),
        r = ln(e, "b", "notEqualStrict");
    return y(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r);
  }
});
exports.notEqualStrict = bc;
exports.notEqual = xc;
exports.lessStrict = yc;
exports.lessEqualStrict = gc;
exports.lessEqual = mc;
exports.less = vc;
exports.greaterStrict = dc;
exports.greaterEqualStrict = pc;
exports.greaterEqual = fc;
exports.greater = hc;
exports.equalStrict = lc;
exports.equal = cc;

function wc(t, e) {
  for (var n = [], r = t; r < e; ++r) n.push(r);

  return n;
}

function Cc(t) {
  for (var e = [], n = 0; n < t.length; ++n) for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);

  return e;
}

var Ec = Cn({
  gather_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r = ln(t, "x", "gather"),
        o = ln(e, "indices", "gather", "int32");
    n = D(n, r.shape)[0];

    var a = function (t, e, n) {
      for (var r = t.shape[n], o = [], a = 1, i = 1, u = 0; u < n; u++) o.push(t.shape[u]), a *= t.shape[u];

      for (u = 0; u < e.rank; u++) o.push(e.shape[u]);

      for (u = n + 1; u < t.rank; u++) o.push(t.shape[u]), i *= t.shape[u];

      return {
        batchSize: a,
        sliceSize: i,
        dimSize: r,
        outputShape: o
      };
    }(r, o, n);

    return Nt.runKernelFunc(function (t, e) {
      var a = t.gather(r, o.flatten(), n);
      return e([o]), a;
    }, {
      $x: r
    }, function (t, e) {
      var o = e[0];
      return {
        $x: function () {
          var e = r.shape,
              a = o.size,
              i = e.slice(0, n),
              u = i.length,
              s = e.slice(n, e.length).slice(1),
              c = s.length,
              l = wc(0, u),
              h = wc(u + 1, u + 1 + c),
              f = Cc([i, [a], s]),
              p = t.reshape(f),
              d = o.reshape([a]),
              v = Cc([[u], l, h]),
              m = p.transpose(v),
              g = Rc(m, d, r.shape[n]),
              y = yn(v);
          return g = g.transpose(y);
        }
      };
    }).reshape(a.outputShape);
  }
}),
    Rc = Cn({
  unsortedSegmentSum_: function (t, e, n) {
    var r = ln(t, "x", "unsortedSegmentSum"),
        o = ln(e, "segmentIds", "unsortedSegmentSum", "int32");
    return g(E(n), function () {
      return "numSegments must be of dtype int";
    }), Nt.runKernelFunc(function (t, e) {
      var a = t.unsortedSegmentSum(r, o, n);
      return e([o]), a;
    }, {
      $x: r
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return function (t, e) {
            for (var n = $s(e, zn(e)), r = Ec(t, n), o = fc(e, An(0, "int32")), a = r.rank - o.rank, i = 0; i < a; ++i) o = dr(o, i + 1);

            o = Ms(o, Bn(r.shape, "bool"));
            var u = zn(r);
            return Ws(o, r, u);
          }(t, n);
        }
      };
    });
  }
});
exports.unsortedSegmentSum = Rc;
exports.gather = Ec;

var Ic = function (t, e, o) {
  return n(this, void 0, void 0, function () {
    var n, a, i, u, s, c, l, h, f, p, d, v, m;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          for (n = ln(t, "tensor", "boolMask"), a = ln(e, "mask", "boolMask", "bool"), i = null == o ? 0 : o, u = a.rank, s = n.shape, g(u > 0, function () {
            return "mask cannot be scalar";
          }), y(s.slice(i, i + u), a.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c = 1, l = i; l < i + u; l++) c *= s[l];

          return h = s.slice(0, i).concat([c], s.slice(i + u)), f = n.reshape(h), p = a.reshape([-1]), [4, Us(p)];

        case 1:
          return d = r.sent(), v = d.squeeze([1]), m = Ec(f, v, i), t !== n && n.dispose(), e !== a && a.dispose(), v.dispose(), f.dispose(), p.dispose(), d.dispose(), [2, m];
      }
    });
  });
};

exports.booleanMaskAsync = Ic;

function kc(t, e, n, r, o, a, i) {
  void 0 === a && (a = "NHWC"), g(t.length === e.rank, function () {
    return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var u = t,
      s = e,
      c = !1;
  3 === e.rank && (c = !0, s = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), u = [1, t[0], t[1], t[2]]), g(4 === u.length, function () {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + u.length + ".";
  }), g(4 === s.rank, function () {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + s.rank;
  }), g(4 === n.rank, function () {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank;
  });
  var l = "NHWC" === a ? u[3] : u[1],
      h = "NHWC" === a ? s.shape[3] : s.shape[1];
  g(l === n.shape[2], function () {
    return "Error in conv2dDerInput: depth of input (" + l + ") must match input depth for filter " + n.shape[2] + ".";
  }), g(h === n.shape[3], function () {
    return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + n.shape[3] + ".";
  }), null != i && g(E(o), function () {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
  });
  var f = ko(a),
      p = go(u, n.shape, r, 1, o, i, !1, f),
      d = Nt.runKernelFunc(function (t, e) {
    var r = t.conv2dDerInput(s, n, p);
    return e([n, s]), r;
  }, {
    dy4D: s,
    filter: n
  }, function (t, e) {
    var n = e[0],
        u = e[1];
    return {
      dy4D: function () {
        return Tc(t, n, r, o, a, 1, i);
      },
      filter: function () {
        return Fc(t, u, n.shape, r, o, a, i);
      }
    };
  });
  return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;
}

function Sc(t) {
  var e = function (t) {
    return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;
  }(t),
      n = e[0],
      r = e[1],
      o = e[2];

  return 1 === n && 1 === r && 1 === o;
}

function Ac(t, e, n, r, o) {
  g(t.length === e.rank, function () {
    return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var a = t,
      i = e,
      u = !1;
  4 === e.rank && (u = !0, i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), a = [1, t[0], t[1], t[2], t[3]]);
  var s = a[4],
      c = i.shape[4];
  g(5 === a.length, function () {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + a.length + ".";
  }), g(5 === i.rank, function () {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i.rank;
  }), g(5 === n.rank, function () {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank;
  }), g(s === n.shape[3], function () {
    return "Error in conv3dDerInput: depth of input (" + s + ") must match input depth for filter " + n.shape[3] + ".";
  }), g(c === n.shape[4], function () {
    return "Error in conv3dDerInput: depth of output (" + c + ") must match output depth for filter " + n.shape[4] + ".";
  });
  var l = yo(a, n.shape, r, 1, o),
      h = Nt.runKernelFunc(function (t) {
    return t.conv3dDerInput(i, n, l);
  }, {
    dy5D: i
  });
  return u ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
}

var Dc = Cn({
  conv1d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NWC"), void 0 === a && (a = 1);
    var u = ln(t, "x", "conv1d"),
        s = ln(e, "filter", "conv1d"),
        c = u,
        l = !1;
    2 === u.rank && (l = !0, c = u.as3D(1, u.shape[0], u.shape[1])), g(3 === c.rank, function () {
      return "Error in conv1d: input must be rank 3, but got rank " + c.rank + ".";
    }), g(3 === s.rank, function () {
      return "Error in conv1d: filter must be rank 3, but got rank " + s.rank + ".";
    }), null != i && g(E(r), function () {
      return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    }), g(c.shape[2] === s.shape[1], function () {
      return "Error in conv1d: depth of input (" + c.shape[2] + ") must match input depth for filter " + s.shape[1] + ".";
    }), g(Io(n, a), function () {
      return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + a + "'";
    }), g("NWC" === o, function () {
      return "Error in conv1d: got dataFormat of " + o + " but only NWC is currently supported.";
    });
    var h = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]),
        f = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),
        p = Tc(f, h, [1, n], r, "NHWC", [1, a], i);
    return l ? p.as2D(p.shape[2], p.shape[3]) : p.as3D(p.shape[0], p.shape[2], p.shape[3]);
  }
}),
    Tc = Cn({
  conv2d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NHWC"), void 0 === a && (a = [1, 1]);
    var u = ln(t, "x", "conv2d"),
        s = ln(e, "filter", "conv2d"),
        c = u,
        l = !1;
    3 === u.rank && (l = !0, c = u.as4D(1, u.shape[0], u.shape[1], u.shape[2])), g(4 === c.rank, function () {
      return "Error in conv2d: input must be rank 4, but got rank " + c.rank + ".";
    }), g(4 === s.rank, function () {
      return "Error in conv2d: filter must be rank 4, but got rank " + s.rank + ".";
    }), null != i && g(E(r), function () {
      return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    });
    var h = "NHWC" === o ? c.shape[3] : c.shape[1];
    g(h === s.shape[2], function () {
      return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + s.shape[2] + ".";
    }), g(Io(n, a), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    });
    var f = ko(o),
        p = go(c.shape, s.shape, n, a, r, i, !1, f),
        d = [s, c],
        v = Nt.runKernelFunc(function (t, e) {
      var n = t.conv2d(c, s, p);
      return e([s, c]), n;
    }, {
      x: c,
      filter: s
    }, function (t, e) {
      var i = e,
          u = i[0],
          s = i[1];
      return g(Ro(a), function () {
        return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a + "'";
      }), {
        x: function () {
          return Oc(s.shape, t, u, n, r, o);
        },
        filter: function () {
          return Fc(s, t, u.shape, n, r, o);
        }
      };
    }, "Conv2D", p, d);
    return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
  }
}),
    Nc = Cn({
  conv3d_: function (t, e, n, r, o, a) {
    void 0 === o && (o = "NDHWC"), void 0 === a && (a = [1, 1, 1]);
    var i = ln(t, "x", "conv3d"),
        u = ln(e, "filter", "conv3d"),
        s = i,
        c = !1;
    4 === i.rank && (c = !0, s = i.as5D(1, i.shape[0], i.shape[1], i.shape[2], i.shape[3])), g(5 === s.rank, function () {
      return "Error in conv3d: input must be rank 5, but got rank " + s.rank + ".";
    }), g(5 === u.rank, function () {
      return "Error in conv3d: filter must be rank 5, but got rank " + u.rank + ".";
    }), g(s.shape[4] === u.shape[3], function () {
      return "Error in conv3d: depth of input (" + s.shape[4] + ") must match input depth for filter " + u.shape[3] + ".";
    }), g(function (t, e) {
      return Sc(t) || Sc(e);
    }(n, a), function () {
      return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    }), g("NDHWC" === o, function () {
      return "Error in conv3d: got dataFormat of " + o + " but only NDHWC is currently supported.";
    });
    var l = yo(s.shape, u.shape, n, a, r),
        h = Nt.runKernelFunc(function (t, e) {
      var n = t.conv3d(s, u, l);
      return e([s, u]), n;
    }, {
      x: s,
      $filter: u
    }, function (t, e) {
      g(Sc(a), function () {
        return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a + "'";
      });
      var o = e[0],
          i = e[1];
      return {
        x: function () {
          return Ac(o.shape, t, i, n, r);
        },
        $filter: function () {
          return function (t, e, n, r, o) {
            var a = t;
            4 === t.rank && (a = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));
            var i = e;
            4 === i.rank && (i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])), g(5 === a.rank, function () {
              return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a.shape + ".";
            }), g(5 === i.rank, function () {
              return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i.shape + ".";
            }), g(5 === n.length, function () {
              return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + ".";
            }), g(a.shape[4] === n[3], function () {
              return "Error in conv3dDerFilter: depth of input " + a.shape[4] + ") must match input depth in filter (" + n[3] + ".";
            }), g(i.shape[4] === n[4], function () {
              return "Error in conv3dDerFilter: depth of dy (" + i.shape[4] + ") must match output depth for filter (" + n[4] + ").";
            });
            var u = yo(a.shape, n, r, 1, o);
            return Nt.runKernelFunc(function (t) {
              return t.conv3dDerFilter(a, i, u);
            }, {
              x5D: a,
              dy5D: i
            });
          }(o, t, i.shape, n, r);
        }
      };
    });
    return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
}),
    Fc = Cn({
  conv2dDerFilter_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NHWC");
    var u = t;
    3 === t.rank && (u = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
    var s = e;
    3 === s.rank && (s = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), g(4 === u.rank, function () {
      return "Error in conv2dDerFilter: input must be rank 4, but got shape " + u.shape + ".";
    }), g(4 === s.rank, function () {
      return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + s.shape + ".";
    }), g(4 === n.length, function () {
      return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + ".";
    });
    var c = "NHWC" === a ? u.shape[3] : u.shape[1],
        l = "NHWC" === a ? s.shape[3] : s.shape[1];
    g(c === n[2], function () {
      return "Error in conv2dDerFilter: depth of input " + c + ") must match input depth in filter (" + n[2] + ".";
    }), g(l === n[3], function () {
      return "Error in conv2dDerFilter: depth of dy (" + l + ") must match output depth for filter (" + n[3] + ").";
    }), null != i && g(E(o), function () {
      return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
    });
    var h = ko(a),
        f = go(u.shape, n, r, 1, o, i, !1, h);
    return Nt.runKernelFunc(function (t) {
      return t.conv2dDerFilter(u, s, f);
    }, {
      x4D: u,
      dy4D: s
    });
  }
}),
    Oc = Cn({
  conv2dDerInput_: kc
}),
    _c = Cn({
  depthwiseConv2d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NHWC"), void 0 === a && (a = [1, 1]);
    var u = ln(t, "x", "depthwiseConv2d"),
        s = ln(e, "filter", "depthwiseConv2d"),
        c = u,
        l = !1;
    3 === u.rank && (l = !0, c = u.as4D(1, u.shape[0], u.shape[1], u.shape[2])), g(4 === c.rank, function () {
      return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c.rank + ".";
    }), g(4 === s.rank, function () {
      return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + s.rank + ".";
    }), g(c.shape[3] === s.shape[2], function () {
      return "Error in depthwiseConv2d: number of input channels (" + c.shape[3] + ") must match the inChannels dimension in filter " + s.shape[2] + ".";
    }), null == a && (a = [1, 1]), g(Io(n, a), function () {
      return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    }), null != i && g(E(r), function () {
      return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    });
    var h = go(c.shape, s.shape, n, a, r, i, !0),
        f = Nt.runKernelFunc(function (t, e) {
      var n = t.depthwiseConv2D(c, s, h);
      return e([c, s]), n;
    }, {
      x: c,
      $filter: s
    }, function (t, e) {
      g(Ro(a), function () {
        return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a + "'";
      });
      var n = e[0],
          r = e[1];
      return {
        x: function () {
          return Mc(n.shape, t, r, h);
        },
        $filter: function () {
          return Bc(n, t, r.shape, h);
        }
      };
    });
    return l ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f;
  }
}),
    Mc = Cn({
  depthwiseConv2dDerInput_: function (t, e, n, r) {
    var o = e,
        a = !1;
    3 === e.rank && (a = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
    var i = Nt.runKernelFunc(function (t) {
      return t.depthwiseConv2DDerInput(o, n, r);
    }, {
      dy4D: o
    });
    return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;
  }
}),
    Bc = Cn({
  depthwiseConv2dDerFilter_: function (t, e, n, r) {
    var o = t;
    3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
    var a = e;
    return 3 === a.rank && (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Nt.runKernelFunc(function (t) {
      return t.depthwiseConv2DDerFilter(o, a, r);
    }, {
      x4D: o,
      dy4D: a
    });
  }
}),
    Pc = Cn({
  separableConv2d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = [1, 1]), void 0 === i && (i = "NHWC");
    var u = ln(t, "x", "separableConv2d"),
        s = ln(e, "depthwiseFilter", "separableConv2d"),
        c = ln(n, "pointwiseFilter", "separableConv2d"),
        l = u,
        h = !1;
    if (3 === u.rank && (h = !0, l = u.as4D(1, u.shape[0], u.shape[1], u.shape[2])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    g(4 === l.rank, function () {
      return "Error in separableConv2d: input must be rank 4, but got rank " + l.rank + ".";
    }), g(4 === s.rank, function () {
      return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + s.rank + ".";
    }), g(4 === c.rank, function () {
      return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + s.rank + ".";
    }), g(1 === c.shape[0], function () {
      return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c.shape[0] + ".";
    }), g(1 === c.shape[1], function () {
      return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c.shape[1] + ".";
    });
    var f = s.shape[2],
        p = s.shape[3];
    g(c.shape[2] === f * p, function () {
      return "Error in separableConv2d: the third dimension of pointwise filter must be " + f * p + ", but got " + c.shape[2] + ".";
    });

    var d = _c(l, s, r, o, i, a),
        v = Tc(d, c, 1, "valid", i);

    return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
  }
}),
    Lc = Cn({
  conv2dTranspose_: function (t, e, n, r, o, a) {
    return kc(n, ln(t, "x", "conv2dTranspose"), ln(e, "filter", "conv2dTranspose"), r, o, "NHWC", a);
  }
}),
    Wc = Cn({
  conv3dTranspose_: function (t, e, n, r, o) {
    return Ac(n, ln(t, "x", "conv3dTranspose"), ln(e, "filter", "conv3dTranspose"), r, o);
  }
});

exports.conv3dTranspose = Wc;
exports.conv2dTranspose = Lc;
exports.separableConv2d = Pc;
exports.depthwiseConv2d = _c;
exports.conv3d = Nc;
exports.conv2d = Tc;
exports.conv1d = Dc;
var Uc = Cn({
  matMul_: function (t, e, n, r) {
    var o;
    void 0 === n && (n = !1), void 0 === r && (r = !1);
    var a = ln(t, "a", "matMul"),
        i = ln(e, "b", "matMul");
    o = Rt(a, i), a = o[0], i = o[1];
    var u = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1],
        s = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2],
        c = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2],
        l = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1],
        h = a.shape.slice(0, -2),
        f = i.shape.slice(0, -2),
        p = w(h),
        d = w(f);
    g(a.rank >= 2 && i.rank >= 2 && a.rank === i.rank, function () {
      return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a.rank + " and " + i.rank + ".";
    }), g(C(h, f), function () {
      return "Error in matMul: outer dimensions (" + h + ") and (" + f + ") of Tensors with shapes " + a.shape + " and " + i.shape + " must match.";
    }), g(u === s, function () {
      return "Error in matMul: inner shapes (" + u + ") and (" + s + ") of Tensors with shapes " + a.shape + " and " + i.shape + " and transposeA=" + n + " and transposeB=" + r + " must match.";
    });
    var v = a.shape.slice(0, -2).concat([c, l]),
        m = n ? a.as3D(p, u, c) : a.as3D(p, c, u),
        y = r ? i.as3D(d, l, s) : i.as3D(d, s, l),
        x = {
      transposeA: n,
      transposeB: r
    };
    return Nt.runKernelFunc(function (t, e) {
      var o = t.batchMatMul(m, y, n, r);
      return e([m, y]), o;
    }, {
      a: m,
      b: y
    }, function (t, e) {
      var o = e,
          a = o[0],
          i = o[1];
      return n || r ? !n && r ? {
        a: function () {
          return t.matMul(i, !1, !1);
        },
        b: function () {
          return t.matMul(a, !0, !1);
        }
      } : n && !r ? {
        a: function () {
          return i.matMul(t, !1, !0);
        },
        b: function () {
          return a.matMul(t, !1, !1);
        }
      } : {
        a: function () {
          return i.matMul(t, !0, !0);
        },
        b: function () {
          return t.matMul(a, !0, !0);
        }
      } : {
        a: function () {
          return t.matMul(i, !1, !0);
        },
        b: function () {
          return a.matMul(t, !0, !1);
        }
      };
    }, "BatchMatMul", x).reshape(v);
  }
}),
    Vc = Cn({
  dot_: function (t, e) {
    var n = ln(t, "t1", "dot"),
        r = ln(e, "t2", "dot");
    g(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function () {
      return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + ".";
    });
    var o = 1 === n.rank ? n.size : n.shape[1],
        a = 1 === r.rank ? r.size : r.shape[0];
    return g(o === a, function () {
      return "Error in dot: inner dimensions of inputs must match, but got " + o + " and " + a + ".";
    }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));
  }
}),
    zc = Cn({
  outerProduct_: function (t, e) {
    var n = ln(t, "v1", "outerProduct"),
        r = ln(e, "v2", "outerProduct");
    return g(1 === n.rank && 1 === r.rank, function () {
      return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + ".";
    }), n.as2D(-1, 1).matMul(r.as2D(1, -1));
  }
});
exports.outerProduct = zc;
exports.dot = Vc;
exports.matMul = Uc;
var Gc = Cn({
  reverse_: function (t, e) {
    var n = ln(t, "x", "reverse");
    if (0 === n.rank) return n.clone();
    var r = D(e, n.shape);
    return Nt.runKernelFunc(function (t) {
      return t.reverse(n, r);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return t.reverse(r);
        }
      };
    }).reshapeAs(n);
  }
}),
    Hc = Cn({
  reverse1d_: function (t) {
    var e = ln(t, "x", "reverse");
    return g(1 === e.rank, function () {
      return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + ".";
    }), Gc(e, 0);
  }
}),
    qc = Cn({
  reverse2d_: function (t, e) {
    var n = ln(t, "x", "reverse");
    return g(2 === n.rank, function () {
      return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + ".";
    }), Gc(n, e);
  }
}),
    Kc = Cn({
  reverse3d_: function (t, e) {
    var n = ln(t, "x", "reverse");
    return g(3 === n.rank, function () {
      return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + ".";
    }), Gc(n, e);
  }
}),
    jc = Cn({
  reverse4d_: function (t, e) {
    var n = ln(t, "x", "reverse");
    return g(4 === n.rank, function () {
      return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + ".";
    }), Gc(n, e);
  }
});
exports.reverse4d = jc;
exports.reverse3d = Kc;
exports.reverse2d = qc;
exports.reverse1d = Hc;
exports.reverse = Gc;

function Xc(t, e, n, r, o, a) {
  var i = ln(t, "x", "maxPool"),
      u = i,
      s = !1;
  3 === i.rank && (s = !0, u = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), null == r && (r = [1, 1]), g(4 === u.rank, function () {
    return "Error in maxPool: input must be rank 4 but got rank " + u.rank + ".";
  }), g(Io(n, r), function () {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'";
  }), null != a && g(E(o), function () {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var c = vo(u.shape, e, n, r, o, a),
      l = Nt.runKernelFunc(function (t, e) {
    var n = t.maxPool(u, c);
    return e([u, n]), n;
  }, {
    x: u
  }, function (t, a) {
    var i = a[0],
        u = a[1];
    return {
      x: function () {
        return function (t, e, n, r, o, a, i, u) {
          var s = ln(t, "dy", "maxPoolBackprop"),
              c = ln(e, "input", "maxPoolBackprop"),
              l = ln(n, "output", "maxPoolBackprop");
          g(c.rank === s.rank, function () {
            return "Rank of input (" + c.rank + ") does not match rank of dy (" + s.rank + ")";
          }), null == a && (a = [1, 1]), g(Io(o, a), function () {
            return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
          }), g(4 === s.rank, function () {
            return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + s.rank + ".";
          }), g(4 === c.rank, function () {
            return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c.rank + ".";
          }), null != u && g(E(i), function () {
            return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + u + " but got pad " + i + ".";
          });
          var h = vo(c.shape, r, o, a, i, u);
          return Nt.runKernelFunc(function (t) {
            return t.maxPoolBackprop(s, c, l, h);
          }, {
            $dy: s,
            $input: c
          });
        }(t, i, u, e, n, r, o);
      }
    };
  });
  return s ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;
}

function $c(t, e, n, r, o, a) {
  var i = ln(t, "x", "avgPool", "float32");
  null == r && (r = [1, 1]), g(Io(n, r), function () {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'";
  });
  var u = i,
      s = !1;
  3 === i.rank && (s = !0, u = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), g(4 === u.rank, function () {
    return "Error in avgPool: x must be rank 4 but got rank " + u.rank + ".";
  }), null != a && g(E(o), function () {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var c = vo(u.shape, e, n, r, o, a),
      l = Nt.runKernelFunc(function (t) {
    return t.avgPool(u, c);
  }, {
    x: u
  }, function (t) {
    return {
      x: function () {
        return function (t, e, n, r, o, a) {
          var i = ln(t, "dy", "avgPoolBackprop"),
              u = ln(e, "input", "avgPoolBackprop");
          g(u.rank === i.rank, function () {
            return "Rank of input (" + u.rank + ") does not match rank of dy (" + i.rank + ")";
          }), null == o && (o = [1, 1]), g(Io(r, o), function () {
            return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + o + "'";
          });
          var s = u,
              c = i,
              l = !1;
          3 === u.rank && (l = !0, s = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]), c = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), g(4 === c.rank, function () {
            return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c.rank + ".";
          }), g(4 === s.rank, function () {
            return "Error in avgPoolBackprop: input must be rank 4 but got rank " + s.rank + ".";
          });
          var h = vo(s.shape, n, r, o, a),
              f = Nt.runKernelFunc(function (t) {
            return t.avgPoolBackprop(c, s, h);
          }, {
            dy4D: c,
            input4D: s
          });
          return l ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f;
        }(t, u, e, n, r, o);
      }
    };
  });
  return l = l.cast(i.dtype), s ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;
}

var Yc = Cn({
  maxPool_: function (t, e, n, r, o) {
    return Xc(t, e, n, 1, r, o);
  }
}),
    Qc = Cn({
  avgPool_: function (t, e, n, r, o) {
    return $c(t, e, n, 1, r, o);
  }
}),
    Jc = Cn({
  pool_: function (t, e, n, r, o, a) {
    null == o && (o = [1, 1]), null == a && (a = 1), 0 === r && (r = "valid");
    var i = ln(t, "x", "maxPool"),
        u = i,
        s = !1;
    3 === i.rank && (s = !0, u = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), g(Io(a, o), function () {
      return "Error in pool: Either strides or dilations must be 1. Got strides " + a + " and dilations '" + o + "'";
    });
    var c,
        l = vo(u.shape, e, a, o, r),
        h = [l.dilationHeight, l.dilationWidth];
    c = "same" === r ? function (t, e) {
      var n = t.map(function (t, n) {
        return t + (t - 1) * (e[n] - 1);
      }).map(function (t) {
        return t - 1;
      }),
          r = n.map(function (t) {
        return Math.floor(t / 2);
      }),
          o = n.map(function (t, e) {
        return t - r[e];
      });
      return n.map(function (t, e) {
        return [r[e], o[e]];
      });
    }([l.filterHeight, l.filterWidth], h) : [[0, 0], [0, 0]];

    var f = 1 === h[0] && 1 === h[1],
        p = function (t, e, n) {
      var r = n.map(function (t) {
        return t[0];
      }),
          o = n.map(function (t) {
        return t[1];
      }),
          a = t.concat(r, o),
          i = e.map(function (t, e) {
        return (t - a[e] % t) % t;
      }),
          u = o.map(function (t, e) {
        return t + i[e];
      }),
          s = e.map(function (t, e) {
        return [r[e], u[e]];
      }),
          c = e.map(function (t, e) {
        return [0, i[e]];
      });
      return [s, c];
    }([l.inHeight, l.inWidth], h, c),
        d = p[0],
        v = p[1],
        m = f ? r : "valid",
        y = f ? u : Ar(u, h, d),
        x = ("avg" === n ? function () {
      return $c(y, e, a, 1, m);
    } : function () {
      return Xc(y, e, a, 1, m);
    })(),
        b = f ? x : cr(x, h, v);

    return s ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b;
  }
}),
    Zc = Cn({
  maxPool3d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NDHWC");
    var u = ln(t, "x", "maxPool3d"),
        s = u,
        c = !1;
    4 === u.rank && (c = !0, s = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])), null == i && (i = [1, 1, 1]), g(5 === s.rank, function () {
      return "Error in maxPool3d: x must be rank 5 but got rank " + s.rank + ".";
    }), g("NDHWC" === a, function () {
      return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a;
    }), g(Io(n, i), function () {
      return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'";
    }), null != o && g(E(r), function () {
      return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
    });
    var l = mo(s.shape, e, n, i, r, o, a),
        h = Nt.runKernelFunc(function (t, e) {
      var n = t.maxPool3d(s, l);
      return e([s, n]), n;
    }, {
      x: s
    }, function (t, a) {
      var u = a[0],
          s = a[1];
      return {
        x: function () {
          return function (t, e, n, r, o, a, i, u) {
            var s = ln(t, "dy", "maxPool3dBackprop"),
                c = ln(e, "input", "maxPool3dBackprop"),
                l = ln(n, "output", "maxPool3dBackprop"),
                h = s,
                f = c,
                p = l,
                d = !1;
            4 === c.rank && (d = !0, h = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), f = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), p = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3])), g(5 === h.rank, function () {
              return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h.rank + ".";
            }), g(5 === f.rank, function () {
              return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f.rank + ".";
            }), g(5 === p.rank, function () {
              return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + p.rank + ".";
            }), null == a && (a = [1, 1, 1]), g(Io(o, a), function () {
              return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
            }), null != u && g(E(i), function () {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + u + " but got pad " + i + ".";
            });
            var v = mo(f.shape, r, o, a, i, u),
                m = Nt.runKernelFunc(function (t) {
              return t.maxPool3dBackprop(h, f, p, v);
            }, {
              dy5D: h,
              input5D: f
            });
            return d ? m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]) : m;
          }(t, u, s, e, n, i, r, o);
        }
      };
    });
    return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
}),
    tl = Cn({
  avgPool3d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NDHWC");
    var u = ln(t, "x", "avgPool3d", "float32"),
        s = u,
        c = !1;
    4 === u.rank && (c = !0, s = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])), null == i && (i = [1, 1, 1]), g(5 === s.rank, function () {
      return "Error in avgPool3d: x must be rank 5 but got rank " + s.rank + ".";
    }), g("NDHWC" === a, function () {
      return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a;
    }), g(Io(n, i), function () {
      return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'";
    }), null != o && g(E(r), function () {
      return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
    });
    var l = mo(s.shape, e, n, i, r, o, a),
        h = Nt.runKernelFunc(function (t) {
      return t.avgPool3d(s, l);
    }, {
      x: s
    }, function (t) {
      return {
        x: function () {
          return function (t, e, n, r, o, a, i) {
            var u = ln(t, "dy", "avgPool3dBackprop"),
                s = ln(e, "input", "avgPool3dBackprop"),
                c = u,
                l = s,
                h = !1;
            4 === s.rank && (h = !0, c = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), l = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), g(5 === c.rank, function () {
              return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c.rank + ".";
            }), g(5 === l.rank, function () {
              return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l.rank + ".";
            }), null == o && (o = [1, 1, 1]), g(Io(r, o), function () {
              return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + o + "'";
            }), null != i && g(E(a), function () {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + ".";
            });
            var f = mo(l.shape, n, r, o, a, i),
                p = Nt.runKernelFunc(function (t) {
              return t.avgPool3dBackprop(c, l, f);
            }, {
              dy5D: c,
              input5D: l
            });
            return h ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p;
          }(t, s, e, n, i, r, o);
        }
      };
    });
    return h = h.cast(s.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
});
exports.avgPool3d = tl;
exports.maxPool3d = Zc;
exports.pool = Jc;
exports.avgPool = Qc;
exports.maxPool = Yc;
var el = Cn({
  slice_: function (t, e, n) {
    var r,
        o,
        a = ln(t, "x", "slice");
    if (0 === a.rank) throw new Error("Slicing scalar is not possible");
    (r = "number" == typeof e ? [e].concat(new Array(a.rank - 1).fill(0)) : e.length < a.rank ? e.concat(new Array(a.rank - e.length).fill(0)) : e.slice()).forEach(function (t) {
      g(-1 !== t, function () {
        return "slice() does not support negative begin indexing.";
      });
    }), o = (o = null == n ? new Array(a.rank).fill(-1) : "number" == typeof n ? [n].concat(new Array(a.rank - 1).fill(-1)) : n.length < a.rank ? n.concat(new Array(a.rank - n.length).fill(-1)) : n).map(function (t, e) {
      return t >= 0 ? t : (g(-1 === t, function () {
        return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + e + ".";
      }), a.shape[e] - r[e]);
    }), qr(a, r, o);
    var i = a.shape,
        u = {
      begin: r,
      size: o
    };
    return Nt.runKernelFunc(function (t) {
      return t.slice(a, r, o);
    }, {
      x: a
    }, function (t) {
      for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], i[n] - r[n] - o[n]]);

      return {
        x: function () {
          return t.pad(e);
        }
      };
    }, "Slice", u);
  }
}),
    nl = Cn({
  slice1d_: function (t, e, n) {
    var r = ln(t, "x", "slice1d");
    return g(1 === r.rank, function () {
      return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor";
    }), el(r, [e], [n]);
  }
}),
    rl = Cn({
  slice2d_: function (t, e, n) {
    var r = ln(t, "x", "slice2d");
    return g(2 === r.rank, function () {
      return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor";
    }), el(r, e, n);
  }
}),
    ol = Cn({
  slice3d_: function (t, e, n) {
    var r = ln(t, "x", "slice3d");
    return g(3 === r.rank, function () {
      return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor";
    }), el(r, e, n);
  }
}),
    al = Cn({
  slice4d_: function (t, e, n) {
    var r = ln(t, "x", "slice4d");
    return g(4 === r.rank, function () {
      return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor";
    }), el(r, e, n);
  }
});
exports.slice4d = al;
exports.slice3d = ol;
exports.slice2d = rl;
exports.slice1d = nl;
exports.slice = el;

function il(t, e, n, r, o) {
  return e.rank < n.rank && (e = e.reshape(vn(e.shape, r))), t.rank < n.rank && (t = t.reshape(vn(t.shape, r))), {
    x: function () {
      var r = t.mul(n.equal(e).cast(t.dtype));
      return null == o ? r : r.transpose(o);
    }
  };
}

var ul = Cn({
  all_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "all", "bool"),
        o = D(e, r.shape),
        a = o,
        i = gn(a, r.rank);
    null != i && (r = r.transpose(i), a = xn(a.length, r.rank));
    var u = Nt.runKernelFunc(function (t) {
      return t.all(r, a);
    }, {
      $x: r
    });

    if (n) {
      var s = vn(u.shape, o);
      return u.reshape(s);
    }

    return u;
  }
}),
    sl = Cn({
  any_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "any", "bool"),
        o = D(e, r.shape),
        a = o,
        i = gn(a, r.rank);
    null != i && (r = r.transpose(i), a = xn(a.length, r.rank));
    var u = Nt.runKernelFunc(function (t) {
      return t.any(r, a);
    }, {
      $x: r
    });

    if (n) {
      var s = vn(u.shape, o);
      return u.reshape(s);
    }

    return u;
  }
}),
    cl = Cn({
  argMax_: function (t, e) {
    void 0 === e && (e = 0);
    var n = ln(t, "x", "argMax");
    null == e && (e = 0);
    var r = D(e, n.shape),
        o = gn(r, n.rank);
    return null != o && (n = n.transpose(o), r = xn(r.length, n.rank)), Nt.runKernelFunc(function (t, e) {
      var o = t.argMax(n, r[0]);
      return e([n]), o;
    }, {
      $x: n
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return zn(n);
        }
      };
    });
  }
}),
    ll = Cn({
  argMin_: function (t, e) {
    void 0 === e && (e = 0);
    var n = ln(t, "x", "argMin");
    null == e && (e = 0);
    var r = D(e, n.shape),
        o = gn(r, n.rank);
    return null != o && (n = n.transpose(o), r = xn(r.length, n.rank)), Nt.runKernelFunc(function (t, e) {
      var o = t.argMin(n, r[0]);
      return e([n]), o;
    }, {
      $x: n
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return zn(n);
        }
      };
    });
  }
}),
    hl = Cn({
  logSumExp_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "logSumExp"),
        o = D(e, r.shape),
        a = r.max(o, !0),
        i = r.sub(a).exp().sum(o).log(),
        u = a.reshape(i.shape).add(i);

    if (n) {
      var s = vn(u.shape, o);
      return u.reshape(s);
    }

    return u;
  }
}),
    fl = Cn({
  max_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "max"),
        o = r,
        a = D(e, r.shape),
        i = a,
        u = gn(i, r.rank);
    null != u && (r = r.transpose(u), i = xn(i.length, r.rank));
    var s = [r],
        c = Nt.runKernelFunc(function (t, e) {
      var n = t.max(r, i);
      return e([o, n]), n;
    }, {
      x: r
    }, function (t, e) {
      return il(t, e[1], e[0], a, u);
    }, "Max", {
      axes: i
    }, s, [!0]);

    if (n) {
      var l = vn(c.shape, a);
      c = c.reshape(l);
    }

    return c;
  }
}),
    pl = Cn({
  mean_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "mean"),
        o = D(e, r.shape),
        a = w(dn(r.shape, o)[1]);
    return oo(function (t) {
      var r = An(a);
      return {
        value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),
        gradFunc: function (e) {
          var n = t.shape.slice();
          return o.forEach(function (t) {
            n[t] = 1;
          }), e.reshape(n).mul(Bn(t.shape, "float32")).div(a);
        }
      };
    })(r);
  }
}),
    dl = Cn({
  min_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "min"),
        o = r,
        a = D(e, r.shape),
        i = a,
        u = gn(i, r.rank);
    null != u && (r = r.transpose(u), i = xn(i.length, r.rank));
    var s = [r],
        c = Nt.runKernelFunc(function (t, e) {
      var n = t.min(r, i);
      return e([o, n]), n;
    }, {
      x: r
    }, function (t, e) {
      return il(t, e[1], e[0], a, u);
    }, "Min", {
      axes: i
    }, s, [!0]);

    if (n) {
      var l = vn(c.shape, a);
      c = c.reshape(l);
    }

    return c;
  }
}),
    vl = Cn({
  moments_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = D(e, (t = ln(t, "x", "moments")).shape),
        o = t.mean(r, n),
        a = o.shape;
    n || (a = vn(o.shape, r));
    var i = t.toFloat().sub(o.reshape(a)).square();
    return {
      mean: o,
      variance: i.mean(r, n)
    };
  }
}),
    ml = Cn({
  sum_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "sum");
    "bool" === r.dtype && (r = r.toInt());
    var o = D(e, r.shape);
    return oo(function (t) {
      var e = gn(o, t.rank),
          r = o,
          a = t;
      null != e && (a = t.transpose(e), r = xn(r.length, t.rank));
      var i = Nt.runKernelFunc(function (t) {
        return t.sum(a, r);
      }, {
        permutedX: a
      });

      if (n) {
        var u = vn(i.shape, o);
        i = i.reshape(u);
      }

      return {
        value: i,
        gradFunc: function (e) {
          var n = t.shape.slice();
          return o.forEach(function (t) {
            n[t] = 1;
          }), e.reshape(n).mul(Bn(t.shape, "float32"));
        }
      };
    })(r);
  }
}),
    gl = Cn({
  prod_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = ln(t, "x", "prod");
    "bool" === r.dtype && (r = r.toInt());
    var o = D(e, r.shape),
        a = gn(o, r.rank),
        i = o,
        u = r;
    null != a && (u = r.transpose(a), i = xn(i.length, r.rank));
    var s = Nt.runKernelFunc(function (t) {
      return t.prod(u, i);
    }, {
      permutedX: u
    });

    if (n) {
      var c = vn(s.shape, o);
      s = s.reshape(c);
    }

    return s;
  }
});
exports.prod = gl;
exports.sum = ml;
exports.moments = vl;
exports.min = dl;
exports.mean = pl;
exports.max = fl;
exports.logSumExp = hl;
exports.argMin = ll;
exports.argMax = cl;
exports.any = sl;
exports.all = ul;
var yl = Cn({
  elu_: function (t) {
    var e = ln(t, "x", "elu");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.elu(e);
      return n([r]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return Nt.runKernelFunc(function (e) {
            return e.eluDer(t, n);
          }, {
            dy: t,
            y: n
          });
        }
      };
    });
  }
}),
    xl = Cn({
  leakyRelu_: function (t, e) {
    void 0 === e && (e = .2);
    var n = ln(t, "x", "leakyRelu");
    return $s(An(e).mul(n), n);
  }
}),
    bl = Cn({
  prelu_: function (t, e) {
    var n = ln(t, "x", "prelu"),
        r = ln(e, "alpha", "prelu");
    return Nt.runKernelFunc(function (t, e) {
      var o = t.prelu(n, r);
      return e([n, r]), o;
    }, {
      x: n,
      alpha: r
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          o = n.greater(0);
      return {
        x: function () {
          return Ws(o, t, t.mul(r));
        },
        alpha: function () {
          var e = Ws(o, zn(t), t.mul(n)),
              a = fo(r.shape, t.shape);
          return a.length > 0 && (e = e.sum(a)), e.reshape(r.shape);
        }
      };
    }, "Prelu");
  }
}),
    wl = Cn({
  relu_: function (t) {
    var e = ln(t, "x", "relu");
    return "bool" === e.dtype ? e.toInt() : Nt.runKernelFunc(function (t, n) {
      var r = t.relu(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mulStrict(n.step().toFloat());
        }
      };
    });
  }
}),
    Cl = Cn({
  relu6_: function (t) {
    var e = ln(t, "x", "relu6");
    return "bool" === e.dtype ? e.toInt() : Nt.runKernelFunc(function (t, n) {
      var r = t.relu6(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0],
          r = n.lessEqual(6).mul(n.step());
      return {
        $x: function () {
          return t.mulStrict(r.toFloat());
        }
      };
    });
  }
}),
    El = Cn({
  selu_: function (t) {
    var e = ln(t, "x", "selu");
    return Nt.runKernelFunc(function (t, n) {
      var r = t.selu(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          var e = n.greater(An(0)),
              r = An(iu),
              o = An(uu),
              a = t.mul(o),
              i = t.mul(r).mul(n.toFloat().exp());
          return Ws(e, a, i);
        }
      };
    });
  }
});
exports.selu = El;
exports.relu6 = Cl;
exports.relu = wl;
exports.prelu = bl;
exports.leakyRelu = xl;
exports.elu = yl;
var Rl = Cn({
  transpose_: function (t, e) {
    var n = ln(t, "x", "transpose");
    if (null == e && (e = n.shape.map(function (t, e) {
      return e;
    }).reverse()), g(n.rank === e.length, function () {
      return "Error in transpose: rank of input " + n.rank + " must match length of perm " + e + ".";
    }), e.forEach(function (t) {
      g(t >= 0 && t < n.rank, function () {
        return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + e;
      });
    }), n.rank <= 1) return n.clone();
    var r = {
      perm: e
    };
    return Nt.runKernelFunc(function (t) {
      return t.transpose(n, e);
    }, {
      x: n
    }, function (t) {
      var n = yn(e);
      return {
        x: function () {
          return t.transpose(n);
        }
      };
    }, "Transpose", r);
  }
});
exports.transpose = Rl;
var Il = Cn({
  localResponseNormalization_: function (t, e, n, r, o) {
    void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);
    var a = ln(t, "x", "localResponseNormalization");
    g(4 === a.rank || 3 === a.rank, function () {
      return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a.rank + ".";
    }), g(E(e), function () {
      return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + ".";
    });
    var i = a,
        u = !1;
    3 === a.rank && (u = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));
    var s = Nt.runKernelFunc(function (t, a) {
      var u = t.localResponseNormalization4D(i, e, n, r, o);
      return a([i, u]), u;
    }, {
      x4D: i
    }, function (t, a) {
      var i = a[0],
          u = a[1];
      return {
        x4D: function () {
          return Nt.runKernelFunc(function (a) {
            return a.LRNGrad(t, i, u, e, n, r, o);
          }, {});
        }
      };
    });
    return u ? s.as3D(s.shape[1], s.shape[2], s.shape[3]) : s;
  }
});
exports.localResponseNormalization = Il;
var kl = Cn({
  norm_: function (t, e, n, r) {
    void 0 === e && (e = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);

    var o = function t(e, n, r) {
      if (void 0 === r && (r = null), 0 === e.rank) return e.abs();
      if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);

      if (1 === e.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
        if (1 === n) return e.abs().sum(r);
        if (n === 1 / 0) return e.abs().max(r);
        if (n === -1 / 0) return e.abs().min(r);
        if ("euclidean" === n || 2 === n) return e.abs().pow(An(2, "int32")).sum(r).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n);
      }

      if (Array.isArray(r) && 2 === r.length) {
        if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);
        if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
        if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
        if ("fro" === n || "euclidean" === n) return e.square().sum(r).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n);
      }

      throw new Error("Error in norm: invalid axis: " + r);
    }(t = ln(t, "x", "norm"), e, n),
        a = o.shape;

    if (r) {
      var i = D(n, t.shape);
      a = vn(o.shape, i);
    }

    return o.reshape(a);
  }
});
exports.norm = kl;
var Sl = Cn({
  basicLSTMCell_: function (t, e, n, r, o, a) {
    var i = ln(t, "forgetBias", "basicLSTMCell"),
        u = ln(e, "lstmKernel", "basicLSTMCell"),
        s = ln(n, "lstmBias", "basicLSTMCell"),
        c = ln(r, "data", "basicLSTMCell"),
        l = ln(o, "c", "basicLSTMCell"),
        h = ln(a, "h", "basicLSTMCell"),
        f = c.concat(h, 1).matMul(u).add(s),
        p = f.shape[0],
        d = f.shape[1] / 4,
        v = [p, d],
        m = f.slice([0, 0], v),
        g = f.slice([0, d], v),
        y = f.slice([0, 2 * d], v),
        x = f.slice([0, 3 * d], v),
        b = m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())),
        w = b.tanh().mulStrict(x.sigmoid());
    return [b, w];
  }
}),
    Al = Cn({
  multiRNNCell_: function (t, e, n, r) {
    for (var o = ln(e, "data", "multiRNNCell"), a = hn(n, "c", "multiRNNCell"), i = hn(r, "h", "multiRNNCell"), u = o, s = [], c = 0; c < t.length; c++) {
      var l = t[c](u, a[c], i[c]);
      s.push(l[0]), s.push(l[1]), u = l[1];
    }

    var h = [],
        f = [];

    for (c = 0; c < s.length; c += 2) h.push(s[c]), f.push(s[c + 1]);

    return [h, f];
  }
});
exports.multiRNNCell = Al;
exports.basicLSTMCell = Sl;
var Dl = Cn({
  movingAverage_: function (t, e, n, r, o) {
    void 0 === o && (o = !0);
    var a = ln(t, "v", "movingAverage"),
        i = ln(e, "x", "movingAverage"),
        u = ln(n, "decay", "movingAverage");
    It(a, i), g(C(a.shape, i.shape), function () {
      return "Shape mismatch in v and x";
    });
    var s = An(1),
        c = s.sub(u),
        l = i.sub(a).mul(c);

    if (o) {
      g(null != r, function () {
        return "When using zeroDebias: true, step is required.";
      });
      var h = ln(r, "step", "movingAverage");
      l = l.div(s.sub(rc(u, h)));
    }

    return a.add(l);
  }
});
exports.movingAverage = Dl;
var Tl = Cn({
  stridedSlice_: function (t, e, n, r, o, a, i, u, s) {
    if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === u && (u = 0), void 0 === s && (s = 0), null == r && (r = new Array(e.length)), 0 !== i) throw new Error("ellipsis mask is not yet supported");
    var c = ln(t, "x", "stridedSlice"),
        l = Kr(u),
        h = c.shape.slice();
    l.forEach(function (t) {
      e[t] = 0, n[t] = 1, h.splice(t, 0, 1);
    }), c = c.reshape(h);

    for (var f = 0; f < c.rank; f++) e[f] = Xr(o, e, r, c.shape, f), n[f] = $r(a, n, r, c.shape, f), r[f] = r[f] || 1;

    var p = Kr(s);
    p.forEach(function (t) {
      n[t] = e[t] + 1, r[t] = 1;
    });
    var d = jr(e, n, r),
        v = d.filter(function (t, e) {
      return -1 === p.indexOf(e);
    });
    return r.every(function (t) {
      return 1 === t;
    }) ? el(c, e, d).reshape(v) : Nt.runKernelFunc(function (t) {
      return t.stridedSlice(c, e, n, r);
    }, {
      $x: c
    }).reshape(v);
  }
});
exports.stridedSlice = Tl;
var Nl = Cn({
  topk_: function (t, e, n) {
    void 0 === e && (e = 1), void 0 === n && (n = !0);
    var r = ln(t, "x", "topk");
    if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
    var o = r.shape[r.shape.length - 1];
    if (e > o) throw new Error("'k' passed to topk() must be <= the last dimension (" + o + ") but got " + e);
    var a = Nt.runKernelFunc(function (t) {
      return t.topk(r, e, n);
    }, {
      $x: r
    });
    return {
      values: a[0],
      indices: a[1]
    };
  }
});
exports.topk = Nl;
var Fl = Cn({
  scatterND_: function (t, e, n) {
    var r = ln(t, "indices", "scatterND", "int32"),
        o = ln(e, "updates", "scatterND");
    return Gr(o, r, n), Nt.runKernelFunc(function (t) {
      return t.scatterND(r, o, n);
    }, {
      $indices: r,
      $updates: o
    });
  }
});
exports.scatterND = Fl;

var Ol = Cn({
  fft_: function (t) {
    g("complex64" === t.dtype, function () {
      return "The dtype for tf.spectral.fft() must be complex64 but got " + t.dtype + ".";
    });
    var e = t.shape[t.shape.length - 1],
        n = t.size / e,
        r = t.as2D(n, e);
    return Nt.runKernelFunc(function (t) {
      return t.fft(r);
    }, {
      input: t
    }).reshape(t.shape);
  }
}),
    _l = Cn({
  ifft_: function (t) {
    g("complex64" === t.dtype, function () {
      return "The dtype for tf.spectral.ifft() must be complex64 but got " + t.dtype + ".";
    });
    var e = t.shape[t.shape.length - 1],
        n = t.size / e,
        r = t.as2D(n, e);
    return Nt.runKernelFunc(function (t) {
      return t.ifft(r);
    }, {
      input: t
    }).reshape(t.shape);
  }
}),
    Ml = Cn({
  rfft_: function (t, e) {
    g("float32" === t.dtype, function () {
      return "The dtype for rfft() must be real value but got " + t.dtype;
    });
    var n,
        r = t.shape[t.shape.length - 1],
        o = t.size / r;

    if (null != e && e < r) {
      var a = t.shape.map(function (t) {
        return 0;
      }),
          i = t.shape.map(function (t) {
        return t;
      });
      i[t.shape.length - 1] = e, n = t.slice(a, i), r = e;
    } else if (null != e && e > r) {
      var u = t.shape.map(function (t) {
        return t;
      });
      u[t.shape.length - 1] = e - r, n = t.concat(Pn(u), t.shape.length - 1), r = e;
    } else n = t;

    var s = n.zerosLike(),
        c = En(n, s).as2D(o, r),
        l = Ol(c),
        h = Math.floor(r / 2) + 1,
        f = Rn(l),
        p = In(l),
        d = f.split([h, r - h], f.shape.length - 1),
        v = p.split([h, r - h], p.shape.length - 1),
        m = n.shape.slice();
    return m[n.shape.length - 1] = h, En(d[0], v[0]).reshape(m);
  }
}),
    Bl = Cn({
  irfft_: function (t) {
    var e = t.shape[t.shape.length - 1],
        n = t.size / e;

    if (e <= 2) {
      var r = t.as2D(n, e),
          o = _l(r);

      return Rn(o);
    }

    var a = [n, 2 * (e - 1)],
        i = Rn(t).as2D(n, e),
        u = In(t).as2D(n, e),
        s = i.slice([0, 1], [n, e - 2]).reverse(1),
        c = u.slice([0, 1], [n, e - 2]).reverse(1).mul(An(-1)),
        l = i.concat(s, 1),
        h = u.concat(c, 1);
    return r = En(l, h).as2D(a[0], a[1]), o = _l(r), Rn(o);
  }
}),
    Pl = Object.freeze({
  fft: Ol,
  ifft: _l,
  rfft: Ml,
  irfft: Bl
});

exports.spectral = Pl;
exports.irfft = Bl;
exports.rfft = Ml;
exports.ifft = _l;
exports.fft = Ol;
var Ll = Cn({
  sparseToDense_: function (t, e, n, r) {
    void 0 === r && (r = 0);
    var o = ln(t, "sparseIndices", "sparseToDense", "int32"),
        a = ln(e, "sparseValues", "sparseToDense"),
        i = ln(r, "defaultValue", "sparseToDense", a.dtype);
    return function (t, e, n, r) {
      if ("int32" !== t.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
      if (t.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t.shape + ".");
      var o = t.rank > 0 ? t.shape[0] : 1,
          a = t.rank > 1 ? t.shape[1] : 1;
      if (n.length !== a) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + a + ".");
      var i = e.size;
      if (0 !== e.rank && (1 !== e.rank || i !== o)) throw new Error("sparseValues has incorrect shape " + e.shape + ", should be [] or [" + o + "]");
      if (e.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }(o, a, n, i), Nt.runKernelFunc(function (t) {
      return t.sparseToDense(o, a, n, i);
    }, {
      $sparseIndices: o,
      $sparseValues: a,
      $defaultValue: i
    });
  }
});
exports.sparseToDense = Ll;
var Wl = Cn({
  gatherND_: function (t, e) {
    var n = ln(e, "indices", "gatherND", "int32"),
        r = ln(t, "x", "gatherND");
    return Nt.runKernelFunc(function (t) {
      return t.gatherND(r, n);
    }, {
      $x: r,
      $indices: n
    });
  }
});
exports.gatherND = Wl;
var Ul = Cn({
  diag_: function (t) {
    var e = ln(t, "x", "diag").flatten(),
        n = t.shape.concat(t.shape);
    return Nt.runKernelFunc(function (t) {
      return t.diag(e);
    }, {
      $x: e
    }).reshape(n);
  }
});
exports.diag = Ul;
var Vl = Cn({
  dropout_: function (t, e, n, r) {
    var o = ln(t, "x", "dropout");
    if (g("float32" === o.dtype, function () {
      return "x has to be a floating point tensor since it's going to be scaled, but got a " + o.dtype + " tensor instead.";
    }), g(e >= 0 && e < 1, function () {
      return "rate must be a float in the range [0, 1), but got " + e + ".";
    }), 0 === e) return t instanceof dt ? o.clone() : o;

    var a = function (t, e) {
      if (null == e) return t.shape.slice();
      if (C(t.shape, e)) return e;

      if (t.shape.length === e.length) {
        for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);

        return n;
      }

      return e;
    }(o, n),
        i = 1 - e,
        u = kr(a, 0, 1, "float32", r).add(i).floor().div(i);

    return o.mul(u);
  }
});
exports.dropout = Vl;

function zl(t, e, n) {
  for (var r = 1 - t % 2, o = new Float32Array(t), a = 0; a < t; ++a) {
    var i = 2 * Math.PI * a / (t + r - 1);
    o[a] = e - n * Math.cos(i);
  }

  return Dn(o, "float32");
}

var Gl = Cn({
  hannWindow_: function (t) {
    return zl(t, .5, .5);
  }
}),
    Hl = Cn({
  hammingWindow_: function (t) {
    return zl(t, .54, .46);
  }
}),
    ql = Cn({
  frame_: function (t, e, n, r, o) {
    void 0 === r && (r = !1), void 0 === o && (o = 0);

    for (var a = 0, i = []; a + e <= t.size;) i.push(el(t, a, e)), a += n;

    if (r) for (; a < t.size;) {
      var u = a + e - t.size,
          s = Gn([el(t, a, e - u), Ln([u], o)]);
      i.push(s), a += n;
    }
    return 0 === i.length ? Tn([], [0, e]) : Gn(i).as2D(i.length, e);
  }
}),
    Kl = Cn({
  stft_: function (t, e, n, r, o) {
    var a;
    void 0 === o && (o = Gl), null == r && (a = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))));

    for (var i = ql(t, e, n), u = ec(i, o(e)), s = [], c = 0; c < i.shape[0]; c++) s.push(Ml(u.slice([c, 0], [1, e]), r));

    return Gn(s);
  }
}),
    jl = Object.freeze({
  hannWindow: Gl,
  hammingWindow: Hl,
  frame: ql,
  stft: Kl
});
exports.signal = jl;
exports.stft = Kl;
exports.frame = ql;
exports.hammingWindow = Hl;
exports.hannWindow = Gl;

var Xl,
    $l = function (t, e, o) {
  return void 0 === o && (o = 1), n(this, void 0, void 0, function () {
    var n, a, i, u, s, c, l, h, f, p, d, v, m, x;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = ln(t, "predictions", "inTopK"), a = ln(e, "targets", "inTopK"), g(n.rank > 1, function () {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n.rank;
          }), g(n.rank - 1 === a.rank, function () {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n.rank + " and targets rank " + a.rank;
          }), y(n.shape.slice(0, n.shape.length - 1), a.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i = n.shape[n.shape.length - 1], g(o > 0 && o <= i, function () {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i + "), but got " + o;
          }), [4, n.data()];

        case 1:
          return u = r.sent(), [4, a.data()];

        case 2:
          for (s = r.sent(), c = [u.length / i, i], h = c[1], f = N("bool", l = c[0]), p = 0; p < l; p++) {
            for (d = p * h, v = u.subarray(d, d + h), m = [], x = 0; x < v.length; x++) m.push({
              value: v[x],
              index: x
            });

            for (m.sort(function (t, e) {
              return e.value - t.value;
            }), f[p] = 0, x = 0; x < o; x++) if (m[x].index === s[p]) {
              f[p] = 1;
              break;
            }
          }

          return t !== n && n.dispose(), e !== a && a.dispose(), [2, kn(f, a.shape, "bool")];
      }
    });
  });
};

exports.inTopKAsync = $l;
exports.Reduction = Xl;
!function (t) {
  t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(Xl || (exports.Reduction = Xl = {}));
var Yl = Cn({
  absoluteDifference_: function (t, e, n, r) {
    void 0 === r && (r = Xl.SUM_BY_NONZERO_WEIGHTS);
    var o = ln(t, "labels", "absoluteDifference"),
        a = ln(e, "predictions", "absoluteDifference"),
        i = null;
    null != n && (i = ln(n, "weights", "absoluteDifference")), y(o.shape, a.shape, "Error in absoluteDifference: ");
    var u = o.sub(a).abs();
    return Ql(u, i, r);
  }
}),
    Ql = Cn({
  computeWeightedLoss_: function (t, e, n) {
    void 0 === n && (n = Xl.SUM_BY_NONZERO_WEIGHTS);
    var r = ln(t, "losses", "computeWeightedLoss"),
        o = null;
    null != e && (o = ln(e, "weights", "computeWeightedLoss"));
    var a = null == o ? r : r.mul(o);
    if (n === Xl.NONE) return a;
    if (n === Xl.SUM) return a.sum();

    if (n === Xl.MEAN) {
      if (null == o) return a.mean();
      var i = r.size / o.size,
          u = a.sum().div(o.sum());
      return i > 1 ? u.div(An(i)) : u;
    }

    if (n === Xl.SUM_BY_NONZERO_WEIGHTS) {
      if (null == o) return a.sum().div(An(r.size));
      var s = o.mul(Bn(r.shape)).notEqual(An(0)).sum().toFloat();
      return a.sum().div(s);
    }

    throw Error("Unknown reduction: " + n);
  }
}),
    Jl = Cn({
  cosineDistance_: function (t, e, n, r, o) {
    void 0 === o && (o = Xl.SUM_BY_NONZERO_WEIGHTS);
    var a = ln(t, "labels", "cosineDistance"),
        i = ln(e, "predictions", "cosineDistance"),
        u = null;
    null != r && (u = ln(r, "weights", "cosineDistance")), y(a.shape, i.shape, "Error in cosineDistance: ");
    var s = An(1).sub(a.mul(i).sum(n, !0));
    return Ql(s, u, o);
  }
}),
    Zl = Cn({
  hingeLoss_: function (t, e, n, r) {
    void 0 === r && (r = Xl.SUM_BY_NONZERO_WEIGHTS);
    var o = ln(t, "labels", "hingeLoss"),
        a = ln(e, "predictions", "hingeLoss"),
        i = null;
    null != n && (i = ln(n, "weights", "hingeLoss")), y(o.shape, a.shape, "Error in hingeLoss: ");
    var u = An(1);
    o = An(2).mul(o).sub(u);
    var s = u.sub(o.mul(a)).relu();
    return Ql(s, i, r);
  }
}),
    th = Cn({
  huberLoss_: function (t, e, n, r, o) {
    void 0 === r && (r = 1), void 0 === o && (o = Xl.SUM_BY_NONZERO_WEIGHTS);
    var a = ln(t, "labels", "huberLoss"),
        i = ln(e, "predictions", "huberLoss"),
        u = null;
    null != n && (u = ln(n, "weights", "huberLoss")), y(a.shape, i.shape, "Error in huberLoss: ");
    var s = An(r),
        c = i.sub(a).abs(),
        l = Qs(c, s),
        h = c.sub(l),
        f = An(.5).mul(l.square()).add(s.mul(h));
    return Ql(f, u, o);
  }
}),
    eh = Cn({
  logLoss_: function (t, e, n, r, o) {
    void 0 === r && (r = 1e-7), void 0 === o && (o = Xl.SUM_BY_NONZERO_WEIGHTS);
    var a = ln(t, "labels", "logLoss"),
        i = ln(e, "predictions", "logLoss"),
        u = null;
    null != n && (u = ln(n, "weights", "logLoss")), y(a.shape, i.shape, "Error in logLoss: ");
    var s = An(1),
        c = An(r),
        l = a.mul(i.add(c).log()).neg().sub(s.sub(a).mul(s.sub(i).add(c).log()));
    return Ql(l, u, o);
  }
}),
    nh = Cn({
  meanSquaredError_: function (t, e, n, r) {
    void 0 === r && (r = Xl.SUM_BY_NONZERO_WEIGHTS);
    var o = ln(t, "labels", "meanSquaredError"),
        a = ln(e, "predictions", "meanSquaredError"),
        i = null;
    null != n && (i = ln(n, "weights", "meanSquaredError")), y(o.shape, a.shape, "Error in meanSquaredError: ");
    var u = o.squaredDifference(a);
    return Ql(u, i, r);
  }
}),
    rh = Cn({
  sigmoidCrossEntropy_: function (t, e, n, r, o) {
    void 0 === r && (r = 0), void 0 === o && (o = Xl.SUM_BY_NONZERO_WEIGHTS);
    var a = ln(t, "multiClassLabels", "sigmoidCrossEntropy"),
        i = ln(e, "logits", "sigmoidCrossEntropy"),
        u = null;

    if (null != n && (u = ln(n, "weights", "sigmoidCrossEntropy")), y(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
      var s = An(r),
          c = An(1),
          l = An(.5);
      a = a.mul(c.sub(s)).add(l.mul(s));
    }

    var h = function (t, e) {
      var n = ln(t, "labels", "sigmoidCrossEntropyWithLogits"),
          r = ln(e, "logits", "sigmoidCrossEntropyWithLogits");
      y(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var o = r.relu(),
          a = r.mul(n),
          i = r.abs().neg().exp().log1p();
      return o.sub(a).add(i);
    }(a, i);

    return Ql(h, u, o);
  }
}),
    oh = Cn({
  softmaxCrossEntropy_: function (t, e, n, r, o) {
    void 0 === r && (r = 0), void 0 === o && (o = Xl.SUM_BY_NONZERO_WEIGHTS);
    var a = ln(t, "onehotLabels", "softmaxCrossEntropy"),
        i = ln(e, "logits", "softmaxCrossEntropy"),
        u = null;

    if (null != n && (u = ln(n, "weights", "softmaxCrossEntropy")), y(a.shape, i.shape, "Error in softmaxCrossEntropy: "), r > 0) {
      var s = An(r),
          c = An(1),
          l = An(a.shape[1]);
      a = a.mul(c.sub(s)).add(s.div(l));
    }

    var h = function (t, e, n) {
      if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e.rank + " and dim was " + n);
      return oo(function (t, e, r) {
        var o = e.logSumExp([n], !0),
            a = e.toFloat().sub(o);
        return r([t, a]), {
          value: a.mul(t).neg().sum([n]),
          gradFunc: function (t, e) {
            var r = e[0],
                o = e[1],
                a = vn(t.shape, [n]);
            return [t.reshape(a).mul(r.toFloat().sub(o.exp())), t.reshape(a).mul(o.exp().sub(r.toFloat()))];
          }
        };
      })(t, e);
    }(a, i);

    return Ql(h, u, o);
  }
}),
    ah = Object.freeze({
  get Reduction() {
    return Xl;
  },

  absoluteDifference: Yl,
  computeWeightedLoss: Ql,
  cosineDistance: Jl,
  hingeLoss: Zl,
  huberLoss: th,
  logLoss: eh,
  meanSquaredError: nh,
  sigmoidCrossEntropy: rh,
  softmaxCrossEntropy: oh
});
exports.losses = ah;

function ih(t, e) {
  return void 0 === e && (e = !1), Nt.tidy(function () {
    if (2 !== t.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t.shape.length + "D Tensor.");

    for (var n = t.shape[0], r = t.shape[1], o = vr(n), a = t.clone(), i = Tn([[1]], [1, 1]), u = i.clone(), s = n >= r ? r : n, c = function (t) {
      var e,
          s = a,
          c = u,
          l = o;
      e = Nt.tidy(function () {
        var e = a.slice([t, t], [n - t, 1]),
            s = e.norm(),
            c = a.slice([t, t], [1, 1]),
            l = Tn([[-1]]).where(c.greater(0), Tn([[1]])),
            h = c.sub(l.mul(s)),
            f = e.div(h);
        u = 1 === f.shape[0] ? i.clone() : i.concat(f.slice([1, 0], [f.shape[0] - 1, f.shape[1]]), 0);
        var p = l.matMul(h).div(s).neg(),
            d = a.slice([t, 0], [n - t, r]),
            v = p.mul(u);
        if (0 === t) a = d.sub(v.matMul(u.transpose().matMul(d)));else {
          var m = d.sub(v.matMul(u.transpose().matMul(d)));
          a = a.slice([0, 0], [t, r]).concat(m, 0);
        }
        var g = o.slice([0, t], [n, o.shape[1] - t]);
        if (0 === t) o = g.sub(g.matMul(u).matMul(v.transpose()));else {
          var y = g.sub(g.matMul(u).matMul(v.transpose()));
          o = o.slice([0, 0], [n, t]).concat(y, 1);
        }
        return [u, a, o];
      }), u = e[0], a = e[1], o = e[2], Xe([s, c, l]);
    }, l = 0; l < s; ++l) c(l);

    return !e && n > r && (o = o.slice([0, 0], [n, r]), a = a.slice([0, 0], [r, r])), [o, a];
  });
}

var uh = Cn({
  gramSchmidt_: function (t) {
    var e;

    if (Array.isArray(t)) {
      e = !1, g(null != t && t.length > 0, function () {
        return "Gram-Schmidt process: input must not be null, undefined, or empty";
      });

      for (var n = t[0].shape[0], r = function (e) {
        g(t[e].shape[0] === n, function () {
          return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t[e].shape[0] + " vs. " + n + ")";
        });
      }, o = 1; o < t.length; ++o) r(o);
    } else e = !0, t = Xn(t, t.shape[0], 0).map(function (t) {
      return Dr(t, [0]);
    });

    g(t.length <= t[0].shape[0], function () {
      return "Gram-Schmidt: Number of vectors (" + t.length + ") exceeds number of dimensions (" + t[0].shape[0] + ").";
    });

    var a = [],
        i = t,
        u = function (t) {
      a.push(Nt.tidy(function () {
        var e = i[t];
        if (t > 0) for (var n = 0; n < t; ++n) {
          var r = ml(a[n].mulStrict(e)).mul(a[n]);
          e = e.sub(r);
        }
        return e.div(kl(e, "euclidean"));
      }));
    };

    for (o = 0; o < t.length; ++o) u(o);

    return e ? Tr(a, 0) : a;
  }
}),
    sh = Cn({
  qr_: function (t, e) {
    if (void 0 === e && (e = !1), t.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t.rank);
    if (2 === t.rank) return ih(t, e);
    var n = t.shape.slice(0, t.shape.length - 2).reduce(function (t, e) {
      return t * e;
    }),
        r = Or(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),
        o = [],
        a = [];
    return r.forEach(function (t) {
      var n = ih(t, e),
          r = n[0],
          i = n[1];
      o.push(r), a.push(i);
    }), [Tr(o, 0).reshape(t.shape), Tr(a, 0).reshape(t.shape)];
  }
}),
    ch = Object.freeze({
  gramSchmidt: uh,
  qr: sh
});
exports.linalg = ch;

function lh(t, e, n, r, o) {
  null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY);
  var a = t.shape[0];
  return n = Math.min(n, a), g(0 <= r && r <= 1, function () {
    return "iouThreshold must be in [0, 1], but was '" + r + "'";
  }), g(2 === t.rank, function () {
    return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'";
  }), g(4 === t.shape[1], function () {
    return "boxes must have 4 columns, but 2nd dimension was " + t.shape[1];
  }), g(1 === e.rank, function () {
    return "scores must be a 1D tensor";
  }), g(e.shape[0] === a, function () {
    return "scores has incompatible shape with boxes. Expected " + a + ", but was " + e.shape[0];
  }), {
    maxOutputSize: n,
    iouThreshold: r,
    scoreThreshold: o
  };
}

var hh = Cn({
  resizeBilinear_: function (t, e, n) {
    void 0 === n && (n = !1);
    var r = ln(t, "images", "resizeBilinear");
    g(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + ".";
    }), g(2 === e.length, function () {
      return "Error in resizeBilinear: new shape must 2D, but got shape " + e + ".";
    });
    var o = r,
        a = !1;
    3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
    var i = e[0],
        u = e[1],
        s = Nt.runKernelFunc(function (t, e) {
      return e([o]), t.resizeBilinear(o, i, u, n);
    }, {
      batchImages: o
    }, function (t, e) {
      return {
        batchImages: function () {
          return Nt.runKernelFunc(function (r) {
            return r.resizeBilinearBackprop(t, e[0], n);
          }, {});
        }
      };
    });
    return a ? s.as3D(s.shape[1], s.shape[2], s.shape[3]) : s;
  }
}),
    fh = Cn({
  resizeNearestNeighbor_: function (t, e, n) {
    void 0 === n && (n = !1);
    var r = ln(t, "images", "resizeNearestNeighbor");
    g(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + ".";
    }), g(2 === e.length, function () {
      return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + ".";
    }), g("float32" === r.dtype || "int32" === r.dtype, function () {
      return "`images` must have `int32` or `float32` as dtype";
    });
    var o = r,
        a = !1;
    3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
    var i = e[0],
        u = e[1],
        s = Nt.runKernelFunc(function (t, e) {
      return e([o]), t.resizeNearestNeighbor(o, i, u, n);
    }, {
      batchImages: o
    }, function (t, e) {
      return {
        batchImages: function () {
          return Nt.runKernelFunc(function (r) {
            return r.resizeNearestNeighborBackprop(t, e[0], n);
          }, {});
        }
      };
    });
    return a ? s.as3D(s.shape[1], s.shape[2], s.shape[3]) : s;
  }
}),
    ph = Cn({
  nonMaxSuppression_: function (t, e, n, r, o) {
    void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);
    var a = ln(t, "boxes", "nonMaxSuppression"),
        i = ln(e, "scores", "nonMaxSuppression"),
        u = lh(a, i, n, r, o);
    return n = u.maxOutputSize, r = u.iouThreshold, o = u.scoreThreshold, Nt.runKernelFunc(function (t) {
      return t.nonMaxSuppression(a, i, n, r, o);
    }, {
      $boxes: a
    });
  }
}),
    dh = function (t, e, o, a, i) {
  return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function () {
    var n, u, s, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = ln(t, "boxes", "nonMaxSuppressionAsync"), u = ln(e, "scores", "nonMaxSuppressionAsync"), s = lh(n, u, o, a, i), o = s.maxOutputSize, a = s.iouThreshold, i = s.scoreThreshold, [4, Promise.all([n.data(), u.data()])];

        case 1:
          return c = r.sent(), l = c[0], h = c[1], f = Mo(l, h, o, a, i), n !== t && n.dispose(), u !== e && u.dispose(), [2, f];
      }
    });
  });
},
    vh = Cn({
  cropAndResize_: function (t, e, n, r, o, a) {
    var i = ln(t, "image", "cropAndResize", "float32"),
        u = ln(e, "boxes", "cropAndResize", "float32"),
        s = ln(n, "boxInd", "cropAndResize", "int32");
    o = o || "bilinear", a = a || 0;
    var c = u.shape[0];
    return g(4 === i.rank, function () {
      return "Error in cropAndResize: image must be rank 4,but got rank " + i.rank + ".";
    }), g(2 === u.rank && 4 === u.shape[1], function () {
      return "Error in cropAndResize: boxes must be have size [" + c + ",4] but had shape " + u.shape + ".";
    }), g(1 === s.rank && s.shape[0] === c, function () {
      return "Error in cropAndResize: boxInd must be have size [" + c + "] but had shape " + u.shape + ".";
    }), g(2 === r.length, function () {
      return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + ".";
    }), g(r[0] >= 1 && r[1] >= 1, function () {
      return "cropSize must be atleast [1,1], but was " + r;
    }), g("bilinear" === o || "nearest" === o, function () {
      return "method must be bilinear or nearest, but was " + o;
    }), Nt.runKernelFunc(function (t, e) {
      return t.cropAndResize(i, u, s, r, o, a);
    }, {
      images: i,
      boxes: u,
      boxInd: s
    }, null, "CropAndResize", {
      method: o,
      extrapolationValue: a,
      cropSize: r
    });
  }
}),
    mh = Object.freeze({
  resizeBilinear: hh,
  resizeNearestNeighbor: fh,
  nonMaxSuppression: ph,
  nonMaxSuppressionAsync: dh,
  cropAndResize: vh
}),
    gh = function (t, e) {
  return !(t > 0) && ("linear" === e || "relu" === e);
},
    yh = function (t, e, n) {
  if (null == n || "linear" === n) return t;
  if ("relu" === n) return t.mul(e.step());
  throw new Error("Gradient for activation " + n + " has not been implemented yet.");
},
    xh = function (t, e) {
  var n = e,
      r = fo(t.shape, e.shape);
  return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);
},
    bh = function (t, e, n) {
  if ("linear" === e) return t;
  if ("relu" === e) return wl(t);
  if ("elu" === e) return yl(t);
  if ("relu6" === e) return Cl(t);
  if ("prelu" === e) return bl(t, n);
  throw new Error("Unknown fused activation " + e + ".");
};

exports.image = mh;
var wh = Cn({
  matMul_: function (t) {
    var e,
        n = t.a,
        r = t.b,
        o = t.transposeA,
        a = void 0 !== o && o,
        i = t.transposeB,
        u = void 0 !== i && i,
        s = t.bias,
        c = t.activation,
        l = void 0 === c ? "linear" : c,
        h = t.preluActivationWeights;

    if (!1 === gh(Nt.state.gradientDepth, l)) {
      var f = Uc(n, r, a, u);
      return null != s && (f = Vs(f, s)), bh(f, l, h);
    }

    var p = ln(n, "a", "fused matMul"),
        d = ln(r, "b", "fused matMul");
    e = Rt(p, d), p = e[0], d = e[1];
    var v = a ? p.shape[p.rank - 2] : p.shape[p.rank - 1],
        m = u ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
        y = a ? p.shape[p.rank - 1] : p.shape[p.rank - 2],
        x = u ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
        b = p.shape.slice(0, -2),
        E = d.shape.slice(0, -2),
        R = w(b),
        I = w(E);
    g(p.rank >= 2 && d.rank >= 2 && p.rank === d.rank, function () {
      return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + p.rank + " and " + d.rank + ".";
    }), g(C(b, E), function () {
      return "Error in fused matMul: outer dimensions (" + b + ") and (" + E + ") of Tensors with shapes " + p.shape + " and " + d.shape + " must match.";
    }), g(v === m, function () {
      return "Error in fused matMul: inner shapes (" + v + ") and (" + m + ") of Tensors with shapes " + p.shape + " and " + d.shape + " and transposeA=" + a + " and transposeB=" + u + " must match.";
    });
    var k,
        S,
        A = p.shape.slice(0, -2).concat([y, x]),
        D = a ? p.as3D(R, v, y) : p.as3D(R, y, v),
        T = u ? d.as3D(I, x, m) : d.as3D(I, m, x);
    null != s && po(A, (k = Rt(k = ln(s, "bias", "fused matMul"), p)[0]).shape), null != h && (S = ln(h, "prelu weights", "fused matMul"));
    var N = {
      $a: D,
      $b: T
    };
    return null != s && (N.$bias = k), null != h && (N.$preluActivationWeights = S), Nt.runKernelFunc(function (t, e) {
      var n = t.fusedBatchMatMul({
        a: D,
        b: T,
        transposeA: a,
        transposeB: u,
        bias: k,
        activation: l,
        preluActivationWeights: S
      });
      return e([D, T, n]), n;
    }, N, function (t, e) {
      var n = e[0],
          r = e[1],
          o = e[2],
          i = yh(t, o, l),
          c = {};
      return null != s && (c = {
        $bias: function () {
          return xh(k, i);
        }
      }), a || u ? !a && u ? Object.assign({
        $a: function () {
          return i.matMul(r, !1, !1);
        },
        $b: function () {
          return i.matMul(n, !0, !1);
        }
      }, c) : a && !u ? Object.assign({
        $a: function () {
          return r.matMul(i, !1, !0);
        },
        $b: function () {
          return n.matMul(i, !1, !1);
        }
      }, c) : Object.assign({
        $a: function () {
          return r.matMul(i, !0, !0);
        },
        $b: function () {
          return i.matMul(n, !0, !0);
        }
      }, c) : Object.assign({
        $a: function () {
          return i.matMul(r, !1, !0);
        },
        $b: function () {
          return n.matMul(i, !0, !1);
        }
      }, c);
    }).reshape(A);
  }
}),
    Ch = Cn({
  conv2d_: function (t) {
    var e = t.x,
        n = t.filter,
        r = t.strides,
        o = t.pad,
        a = t.dataFormat,
        i = void 0 === a ? "NHWC" : a,
        u = t.dilations,
        s = void 0 === u ? [1, 1] : u,
        c = t.dimRoundingMode,
        l = t.bias,
        h = t.activation,
        f = void 0 === h ? "linear" : h,
        p = t.preluActivationWeights;

    if (f = f || "linear", !1 === gh(Nt.state.gradientDepth, f)) {
      var d = Tc(e, n, r, o, i, s, c);
      return null != l && (d = Vs(d, l)), bh(d, f, p);
    }

    var v = ln(e, "x", "conv2d"),
        m = ln(n, "filter", "conv2d"),
        y = v,
        x = !1;
    3 === v.rank && (x = !0, y = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), g(4 === y.rank, function () {
      return "Error in fused conv2d: input must be rank 4, but got rank " + y.rank + ".";
    }), g(4 === m.rank, function () {
      return "Error in fused conv2d: filter must be rank 4, but got rank " + m.rank + ".";
    }), null != c && g(E(o), function () {
      return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c + " but got pad " + o + ".";
    }), g(y.shape[3] === m.shape[2], function () {
      return "Error in conv2d: depth of input (" + y.shape[3] + ") must match input depth for filter " + m.shape[2] + ".";
    }), g(Io(r, s), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + s + "'";
    }), g("NHWC" === i, function () {
      return "Error in conv2d: got dataFormat of " + i + " but only NHWC is currently supported.";
    });
    var b,
        w,
        C = go(y.shape, m.shape, r, s, o, c);
    null != l && (b = Rt(b = ln(l, "bias", "fused conv2d"), v)[0], po(C.outShape, b.shape)), null != p && (w = ln(p, "prelu weights", "fused conv2d"));
    var R = {
      x: y,
      filter: m
    };
    null != l && (R.bias = b), null != p && (R.preluActivationWeights = w);
    var I = [m, y],
        k = Nt.runKernelFunc(function (t, e) {
      var n = t.fusedConv2d({
        input: y,
        filter: m,
        convInfo: C,
        bias: b,
        activation: f,
        preluActivationWeights: w
      });
      return e([m, y, n]), n;
    }, R, function (t, e) {
      var n = e,
          a = n[0],
          i = n[1],
          u = n[2],
          c = yh(t, u, f);
      g(Ro(s), function () {
        return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + s + "'";
      });
      var h = {};
      return null != l && (h = {
        $bias: function () {
          return xh(b, c);
        }
      }), Object.assign({
        x: function () {
          return Oc(i.shape, c, a, r, o);
        },
        filter: function () {
          return Fc(i, c, a.shape, r, o);
        }
      }, h);
    }, "FusedConv2D", {
      convInfo: C,
      activation: f
    }, I, [!0]);
    return x ? k.as3D(k.shape[1], k.shape[2], k.shape[3]) : k;
  }
}),
    Eh = Cn({
  depthwiseConv2d_: function (t) {
    var e = t.x,
        n = t.filter,
        r = t.strides,
        o = t.pad,
        a = t.dataFormat,
        i = void 0 === a ? "NHWC" : a,
        u = t.dilations,
        s = void 0 === u ? [1, 1] : u,
        c = t.dimRoundingMode,
        l = t.bias,
        h = t.activation,
        f = void 0 === h ? "linear" : h,
        p = t.preluActivationWeights;

    if (!1 === gh(Nt.state.gradientDepth, f)) {
      var d = _c(e, n, r, o, i, s, c);

      return null != l && (d = Vs(d, l)), bh(d, f, p);
    }

    var v = ln(e, "x", "depthwiseConv2d"),
        m = ln(n, "filter", "depthwiseConv2d"),
        y = v,
        x = !1;
    3 === v.rank && (x = !0, y = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), g(4 === y.rank, function () {
      return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + y.rank + ".";
    }), g(4 === m.rank, function () {
      return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m.rank + ".";
    }), g(y.shape[3] === m.shape[2], function () {
      return "Error in fused depthwiseConv2d: number of input channels (" + y.shape[3] + ") must match the inChannels dimension in filter " + m.shape[2] + ".";
    }), null == s && (s = [1, 1]), g(Io(r, s), function () {
      return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + s + "'";
    }), null != c && g(E(o), function () {
      return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c + " but got pad " + o + ".";
    });
    var b,
        w,
        C = go(y.shape, m.shape, r, s, o, c, !0);
    null != l && (b = Rt(b = ln(l, "bias", "fused conv2d"), v)[0], po(C.outShape, b.shape)), null != p && (w = ln(p, "prelu weights", "fused depthwiseConv2d"));
    var R = {
      x: y,
      $filter: m
    };
    null != l && (R.$bias = b), null != p && (R.$preluActivationWeights = w);
    var I = Nt.runKernelFunc(function (t, e) {
      var n = t.fusedDepthwiseConv2D({
        input: y,
        filter: m,
        convInfo: C,
        bias: b,
        activation: f,
        preluActivationWeights: w
      });
      return e([y, m, n]), n;
    }, R, function (t, e) {
      g(Ro(s), function () {
        return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + s + "'";
      });
      var n = e[0],
          r = e[1],
          o = e[2],
          a = yh(t, o, f),
          i = {};
      return null != l && (i = {
        $bias: function () {
          return xh(b, a);
        }
      }), Object.assign({
        x: function () {
          return Mc(n.shape, a, r, C);
        },
        $filter: function () {
          return Bc(n, a, r.shape, C);
        }
      }, i);
    });
    return x ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
  }
}),
    Rh = Object.freeze({
  matMul: wh,
  conv2d: Ch,
  depthwiseConv2d: Eh
}),
    Ih = Object.freeze({
  image: mh,
  linalg: ch,
  losses: ah,
  spectral: Pl,
  fused: Rh,
  signal: jl,
  square: Uu,
  conv1d: Dc,
  conv2d: Tc,
  conv3d: Nc,
  depthwiseConv2d: _c,
  separableConv2d: Pc,
  conv2dTranspose: Lc,
  conv3dTranspose: Wc,
  op: Cn,
  batchNormalization2d: Ss,
  batchNormalization3d: As,
  batchNormalization4d: Ds,
  batchNormalization: Ts,
  batchNorm: Ns,
  batchNorm2d: Fs,
  batchNorm3d: Os,
  batchNorm4d: _s,
  booleanMaskAsync: Ic,
  complex: En,
  real: Rn,
  imag: In,
  concat: Gn,
  concat1d: Hn,
  concat2d: qn,
  concat3d: Kn,
  concat4d: jn,
  split: Xn,
  matMul: Uc,
  dot: Vc,
  outerProduct: zc,
  reverse: Gc,
  reverse1d: Hc,
  reverse2d: qc,
  reverse3d: Kc,
  reverse4d: jc,
  maxPool: Yc,
  avgPool: Qc,
  pool: Jc,
  maxPool3d: Zc,
  avgPool3d: tl,
  slice: el,
  slice1d: nl,
  slice2d: rl,
  slice3d: ol,
  slice4d: al,
  abs: Vu,
  acos: zu,
  acosh: Gu,
  asin: Hu,
  asinh: qu,
  atan: Ku,
  atanh: ju,
  ceil: Xu,
  clipByValue: $u,
  cos: Yu,
  cosh: Qu,
  erf: Ju,
  exp: Zu,
  expm1: ts,
  floor: es,
  log: ns,
  log1p: rs,
  logSigmoid: os,
  neg: as,
  reciprocal: is,
  round: us,
  rsqrt: ss,
  sigmoid: cs,
  sign: ls,
  isNaN: hs,
  isInf: fs,
  isFinite: ps,
  sin: ds,
  sinh: vs,
  softplus: ms,
  sqrt: gs,
  step: ys,
  tan: xs,
  tanh: bs,
  all: ul,
  any: sl,
  argMax: cl,
  argMin: ll,
  logSumExp: hl,
  max: fl,
  mean: pl,
  min: dl,
  moments: vl,
  sum: ml,
  prod: gl,
  equal: cc,
  equalStrict: lc,
  greater: hc,
  greaterEqual: fc,
  greaterEqualStrict: pc,
  greaterStrict: dc,
  less: vc,
  lessEqual: mc,
  lessEqualStrict: gc,
  lessStrict: yc,
  notEqual: xc,
  notEqualStrict: bc,
  add: Vs,
  addN: zs,
  addStrict: Gs,
  atan2: Hs,
  div: qs,
  divNoNan: Ks,
  divStrict: js,
  floorDiv: Xs,
  maximum: $s,
  maximumStrict: Ys,
  minimum: Qs,
  minimumStrict: Js,
  mod: Zs,
  modStrict: tc,
  mul: ec,
  mulStrict: nc,
  pow: rc,
  powStrict: oc,
  squaredDifference: ac,
  squaredDifferenceStrict: ic,
  sub: uc,
  subStrict: sc,
  elu: yl,
  leakyRelu: xl,
  prelu: bl,
  relu: wl,
  relu6: Cl,
  selu: El,
  logicalAnd: Ms,
  logicalNot: Bs,
  logicalOr: Ps,
  logicalXor: Ls,
  where: Ws,
  whereAsync: Us,
  buffer: ur,
  print: sr,
  batchToSpaceND: cr,
  cast: lr,
  clone: hr,
  cumsum: fr,
  depthToSpace: pr,
  expandDims: dr,
  eye: vr,
  multinomial: mr,
  oneHot: gr,
  pad: yr,
  pad1d: xr,
  pad2d: br,
  pad3d: wr,
  pad4d: Cr,
  rand: Er,
  randomNormal: Rr,
  randomGamma: Ir,
  randomUniform: kr,
  reshape: Sr,
  spaceToBatchND: Ar,
  squeeze: Dr,
  stack: Tr,
  tile: Nr,
  truncatedNormal: Fr,
  unstack: Or,
  setdiff1dAsync: _r,
  fill: Ln,
  linspace: Wn,
  ones: Bn,
  range: Un,
  scalar: An,
  tensor: kn,
  tensor1d: Dn,
  tensor2d: Tn,
  tensor3d: Nn,
  tensor4d: Fn,
  tensor5d: On,
  tensor6d: _n,
  variable: Mn,
  zeros: Pn,
  onesLike: Vn,
  zerosLike: zn,
  transpose: Rl,
  softmax: io,
  logSoftmax: uo,
  localResponseNormalization: Il,
  norm: kl,
  gather: Ec,
  unsortedSegmentSum: Rc,
  basicLSTMCell: Sl,
  multiRNNCell: Al,
  movingAverage: Dl,
  stridedSlice: Tl,
  topk: Nl,
  scatterND: Fl,
  fft: Ol,
  ifft: _l,
  rfft: Ml,
  irfft: Bl,
  sparseToDense: Ll,
  gatherND: Wl,
  diag: Ul,
  dropout: Vl,
  hannWindow: Gl,
  hammingWindow: Hl,
  frame: ql,
  stft: Kl,
  inTopKAsync: $l
});
exports.fused = Rh;

function kh(t, e) {
  Array.isArray(t) || (t = [t]), t.forEach(function (t) {
    null != t && g("complex64" !== t.dtype, function () {
      return e + " does not support complex64 tensors.";
    });
  });
}

function Sh(t, e, n, r) {
  if ("linear" === n) return t.linear(e);
  if ("relu" === n) return t.relu(e);
  if ("elu" === n) return t.elu(e);
  if ("relu6" === n) return t.relu6(e);
  if ("prelu" === n) return t.prelu(e, r);
  throw new Error("Activation " + n + " has not been implemented for the CPU backend.");
}

var Ah = function (t) {
  function o() {
    var e = t.call(this) || this;

    if (e.blockSize = 48, e.firstUse = !0, a().get("IS_BROWSER")) {
      var n = "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(300, 150) : "undefined" != typeof document ? document.createElement("canvas") : null;
      null !== n && (e.fromPixels2DContext = n.getContext("2d"));
    }

    return e.data = new so(e, Nt), e;
  }

  return e(o, t), o.prototype.write = function (t, e, n) {
    this.firstUse && (this.firstUse = !1, a().get("IS_NODE") && un("\n============================\nHi there ð. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n"));
    var r = {};
    return this.data.set(r, {
      values: t,
      dtype: n
    }), r;
  }, o.prototype.move = function (t, e, n, r) {
    this.data.set(t, {
      values: e,
      dtype: r
    });
  }, o.prototype.numDataIds = function () {
    return this.data.numDataIds();
  }, o.prototype.fromPixels = function (t, e) {
    if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n,
        r,
        o = t.data instanceof Uint8Array,
        i = "undefined" != typeof ImageData && t instanceof ImageData,
        u = "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement,
        s = "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement,
        c = u ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
        l = c[0],
        h = c[1];
    if (a().get("IS_NODE") && null == t.getContext) throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");
    if (null != t.getContext) n = t.getContext("2d").getImageData(0, 0, l, h).data;else if (i || o) n = t.data;else {
      if (!s && !u) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
      if (null == this.fromPixels2DContext) throw new Error("Can't read pixels from HTMLImageElement outside the browser.");
      this.fromPixels2DContext.canvas.width = l, this.fromPixels2DContext.canvas.height = h, this.fromPixels2DContext.drawImage(t, 0, 0, l, h), n = this.fromPixels2DContext.getImageData(0, 0, l, h).data;
    }
    if (4 === e) r = new Int32Array(n);else {
      var f = l * h;
      r = new Int32Array(f * e);

      for (var p = 0; p < f; p++) for (var d = 0; d < e; ++d) r[p * e + d] = n[4 * p + d];
    }
    return Nn(r, [h, l, e], "int32");
  }, o.prototype.read = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        return [2, this.readSync(t)];
      });
    });
  }, o.prototype.readSync = function (t) {
    var e = this.data.get(t),
        n = e.dtype,
        r = e.complexTensors;
    return "complex64" === n ? No(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values;
  }, o.prototype.bufferSync = function (t) {
    var e = this.readSync(t.dataId),
        n = e;
    if ("string" === t.dtype) try {
      n = e.map(function (t) {
        return Z(t);
      });
    } catch (t) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return ur(t.shape, t.dtype, n);
  }, o.prototype.makeOutput = function (t, e, n) {
    var r = this.write(t, e, n);
    return Nt.makeTensorFromDataId(r, e, n, this);
  }, o.prototype.disposeData = function (t) {
    if (this.data.has(t)) {
      var e = this.data.get(t).complexTensors;
      null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);
    }
  }, o.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return e = Y(), t(), [2, {
          kernelMs: Y() - e
        }];
      });
    });
  }, o.prototype.memory = function () {
    return {
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }, o.prototype.complex = function (t, e) {
    var n = this.makeOutput(null, t.shape, "complex64");
    return this.data.get(n.dataId).complexTensors = {
      real: Nt.keep(t.clone()),
      imag: Nt.keep(e.clone())
    }, n;
  }, o.prototype.real = function (t) {
    return this.data.get(t.dataId).complexTensors.real.clone();
  }, o.prototype.imag = function (t) {
    return this.data.get(t.dataId).complexTensors.imag.clone();
  }, o.prototype.slice = function (t, e, n) {
    if (kh(t, "slice"), Yr(t.shape, e, n)) {
      var r = Qr(e, t.strides),
          o = w(n);
      return kn(this.readSync(t.dataId).subarray(r, r + o), n, t.dtype);
    }

    for (var a = ur(n, t.dtype), i = this.bufferSync(t), u = 0; u < a.size; ++u) {
      var s = a.indexToLoc(u).map(function (t, n) {
        return t + e[n];
      });
      a.values[u] = i.get.apply(i, s);
    }

    return a.toTensor();
  }, o.prototype.stridedSlice = function (t, e, n, r) {
    kh(t, "stridedSlice");
    var o = jr(e, n, r);
    if (o.some(function (t) {
      return 0 === t;
    })) return kn([], o);

    for (var a = ur(o, t.dtype), i = this.bufferSync(t), u = 0; u < a.size; u++) {
      for (var s = a.indexToLoc(u), c = new Array(s.length), l = 0; l < c.length; l++) c[l] = s[l] * r[l] + e[l];

      a.set.apply(a, [i.get.apply(i, c)].concat(s));
    }

    return a.toTensor();
  }, o.prototype.diag = function (t) {
    for (var e = this.readSync(t.dataId), n = ur([t.size, t.size], t.dtype), r = n.values, o = 0; o < e.length; o++) r[o * t.size + o] = e[o];

    return n.toTensor();
  }, o.prototype.unstack = function (t, e) {
    for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++) a !== e && (r[o++] = t.shape[a]);

    var i = new Array(t.rank).fill(0),
        u = t.shape.slice();
    u[e] = 1;
    var s = new Array(n);

    for (a = 0; a < s.length; a++) i[e] = a, s[a] = this.slice(t, i, u).reshape(r);

    return s;
  }, o.prototype.reverse = function (t, e) {
    kh(t, "reverse");

    for (var n = ur(t.shape, t.dtype), r = this.bufferSync(t), o = function (o) {
      var a = n.indexToLoc(o),
          i = a.slice();
      e.forEach(function (e) {
        return i[e] = t.shape[e] - 1 - i[e];
      }), n.set.apply(n, [r.get.apply(r, i)].concat(a));
    }, a = 0; a < n.size; a++) o(a);

    return n.toTensor();
  }, o.prototype.concat = function (t, e) {
    var n = this;

    if ("complex64" === t[0].dtype) {
      var r = t.map(function (t) {
        return Rn(t);
      }),
          o = t.map(function (t) {
        return In(t);
      });
      return En(this.concat(r, e), this.concat(o, e));
    }

    var a = t.map(function (t) {
      var n = w(t.shape.slice(e));
      return t.as2D(-1, n);
    }),
        i = wn(a.map(function (t) {
      return t.shape;
    }), 1),
        u = ur(i, t[0].dtype).values;

    if (1 === a[0].shape[0]) {
      var s = 0;
      a.forEach(function (t) {
        u.set(n.readSync(t.dataId), s), s += t.size;
      });
    } else {
      var c = 0;
      a.forEach(function (t) {
        for (var e = n.readSync(t.dataId), r = 0, o = 0; o < t.shape[0]; ++o) for (var a = o * i[1] + c, s = 0; s < t.shape[1]; ++s) u[a + s] = e[r++];

        c += t.shape[1];
      });
    }

    var l = wn(t.map(function (t) {
      return t.shape;
    }), e);
    return kn(u, l, t[0].dtype);
  }, o.prototype.neg = function (t) {
    return kh(t, "neg"), this.multiply(An(-1), t);
  }, o.prototype.add = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t + n,
        imag: e + r
      };
    }) : this.broadcastedBinaryOp(t, e, Ct(t.dtype, e.dtype), function (t, e) {
      return t + e;
    });
  }, o.prototype.addN = function (t) {
    var e = this;
    kh(t, "addN");

    for (var n = t.map(function (t) {
      return e.readSync(t.dataId);
    }), r = ur(t[0].shape, t[0].dtype), o = r.values, a = 0; a < t.length; a++) for (var i = n[a], u = 0; u < o.length; u++) o[u] += i[u];

    return r.toTensor();
  }, o.prototype.subtract = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t - n,
        imag: e - r
      };
    }) : this.broadcastedBinaryOp(t, e, Ct(t.dtype, e.dtype), function (t, e) {
      return t - e;
    });
  }, o.prototype.pow = function (t, e) {
    return kh([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.pow(t, e);
    });
  }, o.prototype.batchMatMul = function (t, e, n, r) {
    kh([t, e], "matMul");

    for (var o = n ? t.shape[1] : t.shape[2], a = n ? t.shape[2] : t.shape[1], i = r ? e.shape[1] : e.shape[2], u = t.shape[0], s = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], f = l[1], p = l[2], d = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], v = d[0], m = d[1], g = d[2], y = a * i, x = ur([u, a, i], t.dtype), b = x.values, w = this.blockSize, C = 0; C < u; C++) for (var E = 0; E < a; E += w) for (var R = 0; R < i; R += w) for (var I = 0; I < o; I += w) for (var k = Math.min(E + w, a), S = Math.min(R + w, i), A = Math.min(I + w, o), D = E; D < k; D++) for (var T = R; T < S; T++) {
      for (var N = 0, F = I; F < A; F++) N += s[C * h + D * f + F * p] * c[F * v + T * m + C * g];

      b[C * y + (D * i + T)] += N;
    }

    return x.toTensor();
  }, o.prototype.fusedBatchMatMul = function (t) {
    var e = t.a,
        n = t.b,
        r = t.transposeA,
        o = t.transposeB,
        a = t.bias,
        i = t.activation,
        u = t.preluActivationWeights,
        s = this.batchMatMul(e, n, r, o);
    return a && (s = this.add(s, a)), i && (s = Sh(this, s, i, u)), s;
  }, o.prototype.multiply = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t * n - e * r,
        imag: t * r + e * n
      };
    }) : this.broadcastedBinaryOp(t, e, Ct(t.dtype, e.dtype), function (t, e) {
      return t * e;
    });
  }, o.prototype.realDivide = function (t, e) {
    kh([t, e], "realDivide");
    return this.broadcastedBinaryOp(t, e, "float32", function (t, e) {
      return t / e;
    });
  }, o.prototype.floorDiv = function (t, e) {
    kh([t, e], "floorDiv");
    return this.broadcastedBinaryOp(t, e, "int32", function (t, e) {
      return Math.floor(t / e);
    });
  }, o.prototype.sum = function (t, e) {
    kh(t, "sum"), mn("sum", e, t.rank);

    for (var n = dn(t.shape, e), r = n[0], o = n[1], a = Pn(r, Ct(t.dtype, "int32")), i = w(o), u = this.readSync(a.dataId), s = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
      for (var l = c * i, h = 0, f = 0; f < i; ++f) h += s[l + f];

      u[c] = h;
    }

    return a;
  }, o.prototype.prod = function (t, e) {
    kh(t, "sum");

    for (var n = dn(t.shape, e), r = n[0], o = n[1], a = Pn(r, Ct(t.dtype, "int32")), i = w(o), u = this.readSync(a.dataId), s = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
      for (var l = c * i, h = 1, f = 0; f < i; ++f) h *= s[l + f];

      u[c] = h;
    }

    return a;
  }, o.prototype.unsortedSegmentSum = function (t, e, n) {
    kh(t, "unsortedSegmentSum");

    for (var r = [], o = t.rank - e.rank, a = 0; a < o; ++a) e = e.expandDims(a + 1);

    for (a = 0; a < n; ++a) {
      var i = An(a, "int32"),
          u = cc(i, e).asType("float32").mul(t).sum(0);
      r.push(u);
    }

    return Tr(r);
  }, o.prototype.argMin = function (t, e) {
    kh(t, "argMin");
    var n = [e];
    mn("argMin", n, t.rank);

    for (var r = dn(t.shape, n), o = r[0], a = r[1], i = Pn(o, "int32"), u = w(a), s = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
      for (var h = l * u, f = c[h], p = 0, d = 0; d < u; ++d) {
        var v = c[h + d];
        v < f && (f = v, p = d);
      }

      s[l] = p;
    }

    return i;
  }, o.prototype.argMax = function (t, e) {
    kh(t, "argMax");
    var n = [e];
    mn("argMax", n, t.rank);

    for (var r = dn(t.shape, n), o = r[0], a = r[1], i = Pn(o, "int32"), u = w(a), s = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
      for (var h = l * u, f = c[h], p = 0, d = 0; d < u; ++d) {
        var v = c[h + d];
        v > f && (f = v, p = d);
      }

      s[l] = p;
    }

    return i;
  }, o.prototype.cumsum = function (t, e, n, r) {
    if (kh(t, "cumsum"), e !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);

    for (var o = Ct(t.dtype, "int32"), a = Pn(t.shape, o), i = this.readSync(a.dataId), u = this.readSync(t.dataId), s = t.shape[t.rank - 1], c = r ? function (t, e) {
      return t + s - e - 1;
    } : function (t, e) {
      return t + e;
    }, l = 0; l < u.length; l += s) for (var h = 0; h < s; h++) {
      var f = c(l, h);
      if (0 === h) i[f] = n ? 0 : u[f];else {
        var p = c(l, h - 1);
        i[f] = n ? u[p] + i[p] : u[f] + i[p];
      }
    }

    return a;
  }, o.prototype.equal = function (t, e) {
    return kh([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t === e ? 1 : 0;
    });
  }, o.prototype.notEqual = function (t, e) {
    return kh([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t !== e ? 1 : 0;
    });
  }, o.prototype.less = function (t, e) {
    return kh([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t < e ? 1 : 0;
    });
  }, o.prototype.lessEqual = function (t, e) {
    return kh([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t <= e ? 1 : 0;
    });
  }, o.prototype.greater = function (t, e) {
    return kh([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t > e ? 1 : 0;
    });
  }, o.prototype.greaterEqual = function (t, e) {
    return kh([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t >= e ? 1 : 0;
    });
  }, o.prototype.logicalNot = function (t) {
    kh(t, "logicalNot");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.logicalAnd = function (t, e) {
    return kh([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t && e;
    });
  }, o.prototype.logicalOr = function (t, e) {
    return kh([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t || e;
    });
  }, o.prototype.select = function (t, e, n) {
    kh([t, e, n], "select");

    for (var r = this.readSync(t.dataId), o = this.readSync(e.dataId), a = this.readSync(n.dataId), i = Pn(e.shape, Ct(e.dtype, n.dtype)), u = this.readSync(i.dataId), s = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : w(e.shape.slice(1)), l = 0; l < r.length; l++) for (var h = 0; h < c; h++) 1 === r[l] ? u[s++] = o[l] : u[s++] = a[l];

    return i;
  }, o.prototype.where = function (t) {
    kh([t], "where");
    var e = this.readSync(t.dataId);
    return Uo(t.shape, e);
  }, o.prototype.topk = function (t, e, n) {
    return kh(t, "topk"), Wo(this.readSync(t.dataId), t.shape, t.dtype, e);
  }, o.prototype.min = function (t, e) {
    kh(t, "min"), mn("min", e, t.rank);

    for (var n = dn(t.shape, e), r = n[0], o = n[1], a = Pn(r, t.dtype), i = w(o), u = this.readSync(a.dataId), s = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
      for (var l = c * i, h = s[l], f = 0; f < i; ++f) {
        var p = s[l + f];
        p < h && (h = p);
      }

      u[c] = h;
    }

    return a;
  }, o.prototype.minimum = function (t, e) {
    return kh([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.min(t, e);
    });
  }, o.prototype.mod = function (t, e) {
    return kh([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      var n = t % e;
      return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;
    });
  }, o.prototype.max = function (t, e) {
    kh(t, "max"), mn("max", e, t.rank);

    for (var n = dn(t.shape, e), r = n[0], o = n[1], a = Pn(r, t.dtype), i = w(o), u = this.readSync(a.dataId), s = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
      for (var l = c * i, h = s[l], f = 0; f < i; ++f) {
        var p = s[l + f];
        p > h && (h = p);
      }

      u[c] = h;
    }

    return a;
  }, o.prototype.maximum = function (t, e) {
    return kh([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.max(t, e);
    });
  }, o.prototype.all = function (t, e) {
    kh(t, "all"), mn("all", e, t.rank);

    for (var n = dn(t.shape, e), r = n[0], o = n[1], a = Pn(r, t.dtype), i = w(o), u = this.readSync(a.dataId), s = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
      for (var l = c * i, h = s[l], f = 0; f < i; ++f) {
        var p = s[l + f];
        h = h && p;
      }

      u[c] = h;
    }

    return a;
  }, o.prototype.any = function (t, e) {
    kh(t, "any"), mn("any", e, t.rank);

    for (var n = dn(t.shape, e), r = n[0], o = n[1], a = Pn(r, t.dtype), i = w(o), u = this.readSync(a.dataId), s = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
      for (var l = c * i, h = s[l], f = 0; f < i; ++f) {
        var p = s[l + f];
        h = h || p;
      }

      u[c] = h;
    }

    return a;
  }, o.prototype.squaredDifference = function (t, e) {
    return kh([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      var n = t - e;
      return n * n;
    });
  }, o.prototype.ceil = function (t) {
    kh(t, "ceil");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.floor = function (t) {
    kh(t, "floor");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sign = function (t) {
    kh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.isNaN = function (t) {
    kh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.isInf = function (t) {
    kh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.isFinite = function (t) {
    kh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.round = function (t) {
    kh(t, "round");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = Math.floor(e[r]);
      e[r] - o < .5 ? n[r] = Math.floor(e[r]) : e[r] - o > .5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.exp = function (t) {
    kh(t, "exp");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.expm1 = function (t) {
    kh(t, "expm1");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.log = function (t) {
    kh(t, "log");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.log(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.log1p = function (t) {
    kh(t, "log1p");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.log1p(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sqrt = function (t) {
    kh(t, "sqrt");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.sqrt(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.rsqrt = function (t) {
    kh(t, "rsqrt");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = 1 / Math.sqrt(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.reciprocal = function (t) {
    kh(t, "reciprocal");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.linear = function (t) {
    return t;
  }, o.prototype.relu = function (t) {
    kh(t, "relu");

    for (var e = Pn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.max(0, r[o]);

    return e;
  }, o.prototype.relu6 = function (t) {
    kh(t, "relu");

    for (var e = Pn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.min(Math.max(0, r[o]), 6);

    return e;
  }, o.prototype.prelu = function (t, e) {
    return kh([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return t < 0 ? e * t : t;
    });
  }, o.prototype.elu = function (t) {
    kh(t, "elu");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
      var o = n[r];
      e[r] = o >= 0 ? o : Math.exp(o) - 1;
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.eluDer = function (t, e) {
    kh([t, e], "eluDer");

    for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), a = 0; a < r.length; ++a) {
      var i = r[a];
      n[a] = i >= 1 ? o[a] : o[a] * (i + 1);
    }

    return this.makeOutput(n, e.shape, "float32");
  }, o.prototype.selu = function (t) {
    kh(t, "selu");

    for (var e = iu, n = uu, r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a) {
      var i = o[a];
      r[a] = i >= 0 ? n * i : e * (Math.exp(i) - 1);
    }

    return this.makeOutput(r, t.shape, "float32");
  }, o.prototype.clip = function (t, e, n) {
    kh(t, "clip");

    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a) {
      var i = o[a];
      r[a] = i > n ? n : i < e ? e : i;
    }

    return this.makeOutput(r, t.shape, "float32");
  }, o.prototype.abs = function (t) {
    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.complexAbs = function (t) {
    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
      var o = n[2 * r],
          a = n[2 * r + 1];
      e[r] = Math.hypot(o, a);
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.int = function (t) {
    kh(t, "int");

    for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];

    return this.makeOutput(e, t.shape, "int32");
  }, o.prototype.sigmoid = function (t) {
    kh(t, "sigmoid");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.softplus = function (t) {
    kh(t, "softplus");

    for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
      var a = r[o] > -e,
          i = r[o] < e,
          u = Math.exp(r[o]),
          s = void 0;
      s = i ? u : a ? r[o] : Math.log(1 + u), n[o] = s;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sin = function (t) {
    kh(t, "sin");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.cos = function (t) {
    kh(t, "cos");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.tan = function (t) {
    kh(t, "tan");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.asin = function (t) {
    kh(t, "asin");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.acos = function (t) {
    kh(t, "acos");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atan = function (t) {
    kh(t, "atan");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atan2 = function (t, e) {
    return kh([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.atan2(t, e);
    });
  }, o.prototype.sinh = function (t) {
    kh(t, "sinh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.cosh = function (t) {
    kh(t, "cosh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.tanh = function (t) {
    kh(t, "tanh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = R(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.asinh = function (t) {
    kh(t, "asinh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.acosh = function (t) {
    kh(t, "acosh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atanh = function (t) {
    kh(t, "atanh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.erf = function (t) {
    kh(t, "erf");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
      var o = Math.sign(n[r]),
          a = Math.abs(n[r]),
          i = 1 / (1 + .3275911 * a);
      e[r] = o * (1 - ((((1.061405429 * i - 1.453152027) * i + 1.421413741) * i - .284496736) * i + .254829592) * i * Math.exp(-a * a));
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.step = function (t, e) {
    void 0 === e && (e = 0), kh(t, "step");

    for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
      var a = r[o];
      isNaN(a) ? n[o] = NaN : n[o] = a > 0 ? 1 : e;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.fusedConv2d = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        i = t.preluActivationWeights,
        u = this.conv2d(e, n, r);
    return o && (u = this.add(u, o)), a && (u = Sh(this, u, a, i)), u;
  }, o.prototype.conv2d = function (t, e, n) {
    kh([t, e], "conv2d");

    for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, u = n.padInfo.left, s = n.padInfo.top, c = "channelsLast" === n.dataFormat, l = ur(n.outShape, t.dtype), h = t.strides[0], f = c ? t.strides[1] : t.strides[2], p = c ? t.strides[2] : 1, d = c ? 1 : t.strides[1], v = l.strides[0], m = c ? l.strides[1] : l.strides[2], g = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], x = this.readSync(t.dataId), b = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C) for (var E = C * h, R = C * v, I = 0; I < n.outHeight; ++I) for (var k = R + I * m, S = I * n.strideHeight - s, A = 0; A < r; A++) {
      var D = S + A * a;
      if (!(D < 0 || D >= n.inHeight)) for (var T = A * e.strides[0], N = E + D * f, F = 0; F < n.outWidth; ++F) for (var O = k + F * g, _ = F * n.strideWidth - u, M = 0; M < o; M++) {
        var B = _ + M * i;
        if (!(B < 0 || B >= n.inWidth)) for (var P = N + B * p, L = T + M * e.strides[1], W = 0; W < n.inChannels; ++W) {
          for (var U = x[P + W * d], V = 0; V < n.outChannels; ++V) w[O + V * y] += U * b[L + V];

          L += n.outChannels;
        }
      }
    }

    return l.toTensor();
  }, o.prototype.conv3d = function (t, e, n) {
    for (var r = n.filterDepth, o = n.filterHeight, a = n.filterWidth, i = n.dilationDepth, u = n.dilationHeight, s = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, f = ur(n.outShape, t.dtype), p = this.readSync(t.dataId), d = this.readSync(e.dataId), v = f.values, m = 0; m < n.batchSize; ++m) for (var g = m * t.strides[0], y = m * f.strides[0], x = 0; x < n.outDepth; ++x) for (var b = y + x * f.strides[1], w = x * n.strideDepth - c, C = 0; C < r; C++) {
      var E = w + C * i;
      if (!(E < 0 || E >= n.inDepth)) for (var R = C * e.strides[0], I = g + E * t.strides[1], k = 0; k < n.outHeight; ++k) for (var S = b + k * f.strides[2], A = k * n.strideHeight - h, D = 0; D < o; D++) {
        var T = A + D * u;
        if (!(T < 0 || T >= n.inHeight)) for (var N = R + D * e.strides[1], F = I + T * t.strides[2], O = 0; O < n.outWidth; ++O) for (var _ = S + O * n.outChannels, M = O * n.strideWidth - l, B = 0; B < a; B++) {
          var P = M + B * s;
          if (!(P < 0 || P >= n.inWidth)) for (var L = N + B * e.strides[2], W = F + P * n.inChannels, U = L, V = 0; V < n.inChannels; ++V) {
            for (var z = p[W + V], G = 0; G < n.outChannels; ++G) v[_ + G] += z * d[U + G];

            U += n.outChannels;
          }
        }
      }
    }

    return f.toTensor();
  }, o.prototype.conv2dDerInput = function (t, e, n) {
    kh([t, e], "conv2dDerInput");

    for (var r = ur(n.inShape, "float32"), o = r.values, a = this.readSync(t.dataId), i = this.readSync(e.dataId), u = e.strides, s = u[0], c = u[1], l = u[2], h = n.batchSize, f = n.filterHeight, p = n.filterWidth, d = n.inChannels, v = n.inHeight, m = n.inWidth, g = n.outChannels, y = n.outHeight, x = n.outWidth, b = n.strideHeight, w = n.strideWidth, C = n.dataFormat, E = f - 1 - n.padInfo.top, R = p - 1 - n.padInfo.left, I = "channelsLast" === C, k = r.strides[0], S = I ? r.strides[1] : r.strides[2], A = I ? r.strides[2] : 1, D = I ? 1 : r.strides[1], T = t.strides[0], N = I ? t.strides[1] : t.strides[2], F = I ? t.strides[2] : 1, O = I ? 1 : t.strides[1], _ = 0; _ < h; ++_) for (var M = 0; M < d; ++M) for (var B = 0; B < v; ++B) for (var P = B - E, L = Math.max(0, Math.ceil(P / b)), W = Math.min(y, (f + P) / b), U = 0; U < m; ++U) {
      for (var V = U - R, z = Math.max(0, Math.ceil(V / w)), G = Math.min(x, (p + V) / w), H = 0, q = L; q < W; ++q) for (var K = q * b - P, j = z; j < G; ++j) for (var X = T * _ + N * q + F * j, $ = s * (f - 1 - K) + c * (p - 1 - (j * w - V)) + l * M, Y = 0; Y < g; ++Y) {
        H += a[X + O * Y] * i[$ + Y];
      }

      o[k * _ + S * B + A * U + D * M] = H;
    }

    return r.toTensor();
  }, o.prototype.conv3dDerInput = function (t, e, n) {
    for (var r = ur(n.inShape, "float32"), o = r.values, a = r.strides, i = a[0], u = a[1], s = a[2], c = a[3], l = this.readSync(t.dataId), h = t.strides, f = h[0], p = h[1], d = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = n.batchSize, E = n.filterDepth, R = n.filterHeight, I = n.filterWidth, k = n.inChannels, S = n.inDepth, A = n.inHeight, D = n.inWidth, T = n.outChannels, N = n.outDepth, F = n.outHeight, O = n.outWidth, _ = n.strideDepth, M = n.strideHeight, B = n.strideWidth, P = E - 1 - n.padInfo.front, L = R - 1 - n.padInfo.top, W = I - 1 - n.padInfo.left, U = 0; U < C; ++U) for (var V = 0; V < k; ++V) for (var z = 0; z < S; ++z) for (var G = z - P, H = Math.max(0, Math.ceil(G / _)), q = Math.min(N, (E + G) / _), K = 0; K < A; ++K) for (var j = K - L, X = Math.max(0, Math.ceil(j / M)), $ = Math.min(F, (R + j) / M), Y = 0; Y < D; ++Y) {
      for (var Q = Y - W, J = Math.max(0, Math.ceil(Q / B)), Z = Math.min(O, (I + Q) / B), tt = 0, et = H; et < q; ++et) for (var nt = et * _ - G, rt = X; rt < $; ++rt) for (var ot = rt * M - j, at = J; at < Z; ++at) for (var it = f * U + p * et + d * rt + v * at, ut = y * (E - 1 - nt) + x * (R - 1 - ot) + b * (I - 1 - (at * B - Q)) + w * V, st = 0; st < T; ++st) {
        tt += l[it + st] * m[ut + st];
      }

      o[i * U + u * z + s * K + c * Y + V] = tt;
    }

    return r.toTensor();
  }, o.prototype.conv2dDerFilter = function (t, e, n) {
    kh([t, e], "conv2dDerFilter");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, u = "channelsLast" === n.dataFormat, s = ur(n.filterShape, "float32"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), f = this.bufferSync(e), p = 0; p < a; ++p) for (var d = Math.max(0, Math.ceil((l - p) / r)), v = Math.min(n.outHeight, (n.inHeight + l - p) / r), m = 0; m < i; ++m) for (var g = Math.max(0, Math.ceil((c - m) / o)), y = Math.min(n.outWidth, (n.inWidth + c - m) / o), x = 0; x < n.inChannels; ++x) for (var b = 0; b < n.outChannels; ++b) {
      for (var w = 0, C = 0; C < n.batchSize; ++C) for (var E = d; E < v; ++E) for (var R = p + E * r - l, I = g; I < y; ++I) {
        var k = m + I * o - c;
        w += u ? h.get(C, R, k, x) * f.get(C, E, I, b) : h.get(C, x, R, k) * f.get(C, b, E, I);
      }

      s.set(w, p, m, x, b);
    }

    return s.toTensor();
  }, o.prototype.conv3dDerFilter = function (t, e, n) {
    for (var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, u = n.filterHeight, s = n.filterWidth, c = ur(n.filterShape, "float32"), l = c.values, h = c.strides, f = h[0], p = h[1], d = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = this.readSync(t.dataId), E = t.strides, R = E[0], I = E[1], k = E[2], S = E[3], A = n.padInfo.front, D = n.padInfo.left, T = n.padInfo.top, N = 0; N < i; ++N) for (var F = Math.max(0, Math.ceil((A - N) / r)), O = Math.min(n.outDepth, (n.inDepth + A - N) / r), _ = N * f, M = 0; M < u; ++M) for (var B = Math.max(0, Math.ceil((T - M) / o)), P = Math.min(n.outHeight, (n.inHeight + T - M) / o), L = M * p + _, W = 0; W < s; ++W) for (var U = Math.max(0, Math.ceil((D - W) / a)), V = Math.min(n.outWidth, (n.inWidth + D - W) / a), z = W * d + L, G = 0; G < n.inChannels; ++G) for (var H = G * v + z, q = 0; q < n.outChannels; ++q) {
      for (var K = 0, j = 0; j < n.batchSize; ++j) for (var X = j * R, $ = j * y, Y = F; Y < O; ++Y) for (var Q = (N + Y * r - A) * I + X, J = Y * x + $, Z = B; Z < P; ++Z) for (var tt = (M + Z * o - T) * k + Q, et = Z * b + J, nt = U; nt < V; ++nt) {
        var rt = nt * w + et;
        K += C[(W + nt * a - D) * S + tt + G] * m[rt + q];
      }

      l[H + q] = K;
    }

    return c.toTensor();
  }, o.prototype.fusedDepthwiseConv2D = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        i = t.preluActivationWeights,
        u = this.depthwiseConv2D(e, n, r);
    return o && (u = this.add(u, o)), a && (u = Sh(this, u, a, i)), u;
  }, o.prototype.depthwiseConv2D = function (t, e, n) {
    kh([t, e], "depthwiseConv2D");

    for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, u = n.padInfo.left, s = n.padInfo.top, c = n.outChannels / n.inChannels, l = ur(n.outShape, t.dtype), h = this.readSync(t.dataId), f = this.readSync(e.dataId), p = l.values, d = 0; d < n.batchSize; ++d) for (var v = d * t.strides[0], m = d * l.strides[0], g = 0; g < n.outHeight; ++g) for (var y = m + g * l.strides[1], x = g * n.strideHeight - u, b = 0; b < r; ++b) {
      var w = x + b * a;
      if (!(w < 0 || w >= n.inHeight)) for (var C = b * e.strides[0], E = v + w * t.strides[1], R = 0; R < n.outWidth; ++R) for (var I = y + R * l.strides[2], k = R * n.strideWidth - s, S = 0; S < o; ++S) {
        var A = k + S * i;
        if (!(A < 0 || A >= n.inWidth)) for (var D = C + S * e.strides[1], T = E + A * n.inChannels, N = I, F = D, O = 0; O < n.inChannels; ++O) {
          for (var _ = h[T + O], M = 0; M < c; ++M) p[N + M] += _ * f[F + M];

          N += c, F += c;
        }
      }
    }

    return l.toTensor();
  }, o.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    kh([t, e], "depthwiseConv2DDerInput");

    for (var r = ur(n.inShape, "float32"), o = r.values, a = r.strides, i = a[0], u = a[1], s = a[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], f = l[1], p = l[2], d = this.readSync(e.dataId), v = e.strides, m = v[0], g = v[1], y = v[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, C = n.inChannels, E = n.inHeight, R = n.inWidth, I = n.outChannels, k = n.outHeight, S = n.outWidth, A = n.strideHeight, D = n.strideWidth, T = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, F = I / C, O = 0; O < x; ++O) for (var _ = 0; _ < C; ++_) for (var M = 0; M < E; ++M) for (var B = M - T, P = Math.max(0, Math.ceil(B / A)), L = Math.min(k, (b + B) / A), W = 0; W < R; ++W) {
      for (var U = W - N, V = Math.max(0, Math.ceil(U / D)), z = Math.min(S, (w + U) / D), G = 0, H = P; H < L; ++H) for (var q = H * A - B, K = V; K < z; ++K) for (var j = h * O + f * H + p * K, X = m * (b - 1 - q) + g * (w - 1 - (K * D - U)) + y * _, $ = 0; $ < F; ++$) {
        G += c[j + (_ * F + $)] * d[X + $];
      }

      o[i * O + u * M + s * W + _] = G;
    }

    return r.toTensor();
  }, o.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    kh([t, e], "depthwiseConv2DDerFilter");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, u = ur(n.filterShape, "float32"), s = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), f = this.bufferSync(e), p = 0; p < a; ++p) for (var d = Math.max(0, Math.ceil((c - p) / r)), v = Math.min(n.outHeight, (n.inHeight + c - p) / r), m = 0; m < i; ++m) for (var g = Math.max(0, Math.ceil((s - m) / o)), y = Math.min(n.outWidth, (n.inWidth + s - m) / o), x = 0; x < n.outChannels; ++x) {
      for (var b = Math.trunc(x / l), w = x % l, C = 0, E = 0; E < n.batchSize; ++E) for (var R = d; R < v; ++R) for (var I = p + R * r - c, k = g; k < y; ++k) {
        var S = m + k * o - s;
        C += h.get(E, I, S, b) * f.get(E, R, k, x);
      }

      u.set(C, p, m, b, w);
    }

    return u.toTensor();
  }, o.prototype.tile = function (t, e) {
    return kh(t, "tile"), Lo(this.bufferSync(t), e);
  }, o.prototype.pad = function (t, e, n) {
    kh(t, "pad");
    var r = e.map(function (e, n) {
      return e[0] + t.shape[n] + e[1];
    }),
        o = e.map(function (t) {
      return t[0];
    }),
        a = this.bufferSync(t),
        i = ur(r, t.dtype);
    0 !== n && i.values.fill(n);

    for (var u = 0; u < t.size; u++) {
      var s = a.indexToLoc(u),
          c = s.map(function (t, e) {
        return t + o[e];
      });
      i.set.apply(i, [a.get.apply(a, s)].concat(c));
    }

    return i.toTensor();
  }, o.prototype.transpose = function (t, e) {
    kh(t, "transpose");

    for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];

    var o = this.readSync(t.dataId),
        a = ur(n, t.dtype),
        i = this.bufferSync(t);

    for (r = 0; r < t.size; ++r) {
      for (var u = i.indexToLoc(r), s = new Array(u.length), c = 0; c < s.length; c++) s[c] = u[e[c]];

      var l = a.locToIndex(s);
      a.values[l] = o[r];
    }

    return a.toTensor();
  }, o.prototype.gather = function (t, e, n) {
    kh([t, e], "gather");
    var r = t.shape.slice(),
        o = this.readSync(e.dataId);
    r[n] = o.length;

    for (var a = ur(r, t.dtype), i = this.bufferSync(t), u = 0; u < a.size; ++u) {
      var s = a.indexToLoc(u),
          c = s.slice();
      c[n] = o[s[n]];
      var l = i.locToIndex(c);
      a.values[u] = i.values[l];
    }

    return a.toTensor();
  }, o.prototype.batchToSpaceND = function (t, e, n) {
    kh([t], "batchToSpaceND");
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = Mr(t.shape, e, r),
        a = Br(o.length, e.length),
        i = Pr(t.shape, e, r),
        u = Lr(n, e.length),
        s = Wr(i, n, e.length);
    return t.reshape(o).transpose(a).reshape(i).slice(u, s);
  }, o.prototype.spaceToBatchND = function (t, e, n) {
    kh([t], "spaceToBatchND");
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = [[0, 0]];
    o.push.apply(o, n);

    for (var a = 1 + e.length; a < t.shape.length; ++a) o.push([0, 0]);

    var i = t.pad(o),
        u = Mr(i.shape, e, r, !1),
        s = Br(u.length, e.length, !1),
        c = Pr(i.shape, e, r, !1);
    return i.reshape(u).transpose(s).reshape(c);
  }, o.prototype.pool = function (t, e, n) {
    kh(t, "pool");

    for (var r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, u = e.effectiveFilterHeight, s = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f = this.readSync(t.dataId), p = ur(e.outShape, t.dtype), d = p.values, v = e.outShape[1] * e.outShape[2] * e.outShape[3], m = e.outShape[2] * e.outShape[3], g = e.outShape[3], y = 0; y < e.batchSize; ++y) for (var x = y * v, b = y * t.strides[0], w = 0; w < e.inChannels; ++w) for (var C = 0; C < e.outHeight; ++C) for (var E = C * r - c, R = Math.max(0, E), I = Math.min(e.inHeight, u + E), k = x + C * m, S = 0; S < e.outWidth; ++S) {
      for (var A = S * o - l, D = Math.max(0, A), T = Math.min(e.inWidth, s + A), N = h, F = 0, O = 0, _ = R; _ < I; _ += a) {
        for (var M = b + _ * t.strides[1], B = D; B < T; B += i) {
          var P = f[M + B * t.strides[2] + w];
          "max" === n && P > N ? N = P : "avg" === n && (F += P, O++);
        }

        if (isNaN(N)) break;
      }

      d[k + S * g + w] = "avg" === n ? F / O : N;
    }

    return p.toTensor();
  }, o.prototype.maxPool = function (t, e) {
    return this.pool(t, e, "max");
  }, o.prototype.maxPoolPositions = function (t, e) {
    for (var n = ur(e.outShape, "int32"), r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, u = e.effectiveFilterHeight, s = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), f = 0; f < e.batchSize; ++f) for (var p = 0; p < e.inChannels; ++p) for (var d = 0; d < e.outHeight; ++d) {
      for (var v = d * r - c, m = v; m < 0;) m += a;

      for (var g = Math.min(e.inHeight, u + v), y = 0; y < e.outWidth; ++y) {
        for (var x = y * o - l, b = x; b < 0;) b += i;

        for (var w = Math.min(e.inWidth, s + x), C = Number.NEGATIVE_INFINITY, E = -1, R = m; R < g; R += a) for (var I = R - v, k = b; k < w; k += i) {
          var S = k - x,
              A = h.get(f, R, k, p);
          A > C && (C = A, E = I * s + S);
        }

        n.set(E, f, d, y, p);
      }
    }

    return n.toTensor();
  }, o.prototype.maxPoolBackprop = function (t, e, n, r) {
    kh([e, n], "maxPoolBackprop");

    for (var o = this.maxPoolPositions(e, r), a = r.strideHeight, i = r.strideWidth, u = r.dilationHeight, s = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, f = c - 1 - r.padInfo.top, p = ur(e.shape, "float32"), d = this.bufferSync(o), v = this.bufferSync(t), m = 0; m < r.batchSize; ++m) for (var g = 0; g < r.inChannels; ++g) for (var y = 0; y < r.inHeight; ++y) for (var x = 0; x < r.inWidth; ++x) {
      for (var b = y - f, w = x - h, C = 0, E = 0; E < c; E += u) {
        var R = (b + E) / a;
        if (!(R < 0 || R >= r.outHeight || Math.floor(R) !== R)) for (var I = 0; I < l; I += s) {
          var k = (w + I) / i;

          if (!(k < 0 || k >= r.outWidth || Math.floor(k) !== k)) {
            var S = c * l - 1 - d.get(m, R, k, g) === E * l + I ? 1 : 0;
            if (0 !== S) C += v.get(m, R, k, g) * S;
          }
        }
      }

      p.set(C, m, y, x, g);
    }

    return p.toTensor();
  }, o.prototype.avgPoolBackprop = function (t, e, n) {
    kh([t, e], "avgPoolBackprop");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, u = n.dilationHeight, s = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, f = c - 1 - n.padInfo.top, p = ur(e.shape, "float32"), d = 1 / (a * i), v = this.bufferSync(t), m = 0; m < n.batchSize; ++m) for (var g = 0; g < n.inChannels; ++g) for (var y = 0; y < n.inHeight; ++y) for (var x = 0; x < n.inWidth; ++x) {
      for (var b = y - f, w = x - h, C = 0, E = 0; E < c; E += u) {
        var R = (b + E) / r;
        if (!(R < 0 || R >= n.outHeight || Math.floor(R) !== R)) for (var I = 0; I < l; I += s) {
          var k = (w + I) / o;
          if (!(k < 0 || k >= n.outWidth || Math.floor(k) !== k)) C += v.get(m, R, k, g);
        }
      }

      p.set(C * d, m, y, x, g);
    }

    return p.toTensor();
  }, o.prototype.pool3d = function (t, e, n) {
    kh(t, "pool3d");

    for (var r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, u = e.dilationHeight, s = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, p = e.padInfo.top, d = e.padInfo.left, v = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t.dataId), g = ur(e.outShape, t.dtype), y = g.values, x = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], b = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], E = 0; E < e.batchSize; ++E) for (var R = E * x, I = E * t.strides[0], k = 0; k < e.inChannels; ++k) for (var S = 0; S < e.outDepth; ++S) {
      for (var A = S * r - f, D = A; D < 0;) D += i;

      for (var T = Math.min(e.inDepth, c + A), N = R + S * b, F = 0; F < e.outHeight; ++F) {
        for (var O = F * o - p, _ = O; _ < 0;) _ += u;

        for (var M = Math.min(e.inHeight, l + O), B = N + F * w, P = 0; P < e.outWidth; ++P) {
          for (var L = P * a - d, W = L; W < 0;) W += s;

          for (var U = Math.min(e.inWidth, h + L), V = B + P * C, z = v, G = 0, H = 0, q = D; q < T; q += i) {
            for (var K = I + q * t.strides[1], j = _; j < M; j += u) {
              for (var X = K + j * t.strides[2], $ = W; $ < U; $ += s) {
                var Y = m[X + $ * t.strides[3] + k];
                if ("max" === n && Y > z ? z = Y : "avg" === n && (G += Y, H++), isNaN(z)) break;
              }

              if (isNaN(z)) break;
            }

            if (isNaN(z)) break;
          }

          y[V + k] = "avg" === n ? G / H : z;
        }
      }
    }

    return g.toTensor();
  }, o.prototype.avgPool3d = function (t, e) {
    return kh(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat();
  }, o.prototype.avgPool3dBackprop = function (t, e, n) {
    kh([t, e], "avgPool3dBackprop");

    for (var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, u = n.filterHeight, s = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, f = n.effectiveFilterDepth, p = n.effectiveFilterHeight, d = n.effectiveFilterWidth, v = f - 1 - n.padInfo.front, m = d - 1 - n.padInfo.left, g = p - 1 - n.padInfo.top, y = ur(e.shape, "float32"), x = 1 / (i * u * s), b = this.bufferSync(t), w = 0; w < n.batchSize; ++w) for (var C = 0; C < n.inChannels; ++C) for (var E = 0; E < n.inDepth; ++E) for (var R = 0; R < n.inHeight; ++R) for (var I = 0; I < n.inWidth; ++I) {
      for (var k = E - v, S = R - g, A = I - m, D = 0, T = 0; T < f; T += c) {
        var N = (k + T) / r;
        if (!(N < 0 || N >= n.outDepth || Math.floor(N) !== N)) for (var F = 0; F < p; F += l) {
          var O = (S + F) / o;
          if (!(O < 0 || O >= n.outHeight || Math.floor(O) !== O)) for (var _ = 0; _ < d; _ += h) {
            var M = (A + _) / a;
            if (!(M < 0 || M >= n.outWidth || Math.floor(M) !== M)) D += b.get(w, N, O, M, C);
          }
        }
      }

      y.set(D * x, w, E, R, I, C);
    }

    return y.toTensor();
  }, o.prototype.maxPool3d = function (t, e) {
    return kh(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat();
  }, o.prototype.maxPool3dPositions = function (t, e) {
    for (var n = ur(e.outShape, "int32"), r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, u = e.dilationHeight, s = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, p = e.padInfo.top, d = e.padInfo.left, v = this.bufferSync(t), m = 0; m < e.batchSize; ++m) for (var g = 0; g < e.inChannels; ++g) for (var y = 0; y < e.outDepth; ++y) {
      for (var x = y * r - f, b = x; b < 0;) b += i;

      for (var w = Math.min(e.inDepth, c + x), C = 0; C < e.outHeight; ++C) {
        for (var E = C * o - p, R = E; R < 0;) R += u;

        for (var I = Math.min(e.inHeight, l + E), k = 0; k < e.outWidth; ++k) {
          for (var S = k * a - d, A = S; A < 0;) A += s;

          for (var D = Math.min(e.inWidth, h + S), T = Number.NEGATIVE_INFINITY, N = -1, F = b; F < w; F += i) for (var O = F - x, _ = R; _ < I; _ += u) for (var M = _ - E, B = A; B < D; B += s) {
            var P = B - S,
                L = v.get(m, F, _, B, g);
            L >= T && (T = L, N = O * l * h + M * l + P);
          }

          n.set(N, m, y, C, k, g);
        }
      }
    }

    return n.toTensor();
  }, o.prototype.maxPool3dBackprop = function (t, e, n, r) {
    kh([e, n], "maxPool3dBackprop");

    for (var o = this.maxPool3dPositions(e, r), a = r.strideDepth, i = r.strideHeight, u = r.strideWidth, s = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, f = r.effectiveFilterHeight, p = r.effectiveFilterWidth, d = h - 1 - r.padInfo.front, v = p - 1 - r.padInfo.left, m = f - 1 - r.padInfo.top, g = ur(e.shape, "float32"), y = this.bufferSync(o), x = this.bufferSync(t), b = 0; b < r.batchSize; ++b) for (var w = 0; w < r.inChannels; ++w) for (var C = 0; C < r.inDepth; ++C) for (var E = 0; E < r.inHeight; ++E) for (var R = 0; R < r.inWidth; ++R) {
      for (var I = C - d, k = E - m, S = R - v, A = 0, D = 0; D < h; D += s) {
        var T = (I + D) / a;
        if (!(T < 0 || T >= r.outDepth || Math.floor(T) !== T)) for (var N = 0; N < f; N += c) {
          var F = (k + N) / i;
          if (!(F < 0 || F >= r.outHeight || Math.floor(F) !== F)) for (var O = 0; O < p; O += l) {
            var _ = (S + O) / u;

            if (!(_ < 0 || _ >= r.outWidth || Math.floor(_) !== _)) {
              var M = h * f * p - 1 - y.get(b, T, F, _, w) === D * f * p + N * p + O ? 1 : 0;
              if (0 !== M) A += x.get(b, T, F, _, w) * M;
            }
          }
        }
      }

      g.set(A, b, C, E, R, w);
    }

    return g.toTensor();
  }, o.prototype.cast = function (t, e) {
    return So(t, e, this);
  }, o.prototype.reshape = function (t, e) {
    return Ao(t, e);
  }, o.prototype.avgPool = function (t, e) {
    return kh(t, "avgPool"), this.pool(t, e, "avg").toFloat();
  }, o.prototype.resizeBilinear = function (t, e, n, r) {
    kh(t, "resizeBilinear");

    for (var o = t.shape, a = o[0], i = o[1], u = o[2], s = o[3], c = this.readSync(t.dataId), l = new Float32Array(w([a, e, n, s])), h = [r && e > 1 ? i - 1 : i, r && n > 1 ? u - 1 : u], f = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], p = 0, d = h[0] / f[0], v = h[1] / f[1], m = 0; m < a; m++) for (var g = 0; g < e; g++) for (var y = d * g, x = Math.floor(y), b = y - x, C = Math.min(i - 1, Math.ceil(y)), E = m * t.strides[0] + x * t.strides[1], R = m * t.strides[0] + C * t.strides[1], I = 0; I < n; I++) for (var k = v * I, S = Math.floor(k), A = k - S, D = Math.min(u - 1, Math.ceil(k)), T = E + S * t.strides[2], N = R + S * t.strides[2], F = E + +D * t.strides[2], O = R + D * t.strides[2], _ = 0; _ < s; _++) {
      var M = c[T + _],
          B = c[N + _],
          P = M + (c[F + _] - M) * A,
          L = P + (B + (c[O + _] - B) * A - P) * b;
      l[p++] = L;
    }

    return kn(l, [a, e, n, s]);
  }, o.prototype.resizeBilinearBackprop = function (t, e, n) {
    kh([t, e], "resizeBilinearBackprop");

    for (var r = e.shape, o = r[0], a = r[1], i = r[2], u = r[3], s = t.shape, c = s[1], l = s[2], h = new Float32Array(o * a * i * u), f = [n && c > 1 ? a - 1 : a, n && l > 1 ? i - 1 : i], p = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], d = f[0] / p[0], v = f[1] / p[1], m = this.readSync(t.dataId), g = 0, y = 0; y < o; y++) for (var x = y * e.strides[0], b = 0; b < c; b++) for (var w = b * d, C = Math.floor(w), E = Math.min(Math.ceil(w), a - 1), R = x + C * e.strides[1], I = x + E * e.strides[1], k = w - C, S = 1 - k, A = 0; A < l; A++) for (var D = A * v, T = Math.floor(D), N = Math.min(Math.ceil(D), i - 1), F = D - T, O = 1 - F, _ = R + T * e.strides[2], M = R + N * e.strides[2], B = I + T * e.strides[2], P = I + N * e.strides[2], L = S * O, W = S * F, U = k * O, V = k * F, z = 0; z < u; z++) {
      var G = m[g++];
      h[_ + z] += G * L, h[M + z] += G * W, h[B + z] += G * U, h[P + z] += G * V;
    }

    return Fn(h, [o, i, a, u], e.dtype);
  }, o.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    kh(t, "resizeNearestNeighbor");

    for (var o = t.shape, a = o[0], i = o[1], u = o[2], s = o[3], c = this.readSync(t.dataId), l = new Float32Array(a * e * n * s), h = [r && e > 1 ? i - 1 : i, r && n > 1 ? u - 1 : u], f = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], p = h[0] / f[0], d = h[1] / f[1], v = 0, m = 0; m < a; m++) for (var g = m * t.strides[0], y = 0; y < e; y++) for (var x = p * y, b = g + Math.min(i - 1, r ? Math.round(x) : Math.floor(x)) * t.strides[1], w = 0; w < n; w++) for (var C = d * w, E = b + Math.min(u - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], R = 0; R < s; R++) {
      var I = c[E + R];
      l[v++] = I;
    }

    return kn(l, [a, e, n, s], t.dtype);
  }, o.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    kh([t, e], "resizeNearestNeighborBackprop");

    for (var r = e.shape, o = r[0], a = r[1], i = r[2], u = r[3], s = t.shape, c = s[1], l = s[2], h = new Float32Array(o * a * i * u), f = this.readSync(t.dataId), p = [n && c > 1 ? a - 1 : a, n && l > 1 ? i - 1 : i], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], v = p[0] / d[0], m = p[1] / d[1], g = 1 / v, y = 1 / m, x = 2 * Math.ceil(g) + 2, b = 2 * Math.ceil(y) + 2, w = 0; w < o; w++) for (var C = w * e.strides[0], E = 0; E < a; E++) for (var R = C + E * e.strides[1], I = Math.floor(E * g), k = Math.floor(I - x / 2), S = 0; S < i; S++) for (var A = R + S * e.strides[2], D = Math.floor(S * y), T = Math.floor(D - b / 2), N = 0; N < u; N++) {
      for (var F = 0, O = 0; O < x; O++) {
        var _ = O + k;

        if (!(_ < 0 || _ >= c)) {
          var M = C + _ * t.strides[1],
              B = _ * v;
          if (E === Math.min(a - 1, n ? Math.round(B) : Math.floor(B))) for (var P = 0; P < b; P++) {
            var L = P + T;

            if (!(L < 0 || L >= l)) {
              var W = M + L * t.strides[2],
                  U = L * m;
              S === Math.min(i - 1, n ? Math.round(U) : Math.floor(U)) && (F += f[W + N]);
            }
          }
        }
      }

      h[A + N] = F;
    }

    return Fn(h, e.shape, e.dtype);
  }, o.prototype.batchNormalization = function (t, e, n, r, o, a) {
    kh([t, e, n, o, a], "batchNorm");

    for (var i = this.readSync(t.dataId), u = this.readSync(e.dataId), s = this.readSync(n.dataId), c = o ? this.readSync(o.dataId) : new Float32Array([1]), l = a ? this.readSync(a.dataId) : new Float32Array([0]), h = new Float32Array(i.length), f = l.length, p = c.length, d = s.length, v = u.length, m = 0, g = 0, y = 0, x = 0, b = 0; b < i.length; ++b) h[b] = l[m++] + (i[b] - u[g++]) * c[y++] / Math.sqrt(s[x++] + r), m >= f && (m = 0), g >= v && (g = 0), y >= p && (y = 0), x >= d && (x = 0);

    return Fn(h, t.shape);
  }, o.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    kh(t, "localResponseNormalization4D");
    var a = t.shape[3],
        i = a - 1,
        u = this.readSync(t.dataId),
        s = t.size,
        c = new Float32Array(s);

    function l(t) {
      for (var n = t % a, r = t - n + Math.max(0, n - e), o = t - n + Math.min(n + e, i), s = 0; r <= o; r++) {
        var c = u[r];
        s += c * c;
      }

      return s;
    }

    for (var h = 0; h < s; h++) {
      var f = l(h),
          p = u[h] * Math.pow(n + r * f, -o);
      c[h] = p;
    }

    return Fn(c, t.shape);
  }, o.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    kh(t, "LRNGrad");

    for (var u = t.shape[3], s = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), f = t.size, p = 0; p < f; p++) {
      for (var d = p % u, v = p - d + Math.max(0, d - r), m = p - d + Math.min(u, d + r + 1), g = 0, y = v; y < m; y++) g += Math.pow(c[y], 2);

      g = a * g + o;

      for (y = v; y < m; y++) {
        var x = -2 * a * i * c[y] * l[p] / g;
        p === y && (x += Math.pow(g, -i)), x *= s[p], h[y] += x;
      }
    }

    return Fn(h, t.shape);
  }, o.prototype.multinomial = function (t, e, n, r) {
    kh(t, "multinomial");

    for (var o = e ? t : io(t), a = o.shape[0], i = o.shape[1], u = Pn([a, n], "int32"), s = this.readSync(u.dataId), c = this.readSync(o.dataId), l = 0; l < a; ++l) {
      var h = l * i,
          f = new Float32Array(i - 1);
      f[0] = c[h];

      for (var p = 1; p < f.length; ++p) f[p] = f[p - 1] + c[h + p];

      for (var d = rr(r.toString()), v = l * n, m = 0; m < n; ++m) {
        var g = d();
        s[v + m] = f.length;

        for (var y = 0; y < f.length; y++) if (g < f[y]) {
          s[v + m] = y;
          break;
        }
      }
    }

    return u;
  }, o.prototype.oneHot = function (t, e, n, r) {
    kh(t, "oneHot");
    var o = new Float32Array(t.size * e);
    o.fill(r);

    for (var a = this.readSync(t.dataId), i = 0; i < t.size; ++i) a[i] >= 0 && a[i] < e && (o[i * e + a[i]] = n);

    return Tn(o, [t.size, e], "int32");
  }, o.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return kh(t, "nonMaxSuppression"), Mo(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o);
  }, o.prototype.fft = function (t) {
    return this.fftBatch(t, !1);
  }, o.prototype.ifft = function (t) {
    return this.fftBatch(t, !0);
  }, o.prototype.fftBatch = function (t, e) {
    for (var n = t.shape[0], r = t.shape[1], o = ur(t.shape, "float32"), a = ur(t.shape, "float32"), i = Rn(t).as2D(n, r), u = In(t).as2D(n, r), s = 0; s < n; s++) for (var c = i.slice([s, 0], [1, r]), l = u.slice([s, 0], [1, r]), h = En(c, l), f = this.readSync(this.fftImpl(h, e).dataId), p = 0; p < r; p++) {
      var d = Fo(f, p);
      o.values[s * r + p] = d.real, a.values[s * r + p] = d.imag;
    }

    return En(o.toTensor(), a.toTensor()).as2D(n, r);
  }, o.prototype.fftImpl = function (t, e) {
    var n = t.as1D(),
        r = n.size;

    if (this.isExponentOf2(r)) {
      var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
      return e && (o = En(Rn(o).div(An(r)), In(o).div(An(r)))), o;
    }

    var a = this.readSync(t.dataId),
        i = function (t) {
      for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];

      return {
        real: e,
        imag: n
      };
    }(this.fourierTransformByMatmul(a, r, e));

    return En(i.real, i.imag).as2D(t.shape[0], t.shape[1]);
  }, o.prototype.isExponentOf2 = function (t) {
    return 0 == (t & t - 1);
  }, o.prototype.fftRadix2 = function (t, e, n) {
    if (1 === e) return t;

    var r = this.readSync(t.dataId),
        o = e / 2,
        a = function (t) {
      for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

      return {
        real: n,
        imag: r
      };
    }(r),
        i = En(a.real, a.imag).as1D(),
        u = function (t) {
      for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

      return {
        real: n,
        imag: r
      };
    }(r),
        s = En(u.real, u.imag).as1D();

    i = this.fftRadix2(i, o, n), s = this.fftRadix2(s, o, n);

    var c = function (t, e) {
      for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++) {
        var a = (e ? 2 : -2) * Math.PI * (o / t);
        n[o] = Math.cos(a), r[o] = Math.sin(a);
      }

      return {
        real: n,
        imag: r
      };
    }(e, n),
        l = En(c.real, c.imag).mul(s),
        h = i.add(l),
        f = i.sub(l),
        p = Rn(h).concat(Rn(f)),
        d = In(h).concat(In(f));

    return En(p, d).as1D();
  }, o.prototype.fourierTransformByMatmul = function (t, e, n) {
    for (var r = new Float32Array(2 * e), o = 0; o < e; o++) {
      for (var a = 0, i = 0, u = 0; u < e; u++) {
        var s = _o(o * u, e, n),
            c = Fo(t, u);

        a += c.real * s.real - c.imag * s.imag, i += c.real * s.imag + c.imag * s.real;
      }

      n && (a /= e, i /= e), Oo(r, a, i, o);
    }

    return r;
  }, o.prototype.depthToSpace = function (t, e, n) {
    g("NHWC" === n, function () {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n;
    }), g(e > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: " + e;
    });

    for (var r = t.shape[0], o = t.shape[1], a = t.shape[2], i = t.shape[3], u = o * e, s = a * e, c = i / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * u * s * c), f = 0, p = 0; p < r; ++p) for (var d = 0; d < u; ++d) for (var v = Math.floor(d / e), m = d % e, y = 0; y < s; ++y) for (var x = Math.floor(y / e), b = (m * e + y % e) * c, w = 0; w < c; ++w) {
      var C = w + b + i * (x + a * (v + o * p));
      h[f++] = l[C];
    }

    return Fn(h, [r, u, s, c]);
  }, o.prototype.broadcastedBinaryOp = function (t, e, n, r) {
    var o = po(t.shape, e.shape),
        a = ur(o, n),
        i = this.readSync(t.dataId),
        u = this.readSync(e.dataId),
        s = ho(t.shape, o),
        c = ho(e.shape, o),
        l = a.values;
    if (s.length + c.length === 0) for (var h = 0; h < l.length; ++h) l[h] = r(i[h % i.length], u[h % u.length]);else {
      var f = this.bufferSync(t),
          p = this.bufferSync(e),
          d = function (n) {
        var o = a.indexToLoc(n),
            h = o.slice(-t.rank);
        s.forEach(function (t) {
          return h[t] = 0;
        });
        var d = f.locToIndex(h),
            v = o.slice(-e.rank);
        c.forEach(function (t) {
          return v[t] = 0;
        });
        var m = p.locToIndex(v);
        l[n] = r(i[d], u[m]);
      };

      for (h = 0; h < l.length; ++h) d(h);
    }
    return a.toTensor();
  }, o.prototype.broadcastedBinaryComplexOp = function (t, e, n) {
    var r = po(t.shape, e.shape),
        o = ur(r, "float32"),
        a = ur(r, "float32"),
        i = this.readSync(t.dataId),
        u = this.readSync(e.dataId),
        s = ho(t.shape, r),
        c = ho(e.shape, r),
        l = o.values,
        h = a.values;
    if (s.length + c.length === 0) for (var f = 0; f < l.length; f++) {
      var p = f % i.length,
          d = f % u.length,
          v = n(i[2 * p], i[2 * p + 1], u[2 * d], u[2 * d + 1]);
      l[f] = v.real, h[f] = v.imag;
    } else {
      var m = this.bufferSync(this.data.get(t.dataId).complexTensors.real),
          g = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
          y = function (r) {
        var a = o.indexToLoc(r),
            f = a.slice(-t.rank);
        s.forEach(function (t) {
          return f[t] = 0;
        });
        var p = m.locToIndex(f),
            d = a.slice(-e.rank);
        c.forEach(function (t) {
          return d[t] = 0;
        });
        var v = g.locToIndex(d),
            y = n(i[2 * p], i[2 * p + 1], u[2 * v], u[2 * v + 1]);
        l[r] = y.real, h[r] = y.imag;
      };

      for (f = 0; f < l.length; f++) y(f);
    }
    return this.complex(o.toTensor(), a.toTensor());
  }, o.prototype.split = function (t, e, n) {
    return Po(t, e, n);
  }, o.prototype.dispose = function () {}, o.prototype.floatPrecision = function () {
    return 32;
  }, o.prototype.epsilon = function () {
    return 1e-7;
  }, o.prototype.cropAndResize = function (t, e, n, r, o, a) {
    for (var i = t.shape, u = i[0], s = i[1], c = i[2], l = i[3], h = e.shape[0], f = r[0], p = r[1], d = ur([h, f, p, l], t.dtype), v = this.readSync(e.dataId), m = this.readSync(n.dataId), g = this.readSync(t.dataId), y = t.strides, x = d.strides, b = 0; b < h; b++) {
      var w = 4 * b,
          C = v[w],
          E = v[w + 1],
          R = v[w + 2],
          I = v[w + 3],
          k = m[b];
      if (!(k >= u)) for (var S = f > 1 ? (R - C) * (s - 1) / (f - 1) : 0, A = p > 1 ? (I - E) * (c - 1) / (p - 1) : 0, D = 0; D < f; D++) {
        var T = f > 1 ? C * (s - 1) + D * S : .5 * (C + R) * (s - 1);
        if (T < 0 || T > s - 1) for (var N = 0; N < p; N++) for (var F = 0; F < l; F++) {
          var O = F + N * x[2] + D * x[1] + b * x[0];
          d.values[O] = a;
        } else if ("bilinear" === o) {
          var _ = Math.floor(T),
              M = Math.ceil(T),
              B = T - _;

          for (N = 0; N < p; N++) {
            if ((q = p > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for (F = 0; F < l; F++) {
              O = F + N * x[2] + D * x[1] + b * x[0];
              d.values[O] = a;
            } else {
              var P = Math.floor(q),
                  L = Math.ceil(q),
                  W = q - P;

              for (F = 0; F < l; F++) {
                var U = g[O = F + P * y[2] + _ * y[1] + k * y[0]],
                    V = g[O = F + L * y[2] + _ * y[1] + k * y[0]],
                    z = g[O = F + P * y[2] + M * y[1] + k * y[0]],
                    G = U + (V - U) * W,
                    H = z + (g[O = F + L * y[2] + M * y[1] + k * y[0]] - z) * W;
                O = F + N * x[2] + D * x[1] + b * x[0], d.values[O] = G + (H - G) * B;
              }
            }
          }
        } else for (N = 0; N < p; ++N) {
          var q;
          if ((q = p > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for (F = 0; F < l; F++) {
            O = F + N * x[2] + D * x[1] + b * x[0];
            d.values[O] = a;
          } else {
            var K = Math.round(q),
                j = Math.round(T);

            for (F = 0; F < l; F++) {
              var X = F + K * y[2] + j * y[1] + k * y[0],
                  $ = F + N * x[2] + D * x[1] + b * x[0];
              d.values[$] = g[X];
            }
          }
        }
      }
    }

    return d.toTensor();
  }, o.prototype.sparseToDense = function (t, e, n, r) {
    var o = Hr(0, t, n),
        a = o.sliceRank,
        i = o.numUpdates,
        u = o.sliceSize,
        s = o.strides,
        c = o.outputSize;
    return this.scatter(t, e, n, c, u, i, a, s, r, !1);
  }, o.prototype.gatherND = function (t, e) {
    var n = e.shape,
        r = n[n.length - 1],
        o = Ur(t, e),
        a = o[0],
        i = o[1],
        u = o[2],
        s = o[3];
    if (0 === i) return kn([], a, t.dtype);

    for (var c = new lt([i, u], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), f = 0; f < i; f++) {
      for (var p = [], d = 0, v = 0; v < r; v++) {
        var m = l[f * r + v];
        d += m * s[v], p.push(m);
      }

      if (d < 0 || d >= t.size / u) throw new Error("Invalid indices: " + p + " does not index into " + t.shape);

      for (var g = 0; g < u; g++) c.values[f * u + g] = h[d * u + g];
    }

    return c.toTensor().reshape(a);
  }, o.prototype.scatterND = function (t, e, n) {
    var r = Hr(0, t, n),
        o = r.sliceRank,
        a = r.numUpdates,
        i = r.sliceSize,
        u = r.strides,
        s = r.outputSize,
        c = An(0);
    return this.scatter(t, e, n, s, i, a, o, u, c, !0);
  }, o.prototype.fill = function (t, e, n) {
    var r = F(n = n || z(e), w(t));
    return r.fill(e), Nt.makeTensor(r, t, n, this);
  }, o.prototype.onesLike = function (t) {
    if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
    return this.fill(t.shape, 1, t.dtype);
  }, o.prototype.zerosLike = function (t) {
    var e = F(t.dtype, w(t.shape));
    return this.makeOutput(e, t.shape, t.dtype);
  }, o.prototype.linspace = function (t, e, n) {
    return Do(t, e, n);
  }, o.prototype.scatter = function (t, e, n, r, o, a, i, u, s, c) {
    var l = [r / o, o],
        h = this.readSync(t.dataId),
        f = this.readSync(e.dataId);
    if (0 === r) return kn([], n, e.dtype);
    var p = new lt(l, e.dtype);
    p.values.fill(this.readSync(s.dataId)[0]);

    for (var d = 0; d < a; d++) {
      for (var v = [], m = 0, g = 0; g < i; g++) {
        var y = h[d * i + g];
        v.push(y), m += y * u[g];
      }

      if (m < 0 || m >= r / o) throw new Error("Invalid indices: " + v + " does not index into " + n);

      for (var x = 0; x < o; x++) c ? p.values[m * o + x] += f[d * o + x] : p.values[m * o + x] = 0 === e.rank ? f[0] : f[d * o + x];
    }

    return p.toTensor().reshape(n);
  }, o;
}(co);

Nt.registerBackend("cpu", function () {
  return new Ah();
}, 1), l({
  kernelName: "Square",
  backendName: "cpu",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e.x,
        o = n;
    kh(r, "square");

    for (var a = o.data.get(r.dataId).values, i = new Float32Array(a.length), u = 0; u < a.length; ++u) {
      var s = a[u];
      i[u] = s * s;
    }

    return {
      dataId: o.write(i, r.shape, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
}), l({
  kernelName: "Square",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e.x,
        o = n,
        a = new su(r.shape, "return x * x;");
    return o.runWebGLProgram(a, [r], r.dtype);
  }
});

var Dh = function () {
  function t() {}

  return t.prototype.fetch = function (t, e) {
    return fetch(t, e);
  }, t.prototype.now = function () {
    return performance.now();
  }, t.prototype.encode = function (t, e) {
    if ("utf-8" !== e && "utf8" !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e);
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);
  }, t.prototype.decode = function (t, e) {
    return new TextDecoder(e).decode(t);
  }, t;
}();

a().get("IS_BROWSER") && a().setPlatform("browser", new Dh());

var Th,
    Nh = function () {
  return require("node-fetch");
},
    Fh = function () {
  function t() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }

  return t.prototype.fetch = function (t, e) {
    return null != a().global.fetch ? a().global.fetch(t, e) : (null == Th && (Th = Nh()), Th(t, e));
  }, t.prototype.now = function () {
    var t = process.hrtime();
    return 1e3 * t[0] + t[1] / 1e6;
  }, t.prototype.encode = function (t, e) {
    if ("utf-8" !== e && "utf8" !== e) throw new Error("Node built-in encoder only supports utf-8, but got " + e);
    return this.textEncoder.encode(t);
  }, t.prototype.decode = function (t, e) {
    return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t);
  }, t;
}();

a().get("IS_NODE") && a().setPlatform("node", new Fh());
var Oh = {
  float32: 4,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1
},
    _h = 4;

function Mh(t, e) {
  for (var n = {}, r = 0, o = function (e) {
    var o = e.name,
        a = e.dtype,
        i = e.shape,
        u = w(i),
        s = void 0;

    if (("quantization" in e)) {
      var c = e.quantization;
      if ("uint8" !== c.dtype && "uint16" !== c.dtype) throw new Error("Weight " + e.name + " has unknown quantization dtype " + c.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var l = Oh[c.dtype],
          h = t.slice(r, r + u * l),
          f = "uint8" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);
      if ("float32" === a) s = Float32Array.from(f, function (t) {
        return t * c.scale + c.min;
      });else {
        if ("int32" !== a) throw new Error("Unsupported dtype in weight '" + o + "': " + a);
        s = Int32Array.from(f, function (t) {
          return Math.round(t * c.scale + c.min);
        });
      }
      r += u * l;
    } else if ("string" === a) {
      var p = w(e.shape);
      s = [];

      for (var d = 0; d < p; d++) {
        var v = new Uint32Array(t.slice(r, r + _h))[0];
        r += _h;
        var m = new Uint8Array(t.slice(r, r + v));
        s.push(m), r += v;
      }
    } else {
      var g = Oh[a];
      h = t.slice(r, r + u * g);
      if ("float32" === a) s = new Float32Array(h);else if ("int32" === a) s = new Int32Array(h);else {
        if ("bool" !== a) throw new Error("Unsupported dtype in weight '" + o + "': " + a);
        s = new Uint8Array(h);
      }
      r += u * g;
    }

    n[o] = kn(s, i, a);
  }, a = 0, i = e; a < i.length; a++) {
    o(i[a]);
  }

  return n;
}

function Bh(t) {
  if (null === t) throw new Error("Invalid input value: " + JSON.stringify(t));
  var e = 0,
      n = [];
  t.forEach(function (t) {
    if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t.constructor.name);
  });
  var r = new Uint8Array(e),
      o = 0;
  return n.forEach(function (t) {
    r.set(new Uint8Array(t.buffer), o), o += t.byteLength;
  }), r.buffer;
}

var Ph = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

function Lh(t) {
  return Ph ? Buffer.byteLength(t) : new Blob([t]).size;
}

function Wh(t) {
  var e = 0;
  t.forEach(function (t) {
    e += t.byteLength;
  });
  var n = new Uint8Array(e),
      r = 0;
  return t.forEach(function (t) {
    n.set(new Uint8Array(t), r), r += t.byteLength;
  }), n.buffer;
}

function Uh(t) {
  for (t = t.trim(); t.endsWith("/");) t = t.slice(0, t.length - 1);

  var e = t.split("/");
  return e[e.length - 1];
}

function Vh(t) {
  if (t.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: null == t.modelTopology ? 0 : Lh(JSON.stringify(t.modelTopology)),
    weightSpecsBytes: null == t.weightSpecs ? 0 : Lh(JSON.stringify(t.weightSpecs)),
    weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength
  };
}

var zh = function () {
  function t() {
    this.saveRouters = [], this.loadRouters = [];
  }

  return t.getInstance = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.registerSaveRouter = function (e) {
    t.getInstance().saveRouters.push(e);
  }, t.registerLoadRouter = function (e) {
    t.getInstance().loadRouters.push(e);
  }, t.getSaveHandlers = function (e) {
    return t.getHandlers(e, "save");
  }, t.getLoadHandlers = function (e, n) {
    return t.getHandlers(e, "load", n);
  }, t.getHandlers = function (e, n, r) {
    var o = [];
    return ("load" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function (t) {
      var n = t(e, r);
      null !== n && o.push(n);
    }), o;
  }, t;
}(),
    Gh = "://",
    Hh = function () {
  function t() {
    this.managers = {};
  }

  return t.getInstance = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.registerManager = function (e, n) {
    g(null != e, function () {
      return "scheme must not be undefined or null.";
    }), e.endsWith(Gh) && (e = e.slice(0, e.indexOf(Gh))), g(e.length > 0, function () {
      return "scheme must not be an empty string.";
    });
    var r = t.getInstance();
    g(null == r.managers[e], function () {
      return "A model store manager is already registered for scheme '" + e + "'.";
    }), r.managers[e] = n;
  }, t.getManager = function (t) {
    var e = this.getInstance().managers[t];
    if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'");
    return e;
  }, t.getSchemes = function () {
    return Object.keys(this.getInstance().managers);
  }, t;
}();

function qh(t) {
  if (-1 === t.indexOf(Gh)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Hh.getSchemes().join(","));
  return {
    scheme: t.split(Gh)[0],
    path: t.split(Gh)[1]
  };
}

function Kh(t, e, o) {
  return void 0 === o && (o = !1), n(this, void 0, void 0, function () {
    var n, a, i, u, s, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return g(t !== e, function () {
            return "Old path and new path are the same: '" + t + "'";
          }), g((n = zh.getLoadHandlers(t)).length > 0, function () {
            return "Copying failed because no load handler is found for source URL " + t + ".";
          }), g(n.length < 2, function () {
            return "Copying failed because more than one (" + n.length + ") load handlers for source URL " + t + ".";
          }), a = n[0], g((i = zh.getSaveHandlers(e)).length > 0, function () {
            return "Copying failed because no save handler is found for destination URL " + e + ".";
          }), g(i.length < 2, function () {
            return "Copying failed because more than one (" + n.length + ") save handlers for destination URL " + e + ".";
          }), u = i[0], s = qh(t).scheme, c = qh(t).path, l = s === qh(t).scheme, [4, a.load()];

        case 1:
          return h = r.sent(), o && l ? [4, Hh.getManager(s).removeModel(c)] : [3, 3];

        case 2:
          r.sent(), r.label = 3;

        case 3:
          return [4, u.save(h)];

        case 4:
          return f = r.sent(), !o || l ? [3, 6] : [4, Hh.getManager(s).removeModel(c)];

        case 5:
          r.sent(), r.label = 6;

        case 6:
          return [2, f.modelArtifactsInfo];
      }
    });
  });
}

var jh = "models_store",
    Xh = "model_info_store";

function $h() {
  if (!a().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var t = window,
      e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
  if (null == e) throw new Error("The current browser does not appear to support IndexedDB.");
  return e;
}

function Yh(t) {
  var e = t.result;
  e.createObjectStore(jh, {
    keyPath: "modelPath"
  }), e.createObjectStore(Xh, {
    keyPath: "modelPath"
  });
}

var Qh = function () {
  function t(t) {
    if (this.indexedDB = $h(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = t;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, t)];
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, t.prototype.databaseAction = function (t, e) {
    var n = this;
    return new Promise(function (t, r) {
      var o = n.indexedDB.open("tensorflowjs", 1);
      o.onupgradeneeded = function () {
        return Yh(o);
      }, o.onsuccess = function () {
        var a = o.result;

        if (null == e) {
          var i = a.transaction(jh, "readonly"),
              u = i.objectStore(jh).get(n.modelPath);
          u.onsuccess = function () {
            if (null == u.result) return a.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
            t(u.result.modelArtifacts);
          }, u.onerror = function (t) {
            return a.close(), r(u.error);
          }, i.oncomplete = function () {
            return a.close();
          };
        } else {
          var s,
              c = Vh(e),
              l = a.transaction(Xh, "readwrite"),
              h = l.objectStore(Xh),
              f = h.put({
            modelPath: n.modelPath,
            modelArtifactsInfo: c
          });
          f.onsuccess = function () {
            var o = (s = a.transaction(jh, "readwrite")).objectStore(jh).put({
              modelPath: n.modelPath,
              modelArtifacts: e,
              modelArtifactsInfo: c
            });
            o.onsuccess = function () {
              return t({
                modelArtifactsInfo: c
              });
            }, o.onerror = function (t) {
              var e = (h = l.objectStore(Xh)).delete(n.modelPath);
              e.onsuccess = function () {
                return a.close(), r(o.error);
              }, e.onerror = function (t) {
                return a.close(), r(o.error);
              };
            };
          }, f.onerror = function (t) {
            return a.close(), r(f.error);
          }, l.oncomplete = function () {
            null == s ? a.close() : s.oncomplete = function () {
              return a.close();
            };
          };
        }
      }, o.onerror = function (t) {
        return r(o.error);
      };
    });
  }, t.URL_SCHEME = "indexeddb://", t;
}(),
    Jh = function (t) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Qh.URL_SCHEME) ? (e = t.slice(Qh.URL_SCHEME.length), new Qh(e)) : null;
  var e;
};

zh.registerSaveRouter(Jh), zh.registerLoadRouter(Jh);

var Zh = function () {
  function t() {
    this.indexedDB = $h();
  }

  return t.prototype.listModels = function () {
    return n(this, void 0, void 0, function () {
      var t = this;
      return r(this, function (e) {
        return [2, new Promise(function (e, n) {
          var r = t.indexedDB.open("tensorflowjs", 1);
          r.onupgradeneeded = function () {
            return Yh(r);
          }, r.onsuccess = function () {
            var t = r.result,
                o = t.transaction(Xh, "readonly"),
                a = o.objectStore(Xh).getAll();
            a.onsuccess = function () {
              for (var t = {}, n = 0, r = a.result; n < r.length; n++) {
                var o = r[n];
                t[o.modelPath] = o.modelArtifactsInfo;
              }

              e(t);
            }, a.onerror = function (e) {
              return t.close(), n(a.error);
            }, o.oncomplete = function () {
              return t.close();
            };
          }, r.onerror = function (t) {
            return n(r.error);
          };
        })];
      });
    });
  }, t.prototype.removeModel = function (t) {
    return n(this, void 0, void 0, function () {
      var e = this;
      return r(this, function (n) {
        var r;
        return t = (r = t).startsWith(Qh.URL_SCHEME) ? r.slice(Qh.URL_SCHEME.length) : r, [2, new Promise(function (n, r) {
          var o = e.indexedDB.open("tensorflowjs", 1);
          o.onupgradeneeded = function () {
            return Yh(o);
          }, o.onsuccess = function () {
            var e,
                a = o.result,
                i = a.transaction(Xh, "readwrite"),
                u = i.objectStore(Xh),
                s = u.get(t);
            s.onsuccess = function () {
              if (null == s.result) return a.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));

              var o = u.delete(t),
                  i = function () {
                var o = (e = a.transaction(jh, "readwrite")).objectStore(jh).delete(t);
                o.onsuccess = function () {
                  return n(s.result.modelArtifactsInfo);
                }, o.onerror = function (t) {
                  return r(s.error);
                };
              };

              o.onsuccess = i, o.onerror = function (t) {
                return i(), a.close(), r(s.error);
              };
            }, s.onerror = function (t) {
              return a.close(), r(s.error);
            }, i.oncomplete = function () {
              null == e ? a.close() : e.oncomplete = function () {
                return a.close();
              };
            };
          }, o.onerror = function (t) {
            return r(o.error);
          };
        })];
      });
    });
  }, t;
}();

if (a().getBool("IS_BROWSER")) try {
  Hh.registerManager(Qh.URL_SCHEME, new Zh());
} catch (t) {}
var tf = "/",
    ef = "tensorflowjs_models",
    nf = "info",
    rf = "model_topology",
    of = "weight_specs",
    af = "weight_data",
    uf = "model_metadata";

function sf(t) {
  return {
    info: [ef, t, nf].join(tf),
    topology: [ef, t, rf].join(tf),
    weightSpecs: [ef, t, of].join(tf),
    weightData: [ef, t, af].join(tf),
    modelMetadata: [ef, t, uf].join(tf)
  };
}

function cf(t) {
  var e = t.split(tf);
  if (e.length < 3) throw new Error("Invalid key format: " + t);
  return e.slice(1, e.length - 1).join(tf);
}

var lf = function () {
  function t(t) {
    if (!a().getBool("IS_BROWSER") || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = t, this.keys = sf(this.modelPath);
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o;
      return r(this, function (r) {
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), o = Vh(t);

        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, (a = t.weightData, Ph ? Buffer.from(a).toString("base64") : btoa(String.fromCharCode.apply(null, new Uint8Array(a))))), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
            format: t.format,
            generatedBy: t.generatedBy,
            convertedBy: t.convertedBy
          })), [2, {
            modelArtifactsInfo: o
          }];
        } catch (t) {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o.modelTopologyBytes + ", weightSpecsBytes=" + o.weightSpecsBytes + ", weightDataBytes=" + o.weightDataBytes + ".");
        }

        var a;
        return [2];
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, u;
      return r(this, function (r) {
        if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if ("JSON" !== t.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (e.modelTopology = n, null == (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (e.weightSpecs = o, null != (a = this.LS.getItem(this.keys.modelMetadata)) && (i = JSON.parse(a), e.format = i.format, e.generatedBy = i.generatedBy, e.convertedBy = i.convertedBy), null == (u = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return e.weightData = function (t) {
          if (Ph) {
            var e = Buffer.from(t, "base64");
            return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
          }

          for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o);

          return r.buffer;
        }(u), [2, e];
      });
    });
  }, t.URL_SCHEME = "localstorage://", t;
}(),
    hf = function (t) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(lf.URL_SCHEME) ? (e = t.slice(lf.URL_SCHEME.length), new lf(e)) : null;
  var e;
};

zh.registerSaveRouter(hf), zh.registerLoadRouter(hf);

var ff = function () {
  function t() {
    g(a().getBool("IS_BROWSER"), function () {
      return "Current environment is not a web browser";
    }), g(void 0 !== window.localStorage, function () {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }

  return t.prototype.listModels = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i;
      return r(this, function (r) {
        for (t = {}, e = ef + tf, n = tf + nf, o = 0; o < this.LS.length; ++o) (a = this.LS.key(o)).startsWith(e) && a.endsWith(n) && (i = cf(a), t[i] = JSON.parse(this.LS.getItem(a)));

        return [2, t];
      });
    });
  }, t.prototype.removeModel = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        var o;
        if (t = (o = t).startsWith(lf.URL_SCHEME) ? o.slice(lf.URL_SCHEME.length) : o, e = sf(t), null == this.LS.getItem(e.info)) throw new Error("Cannot find model at path '" + t + "'");
        return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n];
      });
    });
  }, t;
}();

if (a().getBool("IS_BROWSER")) try {
  Hh.registerManager(lf.URL_SCHEME, new ff());
} catch (t) {}
var pf = "model",
    df = ".json",
    vf = ".weights.bin";

function mf(t) {
  return new Promise(function (t) {
    return setTimeout(t);
  }).then(t);
}

var gf = function () {
  function t(e) {
    if (!a().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = pf), this.modelTopologyFileName = e + df, this.weightDataFileName = e + vf;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, u;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (e = window.URL.createObjectURL(new Blob([t.weightData], {
              type: "application/octet-stream"
            })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");

          case 1:
            return n = [{
              paths: ["./" + this.weightDataFileName],
              weights: t.weightSpecs
            }], o = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              weightsManifest: n
            }, a = window.URL.createObjectURL(new Blob([JSON.stringify(o)], {
              type: "application/json"
            })), (i = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = a, [4, mf(function () {
              return i.dispatchEvent(new MouseEvent("click"));
            })];

          case 2:
            return r.sent(), null == t.weightData ? [3, 4] : ((u = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, u.href = e, [4, mf(function () {
              return u.dispatchEvent(new MouseEvent("click"));
            })]);

          case 3:
            r.sent(), r.label = 4;

          case 4:
            return [2, {
              modelArtifactsInfo: Vh(t)
            }];
        }
      });
    });
  }, t.URL_SCHEME = "downloads://", t;
}(),
    yf = function () {
  function t(t) {
    if (null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t);
    this.files = t;
  }

  return t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t,
          e,
          n = this;
      return r(this, function (r) {
        return t = this.files[0], e = this.files.slice(1), [2, new Promise(function (r, o) {
          var a = new FileReader();
          a.onload = function (a) {
            var i = JSON.parse(a.target.result),
                u = i.modelTopology;

            if (null != u) {
              0 === e.length && r({
                modelTopology: u
              });
              var s = i.weightsManifest;

              if (null != s) {
                var c;

                try {
                  c = n.checkManifestAndWeightFiles(s, e);
                } catch (t) {
                  return void o(t);
                }

                var l = [],
                    h = [],
                    f = [];
                s.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    h.push(t), f.push(null);
                  }), l.push.apply(l, t.weights);
                }), s.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    var e = new FileReader();
                    e.onload = function (e) {
                      var n = e.target.result,
                          o = h.indexOf(t);
                      f[o] = n, -1 === f.indexOf(null) && r({
                        modelTopology: u,
                        weightSpecs: l,
                        weightData: Wh(f)
                      });
                    }, e.onerror = function (e) {
                      return o("Failed to weights data from file of path '" + t + "'.");
                    }, e.readAsArrayBuffer(c[t]);
                  });
                });
              } else o(new Error("weightManifest field is missing from file " + t.name));
            } else o(new Error("modelTopology field is missing from file " + t.name));
          }, a.onerror = function (e) {
            return o("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, a.readAsText(t);
        })];
      });
    });
  }, t.prototype.checkManifestAndWeightFiles = function (t, e) {
    for (var n = [], r = e.map(function (t) {
      return Uh(t.name);
    }), o = {}, a = 0, i = t; a < i.length; a++) {
      i[a].paths.forEach(function (t) {
        var a = Uh(t);
        if (-1 !== n.indexOf(a)) throw new Error("Duplicate file basename found in weights manifest: '" + a + "'");
        if (n.push(a), -1 === r.indexOf(a)) throw new Error("Weight file with basename '" + a + "' is not provided.");
        o[t] = e[r.indexOf(a)];
      });
    }

    if (n.length !== e.length) throw new Error("Mismatch in the number of files in weights manifest (" + n.length + ") and the number of weight files provided (" + e.length + ").");
    return o;
  }, t;
}();

function xf(t, e, n, r) {
  !function (t) {
    g(null != t && Array.isArray(t) && t.length > 0, function () {
      return "promises must be a none empty array";
    });
  }(t), function (t, e) {
    g(t >= 0 && t <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got startFraction " + t;
    }), g(e >= 0 && e <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got endFraction " + e;
    }), g(e >= t, function () {
      return "startFraction must be no more than endFraction, but got startFraction " + t + " and endFraction " + e;
    });
  }(n = null == n ? 0 : n, r = null == r ? 1 : r);
  var o = 0;
  return Promise.all(t.map(function (a) {
    return a.then(function (a) {
      var i = n + ++o / t.length * (r - n);
      return e(i), a;
    }), a;
  }));
}

function bf(t, e) {
  return n(this, void 0, void 0, function () {
    var n, o, i, u, s, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return null == e && (e = {}), n = null == e.fetchFunc ? a().platform.fetch : e.fetchFunc, o = t.map(function (t) {
            return n(t, e.requestInit, {
              isBinary: !0
            });
          }), i = 0, u = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(o)];

        case 1:
          return s = r.sent(), [3, 4];

        case 2:
          return [4, xf(o, e.onProgress, i, u)];

        case 3:
          s = r.sent(), r.label = 4;

        case 4:
          return c = s.map(function (t) {
            return t.arrayBuffer();
          }), l = .5, h = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(c)];

        case 5:
          return f = r.sent(), [3, 8];

        case 6:
          return [4, xf(c, e.onProgress, l, h)];

        case 7:
          f = r.sent(), r.label = 8;

        case 8:
          return [2, f];
      }
    });
  });
}

function wf(t) {
  var e = this;
  return function (o, a, i) {
    return void 0 === a && (a = ""), n(e, void 0, void 0, function () {
      var e, n, u, s, c, l, h, f, p, d;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (e = o.map(function () {
              return !1;
            }), n = {}, u = null != i ? i.map(function () {
              return !1;
            }) : [], s = [], o.forEach(function (t, r) {
              var o = 0;
              t.weights.forEach(function (t) {
                var a = "quantization" in t ? t.quantization.dtype : t.dtype,
                    c = Oh[a] * w(t.shape),
                    l = function () {
                  e[r] = !0, null == n[r] && (n[r] = []), n[r].push({
                    manifestEntry: t,
                    groupOffset: o,
                    sizeBytes: c
                  });
                };

                null != i ? i.forEach(function (e, n) {
                  e === t.name && (l(), u[n] = !0);
                }) : l(), s.push(t.name), o += c;
              });
            }), !u.every(function (t) {
              return t;
            })) throw c = i.filter(function (t, e) {
              return !u[e];
            }), new Error("Could not find weights in manifest with names: " + c.join(", ") + ". \nManifest JSON has weights with names: " + s.join(", ") + ".");
            return l = e.reduce(function (t, e, n) {
              return e && t.push(n), t;
            }, []), h = [], l.forEach(function (t) {
              o[t].paths.forEach(function (t) {
                var e = a + (a.endsWith("/") ? "" : "/") + t;
                h.push(e);
              });
            }), [4, t(h)];

          case 1:
            return f = r.sent(), p = {}, d = 0, l.forEach(function (t) {
              for (var e = o[t].paths.length, r = 0, a = 0; a < e; a++) r += f[d + a].byteLength;

              for (var i = new ArrayBuffer(r), u = new Uint8Array(i), s = 0, c = 0; c < e; c++) {
                var l = new Uint8Array(f[d + c]);
                u.set(l, s), s += l.byteLength;
              }

              n[t].forEach(function (t) {
                var e = Mh(i.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);

                for (var n in e) p[n] = e[n];
              }), d += e;
            }), [2, p];
        }
      });
    });
  };
}

zh.registerSaveRouter(function (t) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(gf.URL_SCHEME) ? (e = t.slice(gf.URL_SCHEME.length), void 0 === e && (e = "model"), new gf(e)) : null;
  var e;
});

var Cf = function () {
  function t(t, e) {
    if (this.DEFAULT_METHOD = "POST", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (g("function" == typeof e.fetchFunc, function () {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = e.fetchFunc) : this.fetch = a().platform.fetch, g(null != t && t.length > 0, function () {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(t) && g(2 === t.length, function () {
      return "URL paths for http must have a length of 2, (actual length is " + t.length + ").";
    }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = e.requestInit || {};
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (e = Object.assign({
              method: this.DEFAULT_METHOD
            }, this.requestInit)).body = new FormData(), n = [{
              paths: ["./model.weights.bin"],
              weights: t.weightSpecs
            }], o = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              userDefinedMetadata: t.userDefinedMetadata,
              weightsManifest: n
            }, e.body.append("model.json", new Blob([JSON.stringify(o)], {
              type: "application/json"
            }), "model.json"), null != t.weightData && e.body.append("model.weights.bin", new Blob([t.weightData], {
              type: "application/octet-stream"
            }), "model.weights.bin"), [4, this.fetch(this.path, e)];

          case 1:
            if ((a = r.sent()).ok) return [2, {
              modelArtifactsInfo: Vh(t),
              responses: [a]
            }];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a.status + ".");
        }
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, u, s;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];

          case 1:
            if (!(t = r.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
            r.label = 2;

          case 2:
            return r.trys.push([2, 4,, 5]), [4, t.json()];

          case 3:
            return e = r.sent(), [3, 5];

          case 4:
            throw r.sent(), n = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n += " Please make sure the server is serving valid JSON for this request.", new Error(n);

          case 5:
            if (o = e.modelTopology, a = e.weightsManifest, null == o && null == a) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return null == a ? [3, 7] : [4, this.loadWeights(a)];

          case 6:
            s = r.sent(), i = s[0], u = s[1], r.label = 7;

          case 7:
            return [2, {
              modelTopology: o,
              weightSpecs: i,
              weightData: u
            }];
        }
      });
    });
  }, t.prototype.loadWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, u, s, c, l, h, f;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function (t) {
              var e = t.lastIndexOf("/"),
                  n = t.lastIndexOf("?"),
                  r = t.substring(0, e),
                  o = n > e ? t.substring(n) : "";
              return [r + "/", o];
            }(e), o = n[0], a = n[1], i = this.weightPathPrefix || o, u = [], s = 0, c = t; s < c.length; s++) l = c[s], u.push.apply(u, l.weights);

            return h = [], t.forEach(function (t) {
              t.paths.forEach(function (t) {
                h.push(i + t + a);
              });
            }), [4, bf(h, {
              requestInit: this.requestInit,
              fetchFunc: this.fetch,
              onProgress: this.onProgress
            })];

          case 1:
            return f = r.sent(), [2, [u, Wh(f)]];
        }
      });
    });
  }, t.URL_SCHEME_REGEX = /^https?:\/\//, t;
}();

function Ef(t) {
  return null != t.match(Cf.URL_SCHEME_REGEX);
}

var Rf = function (t, e) {
  if ("undefined" == typeof fetch) return null;
  return (Array.isArray(t) ? t.every(function (t) {
    return Ef(t);
  }) : Ef(t)) ? If(t, {
    onProgress: e
  }) : null;
};

function If(t, e) {
  return new Cf(t, e);
}

zh.registerSaveRouter(Rf), zh.registerLoadRouter(Rf);

var kf = function () {
  function t(t) {
    this.modelArtifacts = t;
  }

  return t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return [2, this.modelArtifacts];
      });
    });
  }, t;
}(),
    Sf = function () {
  function t(t) {
    this.saveHandler = t;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        return [2, this.saveHandler(t)];
      });
    });
  }, t;
}();

var Af = Object.freeze({
  browserFiles: function (t) {
    return new yf(t);
  },
  browserHTTPRequest: function (t, e) {
    return If(t, e);
  },
  concatenateArrayBuffers: Wh,
  decodeWeights: Mh,
  encodeWeights: function (t, e) {
    return n(this, void 0, void 0, function () {
      var o,
          a,
          i,
          u,
          s,
          c = this;
      return r(this, function (l) {
        switch (l.label) {
          case 0:
            for (o = [], a = [], i = Array.isArray(t) ? t.map(function (t) {
              return t.name;
            }) : Object.keys(t), u = function (u) {
              var s = i[u],
                  l = Array.isArray(t) ? t[u].tensor : t[s];
              if ("float32" !== l.dtype && "int32" !== l.dtype && "bool" !== l.dtype && "string" !== l.dtype) throw new Error("Unsupported dtype in weight '" + s + "': " + l.dtype);
              var h = {
                name: s,
                shape: l.shape,
                dtype: l.dtype
              };

              if ("string" === l.dtype) {
                var f = new Promise(function (t) {
                  return n(c, void 0, void 0, function () {
                    var e, n, o, a, i, u, s;
                    return r(this, function (r) {
                      switch (r.label) {
                        case 0:
                          return [4, l.bytes()];

                        case 1:
                          for (e = r.sent(), n = e.reduce(function (t, e) {
                            return t + e.length;
                          }, 0) + _h * e.length, o = new Uint8Array(n), a = 0, i = 0; i < e.length; i++) u = e[i], s = new Uint8Array(new Uint32Array([u.length]).buffer), o.set(s, a), a += _h, o.set(u, a), a += u.length;

                          return t(o), [2];
                      }
                    });
                  });
                });
                a.push(f);
              } else a.push(l.data());

              null != e && (h.group = e), o.push(h);
            }, s = 0; s < i.length; ++s) u(s);

            return [4, Promise.all(a)];

          case 1:
            return [2, {
              data: Bh(l.sent()),
              specs: o
            }];
        }
      });
    });
  },
  fromMemory: function (t, e, n, r) {
    return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new kf(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kf({
      modelTopology: t
    })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kf({
      modelTopology: t,
      weightSpecs: e,
      weightData: n,
      trainingConfig: r
    }));
  },
  getLoadHandlers: function (t, e) {
    return zh.getLoadHandlers(t, e);
  },
  getModelArtifactsInfoForJSON: Vh,
  getSaveHandlers: function (t) {
    return zh.getSaveHandlers(t);
  },
  http: If,
  isHTTPScheme: Ef,
  loadWeights: function (t, e, o, a) {
    return void 0 === e && (e = ""), n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return [2, wf(function (t) {
          return bf(t, {
            requestInit: a
          });
        })(t, e, o)];
      });
    });
  },
  registerLoadRouter: function (t) {
    return zh.registerLoadRouter(t);
  },
  registerSaveRouter: function (t) {
    return zh.registerSaveRouter(t);
  },
  weightsLoaderFactory: wf,
  withSaveHandler: function (t) {
    return new Sf(t);
  },
  copyModel: function (t, e) {
    return n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return [2, Kh(t, e, !1)];
      });
    });
  },
  listModels: function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, u;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            t = Hh.getSchemes(), e = {}, n = 0, o = t, r.label = 1;

          case 1:
            return n < o.length ? (a = o[n], [4, Hh.getManager(a).listModels()]) : [3, 4];

          case 2:
            for (u in i = r.sent()) e[a + Gh + u] = i[u];

            r.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2, e];
        }
      });
    });
  },
  moveModel: function (t, e) {
    return n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return [2, Kh(t, e, !0)];
      });
    });
  },
  removeModel: function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return e = qh(t), [2, Hh.getManager(e.scheme).removeModel(e.path)];
      });
    });
  }
});
exports.io = Af;
var Df = Cn({
  confusionMatrix_: function (t, e, n) {
    var r = ln(t, "labels", "confusionMatrix"),
        o = ln(e, "predictions", "confusionMatrix");
    g(null == n || n > 0 && Number.isInteger(n), function () {
      return "If provided, numClasses must be a positive integer, but got " + n;
    }), g(1 === r.rank, function () {
      return "Expected the rank of labels to be 1, but got " + r.rank;
    }), g(1 === o.rank, function () {
      return "Expected the rank of predictions to be 1, but got " + o.rank;
    }), g(r.shape[0] === o.shape[0], function () {
      return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + o.shape[0] + ". Labels and predictions should have the same number of elements.";
    }), g(n > 0 && Number.isInteger(n), function () {
      return "numClasses is required to be a positive integer, but got " + n;
    });
    var a = gr(r.asType("int32"), n),
        i = gr(o.asType("int32"), n);
    return a.transpose().matMul(i).asType("int32");
  }
}),
    Tf = Object.freeze({
  confusionMatrix: Df
});
exports.math = Tf;

var Nf = Cn({
  fromPixels_: function (t, e) {
    if (void 0 === e && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    var n = "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement;
    if (n && n && t.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
    return Nt.fromPixels(t, e);
  }
}),
    Ff = Object.freeze({
  toPixels: function (t, e) {
    return n(this, void 0, void 0, function () {
      var n, o, a, i, u, s, c, l, h, f, p, d, v, m, g, y, x, b, w, C, E, R, I;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (n = ln(t, "img", "toPixels"), t instanceof dt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n.rank + ".");
            if (o = n.shape.slice(0, 2), a = o[0], i = o[1], (u = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === u) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + u);
            return [4, n.data()];

          case 1:
            return s = r.sent(), c = n.min(), l = n.max(), [4, Promise.all([c.data(), l.data()])];

          case 2:
            if (h = r.sent(), f = h[0], p = h[1], d = f[0], v = p[0], c.dispose(), l.dispose(), "float32" === n.dtype) {
              if (d < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d + " - " + v + "].");
            } else {
              if ("int32" !== n.dtype) throw new Error("Unsupported type for toPixels: " + n.dtype + ". Please use float32 or int32 tensors.");
              if (d < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d + " - " + v + "].");
            }

            for (m = "float32" === n.dtype ? 255 : 1, g = new Uint8ClampedArray(i * a * 4), y = 0; y < a * i; ++y) x = void 0, b = void 0, w = void 0, C = void 0, 1 === u ? (x = s[y] * m, b = s[y] * m, w = s[y] * m, C = 255) : 3 === u ? (x = s[3 * y] * m, b = s[3 * y + 1] * m, w = s[3 * y + 2] * m, C = 255) : 4 === u && (x = s[4 * y] * m, b = s[4 * y + 1] * m, w = s[4 * y + 2] * m, C = s[4 * y + 3] * m), g[0 + (E = 4 * y)] = Math.round(x), g[E + 1] = Math.round(b), g[E + 2] = Math.round(w), g[E + 3] = Math.round(C);

            return null != e && (e.width = i, e.height = a, R = e.getContext("2d"), I = new ImageData(g, i, a), R.putImageData(I, 0, 0)), n !== t && n.dispose(), [2, g];
        }
      });
    });
  },
  fromPixels: Nf
}),
    Of = function () {
  function t() {}

  return t.prototype.getClassName = function () {
    return this.constructor.className;
  }, t.fromConfig = function (t, e) {
    return new t(e);
  }, t;
}(),
    _f = function () {
  function t() {
    this.classNameMap = {};
  }

  return t.getMap = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.register = function (e) {
    t.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }, t;
}();

exports.browser = Ff;

function Mf(t) {
  g(null != t.className, function () {
    return "Class being registered does not have the static className property defined.";
  }), g("string" == typeof t.className, function () {
    return "className is required to be a string, but got type " + typeof t.className;
  }), g(t.className.length > 0, function () {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), _f.register(t);
}

var Bf = Object.freeze({
  Serializable: Of,
  SerializationMap: _f,
  registerClass: Mf
}),
    Pf = .001,
    Lf = .1;
exports.serialization = Bf;

function Wf() {
  return 32 === Nt.backend.floatPrecision() ? Pf : Lf;
}

function Uf(t, e, n) {
  var r = !0;

  if ((B(t) || B(e)) && (r = !1), B(t) && B(e) && (r = !0), r) {
    var o = t.constructor.name,
        a = e.constructor.name;
    if (o !== a) throw new Error("Arrays are of different type. Actual: " + o + ". Expected: " + a);
  }

  if (Array.isArray(t) && Array.isArray(e)) {
    var i = sn(t),
        u = sn(e);
    if (!C(i, u)) throw new Error("Arrays have different shapes. Actual: [" + i + "]. Expected: [" + u + "]");
  }

  var s = B(t) ? t : b(t),
      c = B(e) ? e : b(e);
  if (s.length !== c.length) throw new Error("Arrays have different lengths actual: " + s.length + " vs expected: " + c.length + ".\nActual:   " + s + ".\nExpected: " + c + ".");

  for (var l = 0; l < c.length; ++l) {
    var h = s[l],
        f = c[l];
    if (!n(h, f)) throw new Error("Arrays differ: actual[" + l + "] = " + h + ", expected[" + l + "] = " + f + ".\nActual:   " + s + ".\nExpected: " + c + ".");
  }
}

function Vf(t, e, n) {
  return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);
}

var zf = Object.freeze({
  TEST_EPSILON_FLOAT16: Lf,
  expectArraysClose: function (t, e, n) {
    return null == n && (n = Wf()), Uf(t, e, function (t, e) {
      return Vf(t, e, n);
    });
  },
  testEpsilon: Wf,
  expectPromiseToFail: function (t, e) {
    t().then(function () {
      return e.fail();
    }, function () {
      return e();
    });
  },
  expectArraysEqual: function (t, e) {
    var n = "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? [e] : e;
    return W(t) || W(t[0]) || W(e) || W(e[0]) ? Uf(t, n, function (t, e) {
      return t == e;
    }) : Uf(t, e, function (t, e) {
      return Vf(t, e, 0);
    });
  },
  expectNumbersClose: function (t, e, n) {
    if (null == n && (n = Wf()), !Vf(t, e, n)) throw new Error("Numbers differ: actual === " + t + ", expected === " + e);
  },
  expectValuesInRange: function (t, e, n) {
    for (var r = 0; r < t.length; r++) if (t[r] < e || t[r] > n) throw new Error("Value out of range:" + t[r] + " low: " + e + ", high: " + n);
  },
  expectArrayBuffersEqual: function (t, e) {
    expect(new Float32Array(t)).toEqual(new Float32Array(e));
  }
}),
    Gf = "1.3.2";
exports.version_core = Gf;
exports.test_util = zf;

var Hf = Object.freeze({
  gpgpu_util: wi,
  webgl_util: Pe,
  forceHalfFloat: function () {
    a().set("WEBGL_FORCE_F16_TEXTURES", !0);
  },
  MathBackendWebGL: Wu,
  setWebGLContext: Wt,
  GPGPUContext: Ci
}),
    qf = function (t) {
  function o() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return e(o, t), o.prototype.minimize = function (t, e, n) {
    void 0 === e && (e = !1);
    var r = this.computeGradients(t, n),
        o = r.value,
        a = r.grads;

    if (null != n) {
      var i = n.map(function (t) {
        return {
          name: t.name,
          tensor: a[t.name]
        };
      });
      this.applyGradients(i);
    } else this.applyGradients(a);

    return Xe(a), e ? o : (o.dispose(), null);
  }, Object.defineProperty(o.prototype, "iterations", {
    get: function () {
      return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
    },
    enumerable: !0,
    configurable: !0
  }), o.prototype.incrementIterations = function () {
    this.iterations_ = this.iterations + 1;
  }, o.prototype.computeGradients = function (t, e) {
    return ro(t, e);
  }, o.prototype.dispose = function () {
    null != this.iterations_ && Xe(this.iterations_);
  }, o.prototype.saveIterations = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return null == this.iterations_ && (this.iterations_ = 0), [2, {
          name: "iter",
          tensor: An(this.iterations_, "int32")
        }];
      });
    });
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, o.prototype.extractIterations = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return e = this, [4, t[0].tensor.data()];

          case 1:
            return e.iterations_ = n.sent()[0], [2, t.slice(1)];
        }
      });
    });
  }, o;
}(Of);

exports.Optimizer = qf;
exports.webgl = Hf;
Object.defineProperty(qf, Symbol.hasInstance, {
  value: function (t) {
    return null != t.minimize && null != t.computeGradients && null != t.applyGradients;
  }
});

var Kf = function (t) {
  function o(e, n, r) {
    void 0 === r && (r = null);
    var o = t.call(this) || this;
    return o.learningRate = e, o.rho = n, o.epsilon = r, o.accumulatedGrads = [], o.accumulatedUpdates = [], null == r && (o.epsilon = Nt.backend.epsilon()), o;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Nt.registeredVariables[n];
      null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
        originalName: n + "/accum_grad",
        variable: je(function () {
          return zn(o).variable(!1);
        })
      }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {
        originalName: n + "/accum_var",
        variable: je(function () {
          return zn(o).variable(!1);
        })
      });
      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedGrads[r].variable,
            u = e.accumulatedUpdates[r].variable;
        je(function () {
          var t = i.mul(e.rho).add(a.square().mul(1 - e.rho)),
              n = u.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),
              r = u.mul(e.rho).add(n.square().mul(1 - e.rho));
          i.assign(t), u.assign(r);
          var s = n.mul(-e.learningRate).add(o);
          o.assign(s);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedUpdates && (Xe(this.accumulatedGrads.map(function (t) {
      return t.variable;
    })), Xe(this.accumulatedUpdates.map(function (t) {
      return t.variable;
    })));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = n.sent(), e = t.length / 2, !1, this.accumulatedGrads = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.rho, e.epsilon);
  }, o.className = "Adadelta", o;
}(qf);

exports.AdadeltaOptimizer = Kf;
Mf(Kf);

var jf = function (t) {
  function o(e, n) {
    void 0 === n && (n = .1);
    var r = t.call(this) || this;
    return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Nt.registeredVariables[n];

      if (null == e.accumulatedGrads[r]) {
        e.accumulatedGrads[r] = {
          originalName: n + "/accumulator",
          variable: je(function () {
            return Ln(o.shape, e.initialAccumulatorValue).variable(!1);
          })
        };
      }

      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedGrads[r].variable;
        je(function () {
          var t = i.add(a.square());
          i.assign(t);
          var n = a.div(t.add(Nt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);
          o.assign(n);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedGrads && Xe(this.accumulatedGrads.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()].concat(this.accumulatedGrads.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = e.sent(), !1, this.accumulatedGrads = t.map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.initialAccumulatorValue);
  }, o.className = "Adagrad", o;
}(qf);

exports.AdagradOptimizer = jf;
Mf(jf);

var Xf = function (t) {
  function o(e, n, r, o) {
    void 0 === o && (o = null);
    var a = t.call(this) || this;
    return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.accumulatedFirstMoment = [], a.accumulatedSecondMoment = [], je(function () {
      a.accBeta1 = An(n).variable(), a.accBeta2 = An(r).variable();
    }), null == o && (a.epsilon = Nt.backend.epsilon()), a;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t);
    je(function () {
      var r = uc(1, e.accBeta1),
          o = uc(1, e.accBeta2);
      n.forEach(function (n, a) {
        var i = Nt.registeredVariables[n];
        null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {
          originalName: n + "/m",
          variable: je(function () {
            return zn(i).variable(!1);
          })
        }), null == e.accumulatedSecondMoment[a] && (e.accumulatedSecondMoment[a] = {
          originalName: n + "/v",
          variable: je(function () {
            return zn(i).variable(!1);
          })
        });
        var u = Array.isArray(t) ? t[a].tensor : t[n];

        if (null != u) {
          var s = e.accumulatedFirstMoment[a].variable,
              c = e.accumulatedSecondMoment[a].variable,
              l = s.mul(e.beta1).add(u.mul(1 - e.beta1)),
              h = c.mul(e.beta2).add(u.square().mul(1 - e.beta2)),
              f = l.div(r),
              p = h.div(o);
          s.assign(l), c.assign(h);
          var d = f.div(p.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);
          i.assign(d);
        }
      }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2));
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function (t) {
      return t.variable;
    })), null != this.accumulatedSecondMoment && Xe(this.accumulatedSecondMoment.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e,
          n = this;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = r.sent(), je(function () {
              n.accBeta1.assign(rc(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(rc(n.beta2, n.iterations_ + 1));
            }), e = t.length / 2, !1, this.accumulatedFirstMoment = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);
  }, o.className = "Adam", o;
}(qf);

exports.AdamOptimizer = Xf;
Mf(Xf);

var $f = function (t) {
  function o(e, n, r, o, a) {
    void 0 === o && (o = null), void 0 === a && (a = 0);
    var i = t.call(this) || this;
    return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = [], i.accumulatedWeightedInfNorm = [], je(function () {
      i.iteration = An(0).variable(), i.accBeta1 = An(n).variable();
    }), null == o && (i.epsilon = Nt.backend.epsilon()), i;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t);
    je(function () {
      var r = uc(1, e.accBeta1),
          o = qs(-e.learningRate, e.iteration.mul(e.decay).add(1));
      n.forEach(function (n, a) {
        var i = Nt.registeredVariables[n];
        null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {
          originalName: n + "/m",
          variable: zn(i).variable(!1)
        }), null == e.accumulatedWeightedInfNorm[a] && (e.accumulatedWeightedInfNorm[a] = {
          originalName: n + "/v",
          variable: zn(i).variable(!1)
        });
        var u = Array.isArray(t) ? t[a].tensor : t[n];

        if (null != u) {
          var s = e.accumulatedFirstMoment[a].variable,
              c = e.accumulatedWeightedInfNorm[a].variable,
              l = s.mul(e.beta1).add(u.mul(1 - e.beta1)),
              h = c.mul(e.beta2),
              f = u.abs(),
              p = h.maximum(f);
          s.assign(l), c.assign(p);
          var d = o.div(r).mul(l.div(p.add(e.epsilon))).add(i);
          i.assign(d);
        }
      }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1));
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function (t) {
      return t.variable;
    })), null != this.accumulatedWeightedInfNorm && Xe(this.accumulatedWeightedInfNorm.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);
  }, o.className = "Adamax", o;
}(qf);

exports.AdamaxOptimizer = $f;
Mf($f);

var Yf = function (t) {
  function o(e) {
    var n = t.call(this) || this;
    return n.learningRate = e, n.setLearningRate(e), n;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != o) {
        var a = Nt.registeredVariables[n];
        je(function () {
          var t = e.c.mul(o).add(a);
          a.assign(t);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.setLearningRate = function (t) {
    this.learningRate = t, null != this.c && this.c.dispose(), this.c = $e(An(-t));
  }, o.prototype.dispose = function () {
    this.c.dispose();
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()]];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            if (0 !== (t = e.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate);
  }, o.className = "SGD", o;
}(qf);

exports.SGDOptimizer = Yf;
Mf(Yf);

var Qf = function (t) {
  function o(e, n, r) {
    void 0 === r && (r = !1);
    var o = t.call(this, e) || this;
    return o.learningRate = e, o.momentum = n, o.useNesterov = r, o.accumulations = [], o.m = An(o.momentum), o;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Nt.registeredVariables[n];

      if (null == e.accumulations[r]) {
        e.accumulations[r] = {
          originalName: n + "/momentum",
          variable: je(function () {
            return zn(o).variable(!1);
          })
        };
      }

      var a = e.accumulations[r].variable,
          i = Array.isArray(t) ? t[r].tensor : t[n];
      null != i && je(function () {
        var t,
            n = e.m.mul(a).add(i);
        t = e.useNesterov ? e.c.mul(i.add(n.mul(e.m))).add(o) : e.c.mul(n).add(o), a.assign(n), o.assign(t);
      });
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.m.dispose(), null != this.accumulations && Xe(this.accumulations.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.setMomentum = function (t) {
    this.momentum = t;
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()].concat(this.accumulations.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = e.sent(), !1, this.accumulations = t.map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.momentum, e.useNesterov);
  }, o.className = "Momentum", o;
}(Yf);

exports.MomentumOptimizer = Qf;
Mf(Qf);

var Jf = function (t) {
  function o(e, n, r, o, a) {
    void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1);
    var i = t.call(this) || this;
    return i.learningRate = e, i.decay = n, i.momentum = r, i.epsilon = o, i.accumulatedMeanSquares = [], i.accumulatedMoments = [], i.accumulatedMeanGrads = [], i.centered = a, null == o && (i.epsilon = Nt.backend.epsilon()), i;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Nt.registeredVariables[n];
      null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {
        originalName: n + "/rms",
        variable: je(function () {
          return zn(o).variable(!1);
        })
      }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {
        originalName: n + "/momentum",
        variable: je(function () {
          return zn(o).variable(!1);
        })
      }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {
        originalName: n + "/mg",
        variable: je(function () {
          return zn(o).variable(!1);
        })
      });
      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedMeanSquares[r].variable,
            u = e.accumulatedMoments[r].variable;
        je(function () {
          var t = i.mul(e.decay).add(a.square().mul(1 - e.decay));

          if (e.centered) {
            var n = e.accumulatedMeanGrads[r].variable,
                s = n.mul(e.decay).add(a.mul(1 - e.decay)),
                c = u.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(s.square().add(e.epsilon)).sqrt()));
            i.assign(t), n.assign(s), u.assign(c);
            var l = o.sub(c);
            o.assign(l);
          } else {
            var h = i.mul(e.decay).add(a.square().mul(1 - e.decay));
            c = u.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));
            i.assign(h), u.assign(c);
            l = o.sub(c);
            o.assign(l);
          }
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedMeanSquares && Xe(this.accumulatedMeanSquares.map(function (t) {
      return t.variable;
    })), null != this.accumulatedMeanGrads && this.centered && Xe(this.accumulatedMeanGrads.map(function (t) {
      return t.variable;
    })), null != this.accumulatedMoments && Xe(this.accumulatedMoments.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, !1, this.accumulatedMeanSquares = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedMoments = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            })), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);
  }, o.className = "RMSProp", o;
}(qf);

exports.RMSPropOptimizer = Jf;
Mf(Jf);

var Zf = function () {
  function t() {}

  return t.sgd = function (t) {
    return new Yf(t);
  }, t.momentum = function (t, e, n) {
    return void 0 === n && (n = !1), new Qf(t, e, n);
  }, t.rmsprop = function (t, e, n, r, o) {
    return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new Jf(t, e, n, r, o);
  }, t.adam = function (t, e, n, r) {
    return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Xf(t, e, n, r);
  }, t.adadelta = function (t, e, n) {
    return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new Kf(t, e, n);
  }, t.adamax = function (t, e, n, r, o) {
    return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new $f(t, e, n, r, o);
  }, t.adagrad = function (t, e) {
    return void 0 === e && (e = .1), new jf(t, e);
  }, t;
}(),
    tp = {
  sgd: Zf.sgd,
  momentum: Zf.momentum,
  adadelta: Zf.adadelta,
  adagrad: Zf.adagrad,
  rmsprop: Zf.rmsprop,
  adamax: Zf.adamax,
  adam: Zf.adam
},
    ep = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function (t) {
  return t();
};

exports.train = tp;

function np() {
  return new Promise(function (t) {
    return ep(function () {
      return t();
    });
  });
}

ft = Ih;
},{"crypto":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","node-fetch":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js","buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.input = input;
exports.loadLayersModel = loadLayersModel;
exports.model = model;
exports.registerCallbackConstructor = registerCallbackConstructor;
exports.sequential = sequential;
exports.version_layers = exports.LayerVariable = exports.Sequential = exports.RNN = exports.LayersModel = exports.SymbolicTensor = exports.InputSpec = exports.EarlyStopping = exports.callbacks = exports.Callback = exports.History = exports.CustomCallback = exports.CallbackList = exports.regularizers = exports.models = exports.metrics = exports.layers = exports.initializers = exports.constraints = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics = function (e, t) {
  return (extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (e, t) {
    e.__proto__ = t;
  } || function (e, t) {
    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
  })(e, t);
};

function __extends(e, t) {
  function n() {
    this.constructor = e;
  }

  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
}

var _epsilon,
    __assign = function () {
  return (__assign = Object.assign || function (e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);

    return e;
  }).apply(this, arguments);
};

function __awaiter(e, t, n, r) {
  return new (n || (n = Promise))(function (i, a) {
    function o(e) {
      try {
        l(r.next(e));
      } catch (e) {
        a(e);
      }
    }

    function s(e) {
      try {
        l(r.throw(e));
      } catch (e) {
        a(e);
      }
    }

    function l(e) {
      e.done ? i(e.value) : new n(function (t) {
        t(e.value);
      }).then(o, s);
    }

    l((r = r.apply(e, t || [])).next());
  });
}

function __generator(e, t) {
  var n,
      r,
      i,
      a,
      o = {
    label: 0,
    sent: function () {
      if (1 & i[0]) throw i[1];
      return i[1];
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (a[Symbol.iterator] = function () {
    return this;
  }), a;

  function s(a) {
    return function (s) {
      return function (a) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; o;) try {
          if (n = 1, r && (i = 2 & a[0] ? r.return : a[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, a[1])).done) return i;

          switch (r = 0, i && (a = [2 & a[0], i.value]), a[0]) {
            case 0:
            case 1:
              i = a;
              break;

            case 4:
              return o.label++, {
                value: a[1],
                done: !1
              };

            case 5:
              o.label++, r = a[1], a = [0];
              continue;

            case 7:
              a = o.ops.pop(), o.trys.pop();
              continue;

            default:
              if (!(i = (i = o.trys).length > 0 && i[i.length - 1]) && (6 === a[0] || 2 === a[0])) {
                o = 0;
                continue;
              }

              if (3 === a[0] && (!i || a[1] > i[0] && a[1] < i[3])) {
                o.label = a[1];
                break;
              }

              if (6 === a[0] && o.label < i[1]) {
                o.label = i[1], i = a;
                break;
              }

              if (i && o.label < i[2]) {
                o.label = i[2], o.ops.push(a);
                break;
              }

              i[2] && o.ops.pop(), o.trys.pop();
              continue;
          }

          a = t.call(e, o);
        } catch (e) {
          a = [6, e], r = 0;
        } finally {
          n = i = 0;
        }

        if (5 & a[0]) throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        };
      }([a, s]);
    };
  }
}

function epsilon() {
  return null == _epsilon && (_epsilon = (0, _tfjsCore.backend)().epsilon()), _epsilon;
}

function imageDataFormat() {
  return "channelsLast";
}

var AttributeError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    RuntimeError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    ValueError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    NotImplementedError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    AssertionError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    IndexError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error);

function pyListRepeat(e, t) {
  if (Array.isArray(e)) {
    for (var n = [], r = 0; r < t; r++) n = n.concat(e);

    return n;
  }

  return (n = new Array(t)).fill(e), n;
}

function assert(e, t) {
  if (!e) throw new AssertionError(t);
}

function count(e, t) {
  for (var n = 0, r = 0, i = e; r < i.length; r++) {
    i[r] === t && n++;
  }

  return n;
}

function singletonOrArray(e) {
  return 1 === e.length ? e[0] : e;
}

function toList(e) {
  return Array.isArray(e) ? e : [e];
}

function toSnakeCase(e) {
  var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return "_" !== t[0] ? t : "private" + t;
}

function toCamelCase(e) {
  return e.length <= 1 ? e : -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, function (e, t) {
    return t.toUpperCase();
  });
}

var _GLOBAL_CUSTOM_OBJECTS = {};

function serializeKerasObject(e) {
  if (null === e || void 0 === e) return null;
  var t = {};
  return t.className = e.getClassName(), t.config = e.getConfig(), t;
}

function convertNDArrayScalarsInConfig(e) {
  if (null != e && "object" == typeof e) if (Array.isArray(e)) e.forEach(function (e) {
    return convertNDArrayScalarsInConfig(e);
  });else for (var t = 0, n = Object.keys(e); t < n.length; t++) {
    var r = n[t],
        i = e[r];
    null != i && "object" == typeof i && (Array.isArray(i) || "ndarray" !== i.type || "number" != typeof i.value ? convertNDArrayScalarsInConfig(i) : e[r] = i.value);
  }
}

function deserializeKerasObject(e, t, n, r, i) {
  var a, o, s;

  if (void 0 === t && (t = {}), void 0 === n && (n = {}), void 0 === r && (r = "object"), void 0 === i && (i = !1), "string" == typeof e) {
    var l = e,
        u = void 0;
    if (l in n) u = n[l];else if (l in _GLOBAL_CUSTOM_OBJECTS) u = _GLOBAL_CUSTOM_OBJECTS[l];else if (null == (u = t[l])) throw new ValueError("Unknown " + r + ": " + e + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
    return u;
  }

  var c = e;
  if (null == c.className || null == c.config) throw new ValueError(r + ": Improper config format: " + JSON.stringify(c) + ".\n'className' and 'config' must set.");
  var p = c.className,
      h = void 0,
      d = void 0;
  if (p in n ? (h = (a = n[p])[0], d = a[1]) : p in _GLOBAL_CUSTOM_OBJECTS ? (h = (o = _GLOBAL_CUSTOM_OBJECTS.className)[0], d = o[1]) : p in t && (h = (s = t[p])[0], d = s[1]), null == h) throw new ValueError("Unknown " + r + ": " + p + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");

  if (null != d) {
    for (var f = {}, g = 0, m = Object.keys(_GLOBAL_CUSTOM_OBJECTS); g < m.length; g++) {
      f[S = m[g]] = _GLOBAL_CUSTOM_OBJECTS[S];
    }

    for (var y = 0, v = Object.keys(n); y < v.length; y++) {
      f[S = v[y]] = n[S];
    }

    c.config.customObjects = f;

    for (var b = __assign({}, _GLOBAL_CUSTOM_OBJECTS), w = 0, z = Object.keys(n); w < z.length; w++) {
      var S = z[w];
      _GLOBAL_CUSTOM_OBJECTS[S] = n[S];
    }

    convertNDArrayScalarsInConfig(c.config);
    var A = d(h, c.config, n, i);
    return _GLOBAL_CUSTOM_OBJECTS = __assign({}, b), A;
  }

  b = __assign({}, _GLOBAL_CUSTOM_OBJECTS);

  for (var _ = 0, I = Object.keys(n); _ < I.length; _++) {
    S = I[_];
    _GLOBAL_CUSTOM_OBJECTS[S] = n[S];
  }

  A = new h(c.config);
  return _GLOBAL_CUSTOM_OBJECTS = __assign({}, b), A;
}

function numberCompare(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}

function reverseNumberCompare(e, t) {
  return -1 * numberCompare(e, t);
}

function unique(e) {
  if (null == e) return e;

  for (var t = [], n = 0, r = e; n < r.length; n++) {
    var i = r[n];
    -1 === t.indexOf(i) && t.push(i);
  }

  return t;
}

function isObjectEmpty(e) {
  if (null == e) throw new ValueError("Invalid value in obj: " + JSON.stringify(e));

  for (var t in e) if (e.hasOwnProperty(t)) return !1;

  return !0;
}

function checkStringTypeUnionValue(e, t, n) {
  if (null != n && e.indexOf(n) < 0) throw new ValueError(n + " is not a valid " + t + ".  Valid values are " + e + " or null/undefined.");
}

function checkArrayTypeAndLength(e, t, n, r) {
  return void 0 === n && (n = 0), void 0 === r && (r = 1 / 0), assert(n >= 0), assert(r >= n), Array.isArray(e) && e.length >= n && e.length <= r && e.every(function (e) {
    return typeof e === t;
  });
}

function assertPositiveInteger(e, t) {
  Array.isArray(e) ? (_tfjsCore.util.assert(e.length > 0, function () {
    return t + " is unexpectedly an empty array.";
  }), e.forEach(function (e, n) {
    return assertPositiveInteger(e, "element " + (n + 1) + " of " + t);
  })) : _tfjsCore.util.assert(Number.isInteger(e) && e > 0, function () {
    return "Expected " + t + " to be a positive integer, but got " + formatAsFriendlyString(e) + ".";
  });
}

function formatAsFriendlyString(e) {
  return null === e ? "null" : Array.isArray(e) ? "[" + e.map(function (e) {
    return formatAsFriendlyString(e);
  }).join(",") + "]" : "string" == typeof e ? '"' + e + '"' : "" + e;
}

function debounce(e, t) {
  var n,
      r = _tfjsCore.util.now();

  return function () {
    for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a];

    var o = _tfjsCore.util.now();

    return o - r < t ? n : (r = o, n = e.apply(void 0, i));
  };
}

function mapActivationToFusedKernel(e) {
  return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
}

function calcL2Norms(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.sqrt)((0, _tfjsCore.sum)((0, _tfjsCore.mulStrict)(e, e), t, !0));
  });
}

var Constraint = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    return {};
  }, t;
}(_tfjsCore.serialization.Serializable),
    MaxNorm = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.defaultMaxValue = 2, n.defaultAxis = 0, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = calcL2Norms(e, t.axis),
          r = (0, _tfjsCore.clipByValue)(n, 0, t.maxValue);
      return (0, _tfjsCore.mul)(e, (0, _tfjsCore.div)(r, (0, _tfjsCore.add)(epsilon(), n)));
    });
  }, t.prototype.getConfig = function () {
    return {
      maxValue: this.maxValue,
      axis: this.axis
    };
  }, t.className = "MaxNorm", t;
}(Constraint);

_tfjsCore.serialization.registerClass(MaxNorm);

var UnitNorm = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.defaultAxis = 0, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      return (0, _tfjsCore.div)(e, (0, _tfjsCore.add)(epsilon(), calcL2Norms(e, t.axis)));
    });
  }, t.prototype.getConfig = function () {
    return {
      axis: this.axis
    };
  }, t.className = "UnitNorm", t;
}(Constraint);

_tfjsCore.serialization.registerClass(UnitNorm);

var NonNeg = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.relu)(e);
  }, t.className = "NonNeg", t;
}(Constraint);

_tfjsCore.serialization.registerClass(NonNeg);

var MinMaxNorm = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.defaultMinValue = 0, n.defaultMaxValue = 1, n.defaultRate = 1, n.defaultAxis = 0, n.minValue = null != t.minValue ? t.minValue : n.defaultMinValue, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.rate = null != t.rate ? t.rate : n.defaultRate, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = calcL2Norms(e, t.axis),
          r = (0, _tfjsCore.add)((0, _tfjsCore.mul)(t.rate, (0, _tfjsCore.clipByValue)(n, t.minValue, t.maxValue)), (0, _tfjsCore.mul)(1 - t.rate, n));
      return (0, _tfjsCore.mul)(e, (0, _tfjsCore.div)(r, (0, _tfjsCore.add)(epsilon(), n)));
    });
  }, t.prototype.getConfig = function () {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }, t.className = "MinMaxNorm", t;
}(Constraint);

_tfjsCore.serialization.registerClass(MinMaxNorm);

var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};

function serializeConstraint(e) {
  return serializeKerasObject(e);
}

function deserializeConstraint(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "constraint");
}

function getConstraint(e) {
  return null == e ? null : "string" == typeof e ? deserializeConstraint({
    className: e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e,
    config: {}
  }) : e instanceof Constraint ? e : deserializeConstraint(e);
}

function maxNorm(e) {
  return new MaxNorm(e);
}

function unitNorm(e) {
  return new UnitNorm(e);
}

function nonNeg() {
  return new NonNeg();
}

function minMaxNorm(e) {
  return new MinMaxNorm(e);
}

var exports_constraints = Object.freeze({
  maxNorm: maxNorm,
  unitNorm: unitNorm,
  nonNeg: nonNeg,
  minMaxNorm: minMaxNorm
}),
    VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"],
    VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"],
    VALID_POOL_MODE_VALUES = ["max", "avg"],
    VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"],
    nameMap = new Map();
exports.constraints = exports_constraints;

function checkDataFormat(e) {
  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", e);
}

function checkPaddingMode(e) {
  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", e);
}

function checkPoolMode(e) {
  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", e);
}

var _nameScopeStack = [],
    _nameScopeDivider = "/";

function nameScope(e, t) {
  _nameScopeStack.push(e);

  try {
    var n = t();
    return _nameScopeStack.pop(), n;
  } catch (e) {
    throw _nameScopeStack.pop(), e;
  }
}

function currentNameScopePrefix() {
  return 0 === _nameScopeStack.length ? "" : _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
}

function getScopedTensorName(e) {
  if (!isValidTensorName(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  return currentNameScopePrefix() + e;
}

function getUniqueTensorName(e) {
  if (!isValidTensorName(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  nameMap.has(e) || nameMap.set(e, 0);
  var t = nameMap.get(e);

  if (nameMap.set(e, nameMap.get(e) + 1), t > 0) {
    var n = e + "_" + t;
    return nameMap.set(n, 1), n;
  }

  return e;
}

var tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

function isValidTensorName(e) {
  return !!e.match(tensorNameRegex);
}

function isInteger(e) {
  return e === parseInt(e.toString(), 10);
}

function arrayProd(e, t, n) {
  null == t && (t = 0), null == n && (n = e.length);

  for (var r = 1, i = t; i < n; ++i) r *= e[i];

  return r;
}

function toArray1D(e) {
  return e = Array.isArray(e) ? new Float32Array(e) : e, (0, _tfjsCore.tensor1d)(e);
}

function min$1(e) {
  return (0, _tfjsCore.min)(toArray1D(e)).dataSync()[0];
}

function max$1(e) {
  return (0, _tfjsCore.max)(toArray1D(e)).dataSync()[0];
}

function range(e, t) {
  if (t < e) throw new ValueError("end (" + t + ") < begin (" + e + ") is forbidden.");

  for (var n = [], r = e; r < t; ++r) n.push(r);

  return n;
}

function cast$1(e, t) {
  return e.asType(t);
}

function expandDims$1(e, t) {
  void 0 === t && (t = -1);
  var n = e.shape.slice();
  return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), e.reshape(n);
}

function repeat(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    if (2 !== e.shape.length) throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-" + e.shape.length + " tensor.");
    return tile$1(expandDims$1(e, 1), [1, t, 1]);
  });
}

function flatten(e) {
  var t = [arrayProd(e.shape)];
  return e.reshape(t);
}

function batchFlatten(e) {
  if (e.rank <= 1) throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + e.rank + ".");
  var t = [e.shape[0], arrayProd(e.shape, 1)];
  return e.reshape(t);
}

function sliceAlongFirstAxis(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    switch (e.rank) {
      case 1:
        return (0, _tfjsCore.slice1d)(e, t, n);

      case 2:
        return (0, _tfjsCore.slice2d)(e, [t, 0], [n, e.shape[1]]);

      case 3:
        return (0, _tfjsCore.slice3d)(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);

      case 4:
        return (0, _tfjsCore.slice4d)(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);

      case 5:
        return (0, _tfjsCore.slice)(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);

      case 6:
        return (0, _tfjsCore.slice)(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);

      default:
        throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
    }
  });
}

function sliceAlongLastAxis(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    switch (e.rank) {
      case 1:
        return (0, _tfjsCore.slice1d)(e, t, n);

      case 2:
        return (0, _tfjsCore.slice2d)(e, [0, t], [e.shape[0], n]);

      case 3:
        return (0, _tfjsCore.slice3d)(e, [0, 0, t], [e.shape[0], e.shape[1], n]);

      case 4:
        return (0, _tfjsCore.slice4d)(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);

      default:
        throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
    }
  });
}

function sliceAlongAxis(e, t, n, r) {
  return (0, _tfjsCore.tidy)(function () {
    switch (e.rank) {
      case 1:
        return (0, _tfjsCore.slice1d)(e, t, n);

      case 2:
        switch (r) {
          case 1:
            return sliceAlongFirstAxis(e, t, n);

          case 2:
            return sliceAlongLastAxis(e, t, n);

          default:
            throw new ValueError("The axis is not within the rank of the tensor " + r);
        }

      case 3:
        switch (r) {
          case 1:
            return sliceAlongFirstAxis(e, t, n);

          case 2:
            return (0, _tfjsCore.slice3d)(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);

          case 3:
            return sliceAlongLastAxis(e, t, n);

          default:
            throw new ValueError("The axis is not within the rank of the tensor " + r);
        }

      case 4:
        switch (r) {
          case 1:
            return sliceAlongFirstAxis(e, t, n);

          case 2:
            return (0, _tfjsCore.slice4d)(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);

          case 3:
            return (0, _tfjsCore.slice4d)(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);

          case 4:
            return sliceAlongLastAxis(e, t, n);

          default:
            throw new ValueError("The axis is not within the rank of the tensor " + r);
        }

      default:
        throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
    }
  });
}

function concatenate(e, t) {
  var n;
  return void 0 === t && (t = -1), t < 0 && (t = 0 !== (n = e[0].rank) ? n : 0), t === e[0].rank && (t = -1), (0, _tfjsCore.concat)(e, t);
}

function concatAlongFirstAxis(e, t) {
  switch (e.rank) {
    case 1:
      return (0, _tfjsCore.concat1d)([e, t]);

    case 2:
      return (0, _tfjsCore.concat2d)([e, t], 0);

    case 3:
      return (0, _tfjsCore.concat3d)([e, t], 0);

    case 4:
      return (0, _tfjsCore.concat4d)([e, t], 0);

    default:
      throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
  }
}

function tile$1(e, t) {
  if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new ValueError("The length of input n (" + t.length + ") does not match the number of dimensions in input x (" + e.rank + ")");
  return (0, _tfjsCore.tile)(e, t);
}

function randomNormal$1(e, t, n, r, i) {
  return void 0 === t && (t = 0), void 0 === n && (n = 1), (0, _tfjsCore.randomNormal)(e, t, n, r, i);
}

function dot(e, t, n, r) {
  if (e.rank < 2 || t.rank < 2) throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = " + e.shape + " and y shape = " + t.shape);
  if (t.rank >= 3 && e.shape.slice(-1)[0] !== (c = t.shape.slice(-2)[0])) throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + e.shape + " and  y shape = " + t.shape);

  if (2 === e.rank && 2 === t.rank) {
    var i = !1,
        a = !1;
    return _tfjsCore.fused.matMul({
      a: e,
      b: t,
      transposeA: i,
      transposeB: a,
      bias: r ? reshapeBias(e.rank, r, imageDataFormat()) : null,
      activation: n
    });
  }

  var o = e.shape.slice(),
      s = o.pop();
  e = e.reshape([-1, s]);
  var l = t.shape.slice(),
      u = l.pop(),
      c = l.pop(),
      p = l.concat([u]),
      h = Array.from({
    length: t.rank
  }, function (e, n) {
    return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n;
  });
  t = t.transpose(h).reshape([c, -1]);
  var d = o.concat(p);
  i = !1, a = !1;
  return _tfjsCore.fused.matMul({
    a: e,
    b: t,
    transposeA: i,
    transposeB: a,
    bias: r ? reshapeBias(e.rank, r, imageDataFormat()) : null,
    activation: n
  }).reshape(d);
}

function gather$1(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    return t = Array.isArray(t) ? (0, _tfjsCore.tensor1d)(t, "int32") : t.toInt(), (0, _tfjsCore.gather)(e, t, n);
  });
}

function square(e) {
  return (0, _tfjsCore.mulStrict)(e, e);
}

function reshapeBias(e, t, n) {
  var r = t.shape;
  if (1 !== t.rank && t.rank !== e) throw new ValueError("Unexpected bias dimensions: " + t.rank + "; expected it to be 1 or " + e);

  if (5 === e) {
    if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1, 1, 1]) : t.reshape([1, r[3], r[0], r[1], r[2]]);
    if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, 1, 1, r[0]]) : t.reshape([1].concat(r));
  } else if (4 === e) {
    if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1, 1]) : t.reshape([1, r[2], r[0], r[1]]);
    if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, 1, r[0]]) : t.reshape([1].concat(r));
  } else if (3 === e) {
    if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1]) : t.reshape([1, r[1], r[0]]);
    if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, r[0]]) : t.reshape([1].concat(r));
  } else if (e < 3) return t;

  throw new ValueError("Unsupported input rank by biasAdd: " + t.rank);
}

function biasAdd(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    return null == n && (n = imageDataFormat()), checkDataFormat(n), e.add(reshapeBias(e.rank, t, n));
  });
}

function elu$1(e, t) {
  if (void 0 === t && (t = 1), 1 !== t) throw new NotImplementedError("Support for alpha values other than 1 (" + t + ") is not implemented yet.");
  return (0, _tfjsCore.elu)(e);
}

function softsign(e) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.div)(e, (0, _tfjsCore.abs)(e).add(1));
  });
}

function dropout$1(e, t, n, r) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.dropout)(e, t, n, r);
  });
}

function hardSigmoid(e) {
  return (0, _tfjsCore.tidy)(function () {
    var t = (0, _tfjsCore.add)(.5, (0, _tfjsCore.mul)(.2, e));
    return (0, _tfjsCore.clipByValue)(t, 0, 1);
  });
}

function inTrainPhase(e, t, n) {
  return void 0 === n && (n = !1), n ? e() : t();
}

var VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"],
    VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];

function checkFanMode(e) {
  checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", e);
}

function checkDistribution(e) {
  checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", e);
}

var Initializer = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.fromConfigUsesCustomObjects = function () {
    return !1;
  }, t.prototype.getConfig = function () {
    return {};
  }, t;
}(_tfjsCore.serialization.Serializable),
    Zeros = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return (0, _tfjsCore.zeros)(e, t);
  }, t.className = "Zeros", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Zeros);

var Ones = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return (0, _tfjsCore.ones)(e, t);
  }, t.className = "Ones", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Ones);

var Constant = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if ("object" != typeof t) throw new ValueError("Expected argument of type ConstantConfig but got " + t);
    if (void 0 === t.value) throw new ValueError("config must have value set but got " + t);
    return n.value = t.value, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return (0, _tfjsCore.mul)((0, _tfjsCore.scalar)(n.value), (0, _tfjsCore.ones)(e, t));
    });
  }, t.prototype.getConfig = function () {
    return {
      value: this.value
    };
  }, t.className = "Constant", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Constant);

var RandomUniform = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.DEFAULT_MINVAL = -.05, n.DEFAULT_MAXVAL = .05, n.minval = t.minval || n.DEFAULT_MINVAL, n.maxval = t.maxval || n.DEFAULT_MAXVAL, n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return (0, _tfjsCore.randomUniform)(e, this.minval, this.maxval, t);
  }, t.prototype.getConfig = function () {
    return {
      minval: this.minval,
      maxval: this.maxval,
      seed: this.seed
    };
  }, t.className = "RandomUniform", t;
}(Initializer);

_tfjsCore.serialization.registerClass(RandomUniform);

var RandomNormal = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError("randomNormal does not support dType " + t + ".");
    return randomNormal$1(e, this.mean, this.stddev, t, this.seed);
  }, t.prototype.getConfig = function () {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }, t.className = "RandomNormal", t;
}(Initializer);

_tfjsCore.serialization.registerClass(RandomNormal);

var TruncatedNormal = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError("truncatedNormal does not support dType " + t + ".");
    return (0, _tfjsCore.truncatedNormal)(e, this.mean, this.stddev, t, this.seed);
  }, t.prototype.getConfig = function () {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }, t.className = "TruncatedNormal", t;
}(Initializer);

_tfjsCore.serialization.registerClass(TruncatedNormal);

var Identity = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.gain = null != t.gain ? t.gain : 1, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== e.length || e[0] !== e[1]) throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
      return (0, _tfjsCore.mul)(n.gain, (0, _tfjsCore.eye)(e[0]));
    });
  }, t.prototype.getConfig = function () {
    return {
      gain: this.gain
    };
  }, t.className = "Identity", t;
}(Initializer);

function computeFans(e, t) {
  var n, r;
  if (void 0 === t && (t = "channelsLast"), checkDataFormat(t), 2 === e.length) n = e[0], r = e[1];else if (-1 !== [3, 4, 5].indexOf(e.length)) {
    if ("channelsFirst" === t) {
      var i = arrayProd(e, 2);
      n = e[1] * i, r = e[0] * i;
    } else if ("channelsLast" === t) {
      i = arrayProd(e, 0, e.length - 2);
      n = e[e.length - 2] * i, r = e[e.length - 1] * i;
    }
  } else {
    var a = arrayProd(e);
    n = Math.sqrt(a), r = Math.sqrt(a);
  }
  return [n, r];
}

_tfjsCore.serialization.registerClass(Identity);

var VarianceScaling = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if (t.scale < 0) throw new ValueError("scale must be a positive float. Got: " + t.scale);
    return n.scale = null == t.scale ? 1 : t.scale, n.mode = null == t.mode ? "fanIn" : t.mode, checkFanMode(n.mode), n.distribution = null == t.distribution ? "normal" : t.distribution, checkDistribution(n.distribution), n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = computeFans(e),
        r = n[0],
        i = n[1],
        a = this.scale;

    if ("fanIn" === this.mode ? a /= Math.max(1, r) : "fanOut" === this.mode ? a /= Math.max(1, i) : a /= Math.max(1, (r + i) / 2), "normal" === this.distribution) {
      var o = Math.sqrt(a);
      if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError(this.getClassName() + " does not support dType " + t + ".");
      return (0, _tfjsCore.truncatedNormal)(e, 0, o, t, this.seed);
    }

    var s = Math.sqrt(3 * a);
    return (0, _tfjsCore.randomUniform)(e, -s, s, t);
  }, t.prototype.getConfig = function () {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }, t.className = "VarianceScaling", t;
}(Initializer);

_tfjsCore.serialization.registerClass(VarianceScaling);

var GlorotUniform = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "GlorotUniform", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(GlorotUniform);

var GlorotNormal = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "GlorotNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(GlorotNormal);

var HeNormal = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "HeNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(HeNormal);

var HeUniform = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "HeUniform", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(HeUniform);

var LeCunNormal = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "LeCunNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(LeCunNormal);

var LeCunUniform = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "LeCunNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(LeCunUniform);

var Orthogonal = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if (n.DEFAULT_GAIN = 1, n.gain = null == t.gain ? n.DEFAULT_GAIN : t.gain, n.seed = t.seed, null != n.seed) throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
    return n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== e.length) throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");
      e[0] * e[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + e[0] * e[1] + ") elements: Slowness may result.");

      var t = randomNormal$1(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32"),
          r = _tfjsCore.linalg.gramSchmidt(t);

      return e[0] > e[1] && (r = r.transpose()), (0, _tfjsCore.mul)(n.gain, r);
    });
  }, t.prototype.getConfig = function () {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }, t.className = "Orthogonal", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Orthogonal);

var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};

function deserializeInitializer(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "initializer");
}

function serializeInitializer(e) {
  return serializeKerasObject(e);
}

function getInitializer(e) {
  if ("string" == typeof e) {
    var t = e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e;
    if ("GlorotNormal" === t) return new GlorotNormal();
    if ("GlorotUniform" === t) return new GlorotUniform();
    if ("HeNormal" === t) return new HeNormal();
    if ("HeUniform" === t) return new HeUniform();
    if ("LeCunNormal" === t) return new LeCunNormal();
    if ("LeCunUniform" === t) return new LeCunUniform();
    var n = {};
    return n.className = t, n.config = {}, deserializeInitializer(n);
  }

  return e instanceof Initializer ? e : deserializeInitializer(e);
}

function zeros$1() {
  return new Zeros();
}

function ones$1() {
  return new Ones();
}

function constant(e) {
  return new Constant(e);
}

function randomUniform$1(e) {
  return new RandomUniform(e);
}

function randomNormal$2(e) {
  return new RandomNormal(e);
}

function truncatedNormal$1(e) {
  return new TruncatedNormal(e);
}

function identity(e) {
  return new Identity(e);
}

function varianceScaling(e) {
  return new VarianceScaling(e);
}

function glorotUniform(e) {
  return new GlorotUniform(e);
}

function glorotNormal(e) {
  return new GlorotNormal(e);
}

function heNormal(e) {
  return new HeNormal(e);
}

function heUniform(e) {
  return new HeUniform(e);
}

function leCunNormal(e) {
  return new LeCunNormal(e);
}

function leCunUniform(e) {
  return new LeCunUniform(e);
}

function orthogonal(e) {
  return new Orthogonal(e);
}

var exports_initializers = Object.freeze({
  zeros: zeros$1,
  ones: ones$1,
  constant: constant,
  randomUniform: randomUniform$1,
  randomNormal: randomNormal$2,
  truncatedNormal: truncatedNormal$1,
  identity: identity,
  varianceScaling: varianceScaling,
  glorotUniform: glorotUniform,
  glorotNormal: glorotNormal,
  heNormal: heNormal,
  heUniform: heUniform,
  leCunNormal: leCunNormal,
  leCunUniform: leCunUniform,
  orthogonal: orthogonal
}),
    _nextUniqueTensorId = 0;
exports.initializers = exports_initializers;

function getNextUniqueTensorId() {
  return _nextUniqueTensorId++;
}

var _uidPrefixes = {};

function getUid(e) {
  return void 0 === e && (e = ""), e in _uidPrefixes || (_uidPrefixes[e] = 0), _uidPrefixes[e] += 1, e + _uidPrefixes[e].toString();
}

function isArrayOfShapes(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}

function normalizeShapeList(e) {
  return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e];
}

function getExactlyOneTensor(e) {
  var t;

  if (Array.isArray(e)) {
    if (1 !== e.length) throw new ValueError("Expected Tensor length to be 1; got " + e.length);
    t = e[0];
  } else t = e;

  return t;
}

function getExactlyOneShape(e) {
  if (Array.isArray(e) && Array.isArray(e[0])) {
    if (1 === e.length) return (e = e)[0];
    throw new ValueError("Expected exactly 1 Shape; got " + e.length);
  }

  return e;
}

function countParamsInWeights(e) {
  for (var t = 0, n = 0, r = e; n < r.length; n++) {
    var i = r[n];
    0 === i.shape.length ? t += 1 : t += i.shape.reduce(function (e, t) {
      return e * t;
    });
  }

  return t;
}

var DEFAULT_VARIABLE_NAME_PREFIX = "Variable",
    LayerVariable = function () {
  function e(e, t, n, r, i) {
    void 0 === t && (t = "float32"), void 0 === n && (n = DEFAULT_VARIABLE_NAME_PREFIX), void 0 === r && (r = !0), void 0 === i && (i = null), this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = getNextUniqueTensorId(), n = null == n ? DEFAULT_VARIABLE_NAME_PREFIX : n, this.originalName = getScopedTensorName(n), this.name = getUniqueTensorName(this.originalName), this.trainable_ = r, this.constraint = i, this.val = (0, _tfjsCore.variable)(e, this.trainable_, this.name, this.dtype);
  }

  return e.prototype.read = function () {
    return this.assertNotDisposed(), this.val;
  }, e.prototype.write = function (e) {
    return this.assertNotDisposed(), checkShapesMatch(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
  }, e.prototype.dispose = function () {
    this.assertNotDisposed(), this.val.dispose();
  }, e.prototype.assertNotDisposed = function () {
    if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.");
  }, Object.defineProperty(e.prototype, "trainable", {
    get: function () {
      return this.trainable_;
    },
    set: function (e) {
      this.trainable_ = e, this.val.trainable = e;
    },
    enumerable: !0,
    configurable: !0
  }), e;
}();

exports.LayerVariable = LayerVariable;

function checkShapesMatch(e, t) {
  if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
}

function batchGetValue(e) {
  return e.map(function (e) {
    return e.read();
  });
}

function batchSetValue(e) {
  e.forEach(function (e) {
    e[0].write(e[1]);
  });
}

var InputSpec = function () {
  return function (e) {
    this.dtype = e.dtype, this.shape = e.shape, null != e.shape ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
  };
}(),
    SymbolicTensor = function () {
  return function (e, t, n, r, i, a, o) {
    this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = r, this.callArgs = i, this.outputTensorIndex = o, this.id = getNextUniqueTensorId(), null != a && (this.originalName = getScopedTensorName(a), this.name = getUniqueTensorName(this.originalName)), this.rank = t.length;
  };
}(),
    _nextNodeID = 0,
    Node = function () {
  function e(e, t) {
    this.callArgs = t, this.id = _nextNodeID++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;

    for (var n = 0, r = e.inboundLayers; n < r.length; n++) {
      var i = r[n];
      null != i && i.outboundNodes.push(this);
    }

    e.outboundLayer.inboundNodes.push(this);
  }

  return e.prototype.getConfig = function () {
    for (var e = [], t = 0, n = this.inboundLayers; t < n.length; t++) {
      var r = n[t];
      null != r ? e.push(r.name) : e.push(null);
    }

    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: e,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }, e;
}(),
    _nextLayerID = 0,
    Layer = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    n._callHook = null, n._addedWeightNames = [], n._stateful = !1, n.id = _nextLayerID++, n.activityRegularizer = null, n.inputSpec = null, n.supportsMasking = !1, n._trainableWeights = [], n._nonTrainableWeights = [], n._losses = [], n._updates = [], n._built = !1, n.inboundNodes = [], n.outboundNodes = [];
    var r = t.name;

    if (!r) {
      var i = n.getClassName();
      r = toSnakeCase(i) + "_" + getUid(i);
    }

    if (n.name = r, n.trainable_ = null == t.trainable || t.trainable, null != t.inputShape || null != t.batchInputShape) {
      var a = void 0;
      if (null != t.batchInputShape) a = t.batchInputShape;else if (null != t.inputShape) {
        var o = null;
        null != t.batchSize && (o = t.batchSize), a = [o].concat(t.inputShape);
      }
      n.batchInputShape = a;
      var s = t.dtype;
      null == s && (s = t.inputDType), null == s && (s = "float32"), n.dtype = s;
    }

    return null != t.weights ? n.initialWeights = t.weights : n.initialWeights = null, n._refCount = null, n.fastWeightInitDuringBuild = !1, n;
  }

  return __extends(t, e), t.nodeKey = function (e, t) {
    return e.name + "_ib-" + t.toString();
  }, t.prototype.getNodeAtIndex = function (e, t) {
    if (0 === this.inboundNodes.length) throw new RuntimeError("The layer has never been called and thus has no defined " + t + ".");
    if (this.inboundNodes.length <= e) throw new ValueError("Asked to get " + t + " at node " + e + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
    return this.inboundNodes[e];
  }, t.prototype.getInputAt = function (e) {
    return singletonOrArray(this.getNodeAtIndex(e, "input").inputTensors);
  }, t.prototype.getOutputAt = function (e) {
    return singletonOrArray(this.getNodeAtIndex(e, "output").outputTensors);
  }, Object.defineProperty(t.prototype, "input", {
    get: function () {
      if (this.inboundNodes.length > 1) throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
      if (0 === this.inboundNodes.length) throw new AttributeError("Layer " + this.name + " is not connected, no input to return.");
      return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "output", {
    get: function () {
      if (0 === this.inboundNodes.length) throw new AttributeError("Layer " + this.name + " has no inbound nodes.");
      if (this.inboundNodes.length > 1) throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
      return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "losses", {
    get: function () {
      return this._losses;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.calculateLosses = function () {
    return this.losses.map(function (e) {
      return e();
    });
  }, Object.defineProperty(t.prototype, "updates", {
    get: function () {
      return this._updates;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "built", {
    get: function () {
      return this._built;
    },
    set: function (e) {
      this._built = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return this.trainable_;
    },
    set: function (e) {
      this._trainableWeights.forEach(function (t) {
        return t.trainable = e;
      }), this.trainable_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.trainable_ ? this._trainableWeights.filter(function (e) {
        return e.trainable;
      }) : [];
    },
    set: function (e) {
      this._trainableWeights = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.trainable ? this._trainableWeights.filter(function (e) {
        return !e.trainable;
      }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    },
    set: function (e) {
      this._nonTrainableWeights = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "weights", {
    get: function () {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "stateful", {
    get: function () {
      return this._stateful;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.resetStates = function () {
    if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }, t.prototype.assertInputCompatibility = function (e) {
    if (e = toList(e), null != this.inputSpec && 0 !== this.inputSpec.length) {
      var t = toList(this.inputSpec);
      if (e.length !== t.length) throw new ValueError("Layer " + this.name + " expects " + t.length + " inputs, but it received " + e.length + " input tensors. Input received: " + e);

      for (var n = 0; n < e.length; n++) {
        var r = e[n],
            i = t[n];

        if (null != i) {
          var a = r.rank;
          if (null != i.ndim && a !== i.ndim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected ndim=" + i.ndim + ", found ndim=" + a);
          if (null != i.maxNDim && a > i.maxNDim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected max_ndim=" + i.maxNDim + ", found ndim=" + a);
          if (null != i.minNDim && a < i.minNDim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected min_ndim=" + i.minNDim + ", found ndim=" + a + ".");
          if (null != i.dtype && r.dtype !== i.dtype) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + " : expected dtype=" + i.dtype + ", found dtype=" + r.dtype + ".");

          if (i.axes) {
            var o = r.shape;

            for (var s in i.axes) {
              var l = Number(s),
                  u = i.axes[s],
                  c = l >= 0 ? o[l] : o[o.length + l];
              if (null != u && -1 === [u, null].indexOf(c)) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected axis " + l + " of input shape to have value " + u + " but got shape " + o + ".");
            }
          }

          if (null != i.shape) for (var p = 0; p < i.shape.length; ++p) {
            var h = i.shape[p],
                d = r.shape[p];
            if (null != h && null != d && h !== d) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected shape=" + i.shape + ", found shape=" + r.shape + ".");
          }
        }
      }
    }
  }, t.prototype.call = function (e, t) {
    return e;
  }, t.prototype.invokeCallHook = function (e, t) {
    null != this._callHook && this._callHook(e, t);
  }, t.prototype.setCallHook = function (e) {
    this._callHook = e;
  }, t.prototype.clearCallHook = function () {
    this._callHook = null;
  }, t.prototype.apply = function (e, t) {
    var n = this;
    t = t || {}, this.assertNotDisposed();

    for (var r = toList(e), i = !0, a = 0, o = r; a < o.length; a++) {
      if (!(o[a] instanceof SymbolicTensor)) {
        i = !1;
        break;
      }
    }

    for (var s = !0, l = 0, u = r; l < u.length; l++) {
      if (u[l] instanceof SymbolicTensor) {
        s = !1;
        break;
      }
    }

    if (i === s) throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return nameScope(this.name, function () {
      if (!n.built) {
        n.assertInputCompatibility(e);

        for (var i = [], a = 0, o = toList(e); a < o.length; a++) {
          var l = o[a];
          i.push(l.shape);
        }

        n.build(singletonOrArray(i)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && s && (n._refCount = 1);
      }

      if (n.assertInputCompatibility(e), s) {
        for (var u = [], c = 0, p = toList(g = n.call(e, t)); c < p.length; c++) {
          var h = p[c];
          -1 !== r.indexOf(h) && (h = h.clone()), u.push(h);
        }

        if (g = singletonOrArray(u), null != n.activityRegularizer) throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return g;
      }

      var d = collectInputShape(e),
          f = n.computeOutputShape(d),
          g = void 0,
          m = guessOutputDType(e);
      if (n.warnOnIncompatibleInputShape(Array.isArray(e) ? d[0] : d), g = null != f && f.length > 0 && Array.isArray(f[0]) ? f.map(function (r, i) {
        return new SymbolicTensor(m, r, n, toList(e), t, n.name, i);
      }) : new SymbolicTensor(m, f, n, toList(e), t, n.name), n.addInboundNode(e, g, null, null, d, f, t), n._refCount++, null != n.activityRegularizer) throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
      return g;
    });
  }, t.prototype.warnOnIncompatibleInputShape = function (e) {
    if (null != this.batchInputShape) if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(e) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);else {
      var t = !1;
      this.batchInputShape.forEach(function (n, r) {
        null != n && null != e[r] && e[r] !== n && (t = !0);
      }), t && console.warn("The shape of the input tensor (" + JSON.stringify(e) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape));
    }
  }, Object.defineProperty(t.prototype, "outputShape", {
    get: function () {
      if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new AttributeError("The layer " + this.name + " has never been called and thus has no defined output shape.");

      for (var e = [], t = 0, n = this.inboundNodes; t < n.length; t++) {
        var r = n[t],
            i = JSON.stringify(r.outputShapes);
        -1 === e.indexOf(i) && e.push(i);
      }

      if (1 === e.length) {
        var a = this.inboundNodes[0].outputShapes;
        return Array.isArray(a) && Array.isArray(a[0]) && 1 === a.length ? a[0] : a;
      }

      throw new AttributeError("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.');
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.countParams = function () {
    if (!this.built) throw new RuntimeError("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
    return countParamsInWeights(this.weights);
  }, t.prototype.build = function (e) {
    this.built = !0;
  }, t.prototype.getWeights = function (e) {
    return void 0 === e && (e = !1), batchGetValue(e ? this.trainableWeights : this.weights);
  }, t.prototype.setWeights = function (e) {
    var t = this;
    (0, _tfjsCore.tidy)(function () {
      var n = t.weights;
      if (n.length !== e.length) throw new ValueError('You called setWeights(weights) on layer "' + t.name + '" with a weight list of length ' + e.length + ", but the layer was expecting " + n.length + " weights. Provided weights: " + e + "...");

      if (0 !== n.length) {
        for (var r = [], i = batchGetValue(n), a = 0; a < i.length; ++a) {
          var o = i[a],
              s = n[a],
              l = e[a];
          if (!_tfjsCore.util.arraysEqual(o.shape, l.shape)) throw new ValueError("Layer weight shape " + o.shape + " not compatible with provided weight shape " + l.shape);
          r.push([s, l]);
        }

        batchSetValue(r);
      }
    });
  }, t.prototype.addWeight = function (e, t, n, r, i, a, o) {
    if (-1 !== this._addedWeightNames.indexOf(e)) throw new ValueError("Duplicate weight name " + e + " for layer " + this.name);
    this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = getInitializer("zeros"));
    var s = r.apply(t, n),
        l = new LayerVariable(s, n, e, a, o);
    return s.dispose(), null != i && this.addLoss(function () {
      return i.apply(l.read());
    }), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l;
  }, t.prototype.setFastWeightInitDuringBuild = function (e) {
    this.fastWeightInitDuringBuild = e;
  }, t.prototype.addLoss = function (e) {
    var t;
    null == e || Array.isArray(e) && 0 === e.length || (e = toList(e), void 0 !== this._losses && null !== this._losses && (t = this.losses).push.apply(t, e));
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.computeMask = function (e, t) {
    var n = this;

    if (!this.supportsMasking) {
      if (null != t) {
        if (!Array.isArray(t)) throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
        t.forEach(function (e) {
          if (null != e) throw new TypeError("Layer " + n.name + " does not support masking, but was passed an inputMask.");
        });
      }

      return null;
    }

    return t;
  }, t.prototype.addInboundNode = function (e, t, n, r, i, a, o) {
    void 0 === o && (o = null);
    var s = toList(e);
    t = toList(t), n = toList(n), r = toList(r), i = normalizeShapeList(i), a = normalizeShapeList(a);

    for (var l = [], u = [], c = [], p = 0, h = s; p < h.length; p++) {
      var d = h[p];
      l.push(d.sourceLayer), u.push(d.nodeIndex), c.push(d.tensorIndex);
    }

    new Node({
      outboundLayer: this,
      inboundLayers: l,
      nodeIndices: u,
      tensorIndices: c,
      inputTensors: s,
      outputTensors: t,
      inputMasks: n,
      outputMasks: r,
      inputShapes: i,
      outputShapes: a
    }, o);

    for (var f = 0; f < t.length; f++) t[f].sourceLayer = this, t[f].nodeIndex = this.inboundNodes.length - 1, t[f].tensorIndex = f;
  }, t.prototype.getConfig = function () {
    var e = {
      name: this.name,
      trainable: this.trainable
    };
    return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e;
  }, t.prototype.disposeWeights = function () {
    return this.weights.forEach(function (e) {
      return e.dispose();
    }), this.weights.length;
  }, t.prototype.assertNotDisposed = function () {
    if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.");
  }, t.prototype.dispose = function () {
    if (!this.built) throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
    if (null === this._refCount) throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
    this.assertNotDisposed();
    var e = 0;
    return 0 == --this._refCount && (e = this.disposeWeights()), {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: e
    };
  }, t;
}(_tfjsCore.serialization.Serializable);

exports.SymbolicTensor = SymbolicTensor;
exports.InputSpec = InputSpec;

function collectInputShape(e) {
  for (var t = [], n = 0, r = e = toList(e); n < r.length; n++) {
    var i = r[n];
    t.push(i.shape);
  }

  return singletonOrArray(t);
}

function guessOutputDType(e) {
  return "float32";
}

function getSourceInputs(e, t, n) {
  if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
  var r = t.inboundNodes[n];
  if (0 === r.inboundLayers.length) return r.inputTensors;

  for (var i = [], a = 0; a < r.inboundLayers.length; a++) for (var o = 0, s = getSourceInputs(r.inputTensors[a], r.inboundLayers[a], r.nodeIndices[a]); o < s.length; o++) {
    var l = s[o];
    -1 === i.indexOf(l) && i.push(l);
  }

  return i;
}

var ModelLoggingVerbosity,
    InputLayer = function (e) {
  function t(t) {
    var n = e.call(this, {
      dtype: t.dtype,
      name: null != t.name ? t.name : getUid("input").toString()
    }) || this;
    if (null == t.batchSize && (t.batchSize = null), null == t.sparse && (t.sparse = !1), n.trainable = !1, n.built = !0, n.sparse = t.sparse, null != t.inputShape && null != t.batchInputShape) throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    var r = t.batchInputShape;

    if (null == r) {
      if (null == t.inputShape) throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      r = [t.batchSize].concat(t.inputShape);
    } else if (null != t.batchSize) throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");

    var i = t.dtype || "float32";
    n.batchInputShape = r, n.dtype = i, n.inputSpec = [{
      shape: r
    }];
    var a = new SymbolicTensor(n.dtype, n.batchInputShape, n, [], {}, n.name);
    return a.nodeIndex = 0, a.tensorIndex = 0, new Node({
      outboundLayer: n,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [a],
      outputTensors: [a],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [r],
      outputShapes: [r]
    }), n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name);
  }, t.prototype.dispose = function () {
    return {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: 0
    };
  }, t.prototype.getConfig = function () {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }, t.className = "InputLayer", t;
}(Layer);

function Input(e) {
  if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
  if (null != e.batchShape && null != e.shape) throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
  var t = e.batchShape;
  null != e.shape && null == t && (t = [null].concat(e.shape));
  var n = e.dtype;
  return null == n && (n = "float32"), new InputLayer({
    batchInputShape: t,
    name: e.name,
    dtype: n,
    sparse: e.sparse
  }).inboundNodes[0].outputTensors[0];
}

function resolveScalarsInLogs(e) {
  return __awaiter(this, void 0, void 0, function () {
    var t, n, r, i, a, o, s, l;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          if (null == e) return [2];

          for (i in t = [], n = [], r = [], e) "number" != typeof (a = e[i]) && (o = a, t.push(o.data()), n.push(i), r.push(o));

          return t.length > 0 ? [4, Promise.all(t)] : [3, 2];

        case 1:
          for (s = u.sent(), l = 0; l < s.length; ++l) e[n[l]] = s[l][0];

          (0, _tfjsCore.dispose)(r), u.label = 2;

        case 2:
          return [2];
      }
    });
  });
}

function disposeTensorsInLogs(e) {
  if (null != e) for (var t in e) {
    var n = e[t];
    "number" != typeof n && n.dispose();
  }
}

_tfjsCore.serialization.registerClass(InputLayer), function (e) {
  e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE";
}(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));

var DEFAULT_YIELD_EVERY_MS = 125,
    BaseCallback = function () {
  function e() {
    this.validationData = null;
  }

  return e.prototype.setParams = function (e) {
    this.params = e;
  }, e.prototype.onEpochBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onBatchBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.setModel = function (e) {}, e;
}(),
    CallbackList = function () {
  function e(e, t) {
    void 0 === t && (t = 10), null == e && (e = []), this.callbacks = e, this.queueLength = t;
  }

  return e.prototype.append = function (e) {
    this.callbacks.push(e);
  }, e.prototype.setParams = function (e) {
    for (var t = 0, n = this.callbacks; t < n.length; t++) {
      n[t].setParams(e);
    }
  }, e.prototype.setModel = function (e) {
    for (var t = 0, n = this.callbacks; t < n.length; t++) {
      n[t].setModel(e);
    }
  }, e.prototype.onEpochBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onEpochBegin(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onEpochEnd(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onBatchBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onBatchBegin(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onBatchEnd(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      var t, n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            null == e && (e = {}), t = 0, n = this.callbacks, r.label = 1;

          case 1:
            return t < n.length ? [4, n[t].onTrainBegin(e)] : [3, 4];

          case 2:
            r.sent(), r.label = 3;

          case 3:
            return t++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      var t, n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            null == e && (e = {}), t = 0, n = this.callbacks, r.label = 1;

          case 1:
            return t < n.length ? [4, n[t].onTrainEnd(e)] : [3, 4];

          case 2:
            r.sent(), r.label = 3;

          case 3:
            return t++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e;
}(),
    BaseLogger = function (e) {
  function t() {
    return e.call(this) || this;
  }

  return __extends(t, e), t.prototype.onEpochBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.seen = 0, this.totals = {}, [2];
      });
    });
  }, t.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var e,
          n,
          r,
          i,
          a = this;
      return __generator(this, function (o) {
        for (i in null == t && (t = {}), e = null == t.size ? 0 : t.size, this.seen += e, n = function (n) {
          var i = t[n];
          if ("number" == typeof i) r.totals.hasOwnProperty(n) || (r.totals[n] = 0), r.totals[n] = r.totals[n] + i * e;else {
            var o = void 0;
            n in r.totals ? o = r.totals[n] : r.totals[n] = 0;
            var s = (0, _tfjsCore.tidy)(function () {
              return (0, _tfjsCore.add)(a.totals[n], (0, _tfjsCore.mul)(i, e));
            });
            r.totals[n] = s, null != o && o.dispose();
          }
        }, r = this, t) n(i);

        return [2];
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var e,
          n,
          r,
          i,
          a,
          o = this;
      return __generator(this, function (s) {
        if (null != t) for (e = function (e) {
          if (null == n.totals[e]) return "continue";
          "number" == typeof n.totals[e] ? t[e] = n.totals[e] / n.seen : (0, _tfjsCore.tidy)(function () {
            var n = (0, _tfjsCore.mul)((0, _tfjsCore.div)(1, o.seen), o.totals[e]);
            t[e] = n, o.totals[e].dispose(), (0, _tfjsCore.keep)(t[e]);
          });
        }, n = this, r = 0, i = this.params.metrics; r < i.length; r++) a = i[r], e(a);
        return [2];
      });
    });
  }, t;
}(BaseCallback),
    History = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.epoch = [], this.history = {}, [2];
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        for (n in null == t && (t = {}), this.epoch.push(e), t) null == this.history[n] && (this.history[n] = []), this.history[n].push(t[n]);

        return [2];
      });
    });
  }, t.prototype.syncData = function () {
    return __awaiter(this, void 0, void 0, function () {
      var e, t, n, r, i, a, o, s, l;
      return __generator(this, function (u) {
        switch (u.label) {
          case 0:
            for (r in e = [], t = [], n = [], this.history) for (i = this.history[r], a = 0; a < i.length; ++a) "number" != typeof i[a] && (o = i[a], e.push(o.data()), t.push(r), n.push(a));

            return [4, Promise.all(e)];

          case 1:
            for (s = u.sent(), l = 0; l < s.length; ++l) this.history[t[l]][n[l]].dispose(), this.history[t[l]][n[l]] = s[l][0];

            return [2];
        }
      });
    });
  }, t;
}(BaseCallback),
    CustomCallback = function (e) {
  function t(t, n) {
    var r = e.call(this) || this;
    if (r.currentEpoch = 0, r.yieldEvery = n || "auto", "auto" === r.yieldEvery && (r.yieldEvery = DEFAULT_YIELD_EVERY_MS), "never" === r.yieldEvery && null != t.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    return _tfjsCore.util.isNumber(r.yieldEvery) && (r.maybeWait = debounce(r.maybeWait.bind(r), r.yieldEvery)), r.trainBegin = t.onTrainBegin, r.trainEnd = t.onTrainEnd, r.epochBegin = t.onEpochBegin, r.epochEnd = t.onEpochEnd, r.batchBegin = t.onBatchBegin, r.batchEnd = t.onBatchEnd, r.yield = t.onYield, r;
  }

  return __extends(t, e), t.prototype.maybeWait = function (e, t, n) {
    return __awaiter(this, void 0, void 0, function () {
      var r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            return r = [], null == this.yield ? [3, 2] : [4, resolveScalarsInLogs(n)];

          case 1:
            i.sent(), r.push(this.yield(e, t, n)), i.label = 2;

          case 2:
            return r.push((0, _tfjsCore.nextFrame)()), [4, Promise.all(r)];

          case 3:
            return i.sent(), [2];
        }
      });
    });
  }, t.prototype.onEpochBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return this.currentEpoch = e, null == this.epochBegin ? [3, 3] : [4, resolveScalarsInLogs(t)];

          case 1:
            return n.sent(), [4, this.epochBegin(e, t)];

          case 2:
            n.sent(), n.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return n = [], null == this.epochEnd ? [3, 2] : [4, resolveScalarsInLogs(t)];

          case 1:
            r.sent(), n.push(this.epochEnd(e, t)), r.label = 2;

          case 2:
            return "epoch" === this.yieldEvery && n.push((0, _tfjsCore.nextFrame)()), [4, Promise.all(n)];

          case 3:
            return r.sent(), [2];
        }
      });
    });
  }, t.prototype.onBatchBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return null == this.batchBegin ? [3, 3] : [4, resolveScalarsInLogs(t)];

          case 1:
            return n.sent(), [4, this.batchBegin(e, t)];

          case 2:
            n.sent(), n.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return n = [], null == this.batchEnd ? [3, 2] : [4, resolveScalarsInLogs(t)];

          case 1:
            r.sent(), n.push(this.batchEnd(e, t)), r.label = 2;

          case 2:
            return "batch" === this.yieldEvery ? n.push((0, _tfjsCore.nextFrame)()) : _tfjsCore.util.isNumber(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, e, t)), [4, Promise.all(n)];

          case 3:
            return r.sent(), [2];
        }
      });
    });
  }, t.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return null == this.trainBegin ? [3, 3] : [4, resolveScalarsInLogs(e)];

          case 1:
            return t.sent(), [4, this.trainBegin(e)];

          case 2:
            t.sent(), t.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return null == this.trainEnd ? [3, 3] : [4, resolveScalarsInLogs(e)];

          case 1:
            return t.sent(), [4, this.trainEnd(e)];

          case 2:
            t.sent(), t.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t;
}(BaseCallback);

exports.CustomCallback = CustomCallback;
exports.History = History;
exports.CallbackList = CallbackList;

function standardizeCallbacks(e, t) {
  return null == e && (e = {}), e instanceof BaseCallback ? [e] : Array.isArray(e) && e[0] instanceof BaseCallback ? e : toList(e).map(function (e) {
    return new CustomCallback(e, t);
  });
}

var CallbackConstructorRegistry = function () {
  function e() {}

  return e.registerCallbackConstructor = function (t, n) {
    _tfjsCore.util.assert(t >= 0 && Number.isInteger(t), function () {
      return "Verbosity level is expected to be an integer >= 0, but got " + t;
    }), e.checkForDuplicate(n), null == e.constructors[t] && (e.constructors[t] = []), e.constructors[t].push(n);
  }, e.checkForDuplicate = function (t) {
    for (var n in e.constructors) {
      e.constructors[+n].forEach(function (e) {
        if (e === t) throw new ValueError("Duplicate callback constructor.");
      });
    }
  }, e.clear = function () {
    e.constructors = {};
  }, e.createCallbacks = function (t) {
    var n = [];

    for (var r in e.constructors) {
      var i = +r;
      t >= i && n.push.apply(n, e.constructors[i]);
    }

    return n.map(function (e) {
      return new e();
    });
  }, e.constructors = {}, e;
}();

function configureCallbacks(e, t, n, r, i, a, o, s, l) {
  var u = new History(),
      c = [new BaseLogger()].concat(CallbackConstructorRegistry.createCallbacks(t));
  null != e && c.push.apply(c, e), c.push(u);
  var p = new CallbackList(c);
  return p.setParams({
    epochs: n,
    initialEpoch: r,
    samples: i,
    steps: a,
    batchSize: o,
    verbose: t,
    doValidation: s,
    metrics: l
  }), {
    callbackList: p,
    history: u
  };
}

function deserialize(e, t, n) {
  return void 0 === t && (t = {}), void 0 === n && (n = !1), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "layer", n);
}

function l2Normalize(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    "float32" !== e.dtype && (e = e.asType("float32"));
    var n = (0, _tfjsCore.sum)(square(e), t, !0),
        r = (0, _tfjsCore.fill)(n.shape, epsilon()),
        i = (0, _tfjsCore.sqrt)((0, _tfjsCore.maximum)(n, r));
    return (0, _tfjsCore.div)(e, i);
  });
}

function meanSquaredError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.mean)(square((0, _tfjsCore.sub)(t, e)), -1);
  });
}

function meanAbsoluteError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.mean)((0, _tfjsCore.abs)((0, _tfjsCore.sub)(t, e)), -1);
  });
}

function meanAbsolutePercentageError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.sub)(e, t),
        r = (0, _tfjsCore.clipByValue)((0, _tfjsCore.abs)(e), epsilon(), Number.MAX_VALUE),
        i = (0, _tfjsCore.abs)((0, _tfjsCore.div)(n, r));
    return (0, _tfjsCore.mul)(100, (0, _tfjsCore.mean)(i, -1));
  });
}

function meanSquaredLogarithmicError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.clipByValue)(t, epsilon(), Number.MAX_VALUE),
        r = (0, _tfjsCore.log)((0, _tfjsCore.add)(1, n)),
        i = (0, _tfjsCore.clipByValue)(e, epsilon(), Number.MAX_VALUE),
        a = (0, _tfjsCore.log)((0, _tfjsCore.add)(1, i));
    return (0, _tfjsCore.mean)(square((0, _tfjsCore.sub)(r, a)), -1);
  });
}

function squaredHinge(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.maximum)(0, (0, _tfjsCore.sub)(1, (0, _tfjsCore.mul)(e, t)));
    return (0, _tfjsCore.mean)(square(n), -1);
  });
}

function hinge(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.maximum)(0, (0, _tfjsCore.sub)(1, (0, _tfjsCore.mul)(e, t)));
    return (0, _tfjsCore.mean)(n, -1);
  });
}

function categoricalHinge(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.sum)((0, _tfjsCore.mul)(e, t), -1),
        r = (0, _tfjsCore.max)((0, _tfjsCore.mul)((0, _tfjsCore.sub)(1, e), t), -1);
    return (0, _tfjsCore.maximum)(0, (0, _tfjsCore.add)(1, (0, _tfjsCore.sub)(r, n)));
  });
}

function logcosh(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = Math.log(2),
        r = (0, _tfjsCore.sub)(t, e),
        i = (0, _tfjsCore.sub)((0, _tfjsCore.add)(r, (0, _tfjsCore.softplus)((0, _tfjsCore.mul)(-2, r))), n);
    return (0, _tfjsCore.mean)(i, -1);
  });
}

function categoricalCrossentropy(e, t, n) {
  return void 0 === n && (n = !1), (0, _tfjsCore.tidy)(function () {
    if (n) t = (0, _tfjsCore.softmax)(t);else {
      var r = (0, _tfjsCore.sum)(t, t.shape.length - 1, !0);
      t = (0, _tfjsCore.div)(t, r);
    }
    return t = (0, _tfjsCore.clipByValue)(t, epsilon(), 1 - epsilon()), (0, _tfjsCore.neg)((0, _tfjsCore.sum)((0, _tfjsCore.mul)(e.toFloat(), (0, _tfjsCore.log)(t)), t.shape.length - 1));
  });
}

function sparseCategoricalCrossentropy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.floor)(flatten(e)).toInt(),
        r = (t = (0, _tfjsCore.clipByValue)(t, epsilon(), 1 - epsilon())).shape;
    return categoricalCrossentropy((0, _tfjsCore.oneHot)(n, r[r.length - 1]).reshape(r), t, !1);
  });
}

function sigmoidCrossEntropyWithLogits(e, t) {
  if (!_tfjsCore.util.arraysEqual(e.shape, t.shape)) throw new ValueError("logits and labels must have the same shape, but got shapes " + JSON.stringify(e.shape) + " and " + JSON.stringify(t.shape));
  return (0, _tfjsCore.tidy)(function () {
    var n = t.relu(),
        r = t.abs().neg();
    return n.sub(t.mul(e)).add(r.exp().log1p());
  });
}

function binaryCrossentropy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n;
    return n = (0, _tfjsCore.clipByValue)(t, epsilon(), 1 - epsilon()), n = (0, _tfjsCore.log)((0, _tfjsCore.div)(n, (0, _tfjsCore.sub)(1, n))), (0, _tfjsCore.mean)(sigmoidCrossEntropyWithLogits(e, n), -1);
  });
}

function kullbackLeiblerDivergence(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.clipByValue)(e, epsilon(), 1),
        r = (0, _tfjsCore.clipByValue)(t, epsilon(), 1);
    return (0, _tfjsCore.sum)((0, _tfjsCore.mul)(e, (0, _tfjsCore.log)((0, _tfjsCore.div)(n, r))), -1);
  });
}

function poisson(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.log)((0, _tfjsCore.add)(epsilon(), t));
    return (0, _tfjsCore.mean)((0, _tfjsCore.sub)(t, (0, _tfjsCore.mul)(e, n)), -1);
  });
}

function cosineProximity(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = l2Normalize(e, -1),
        r = l2Normalize(t, -1),
        i = (0, _tfjsCore.mul)(n, r);
    return (0, _tfjsCore.neg)((0, _tfjsCore.sum)(i, -1));
  });
}

var lossesMap = {
  meanSquaredError: meanSquaredError,
  meanAbsoluteError: meanAbsoluteError,
  meanAbsolutePercentageError: meanAbsolutePercentageError,
  meanSquaredLogarithmicError: meanSquaredLogarithmicError,
  squaredHinge: squaredHinge,
  hinge: hinge,
  categoricalHinge: categoricalHinge,
  logcosh: logcosh,
  categoricalCrossentropy: categoricalCrossentropy,
  sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
  binaryCrossentropy: binaryCrossentropy,
  kullbackLeiblerDivergence: kullbackLeiblerDivergence,
  poisson: poisson,
  cosineProximity: cosineProximity
};

function get(e) {
  if ("string" == typeof e) {
    if (e in lossesMap) return lossesMap[e];
    var t = "Unknown loss " + e;
    throw e.toLowerCase().includes("softmaxcrossentropy") && (t = "Unknown loss " + e + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new ValueError(t);
  }

  return e;
}

function binaryAccuracy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.mul)(.5, (0, _tfjsCore.onesLike)(t)),
        r = cast$1((0, _tfjsCore.greater)(t, n), e.dtype);
    return (0, _tfjsCore.mean)((0, _tfjsCore.equal)(e, r), -1);
  });
}

function categoricalAccuracy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return cast$1((0, _tfjsCore.equal)((0, _tfjsCore.argMax)(e, -1), (0, _tfjsCore.argMax)(t, -1)), "float32");
  });
}

function truePositives(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.logicalAnd)(e.equal(1), t.equal(1)).sum().cast("float32");
  });
}

function falseNegatives(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.logicalAnd)(e.equal(1), t.equal(0)).sum().cast("float32");
  });
}

function falsePositives(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.logicalAnd)(e.equal(0), t.equal(1)).sum().cast("float32");
  });
}

function precision(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = truePositives(e, t),
        r = falsePositives(e, t),
        i = n.add(r);
    return (0, _tfjsCore.where)((0, _tfjsCore.greater)(i, 0), n.div(i), 0).cast("float32");
  });
}

function recall(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = truePositives(e, t),
        r = falseNegatives(e, t),
        i = n.add(r);
    return (0, _tfjsCore.where)((0, _tfjsCore.greater)(i, 0), n.div(i), 0).cast("float32");
  });
}

function binaryCrossentropy$1(e, t) {
  return binaryCrossentropy(e, t);
}

function sparseCategoricalAccuracy(e, t) {
  return e.rank === t.rank && (e = e.squeeze([e.rank - 1])), (t = t.argMax(-1)).dtype !== e.dtype && (t = t.asType(e.dtype)), (0, _tfjsCore.equal)(e, t).asType("float32");
}

var mse$1 = meanSquaredError,
    MSE$1 = meanSquaredError,
    mae$1 = meanAbsoluteError,
    MAE$1 = meanAbsoluteError,
    mape$1 = meanAbsolutePercentageError,
    MAPE$1 = meanAbsolutePercentageError,
    categoricalCrossentropy$1 = categoricalCrossentropy,
    cosine$1 = cosineProximity,
    sparseCategoricalCrossentropy$1 = sparseCategoricalCrossentropy,
    metricsMap = {
  binaryAccuracy: binaryAccuracy,
  categoricalAccuracy: categoricalAccuracy,
  precision: precision,
  categoricalCrossentropy: categoricalCrossentropy$1,
  sparseCategoricalCrossentropy: sparseCategoricalCrossentropy$1,
  mse: mse$1,
  MSE: MSE$1,
  mae: mae$1,
  MAE: MAE$1,
  mape: mape$1,
  MAPE: MAPE$1,
  cosine: cosine$1
};

function get$1(e) {
  if ("string" == typeof e && e in metricsMap) return metricsMap[e];
  if ("string" != typeof e && null != e) return e;
  throw new ValueError("Unknown metric " + e);
}

function getLossOrMetricName(e) {
  if (assert(null !== e, "Unknown LossOrMetricFn " + e), "string" == typeof e) return e;

  for (var t = void 0, n = 0, r = Object.keys(lossesMap); n < r.length; n++) {
    var i = r[n];

    if (lossesMap[i] === e) {
      t = i;
      break;
    }
  }

  if (void 0 !== t) return t;

  for (var a = 0, o = Object.keys(metricsMap); a < o.length; a++) {
    i = o[a];

    if (metricsMap[i] === e) {
      t = i;
      break;
    }
  }

  return void 0 !== t ? t : e.name;
}

function getOptimizer(e) {
  var t = {
    Adagrad: function () {
      return _tfjsCore.train.adagrad(.01);
    },
    Adadelta: function () {
      return _tfjsCore.train.adadelta(1, .95, epsilon());
    },
    Adam: function () {
      return _tfjsCore.train.adam(.001, .9, .999, epsilon());
    },
    Adamax: function () {
      return _tfjsCore.train.adamax(.002, .9, .999, epsilon(), 0);
    },
    RMSProp: function () {
      return _tfjsCore.train.rmsprop(.001, .9, 0, epsilon());
    },
    SGD: function () {
      return _tfjsCore.train.sgd(.01);
    }
  };
  if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
  throw new ValueError("Unknown Optimizer " + e);
}

var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1048576;

function checkUserDefinedMetadata(e, t, n) {
  if (void 0 === n && (n = !1), null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !plainObjectCheck(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");

  if (n) {
    var r = JSON.stringify(e);
    r.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH && console.warn('User-defined metadata of model "' + t + '" is too large in size (length=' + r.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH + ".");
  }
}

function plainObjectCheck(e) {
  if (null === e) return !0;

  if ("object" == typeof e) {
    if (Object.getPrototypeOf(e) === Object.prototype) {
      for (var t = 0, n = Object.keys(e); t < n.length; t++) {
        var r = n[t];
        if ("string" != typeof r) return !1;
        if (!plainObjectCheck(e[r])) return !1;
      }

      return !0;
    }

    if (Array.isArray(e)) {
      for (var i = 0, a = e; i < a.length; i++) {
        if (!plainObjectCheck(a[i])) return !1;
      }

      return !0;
    }

    return !1;
  }

  var o = typeof e;
  return "string" === o || "number" === o || "boolean" === o;
}

function printSummary(e, t, n, r) {
  void 0 === r && (r = console.log);
  var i,
      a = isModelSequentialLike(e),
      o = ["Layer (type)", "Output shape", "Param #"];
  if (a ? (t = t || 65, n = n || [.45, .85, 1]) : (t = t || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(function (e) {
    return Math.floor(t * e);
  })), !a) for (var s in o.push("Receives inputs"), i = [], e.nodesByDepth) i.push.apply(i, e.nodesByDepth[s]);
  r("_".repeat(t)), printRow(o, n, r), r("=".repeat(t));

  for (var l = e.layers, u = 0; u < l.length; ++u) a ? printLayerSummary(l[u], n, r) : printLayerSummaryWithConnections(l[u], n, i, r), r((u === l.length - 1 ? "=" : "_").repeat(t));

  e.checkTrainableWeightsConsistency();
  var c = countTrainableParams(e),
      p = countParamsInWeights(e.nonTrainableWeights);
  r("Total params: " + (c + p)), r("Trainable params: " + c), r("Non-trainable params: " + p), r("_".repeat(t));
}

function countTrainableParams(e) {
  return null != e.collectedTrainableWeights ? countParamsInWeights(e.collectedTrainableWeights) : countParamsInWeights(e.trainableWeights);
}

function isModelSequentialLike(e) {
  var t = !0,
      n = [],
      r = [];

  for (var i in e.nodesByDepth) n.push(e.nodesByDepth[i]);

  for (var a = 0, o = n; a < o.length; a++) {
    var s = o[a];

    if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
      t = !1;
      break;
    }

    r.push.apply(r, s);
  }

  if (t) for (var l = 0, u = e.layers; l < u.length; l++) {
    for (var c = !1, p = 0, h = u[l].inboundNodes; p < h.length; p++) {
      var d = h[p];

      if (-1 !== r.indexOf(d)) {
        if (c) {
          t = !1;
          break;
        }

        c = !0;
      }
    }

    if (!t) break;
  }
  return t;
}

function printRow(e, t, n) {
  void 0 === n && (n = console.log);

  for (var r = "", i = 0; i < e.length; ++i) i > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += e[i]).slice(0, t[i]), r += " ".repeat(t[i] - r.length);

  n(r);
}

function printLayerSummary(e, t, n) {
  var r;

  try {
    r = JSON.stringify(e.outputShape);
  } catch (e) {
    r = "multiple";
  }

  printRow([e.name + " (" + e.getClassName() + ")", r, e.countParams().toString()], t, n);
}

function printLayerSummaryWithConnections(e, t, n, r) {
  var i;

  try {
    i = JSON.stringify(e.outputShape);
  } catch (e) {
    i = "multiple";
  }

  for (var a = [], o = 0, s = e.inboundNodes; o < s.length; o++) {
    var l = s[o];
    if (!(null != n && n.length > 0 && -1 === n.indexOf(l))) for (var u = 0; u < l.inboundLayers.length; ++u) {
      var c = l.inboundLayers[u].name,
          p = l.nodeIndices[u],
          h = l.tensorIndices[u];
      a.push(c + "[" + p + "][" + h + "]");
    }
  }

  var d = e.name,
      f = e.getClassName(),
      g = 0 === a.length ? "" : a[0];
  printRow([d + " (" + f + ")", i, e.countParams().toString(), g], t, r);

  for (u = 1; u < a.length; ++u) printRow(["", "", "", a[u]], t, r);
}

function isArrayItemInputOrOutputName(e, t, n) {
  return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
}

function convertPythonicToTs(e, t) {
  if (null === e) return null;
  if ("string" == typeof e) return toCamelCase(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    for (var n = [], r = e.length, i = 0; i < r; ++i) {
      var a = e[i];
      isArrayItemInputOrOutputName(t, i, a) ? n.push(a) : n.push(convertPythonicToTs(a, t));
    }

    return n;
  }

  for (var o = {}, s = 0, l = Object.keys(e); s < l.length; s++) {
    var u = l[s],
        c = e[u];
    if ("name" === u && "string" == typeof c) o[u] = c;else {
      var p = toCamelCase(u);
      o[p] = convertPythonicToTs(c, p);
    }
  }

  return o;
}

function convertTsToPythonic(e, t) {
  if (null === e || void 0 === e) return null;
  if ("string" == typeof e) return toSnakeCase(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    for (var n = [], r = e.length, i = 0; i < r; ++i) {
      var a = e[i];
      isArrayItemInputOrOutputName(t, i, a) ? n.push(a) : n.push(convertTsToPythonic(a, t));
    }

    return n;
  }

  for (var o = {}, s = 0, l = Object.keys(e); s < l.length; s++) {
    var u = l[s],
        c = e[u],
        p = toSnakeCase(u);
    o[p] = "name" !== u && "className" !== u || "string" != typeof c ? convertTsToPythonic(c, u) : c;
  }

  return o;
}

var version = "1.3.2";
exports.version_layers = version;

function assertFeedCompatibility(e, t) {
  if (null == e.dtype || e.dtype === t.dtype) return t;

  try {
    return (0, _tfjsCore.cast)(t, e.dtype);
  } catch (n) {
    throw new ValueError("The dtype of the feed (" + t.dtype + ") can not be cast to the dtype of the key '" + e.name + "' (" + e.dtype + ").");
  }
}

var FeedDict = function () {
  function e(t) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof e) for (var n in t.id2Value) this.id2Value[n] = t.id2Value[n], n in t.id2Mask && (this.id2Mask[n] = t.id2Mask[n]);else {
      if (null == t) return;

      for (var r = 0, i = t; r < i.length; r++) {
        var a = i[r];
        this.add(a.key, a.value);
      }
    }
  }

  return e.prototype.add = function (e, t, n) {
    if (null != this.id2Value[e.id]) throw new ValueError("Duplicate key: name=" + e.name + ", id=" + e.id);
    return this.id2Value[e.id] = assertFeedCompatibility(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this;
  }, e.prototype.addFeed = function (e) {
    this.add(e.key, e.value);
  }, e.prototype.hasKey = function (e) {
    return null != this.id2Value[e.id];
  }, e.prototype.names = function () {
    return Object.keys(this.name2Id);
  }, e.prototype.getValue = function (e) {
    if (e instanceof SymbolicTensor) {
      if (null == this.id2Value[e.id]) throw new ValueError("Nonexistent key: " + e.name);
      return this.id2Value[e.id];
    }

    var t = this.name2Id[e];
    if (null == t) throw new ValueError("Feed dict has no SymbolicTensor name: " + e);
    return this.id2Value[t];
  }, e.prototype.getMask = function (e) {
    if (e instanceof SymbolicTensor) {
      if (null == this.id2Value[e.id]) throw new ValueError("Nonexistent key: " + e.name);
      return this.id2Mask[e.id];
    }

    var t = this.name2Id[e];
    if (null == t) throw new ValueError("Feed dict has no SymbolicTensor name: " + e);
    return this.id2Mask[t];
  }, e.prototype.disposeMasks = function () {
    null != this.id2Mask && (0, _tfjsCore.dispose)(this.id2Mask);
  }, e;
}(),
    cachedSorted = {},
    cachedRecipientCounts = {};

function execute(e, t, n, r) {
  for (var i = null != n && n.training, a = Array.isArray(e), o = a ? e : [e], s = o.map(function (e) {
    return e.name;
  }), l = [], u = t.names(), c = 0, p = s; c < p.length; c++) {
    var h = p[c];
    -1 !== u.indexOf(h) ? l.push(t.getValue(h)) : l.push(null);
  }

  null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
  var d,
      f,
      g = s.join(",") + "|" + t.names().join(",");

  if (null == cachedSorted[g]) {
    var m = getTopologicalSortAndRecipientCounts(o, t);
    d = m.sorted, f = m.recipientCounts, cachedSorted[g] = d, cachedRecipientCounts[g] = f;
  }

  d = cachedSorted[g], f = {}, i || Object.assign(f, cachedRecipientCounts[g]);

  for (var y = new FeedDict(t), v = 0; v < d.length; ++v) {
    if (null != r) {
      var b = (0, _tfjsCore.memory)().numTensors;
      b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b);
    }

    var w = d[v],
        z = w.sourceLayer;

    if (!(z instanceof InputLayer)) {
      for (var S = [], A = [], _ = [], I = !1, C = 0, E = w.inputs; C < E.length; C++) {
        var N = E[C],
            k = y.getValue(N),
            x = y.getMask(N);
        S.push(k), A.push(x), null != x && (I = !0), i || (f[N.name]--, 0 !== f[N.name] || t.hasKey(N) || -1 !== s.indexOf(N.name) || k.isDisposed || !0 === N.sourceLayer.stateful || _.push(k));
      }

      I && ((n = n || {}).mask = A[0]);
      var L = toList(z.apply(S, n)),
          T = null;
      z.supportsMasking && (T = z.computeMask(S, A));

      for (var D = getNodeOutputs(w), O = Array.isArray(D) ? D : [D], R = 0; R < O.length; ++R) {
        y.hasKey(O[R]) || y.add(O[R], L[R], Array.isArray(T) ? T[0] : T);
        var M = s.indexOf(O[R].name);
        -1 !== M && (l[M] = L[R]);
      }

      i || (0, _tfjsCore.dispose)(_);
    }
  }

  return y.disposeMasks(), a ? l : l[0];
}

function getTopologicalSortAndRecipientCounts(e, t) {
  _tfjsCore.util.assert(null != e && e.length > 0, function () {
    return "Expected at least one fetch, got none";
  });

  var n = [],
      r = {};

  if (1 === e.length) {
    var i = getTopologicalSortAndRecipientCountsForOneFetch(e[0], t);
    n = i.sorted, r = i.recipientMap;
  } else for (var a = new Set(), o = 0, s = e; o < s.length; o++) {
    for (var l = getTopologicalSortAndRecipientCountsForOneFetch(s[o], t), u = l.sorted, c = l.recipientMap, p = 0, h = u; p < h.length; p++) {
      var d = h[p];
      a.has(d.name) || (n.push(d), a.add(d.name));
    }

    var f = function (e) {
      null == r[e] && (r[e] = new Set()), c[e].forEach(function (t) {
        return r[e].add(t);
      });
    };

    for (var g in c) f(g);
  }

  return {
    sorted: n,
    recipientCounts: recipientMap2Counts(r)
  };
}

function recipientMap2Counts(e) {
  var t = {};

  for (var n in e) t[n] = e[n].size;

  return t;
}

function getTopologicalSortAndRecipientCountsForOneFetch(e, t) {
  for (var n = new Set(), r = [], i = {}, a = 0, o = t.names(); a < o.length; a++) {
    var s = o[a];
    n.add(s);
  }

  var l = [],
      u = [];

  for (l.push(e); l.length > 0;) {
    var c = l[l.length - 1];
    if (n.has(c.name)) l.pop();else {
      var p = u[u.length - 1] === l.length - 1;
      if (0 === c.inputs.length || p) l.pop(), r.push(c), n.add(c.name), p && u.pop();else {
        u.push(l.length - 1);

        for (var h = 0, d = c.inputs; h < d.length; h++) {
          var f = d[h];
          null == i[f.name] && (i[f.name] = new Set()), i[f.name].add(c.name), n.has(f.name) || l.push(f);
        }
      }
    }
  }

  return {
    sorted: r,
    recipientMap: i
  };
}

function getNodeOutputs(e) {
  var t;
  if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;else {
    for (var n = null, r = 0; r < e.sourceLayer.inboundNodes.length; ++r) for (var i = 0, a = e.sourceLayer.inboundNodes[r].outputTensors; i < a.length; i++) {
      if (a[i].id === e.id) {
        n = r;
        break;
      }
    }

    t = e.sourceLayer.getOutputAt(n);
  }
  return t;
}

var Container = function (e) {
  function t(n) {
    var r = e.call(this, {}) || this;

    if (r.containerNodes = new Set(), r.name = n.name, null == r.name) {
      var i = r.getClassName().toLowerCase();
      r.name = getUid(i);
    }

    if (r.supportsMasking = !1, r.trainable_ = !0, Array.isArray(n.inputs) ? r.inputs = n.inputs.slice() : r.inputs = [n.inputs], Array.isArray(n.outputs) ? r.outputs = n.outputs.slice() : r.outputs = [n.outputs], unique(r.inputs).length !== r.inputs.length) throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r.inputs.map(function (e) {
      return e.name;
    }));
    unique(r.outputs).length !== r.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r.outputs.map(function (e) {
      return e.name;
    })), r.inputLayers = [], r.inputLayersNodeIndices = [], r.inputLayersTensorIndices = [], r.outputLayers = [], r.outputLayersNodeIndices = [], r.outputLayersTensorIndices = [], r.layers = [], r.internalContainerRefs = [];

    for (var a = 0, o = r.outputs; a < o.length; a++) {
      var s = (C = o[a]).sourceLayer,
          l = C.nodeIndex,
          u = C.tensorIndex;
      r.outputLayers.push(s), r.outputLayersNodeIndices.push(l), r.outputLayersTensorIndices.push(u);
    }

    for (var c = 0, p = r.inputs; c < p.length; c++) {
      s = (C = p[c]).sourceLayer, l = C.nodeIndex, u = C.tensorIndex;
      assert(0 === l, "input layer has >1 nodes"), assert(0 === u, "input layer has >1 tensors"), r.inputLayers.push(s), r.inputLayersNodeIndices.push(l), r.inputLayersTensorIndices.push(u);
    }

    r.inputNames = [], r.outputNames = [], r.feedInputShapes = [], r.feedInputNames = [], r.feedOutputNames = [];

    for (var h = 0; h < r.inputLayers.length; h++) {
      if (!((s = r.inputLayers[h]) instanceof InputLayer)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n.inputs + ". Input " + h + " (0-based) originates from layer type " + s.getClassName() + ".");
      r.inputNames.push(s.name), r.feedInputShapes.push(s.batchInputShape), r.feedInputNames.push(s.name);
    }

    for (var d = 0, f = r.outputLayers; d < f.length; d++) {
      s = f[d];
      r.outputNames.push(s.name);
    }

    r.internalInputShapes = r.inputs.map(function (e) {
      return e.shape;
    }), r.internalOutputShapes = r.outputs.map(function (e) {
      return e.shape;
    });

    for (var g = {}, m = {}, y = {}, v = {}, b = {}, w = [], z = function (e, n, i, a, o, s) {
      null != a && null != o && null != s || (a = e.sourceLayer, o = e.nodeIndex, s = e.tensorIndex);
      var l = a.inboundNodes[o];
      if (-1 !== i.indexOf(l)) throw new RuntimeError("The tensor " + e.name + ' at layer "' + a.name + '" is part of a cycle.');

      if (-1 === n.indexOf(l)) {
        r.containerNodes.add(t.nodeKey(a, o)), (a.id in b) || (b[a.id] = Object.keys(b).length), -1 === i.indexOf(l) && i.push(l);

        for (var u = l.inboundLayers.length, c = 0; c < u; c++) {
          var p = l.inputTensors[c],
              h = l.inboundLayers[c],
              d = l.nodeIndices[c],
              f = l.tensorIndices[c];
          z(p, n, i, h, d, f);
        }

        for (n.push(l); i.indexOf(l) >= 0;) i.splice(i.indexOf(l), 1);

        w.push(l);
      }
    }, S = [], A = [], _ = 0, I = r.outputs; _ < I.length; _++) {
      var C = I[_];
      z(C, S, A);
    }

    for (var E = 0, N = w.slice().reverse(); E < N.length; E++) {
      m[(K = N[E]).id] = K, K.id in g || (g[K.id] = 0);
      var k = g[K.id],
          x = null == y[K.outboundLayer.id] ? 0 : y[K.outboundLayer.id];
      k = Math.max(k, x), y[K.outboundLayer.id] = k, v[K.outboundLayer.id] = K.outboundLayer, g[K.id] = k;

      for (h = 0; h < K.inboundLayers.length; h++) {
        var L = K.inboundLayers[h],
            T = (l = K.nodeIndices[h], L.inboundNodes[l]),
            D = null == g[T.id] ? 0 : g[T.id];
        g[T.id] = Math.max(k + 1, D), m[T.id] = T;
      }
    }

    var O = {};

    for (var R in g) {
      (k = g[R]) in O || (O[k] = []), O[k].push(m[R]);
    }

    var M = {};

    for (var P in y) {
      (k = y[P]) in M || (M[k] = []), M[k].push(v[P]);
    }

    var F = Object.keys(M).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare);
    r.layers = [];

    for (var V = 0, B = F; V < B.length; V++) {
      var U = M[k = B[V]];
      U.sort(function (e, t) {
        var n = b[e.id],
            r = b[t.id];
        return n < r ? -1 : n > r ? 1 : 0;
      });

      for (var j = 0, W = U; j < W.length; j++) {
        (s = W[j]) instanceof t && r.internalContainerRefs.push(s), r.layers.push(s);
      }
    }

    r.layersByDepth = M, F = Object.keys(O).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare);

    for (var $ = r.inputs.slice(), q = [], G = 0, H = F; G < H.length; G++) for (var J = 0, Z = O[k = H[G]]; J < Z.length; J++) {
      var K;

      if (null != (s = (K = Z[J]).outboundLayer)) {
        for (var Y = 0, X = K.inputTensors; Y < X.length; Y++) {
          C = X[Y];
          if (-1 === $.indexOf(C)) throw new RuntimeError("Graph disconnected: cannot obtain value for tensor " + C + ' at layer "' + s.name + '". The following previous layers were accessed without issue: ' + q);
        }

        for (var Q = 0, ee = K.outputTensors; Q < ee.length; Q++) {
          C = ee[Q];
          $.push(C);
        }

        q.push(s.name);
      }
    }

    r.nodesByDepth = O;

    for (var te = r.layers.map(function (e) {
      return e.name;
    }), ne = function (e) {
      var t = te.filter(function (t) {
        return t === e;
      }).length;
      if (1 !== t) throw new RuntimeError('The name "' + e + '" is used ' + t + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(te));
    }, re = 0, ie = te; re < ie.length; re++) {
      ne(ie[re]);
    }

    return r.outboundNodes = [], r.inboundNodes = [], new Node({
      outboundLayer: r,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: r.inputs,
      outputTensors: r.outputs,
      inputMasks: r.inputs.map(function (e) {
        return null;
      }),
      outputMasks: r.outputs.map(function (e) {
        return null;
      }),
      inputShapes: r.inputs.map(function (e) {
        return e.shape;
      }),
      outputShapes: r.outputs.map(function (e) {
        return e.shape;
      })
    }), r.built = !0, r._refCount = 1, r;
  }

  return __extends(t, e), t.prototype.assertNotDisposed = function () {
    if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.");
  }, t.prototype.dispose = function () {
    this.assertNotDisposed();
    var e = {
      refCountAfterDispose: null,
      numDisposedVariables: 0
    };

    if (0 == --this._refCount) {
      for (var t = 0, n = this.layers; t < n.length; t++) {
        var r = n[t];
        e.numDisposedVariables += r.dispose().numDisposedVariables;
      }

      for (var i = 0, a = this.internalContainerRefs; i < a.length; i++) {
        var o = a[i];
        e.numDisposedVariables += o.dispose().numDisposedVariables;
      }
    }

    return e.refCountAfterDispose = this._refCount, e;
  }, Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return this.trainable_;
    },
    set: function (e) {
      this.layers.forEach(function (t) {
        t._trainableWeights.forEach(function (t) {
          return t.trainable = e;
        });
      }), this.trainable_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      if (this._trainableWeights.length > 0) throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable) return [];

      for (var e = [], t = 0, n = this.layers; t < n.length; t++) {
        var r = n[t];
        e = e.concat(r.trainableWeights);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      for (var e = [], t = 0, n = this.layers; t < n.length; t++) {
        var r = n[t];
        e.push.apply(e, r.nonTrainableWeights);
      }

      if (!this.trainable) {
        for (var i = [], a = 0, o = this.layers; a < o.length; a++) {
          r = o[a];
          i.push.apply(i, r.trainableWeights);
        }

        return i.concat(e);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "weights", {
    get: function () {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.loadWeights = function (e, t) {
    void 0 === t && (t = !0);

    for (var n = {}, r = 0, i = 0, a = this.layers; i < a.length; i++) for (var o = 0, s = a[i].weights; o < s.length; o++) {
      var l = s[o];
      if (null != n[l.originalName]) throw new ValueError("Duplicate weight name: " + l.originalName);
      n[l.originalName] = l, r++;
    }

    var u = [];

    for (var c in e) {
      if (null != n[c]) u.push([n[c], e[c]]);else if (t) throw new ValueError("Provided weight data has no target variable: " + c);
      delete n[c];
    }

    if (t) {
      var p = [];

      for (var h in n) p.push(h);

      if (p.length > 0) throw new ValueError(p.length + " of " + r + " weights are not set: " + p);
    }

    batchSetValue(u);
  }, t.prototype.updatedConfig = function () {
    var e = this.getConfig(),
        t = {};
    return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers " + version, t.backend = "TensorFlow.js", t;
  }, t.prototype.toJSON = function (e, t) {
    void 0 === t && (t = !0);
    var n = convertTsToPythonic(this.updatedConfig());
    return t ? JSON.stringify(n) : n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      e = toList(e);

      for (var r = new FeedDict(), i = 0; i < n.inputs.length; ++i) r.add(n.inputs[i], e[i]);

      return execute(n.outputs, r, t);
    });
  }, t.prototype.computeMask = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r;
      return e = toList(e), r = null == t ? pyListRepeat(null, e.length) : toList(t), n.runInternalGraph(e, r)[1];
    });
  }, t.prototype.computeOutputShape = function (e) {
    var t = normalizeShapeList(e);
    if (t.length !== this.inputLayers.length) throw new ValueError("Invalid inputShape argument " + e + ": model has " + this.inputLayers.length + " tensor inputs.");

    for (var n = {}, r = 0; r < t.length; r++) {
      var i = this.inputLayers[r],
          a = t[r];
      n[A = i.name + "_0_0"] = a;
    }

    var o = Object.keys(this.nodesByDepth).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare);
    if (o.length > 1) for (var s = 0, l = o; s < l.length; s++) for (var u = l[s], c = 0, p = this.nodesByDepth[u]; c < p.length; c++) {
      var h = p[c];
      i = h.outboundLayer;

      if (-1 === this.inputLayers.map(function (e) {
        return e.id;
      }).indexOf(i.id)) {
        for (var d = [], f = 0; f < h.inboundLayers.length; f++) {
          var g = h.inboundLayers[f],
              m = h.nodeIndices[f],
              y = h.tensorIndices[f],
              v = n[A = g.name + "_" + m + "_" + y];
          d.push(v);
        }

        var b = normalizeShapeList(i.computeOutputShape(singletonOrArray(d))),
            w = i.inboundNodes.indexOf(h);

        for (f = 0; f < b.length; f++) {
          n[A = i.name + "_" + w + "_" + f] = b[f];
        }
      }
    }
    var z = [],
        S = [];

    for (r = 0; r < this.outputLayers.length; r++) {
      i = this.outputLayers[r], w = this.outputLayersNodeIndices[r], y = this.outputLayersTensorIndices[r];
      var A = i.name + "_" + w + "_" + y;
      S.push(A);
    }

    for (r = 0; r < S.length; r++) {
      var _ = S[r];
      assert(_ in n), z.push(n[_]);
    }

    return singletonOrArray(z);
  }, t.prototype.runInternalGraph = function (e, t) {
    null == t && (t = pyListRepeat(null, e.length));

    for (var n = {}, r = 0; r < this.inputs.length; ++r) {
      var i = this.inputs[r],
          a = e[r],
          o = t[r];
      n[i.id] = [a, o];
    }

    for (var s = 0, l = Object.keys(this.nodesByDepth).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare); s < l.length; s++) for (var u = l[s], c = 0, p = this.nodesByDepth[u]; c < p.length; c++) {
      for (var h = p[c], d = h.outboundLayer, f = h.inputTensors, g = h.outputTensors, m = new Array(), y = 0, v = f; y < v.length; y++) {
        (i = v[y]).id in n && m.push(n[i.id]);
      }

      if (m.length === f.length) {
        var b = {},
            w = void 0,
            z = void 0,
            S = void 0,
            A = void 0;

        if (null != h.callArgs && (b = h.callArgs), 1 === m.length) {
          var _ = m[0],
              I = _[0],
              C = _[1];
          null == b.mask && (b.mask = C), S = toList(d.call(I, b)), A = toList(d.computeMask(I, C)), w = [I], z = [C];
        } else w = m.map(function (e) {
          return e[0];
        }), z = m.map(function (e) {
          return e[1];
        }), null == b.mask && (b.mask = z), S = toList(d.call(w, b)), A = toList(d.computeMask(w, z));

        if (d.activityRegularizer) throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");

        for (r = 0; r < g.length; ++r) {
          i = g[r], a = S[r], o = A[r];
          n[i.id] = [a, o];
        }
      }
    }

    for (var E = [], N = [], k = [], x = 0, L = this.outputs; x < L.length; x++) {
      assert((i = L[x]).id in n, "Could not compute output " + i.name + " : " + i.id);
      var T = n[i.id],
          D = T[0];
      o = T[1];
      k.push(D.shape), E.push(D), N.push(o);
    }

    return [E, N, k];
  }, t.prototype.buildNodeConversionMap = function (e) {
    for (var n, r = {}, i = 0, a = this.layers; i < a.length; i++) {
      var o = a[i];
      n = o instanceof t ? 1 : 0;

      for (var s = 0; s < o.inboundNodes.length; s++) {
        var l = t.nodeKey(o, s);
        this.containerNodes.has(l) && (r[l] = n, n += 1);
      }
    }

    return r;
  }, t.prototype.getLayer = function (e, t) {
    if (null != t) {
      if (this.layers.length <= t) throw new ValueError("Was asked to retrieve layer at index " + t + ", but model only has " + this.layers.length + " layer(s).");
      return this.layers[t];
    }

    if (null == e) throw new ValueError("Provide either a layer name or layer index");

    for (var n = 0, r = this.layers; n < r.length; n++) {
      var i = r[n];
      if (i.name === e) return i;
    }

    throw new ValueError("No such layer: " + e);
  }, t.prototype.calculateLosses = function () {
    var e = this;
    return (0, _tfjsCore.tidy)(function () {
      for (var n = [], r = 0, i = e.layers; r < i.length; r++) for (var a = i[r], o = 0; o < a.inboundNodes.length; ++o) {
        var s = t.nodeKey(a, o);
        e.containerNodes.has(s) && n.push.apply(n, a.calculateLosses());
      }

      return n;
    });
  }, t.prototype.getConfig = function () {
    for (var e = {
      name: this.name
    }, n = this.buildNodeConversionMap(this.layers), r = [], i = 0, a = this.layers; i < a.length; i++) {
      for (var o = (w = a[i]).getClassName(), s = w.getConfig(), l = [], u = 0; u < w.inboundNodes.length; u++) {
        var c = w.inboundNodes[u],
            p = t.nodeKey(w, u),
            h = {};

        if (this.containerNodes.has(p)) {
          if (c.callArgs) try {
            JSON.stringify(c.callArgs), h = c.callArgs;
          } catch (e) {
            console.warn("Layer " + w.name + " was passed non-serializable keyword arguments: " + c.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), h = {};
          }

          if (c.inboundLayers.length > 0) {
            for (var d = [], f = 0; f < c.inboundLayers.length; f++) {
              var g = c.inboundLayers[f],
                  m = c.nodeIndices[f],
                  y = c.tensorIndices[f];
              null == (S = n[t.nodeKey(g, m)]) && (S = 0), d.push([g.name, S, y, h]);
            }

            l.push(d);
          }
        }
      }

      var v = {};
      v.name = w.name, v.className = o, v.config = s, v.inboundNodes = l, r.push(v);
    }

    e.layers = r;
    var b = [];

    for (f = 0; f < this.inputLayers.length; f++) {
      var w = this.inputLayers[f];
      m = this.inputLayersNodeIndices[f], p = t.nodeKey(w, m);

      if (this.containerNodes.has(p)) {
        null !== (S = n[p]) && void 0 !== S || (S = 0);
        y = this.inputLayersTensorIndices[f];
        b.push([w.name, S, y]);
      }
    }

    e.inputLayers = b;
    var z = [];

    for (f = 0; f < this.outputLayers.length; f++) {
      w = this.outputLayers[f], m = this.outputLayersNodeIndices[f], p = t.nodeKey(w, m);

      if (this.containerNodes.has(p)) {
        var S;
        null !== (S = n[p]) && void 0 !== S || (S = 0);
        y = this.outputLayersTensorIndices[f];
        z.push([w.name, S, y]);
      }
    }

    return e.outputLayers = z, e;
  }, t.fromConfig = function (e, t, n, r) {
    void 0 === n && (n = {}), void 0 === r && (r = !1);
    var i = {},
        a = {};

    function o(e, t) {
      e.name in a ? a[e.name].push(t) : a[e.name] = [t];
    }

    function s(e, t) {
      for (var n, r = [], a = 0, s = t; a < s.length; a++) {
        var l = s[a],
            u = l[0],
            c = l[1],
            p = l[2];
        if (n = null == l[3] ? {} : l[3], !(u in i)) return void o(e, t);
        var h = i[u];
        if (h.inboundNodes.length <= c) return void o(e, t);
        var d = h.inboundNodes[c];
        r.push(d.outputTensors[p]);
      }

      r.length > 0 && e.apply(singletonOrArray(r), n);
    }

    function l(e) {
      var n = e.name,
          a = deserialize(e, null != t.customObjects ? t.customObjects : {});
      a.setFastWeightInitDuringBuild(r), i[n] = a, e.inboundNodes.forEach(function (e) {
        if (!(e instanceof Array)) throw new ValueError("Corrupted configuration, expected array for nodeData: " + e);
        o(a, e);
      });
    }

    for (var u = t.name, c = t.layers, p = 0, h = c; p < h.length; p++) {
      l(g = h[p]);
    }

    for (; !isObjectEmpty(a);) for (var d = 0, f = c; d < f.length; d++) {
      var g = f[d];

      if ((k = i[g.name]).name in a) {
        var m = a[k.name];
        delete a[k.name];

        for (var y = 0, v = m; y < v.length; y++) {
          s(k, v[y]);
        }
      }
    }

    for (var b = [], w = [], z = 0, S = t.inputLayers; z < S.length; z++) {
      var A = (g = S[z])[0],
          _ = g[1],
          I = g[2];
      assert(A in i);
      var C = (k = i[A]).inboundNodes[_].outputTensors;
      b.push(C[I]);
    }

    for (var E = 0, N = t.outputLayers; E < N.length; E++) {
      A = (g = N[E])[0], _ = g[1], I = g[2];
      assert(A in i);
      var k;
      C = (k = i[A]).inboundNodes[_].outputTensors;
      w.push(C[I]);
    }

    return new e({
      inputs: b,
      outputs: w,
      name: u
    });
  }, Object.defineProperty(t.prototype, "stateful", {
    get: function () {
      if (this._stateful) throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");

      for (var e = 0, t = this.layers; e < t.length; e++) {
        if (t[e].stateful) return !0;
      }

      return !1;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.resetStates = function () {
    var e = this;
    (0, _tfjsCore.tidy)(function () {
      e.layers.forEach(function (e) {
        e.stateful && e.resetStates();
      });
    });
  }, t;
}(Layer);

function standardizeSampleOrClassWeights(e, t, n) {
  var r = t.length;
  if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
    return null;
  });
  if (1 === r) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];

  if (Array.isArray(e)) {
    if (e.length !== r) throw new Error("Provided " + n + " is an array of " + e.length + " element(s), but the model has " + r + " outputs. Make sure a set of weights is provided for each model output.");
    return e;
  }

  if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
    var i = [];
    return t.forEach(function (t) {
      t in e ? i.push(e[t]) : i.push(null);
    }), i;
  }

  throw new Error("The model has multiple (" + r + ") outputs, so " + n + " must be either an array with " + r + " elements or an object with " + t + " keys. Provided " + n + " not understood: " + JSON.stringify(e));
}

function standardizeClassWeights(e, t) {
  return standardizeSampleOrClassWeights(e, t, "classWeight");
}

function standardizeWeights(e, t, n, r) {
  return __awaiter(this, void 0, void 0, function () {
    var i, a, o, s, l;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          if (null != t || null != r) throw new Error("Support sampleWeight is not implemented yet");
          return null == n ? [3, 2] : (i = (0, _tfjsCore.tidy)(function () {
            if (1 === e.shape.length) return e.clone();

            if (2 === e.shape.length) {
              if (e.shape[1] > 1) {
                return e.argMax(1);
              }

              if (1 === e.shape[1]) return e.reshape([e.shape[0]]);
              throw new Error("Encountered unexpected last-dimension size (" + e.shape[1] + ") during handling of class weights. The size is expected to be >= 1.");
            }

            throw new Error("Unexpected rank of target (y) tensor (" + e.rank + ") during handling of class weights. The rank is expected to be 1 or 2.");
          }), s = (o = Array).from, [4, i.data()]);

        case 1:
          return a = s.apply(o, [u.sent()]), (0, _tfjsCore.dispose)(i), l = [], a.forEach(function (e) {
            if (null == n[e]) throw new Error("classWeight must contain all classes in the training data. The class " + e + " exists in the data but not in classWeight");
            l.push(n[e]);
          }), [2, (0, _tfjsCore.tensor1d)(l, "float32")];

        case 2:
          return [2, null];
      }
    });
  });
}

function computeWeightedLoss(e, t) {
  return (0, _tfjsCore.mul)(e, t);
}

var DEFAULT_VALIDATION_BATCH_SIZE = 32;

function standardizeDataIteratorOutput(e, t) {
  var n,
      r,
      i = t;
  n = i.xs, r = i.ys, _tfjsCore.util.assert(null != n && null != r, function () {
    return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + t;
  });
  var a = flattenTensorOrArrayOrMap("input", e.inputNames, n),
      o = flattenTensorOrArrayOrMap("output", e.outputNames, r),
      s = a[0].shape[0];
  _tfjsCore.util.assert(a.length === e.inputs.length, function () {
    return "LayersModel has " + e.inputs.length + " inputs, but the dataset provides " + a.length + " inputs.  (Expected input keys: " + JSON.stringify(e.inputNames) + ")";
  }), _tfjsCore.util.assert(o.length === e.outputs.length, function () {
    return "LayersModel has " + e.outputs.length + " outputs, but the dataset provides " + o.length + " outputs.  (Expected output keys: " + JSON.stringify(e.outputNames) + ")";
  });

  var l = function (t) {
    _tfjsCore.util.assert(a[t].shape[0] === s, function () {
      return "Batch size mismatch: input " + e.inputNames[t] + " has " + a[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + ".";
    });
  };

  for (var u in a) l(u);

  var c = function (t) {
    _tfjsCore.util.assert(o[t].shape[0] === s, function () {
      return "Batch size mismatch: output " + e.outputNames[t] + " has " + o[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + ".";
    });
  };

  for (var p in o) c(p);

  return {
    xs: a,
    ys: o
  };
}

function flattenTensorOrArrayOrMap(e, t, n) {
  if (n instanceof _tfjsCore.Tensor) return [n];
  if (Array.isArray(n)) return _tfjsCore.util.assert(n.length === t.length, function () {
    return "Received an array of " + n.length + " Tensors, but expected " + t.length + " to match the " + e + " keys " + t + ".";
  }), n;

  for (var r = [], i = 0, a = t; i < a.length; i++) {
    var o = a[i];
    if (null == n[o]) throw new ValueError("The feature data generated by the dataset lacks the required " + e + " key '" + o + "'.");
    r.push(n[o]);
  }

  return r;
}

function standardizeTensorValidationData(e) {
  if (3 === e.length) throw new NotImplementedError("Validation with sample weights is not implemented yet.");
  return {
    xs: e[0],
    ys: e[1]
  };
}

function fitDataset(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, i, a, o, s, l, u, c, p, h, d, f, g, m, y, v, b, w, z, S, A, _, I, C, E, N, k, x, L, T, D, O, R, M;

    return __generator(this, function (P) {
      switch (P.label) {
        case 0:
          if (r = null != n.batchesPerEpoch, _tfjsCore.util.assert(null != e.optimizer, function () {
            return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
          }), _tfjsCore.util.assert(null != n, function () {
            return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
          }), _tfjsCore.util.assert(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), function () {
            return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + n.epochs;
          }), _tfjsCore.util.assert(!r || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), function () {
            return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + n.batchesPerEpoch;
          }), _tfjsCore.util.assert(null == n.validationSplit, function () {
            return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
          }), e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          e.isTraining = !0, P.label = 1;

        case 1:
          return P.trys.push([1,, 26, 27]), i = null != n.validationData, a = void 0, o = void 0, i && (isDatasetObject(n.validationData) ? _tfjsCore.util.assert(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), function () {
            return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + n.validationBatches;
          }) : (s = standardizeTensorValidationData(n.validationData), a = s.xs, o = s.ys)), l = e.makeTrainFunction(), u = e.getDedupedMetricsNames(), c = void 0, c = i ? u.slice().concat(u.map(function (e) {
            return "val_" + e;
          })) : u.slice(), p = standardizeCallbacks(n.callbacks, n.yieldEvery), h = null == n.verbose ? 1 : n.verbose, d = configureCallbacks(p, h, n.epochs, null, null, getStepsPerEpoch(t, n), null, i, c), f = d.callbackList, g = d.history, f.setModel(e), e.history = g, [4, f.onTrainBegin()];

        case 2:
          return P.sent(), e.stopTraining_ = !1, m = null == n.initialEpoch ? 0 : n.initialEpoch, [4, t.iterator()];

        case 3:
          y = P.sent(), P.label = 4;

        case 4:
          return m < n.epochs ? (v = {}, [4, f.onEpochBegin(m)]) : [3, 23];

        case 5:
          return P.sent(), b = 0, w = 0, r ? [3, 7] : [4, t.iterator()];

        case 6:
          y = P.sent(), P.label = 7;

        case 7:
          return !r || b < n.batchesPerEpoch ? [4, y.next()] : [3, 21];

        case 8:
          return z = P.sent(), r && z.done ? (console.warn("You provided `batchesPerEpoch` as " + n.batchesPerEpoch + ", but your dataset iterator ran out of data after " + b + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset."), [3, 21]) : null == z.value ? [3, 15] : (S = standardizeDataIteratorOutput(e, z.value), A = S.xs, _ = S.ys, (I = {}).batch = w, I.size = A[0].shape[0], [4, f.onBatchBegin(w, I)]);

        case 9:
          if (P.sent(), C = [], null == n.classWeight) return [3, 13];
          E = standardizeClassWeights(n.classWeight, e.outputNames), M = 0, P.label = 10;

        case 10:
          return M < E.length ? (k = (N = C).push, [4, standardizeWeights(_[M], null, E[M])]) : [3, 13];

        case 11:
          k.apply(N, [P.sent()]), P.label = 12;

        case 12:
          return ++M, [3, 10];

        case 13:
          for (x = A.concat(_).concat(C), L = l(x), (0, _tfjsCore.dispose)(x), M = 0; M < u.length; ++M) T = u[M], D = L[M], I[T] = D, (0, _tfjsCore.keep)(D);

          return [4, f.onBatchEnd(w, I)];

        case 14:
          P.sent(), disposeTensorsInLogs(I), w++, b++, P.label = 15;

        case 15:
          return (r ? b >= n.batchesPerEpoch : z.done) ? i ? (O = void 0, isDatasetObject(n.validationData) ? (R = toList, [4, e.evaluateDataset(n.validationData, {
            batches: n.validationBatches
          })]) : [3, 17]) : [3, 19] : [3, 20];

        case 16:
          return O = R.apply(void 0, [P.sent()]), [3, 18];

        case 17:
          O = toList(e.evaluate(a, o, {
            batchSize: null == n.validationBatchSize ? DEFAULT_VALIDATION_BATCH_SIZE : n.validationBatchSize,
            verbose: 0
          })), P.label = 18;

        case 18:
          for (M = 0; M < e.metricsNames.length; ++M) v["val_" + e.metricsNames[M]] = O[M];

          P.label = 19;

        case 19:
          return [3, 21];

        case 20:
          return e.stopTraining_ ? [3, 21] : [3, 7];

        case 21:
          return [4, f.onEpochEnd(m, v)];

        case 22:
          return P.sent(), m++, e.stopTraining_ ? [3, 23] : [3, 4];

        case 23:
          return [4, f.onTrainEnd()];

        case 24:
          return P.sent(), [4, e.history.syncData()];

        case 25:
          return P.sent(), [2, e.history];

        case 26:
          return e.isTraining = !1, [7];

        case 27:
          return [2];
      }
    });
  });
}

function getStepsPerEpoch(e, t) {
  var n = null;
  return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n;
}

function isDatasetObject(e) {
  return "function" == typeof e.iterator;
}

function isLazyIteratorObject(e) {
  return "function" == typeof e.next;
}

function evaluateDataset(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, i, a, o, s, l, u, c, p, h;
    return __generator(this, function (d) {
      switch (d.label) {
        case 0:
          if (r = null != (n = n || {}).batches, i = e.testFunction, a = [], n.verbose > 0) throw new NotImplementedError("Verbose mode is not implemented yet.");
          return _tfjsCore.util.assert(!r || n.batches > 0 && Number.isInteger(n.batches), function () {
            return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(n.batches);
          }), isLazyIteratorObject(t) ? (s = t, [3, 3]) : [3, 1];

        case 1:
          return [4, t.iterator()];

        case 2:
          s = d.sent(), d.label = 3;

        case 3:
          o = s, l = 0, u = 0, c = function () {
            var t;
            return __generator(this, function (s) {
              switch (s.label) {
                case 0:
                  return [4, o.next()];

                case 1:
                  return t = s.sent(), a = (0, _tfjsCore.tidy)(function () {
                    if (t.value) {
                      var n = standardizeDataIteratorOutput(e, t.value),
                          r = n.xs,
                          o = n.ys,
                          s = r.concat(o),
                          c = (0, _tfjsCore.tidy)(function () {
                        return i(s);
                      });
                      if ((0, _tfjsCore.dispose)(s), 0 === u) for (var p = 0; p < c.length; ++p) a.push((0, _tfjsCore.scalar)(0));

                      var h = s[0].shape[0],
                          d = function (e) {
                        var t = c[e],
                            n = a[e];
                        a[e] = (0, _tfjsCore.tidy)(function () {
                          return (0, _tfjsCore.add)(a[e], (0, _tfjsCore.mul)(h, t));
                        }), u > 0 && (0, _tfjsCore.dispose)(n);
                      };

                      for (p = 0; p < c.length; ++p) d(p);

                      (0, _tfjsCore.dispose)(c), l += h, ++u;
                    }

                    return a;
                  }), t.done ? (r && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + n.batches + " batches). You may need to use the repeat() function when building your dataset."), [2, "break"]) : [2];
              }
            });
          }, d.label = 4;

        case 4:
          return !r || u < n.batches ? [5, c()] : [3, 6];

        case 5:
          return "break" === d.sent() ? [3, 6] : [3, 4];

        case 6:
          for (p = 0; p < a.length; ++p) h = a[p], a[p] = (0, _tfjsCore.div)(a[p], l), (0, _tfjsCore.dispose)(h);

          return [2, singletonOrArray(a)];
      }
    });
  });
}

function checkBatchSize(e) {
  _tfjsCore.util.assert(e > 0 && Number.isInteger(e), function () {
    return "batchSize is required to be a positive integer, but got " + e;
  });
}

function sliceArrays(e, t, n) {
  return null == e ? [null] : Array.isArray(e) ? e.map(function (e) {
    return sliceAlongFirstAxis(e, t, n - t);
  }) : sliceAlongFirstAxis(e, t, n - t);
}

function sliceArraysByIndices(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return null == e ? null : Array.isArray(e) ? e.map(function (e) {
      return sliceArraysByIndices(e, t);
    }) : gather$1(e, "int32" === t.dtype ? t : t.toInt());
  });
}

function makeBatches(e, t) {
  for (var n = [], r = 0, i = null; r < e;) (i = r + t) >= e && (i = e), n.push([r, i]), r = i;

  return n;
}

function fitLoop(e, t, n, r, i, a, o, s, l, u, c, p, h, d, f) {
  return __awaiter(this, void 0, void 0, function () {
    var g, m, y, v, b, w, z, S;
    return __generator(this, function (A) {
      switch (A.label) {
        case 0:
          if (null == i && (i = 32), null == a && (a = 1), null == c && (c = !0), null == h && (h = 0), g = !1, null != l && null != u && (g = !0), null != f && (g = !0, null == d)) throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
          return null != (m = e.checkNumSamples(n, i, d, "steps_per_epoch")) && (y = range(0, m)), null == o && (o = 1), v = configureCallbacks(s, o, a, h, m, d, i, g, p), b = v.callbackList, w = v.history, b.setModel(e), e.history = w, [4, b.onTrainBegin()];

        case 1:
          A.sent(), e.stopTraining_ = !1, z = function (a) {
            var o, s, p, h, f;
            return __generator(this, function (v) {
              switch (v.label) {
                case 0:
                  return [4, b.onEpochBegin(a)];

                case 1:
                  if (v.sent(), o = {}, null == d) return [3, 2];
                  throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");

                case 2:
                  if ("batch" === c) throw new NotImplementedError("batch shuffling is not implemneted yet");
                  c && _tfjsCore.util.shuffle(y), s = (0, _tfjsCore.tensor1d)(y), p = makeBatches(m, i), h = function (a) {
                    var c;
                    return __generator(this, function (h) {
                      switch (h.label) {
                        case 0:
                          return c = {}, [4, b.onBatchBegin(a, c)];

                        case 1:
                          return h.sent(), (0, _tfjsCore.tidy)(function () {
                            var h = p[a][0],
                                d = p[a][1],
                                f = sliceAlongFirstAxis(s, h, d - h);
                            c.batch = a, c.size = d - h;

                            for (var m = sliceArraysByIndices(n, f), y = t(m), v = 0; v < r.length; ++v) {
                              var b = r[v],
                                  w = y[v];
                              c[b] = w, (0, _tfjsCore.keep)(w);
                            }

                            if (a === p.length - 1 && g) {
                              var z = e.testLoop(l, u, i);

                              for (v = 0; v < r.length; ++v) {
                                b = r[v], w = z[v];
                                (0, _tfjsCore.keep)(w), o["val_" + b] = w;
                              }
                            }
                          }), [4, b.onBatchEnd(a, c)];

                        case 2:
                          return h.sent(), disposeTensorsInLogs(c), e.stopTraining_ ? [2, "break"] : [2];
                      }
                    });
                  }, f = 0, v.label = 3;

                case 3:
                  return f < p.length ? [5, h(f)] : [3, 6];

                case 4:
                  if ("break" === v.sent()) return [3, 6];
                  v.label = 5;

                case 5:
                  return ++f, [3, 3];

                case 6:
                  s.dispose(), v.label = 7;

                case 7:
                  return [4, b.onEpochEnd(a, o)];

                case 8:
                  return v.sent(), e.stopTraining_ ? [2, "break"] : [2];
              }
            });
          }, S = h, A.label = 2;

        case 2:
          return S < a ? [5, z(S)] : [3, 5];

        case 3:
          if ("break" === A.sent()) return [3, 5];
          A.label = 4;

        case 4:
          return ++S, [3, 2];

        case 5:
          return [4, b.onTrainEnd()];

        case 6:
          return A.sent(), [4, e.history.syncData()];

        case 7:
          return A.sent(), [2, e.history];
      }
    });
  });
}

function fitTensors(e, t, n, r) {
  return void 0 === r && (r = {}), __awaiter(this, void 0, void 0, function () {
    var i, a, o, s, l, u, c, p, h, d, f, g, m, y, v, b, w, z, S, A, _, I;

    return __generator(this, function (C) {
      switch (C.label) {
        case 0:
          if (e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          e.isTraining = !0, C.label = 1;

        case 1:
          return C.trys.push([1,, 7, 8]), checkBatchSize(p = null == r.batchSize ? 32 : r.batchSize), h = !1, [4, e.standardizeUserData(t, n, r.sampleWeight, r.classWeight, h, p)];

        case 2:
          if (d = C.sent(), i = d[0], a = d[1], c = d[2], f = !1, g = void 0, !(null != r.validationData && r.validationData.length > 0)) return [3, 4];
          if (f = !0, 2 !== r.validationData.length) throw 3 === r.validationData.length ? new NotImplementedError("validationData including sample weights is not supported yet.") : new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + r.validationData + " is invalid.");
          return o = r.validationData[0], s = r.validationData[1], m = !0, [4, e.standardizeUserData(o, s, null, null, m, p)];

        case 3:
          return y = C.sent(), l = y[0], u = y[1], g = l.concat(u), [3, 5];

        case 4:
          null != r.validationSplit && r.validationSplit > 0 && r.validationSplit < 1 ? (f = !0, v = Math.floor(i[0].shape[0] * (1 - r.validationSplit)), b = i[0].shape[0], l = sliceArrays(i, v, b), i = sliceArrays(i, 0, v), u = sliceArrays(a, v, b), a = sliceArrays(a, 0, v), g = l.concat(u)) : null != r.validationSteps && (f = !0), C.label = 5;

        case 5:
          return w = i.concat(a).concat(c), e.checkTrainableWeightsConsistency(), z = e.makeTrainFunction(), S = e.getDedupedMetricsNames(), A = void 0, _ = void 0, f ? (e.makeTestFunction(), A = e.testFunction, _ = S.slice().concat(S.map(function (e) {
            return "val_" + e;
          }))) : (A = null, g = [], _ = S.slice()), I = standardizeCallbacks(r.callbacks, r.yieldEvery), [4, fitLoop(e, z, w, S, p, r.epochs, r.verbose, I, A, g, r.shuffle, _, r.initialEpoch, null, null)];

        case 6:
          return [2, C.sent()];

        case 7:
          return e.isTraining = !1, disposeNewTensors(i, t), disposeNewTensors(a, n), disposeNewTensors(l, o), disposeNewTensors(u, s), null != c && (0, _tfjsCore.dispose)(c), [7];

        case 8:
          return [2];
      }
    });
  });
}

function ensureTensorsRank2OrHigher(e) {
  var t = [];
  e instanceof _tfjsCore.Tensor && (e = [e]);

  for (var n = 0; n < e.length; ++n) {
    var r = e[n];
    if (1 === r.rank) t.push(expandDims$1(r, 1));else {
      if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(r);
    }
  }

  return t;
}

function disposeNewTensors(e, t) {
  if (null != e) {
    var n = [];
    if (t instanceof _tfjsCore.Tensor) n.push(t.id);else if (Array.isArray(t)) t.forEach(function (e) {
      return n.push(e.id);
    });else if (null != t) for (var r in t) {
      var i = t[r];
      n.push(i.id);
    }
    var a = [];
    if (e instanceof _tfjsCore.Tensor) -1 === n.indexOf(e.id) && a.push(e);else if (Array.isArray(e)) e.forEach(function (e) {
      -1 === n.indexOf(e.id) && a.push(e);
    });else if (null != e) for (var o in e) {
      var s = e[o];
      -1 === n.indexOf(s.id) && a.push(s);
    }
    a.forEach(function (e) {
      e.isDisposed || e.dispose();
    });
  }
}

function isDataTensor(e) {
  return e instanceof _tfjsCore.Tensor;
}

function isDataArray(e) {
  return Array.isArray(e);
}

function isDataDict(e) {
  return !isDataTensor(e) && !isDataArray(e);
}

function standardizeInputData(e, t, n, r, i) {
  if (void 0 === r && (r = !0), void 0 === i && (i = ""), null == t || 0 === t.length) {
    if (null != e) {
      var a = !1;
      if (isDataArray(e) && e.length > 0) a = !0;else if (isDataDict(e)) {
        for (var o in e) if (e.hasOwnProperty(o)) {
          a = !0;
          break;
        }
      } else a = !0;
      if (a) throw new ValueError("Error when checking model " + i + " expected no data, but got " + e);
    }

    return [];
  }

  if (null == e) return t.map(function (e) {
    return null;
  });
  var s;

  if (isDataDict(e)) {
    e = e, s = [];

    for (var l = 0, u = t; l < u.length; l++) {
      var c = u[l];
      if (null == e[c]) throw new ValueError('No data provided for "' + c + '". Need data for each key in: ' + t);
      s.push(e[c]);
    }
  } else if (isDataArray(e)) {
    if ((e = e).length !== t.length) throw new ValueError("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + t.length + " Tensor(s), but instead got the following list of Tensor(s): " + e);
    s = e;
  } else {
    if (e = e, t.length > 1) throw new ValueError("The model " + i + " expects " + t.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + e.shape);
    s = [e];
  }

  if (s = ensureTensorsRank2OrHigher(s), null != n) for (var p = 0; p < t.length; ++p) if (null != n[p]) {
    var h = s[p];
    if (h.shape.length !== n[p].length) throw new ValueError("Error when checking " + i + ": expected " + t[p] + " to have " + n[p].length + " dimension(s). but got array with shape " + h.shape);

    for (var d = 0; d < n[p].length; ++d) if (0 !== d || r) {
      var f = h.shape[d],
          g = n[p][d];
      if (null != g && g >= 0 && f !== g) throw new ValueError("Error when checking " + i + ": expected " + t[p] + " to have shape [" + n[p] + "], but got array with shape [" + h.shape + "].");
    }
  }
  return s;
}

function checkArrayLengths(e, t, n) {
  var r = unique(e.map(function (e) {
    return e.shape[0];
  }));
  r.sort();
  var i = unique(t.map(function (e) {
    return e.shape[0];
  }));
  if (i.sort(), r.length > 1) throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(e.map(function (e) {
    return e.shape;
  })));
  if (i.length > 1) throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(t.map(function (e) {
    return e.shape;
  })));
  if (r.length > 0 && i.length > 0 && !_tfjsCore.util.arraysEqual(r, i)) throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found " + r[0] + " input sample(s) and " + i[0] + " target sample(s).");
}

function checkLossAndTargetCompatibility(e, t, n) {
  for (var r = [meanSquaredError, binaryCrossentropy, categoricalCrossentropy], i = 0; i < e.length; ++i) {
    var a = e[i],
        o = t[i],
        s = n[i];

    if (null != o) {
      if (o === categoricalCrossentropy && 1 === a.shape[a.shape.length - 1]) throw new ValueError("You are passing a target array of shape " + a.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
      if (-1 !== r.indexOf(o)) for (var l = a.shape.slice(1), u = s.slice(1), c = 0; c < l.length; ++c) {
        var p = l[c],
            h = u[c];
        if (null != h && p !== h) throw new ValueError("A target Tensor with shape " + a.shape + " was passed for an output of shape " + s + ", while using a loss function that expects targets to have the same shape as the output.");
      }
    }
  }
}

function checkInputData(e, t, n, r, i) {
  var a;

  if (void 0 === r && (r = !0), void 0 === i && (i = ""), Array.isArray(e)) {
    if (e.length !== t.length) throw new ValueError("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + t.length + " Tensor(s), but instead got " + e.length + " Tensors(s).");
    a = e;
  } else {
    if (t.length > 1) throw new ValueError("The model expects " + t.length + " " + i + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(e.shape) + ".");
    a = [e];
  }

  if (null != n) for (var o = 0; o < t.length; ++o) if (null != n[o]) {
    var s = a[o];
    if (s.shape.length !== n[o].length) throw new ValueError("Error when checking " + i + ": expected " + t[o] + " to have " + n[o].length + " dimension(s), but got array with shape " + JSON.stringify(s.shape));

    for (var l = 0; l < n[o].length; ++l) if (0 !== l || r) {
      var u = s.shape[l],
          c = n[o][l];
      if (null != c && c !== u) throw new ValueError("Error when checking " + i + ": expected " + t[o] + " to have shape " + JSON.stringify(n[o]) + " but got array with shape " + JSON.stringify(s.shape) + ".");
    }
  }
}

function collectMetrics(e, t) {
  if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
    return [];
  });
  var n;
  if ("string" == typeof e || "function" == typeof e) n = [e];else {
    if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + e);
    n = e;
  }
  if (Array.isArray(n)) return t.map(function (e) {
    return n;
  });

  for (var r = [], i = 0, a = t; i < a.length; i++) {
    var o = a[i],
        s = n.hasOwnProperty(o) ? n[o] : [];
    Array.isArray(s) || (s = [s]), r.push(s);
  }

  return r;
}

var LAYERS_MODEL_FORMAT_NAME = "layers-model",
    LayersModel = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.isTraining = !1, n;
  }

  return __extends(t, e), t.prototype.summary = function (e, t, n) {
    if (void 0 === n && (n = console.log), !this.built) throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    printSummary(this, e, t, n);
  }, t.prototype.compile = function (e) {
    var t = this;
    if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = getOptimizer(e.optimizer), this.isOptimizerOwned = !0;else {
      if (!(e.optimizer instanceof _tfjsCore.Optimizer)) throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1;
    }
    var n = [];
    if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss) {
      if (Array.isArray(e.loss)) {
        if (e.loss.length !== this.outputs.length) throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + e.loss + ".");
        var r = e.loss;
        n = r.map(function (e) {
          return get(e);
        });
      } else {
        var i = get(e.loss);
        this.outputs.forEach(function (e) {
          n.push(i);
        });
      }
    } else {
      for (var a in e.loss = e.loss, e.loss) if (-1 === this.outputNames.indexOf(a)) throw new ValueError('Unknown entry in loss dictionary: "' + a + '". Only expected the following keys: ' + this.outputNames);

      for (var o = 0, s = this.outputNames; o < s.length; o++) {
        var l = s[o];
        null == e.loss[l] && console.warn('Output "' + l + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + l + " during training"), n.push(get(e.loss[l]));
      }
    }
    this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];

    for (var u = 0; u < this.outputs.length; ++u) {
      var c = this.internalOutputShapes[u],
          p = this.outputNames[u];
      this.feedOutputNames.push(p), this.feedOutputShapes.push(c), this.feedLossFns.push(this.lossFunctions[u]);
    }

    var h = [];
    this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], nameScope("loss", function () {
      for (var e = 0; e < t.outputs.length; ++e) if (-1 === h.indexOf(e)) {
        var n = t.lossFunctions[e];
        t.outputs.length > 1 && (t.metricsTensors.push([n, e]), t.metricsNames.push(t.outputNames[e] + "_loss"));
      }
    });
    var d = collectMetrics(e.metrics, this.outputNames);
    nameScope("metric", function () {
      for (var e = function (e) {
        if (-1 !== h.indexOf(e)) return "continue";
        !function (n) {
          for (var r, i, a, o = function (n) {
            if ("string" == typeof n && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(n)) {
              var o = t.internalOutputShapes[e];
              1 === o[o.length - 1] || t.lossFunctions[e] === binaryCrossentropy ? -1 !== ["accuracy", "acc"].indexOf(n) ? i = binaryAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = binaryCrossentropy$1) : t.lossFunctions[e] === sparseCategoricalCrossentropy ? -1 !== ["accuracy", "acc"].indexOf(n) ? i = sparseCategoricalAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = sparseCategoricalCrossentropy$1) : -1 !== ["accuracy", "acc"].indexOf(n) ? i = categoricalAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = categoricalCrossentropy$1);
              var s = void 0;
              -1 !== ["accuracy", "acc"].indexOf(n) ? s = "acc" : -1 !== ["crossentropy", "ce"].indexOf(n) && (s = "ce"), a = i, r = "" + s;
            } else {
              var l = get$1(n);
              a = l, r = "" + getLossOrMetricName(n);
            }

            var u;
            nameScope(r, function () {
              u = a;
            }), function (e, n, r) {
              t.outputNames.length > 1 && (n = t.outputNames[e] + "_" + n), t.metricsNames.push(n), t.metricsTensors.push([r, e]);
            }(e, r, u);
          }, s = 0, l = n; s < l.length; s++) o(l[s]);
        }(d[e]);
      }, n = 0; n < t.outputs.length; ++n) e(n);
    }), this.collectedTrainableWeights = this.trainableWeights;
  }, t.prototype.checkTrainableWeightsConsistency = function () {
    null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }, t.prototype.evaluate = function (e, t, n) {
    void 0 === n && (n = {});
    var r = null == n.batchSize ? 32 : n.batchSize;
    checkBatchSize(r);
    var i = this.standardizeUserDataXY(e, t, !0, r);

    try {
      var a = i[0].concat(i[1]);
      this.makeTestFunction();
      var o = this.testFunction;
      return singletonOrArray(this.testLoop(o, a, r, n.verbose, n.steps));
    } finally {
      disposeNewTensors(i[0], e), disposeNewTensors(i[1], t);
    }
  }, t.prototype.evaluateDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        return this.makeTestFunction(), [2, evaluateDataset(this, e, t)];
      });
    });
  }, t.prototype.checkNumSamples = function (e, t, n, r) {
    var i;

    if (void 0 === r && (r = "steps"), null != n) {
      if (i = null, null != t) throw new ValueError("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + t);
    } else {
      if (null == e) throw new ValueError("Either the input data should have a defined shape, or " + r + " shoud be specified.");
      i = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
    }

    return i;
  }, t.prototype.execute = function (e, t) {
    if (Array.isArray(t) && 0 === t.length) throw new ValueError("`outputs` is an empty Array, which is not allowed.");
    var n = Array.isArray(t),
        r = n ? t : [t],
        i = this.retrieveSymbolicTensors(r),
        a = new FeedDict();

    if (e instanceof _tfjsCore.Tensor && (e = [e]), Array.isArray(e)) {
      if (e.length !== this.inputs.length) throw new ValueError("The number of inputs provided (" + e.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");

      for (var o = 0; o < this.inputs.length; ++o) a.add(this.inputs[o], e[o]);
    } else for (var s = 0, l = this.inputs; s < l.length; s++) {
      var u = l[s],
          c = e[u.name];
      if (null == c) throw new ValueError("No value is provided for the model's input " + u.name);
      a.add(u, c);
    }

    var p = execute(i, a);
    return n ? p : p[0];
  }, t.prototype.retrieveSymbolicTensors = function (e) {
    for (var t = pyListRepeat(null, e.length), n = e.length, r = 0, i = this.layers; r < i.length; r++) {
      for (var a = i[r], o = Array.isArray(a.output) ? a.output : [a.output], s = o.map(function (e) {
        return e.name;
      }), l = 0; l < e.length; ++l) {
        var u = s.indexOf(e[l]);
        if (-1 !== u && (t[l] = o[u], n--), 0 === n) break;
      }

      if (0 === n) break;
    }

    if (n > 0) {
      var c = [];
      throw t.forEach(function (t, n) {
        null == t && c.push(e[n]);
      }), new ValueError("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c));
    }

    return t;
  }, t.prototype.predictLoop = function (e, t, n) {
    var r = this;
    return void 0 === t && (t = 32), void 0 === n && (n = !1), (0, _tfjsCore.tidy)(function () {
      var i = r.checkNumSamples(e);
      if (n) throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");

      for (var a = makeBatches(i, t), o = r.outputs.map(function (e) {
        return [];
      }), s = function (t) {
        (0, _tfjsCore.tidy)(function () {
          var n = a[t][0],
              i = a[t][1],
              o = sliceArrays(e, n, i),
              s = [];
          if (Array.isArray(o)) for (var l = 0; l < o.length; ++l) s.push({
            key: r.inputs[l],
            value: o[l]
          });else s.push({
            key: r.inputs[0],
            value: o
          });
          var u = new FeedDict(s);
          return execute(r.outputs, u);
        }).forEach(function (e, t) {
          return o[t].push(e);
        });
      }, l = 0; l < a.length; ++l) s(l);

      return singletonOrArray(o.map(function (e) {
        return (0, _tfjsCore.concat)(e, 0);
      }));
    });
  }, t.prototype.predict = function (e, t) {
    void 0 === t && (t = {});
    var n = ensureTensorsRank2OrHigher(e);
    checkInputData(n, this.inputNames, this.feedInputShapes, !1);

    try {
      var r = null == t.batchSize ? 32 : t.batchSize;
      return checkBatchSize(r), this.predictLoop(n, r);
    } finally {
      disposeNewTensors(n, e);
    }
  }, t.prototype.predictOnBatch = function (e) {
    checkInputData(e, this.inputNames, this.feedInputShapes, !0);
    var t = (Array.isArray(e) ? e[0] : e).shape[0];
    return this.predictLoop(e, t);
  }, t.prototype.standardizeUserDataXY = function (e, t, n, r) {
    if (void 0 === n && (n = !0), null == this.optimizer_) throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");

    for (var i = [], a = 0; a < this.feedOutputShapes.length; ++a) {
      var o = this.feedOutputShapes[a];
      this.feedLossFns[a] === sparseCategoricalCrossentropy ? i.push(o.slice(0, o.length - 1).concat([1])) : i.push(o);
    }

    if (checkArrayLengths(e = standardizeInputData(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = standardizeInputData(t, this.feedOutputNames, i, !1, "target"), null), checkLossAndTargetCompatibility(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r && r > 0 && e[0].shape[0] % r != 0) throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r + ". Found: " + e[0].shape[0] + " sample(s).");
    return [e, t];
  }, t.prototype.standardizeUserData = function (e, t, n, r, i, a) {
    return void 0 === i && (i = !0), __awaiter(this, void 0, void 0, function () {
      var o, s, l, u, c, p, h, d;
      return __generator(this, function (f) {
        switch (f.label) {
          case 0:
            if (o = this.standardizeUserDataXY(e, t, i, a), s = o[0], l = o[1], null != n) throw new Error("sample weight is not supported yet.");
            if (u = null, null == r) return [3, 4];
            c = standardizeClassWeights(r, this.outputNames), u = [], p = 0, f.label = 1;

          case 1:
            return p < c.length ? (d = (h = u).push, [4, standardizeWeights(l[p], null, c[p])]) : [3, 4];

          case 2:
            d.apply(h, [f.sent()]), f.label = 3;

          case 3:
            return ++p, [3, 1];

          case 4:
            return [2, [s, l, u]];
        }
      });
    });
  }, t.prototype.testLoop = function (e, t, n, r, i) {
    var a = this;
    return void 0 === r && (r = 0), (0, _tfjsCore.tidy)(function () {
      var o = a.checkNumSamples(t, n, i, "steps"),
          s = [];
      if (r > 0) throw new NotImplementedError("Verbose mode is not implemented yet.");
      if (null != i) throw new NotImplementedError("steps mode in testLoop() is not implemented yet");

      for (var l = makeBatches(o, n), u = (0, _tfjsCore.tensor1d)(range(0, o)), c = 0; c < l.length; ++c) {
        var p = l[c][0],
            h = l[c][1],
            d = sliceAlongFirstAxis(u, p, h - p),
            f = sliceArraysByIndices(t, d),
            g = e(f);
        if (0 === c) for (var m = 0; m < g.length; ++m) s.push((0, _tfjsCore.scalar)(0));

        for (m = 0; m < g.length; ++m) {
          var y = g[m];
          s[m] = (0, _tfjsCore.add)(s[m], (0, _tfjsCore.mul)(h - p, y));
        }
      }

      for (m = 0; m < s.length; ++m) s[m] = (0, _tfjsCore.div)(s[m], o);

      return s;
    });
  }, t.prototype.getDedupedMetricsNames = function () {
    for (var e = this.metricsNames, t = [], n = 0; n < e.length; ++n) {
      var r = e[n],
          i = r;
      if (count(e, r) > 1) i += "_" + count(e.slice(0, n), r);
      t.push(i);
    }

    return t;
  }, t.prototype.makeTrainFunction = function () {
    var e = this;
    return function (t) {
      var n = [],
          r = t.slice(0, e.inputs.length),
          i = t.slice(e.inputs.length, e.inputs.length + e.outputs.length),
          a = t.slice(e.inputs.length + e.outputs.length, e.inputs.length + 2 * e.outputs.length),
          o = [],
          s = e.collectedTrainableWeights.map(function (e) {
        return e.read();
      });
      return [e.optimizer_.minimize(function () {
        for (var t = [], s = 0; s < e.inputs.length; ++s) t.push({
          key: e.inputs[s],
          value: r[s]
        });

        var l,
            u = new FeedDict(t),
            c = execute(e.outputs, u, {
          training: !0
        });

        for (s = 0; s < e.lossFunctions.length; ++s) {
          var p = (0, e.lossFunctions[s])(i[s], c[s]);
          null != a[s] && (p = computeWeightedLoss(p, a[s]));
          var h = (0, _tfjsCore.mean)(p);
          n.push(h), l = 0 === s ? p : (0, _tfjsCore.add)(l, p);
        }

        for (s = 0; s < e.metricsTensors.length; ++s) {
          var d = void 0;
          if (e.outputs.length > 1 && s < e.outputs.length) d = n[s];else {
            var f = e.metricsTensors[s][0],
                g = e.metricsTensors[s][1];
            d = (0, _tfjsCore.mean)(f(i[g], c[g]));
          }
          (0, _tfjsCore.keep)(d), o.push(d);
        }

        return l = (0, _tfjsCore.mean)(l), e.calculateLosses().forEach(function (e) {
          l = (0, _tfjsCore.add)(l, e);
        }), l;
      }, !0, s)].concat(o);
    };
  }, t.prototype.makeTestFunction = function () {
    var e = this;

    this.testFunction = function (t) {
      return (0, _tfjsCore.tidy)(function () {
        for (var n, r = [], i = t.slice(0, e.inputs.length), a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length), o = [], s = 0; s < e.inputs.length; ++s) o.push({
          key: e.inputs[s],
          value: i[s]
        });

        var l = new FeedDict(o),
            u = execute(e.outputs, l);

        for (s = 0; s < e.lossFunctions.length; ++s) {
          var c = e.lossFunctions[s],
              p = (0, _tfjsCore.mean)(c(a[s], u[s]));
          n = 0 === s ? p : (0, _tfjsCore.add)(n, p), r.push(n);
        }

        for (s = 0; s < e.metricsTensors.length; ++s) {
          var h = e.metricsTensors[s][0],
              d = e.metricsTensors[s][1],
              f = (0, _tfjsCore.mean)(h(a[d], u[d]));
          r.push(f);
        }

        return r;
      });
    };
  }, t.prototype.fit = function (e, t, n) {
    return void 0 === n && (n = {}), __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (r) {
        return [2, fitTensors(this, e, t, n)];
      });
    });
  }, t.prototype.fitDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        return [2, fitDataset(this, e, t)];
      });
    });
  }, t.prototype.trainOnBatch = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r, i, a, o, s, l, u, c;
      return __generator(this, function (p) {
        switch (p.label) {
          case 0:
            return [4, this.standardizeUserData(e, t)];

          case 1:
            n = p.sent(), r = n[0], i = n[1], a = this.makeTrainFunction(), o = a(r.concat(i)), s = [], l = 0, u = o, p.label = 2;

          case 2:
            return l < u.length ? [4, u[l].data()] : [3, 5];

          case 3:
            c = p.sent(), s.push(c[0]), p.label = 4;

          case 4:
            return l++, [3, 2];

          case 5:
            return (0, _tfjsCore.dispose)(o), [2, singletonOrArray(s)];
        }
      });
    });
  }, t.prototype.getNamedWeights = function (e) {
    for (var t = [], n = null != e && e.trainableOnly, r = n ? this.trainableWeights : this.weights, i = this.getWeights(n), a = 0; a < r.length; ++a) n && !r[a].trainable || t.push({
      name: r[a].originalName,
      tensor: i[a]
    });

    return t;
  }, Object.defineProperty(t.prototype, "stopTraining", {
    get: function () {
      return this.stopTraining_;
    },
    set: function (e) {
      this.stopTraining_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "optimizer", {
    get: function () {
      return this.optimizer_;
    },
    set: function (e) {
      this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.dispose = function () {
    var t = e.prototype.dispose.call(this);

    if (0 === t.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
      var n = (0, _tfjsCore.memory)().numTensors;
      this.optimizer_.dispose(), t.numDisposedVariables += n - (0, _tfjsCore.memory)().numTensors;
    }

    return t;
  }, t.prototype.getLossIdentifiers = function () {
    var e;
    if ("string" == typeof this.loss) e = toSnakeCase(this.loss);else if (Array.isArray(this.loss)) {
      for (var t = 0, n = this.loss; t < n.length; t++) {
        if ("string" != typeof n[t]) throw new Error("Serialization of non-string loss is not supported.");
      }

      e = this.loss.map(function (e) {
        return toSnakeCase(e);
      });
    } else {
      var r = Object.keys(this.loss);
      e = {};

      for (var i = this.loss, a = 0, o = r; a < o.length; a++) {
        var s = o[a];
        if ("string" != typeof i[s]) throw new Error("Serialization of non-string loss is not supported.");
        e[s] = toSnakeCase(i[s]);
      }
    }
    return e;
  }, t.prototype.getMetricIdentifiers = function () {
    if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [toSnakeCase(getLossOrMetricName(this.metrics))];
    if (Array.isArray(this.metrics)) return this.metrics.map(function (e) {
      return toSnakeCase(getLossOrMetricName(e));
    });
    var e = {};

    for (var t in this.metrics) e[t] = toSnakeCase(getLossOrMetricName(this.metrics[t]));

    return e;
  }, t.prototype.getTrainingConfig = function () {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }, t.prototype.loadTrainingConfig = function (e) {
    if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
    if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
    if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
    var t,
        n,
        r = deserialize(convertPythonicToTs(e.optimizer_config));
    if ("string" == typeof e.loss) t = toCamelCase(e.loss);else if (Array.isArray(e.loss)) t = e.loss.map(function (e) {
      return toCamelCase(e);
    });else if (null != e.loss) for (var i in t = {}, e.loss) t[i] = toCamelCase(e.loss[i]);
    if (Array.isArray(e.metrics)) n = e.metrics.map(function (e) {
      return toCamelCase(e);
    });else if (null != e.metrics) for (var i in n = {}, e.metrics) n[i] = toCamelCase(e.metrics[i]);
    this.compile({
      loss: t,
      metrics: n,
      optimizer: r
    });
  }, t.prototype.save = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r, i, a, o, s, l, u, c, p, h, d, f, g;
      return __generator(this, function (m) {
        switch (m.label) {
          case 0:
            if ("string" == typeof e) {
              if (0 === (n = _tfjsCore.io.getSaveHandlers(e)).length) throw new ValueError("Cannot find any save handlers for URL '" + e + "'");
              if (n.length > 1) throw new ValueError("Found more than one (" + n.length + ") save handlers for URL '" + e + "'");
              e = n[0];
            }

            if (null == e.save) throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
            return [4, _tfjsCore.io.encodeWeights(this.getNamedWeights(t))];

          case 1:
            return r = m.sent(), i = !1, a = null, o = this.toJSON(a, i), s = {
              modelTopology: o,
              format: LAYERS_MODEL_FORMAT_NAME,
              generatedBy: "TensorFlow.js tfjs-layers v" + version,
              convertedBy: null
            }, null != t && t.includeOptimizer && null != this.optimizer ? (s.trainingConfig = this.getTrainingConfig(), l = "optimizer", d = (h = _tfjsCore.io).encodeWeights, [4, this.optimizer.getWeights()]) : [3, 4];

          case 2:
            return [4, d.apply(h, [m.sent(), l])];

          case 3:
            u = m.sent(), c = u.data, p = u.specs, (g = r.specs).push.apply(g, p), r.data = _tfjsCore.io.concatenateArrayBuffers([r.data, c]), m.label = 4;

          case 4:
            return null != this.userDefinedMetadata && (f = !0, checkUserDefinedMetadata(this.userDefinedMetadata, this.name, f), s.userDefinedMetadata = this.userDefinedMetadata), s.weightData = r.data, s.weightSpecs = r.specs, [2, e.save(s)];
        }
      });
    });
  }, t.prototype.setUserDefinedMetadata = function (e) {
    checkUserDefinedMetadata(e, this.name), this.userDefinedMetadata = e;
  }, t.prototype.getUserDefinedMetadata = function () {
    return this.userDefinedMetadata;
  }, t.className = "Model", t;
}(Container);

exports.LayersModel = LayersModel;

function modelFromJSON(e, t) {
  return __awaiter(this, void 0, void 0, function () {
    var n, r, i, a, o, s, l, u;
    return __generator(this, function (c) {
      switch (c.label) {
        case 0:
          return "modelTopology" in e || (e = {
            modelTopology: e
          }), null != (n = (e = e).modelTopology).model_config && (n = n.model_config), r = convertPythonicToTs(n), i = deserialize(r, t), null == e.weightsManifest ? [3, 2] : [4, _tfjsCore.io.loadWeights(e.weightsManifest, e.pathPrefix, i.weights.map(function (e) {
            return e.originalName;
          }))];

        case 1:
          for (a = c.sent(), o = {}, s = 0, l = i.weights; s < l.length; s++) u = l[s], o[u.originalName] = a[u.originalName];

          i.loadWeights(o), (0, _tfjsCore.dispose)(a), c.label = 2;

        case 2:
          return [2, i];
      }
    });
  });
}

function loadLayersModelInternal(e, t) {
  return __awaiter(this, void 0, void 0, function () {
    var n;
    return __generator(this, function (r) {
      if (null == t && (t = {}), "string" == typeof e) {
        if (0 === (n = _tfjsCore.io.getLoadHandlers(e, t.onProgress)).length) n.push(_tfjsCore.io.browserHTTPRequest(e, t));else if (n.length > 1) throw new ValueError("Found more than one (" + n.length + ") load handlers for URL '" + e + "'");
        e = n[0];
      }

      return [2, loadLayersModelFromIOHandler(e, void 0, t)];
    });
  });
}

function loadLayersModelFromIOHandler(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, i, a, o, s, l, u, c, p;
    return __generator(this, function (h) {
      switch (h.label) {
        case 0:
          if (null == n && (n = {}), null == e.load) throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
          return [4, e.load()];

        case 1:
          if (r = h.sent(), null != (i = r.modelTopology).model_config && (i = i.model_config), a = null == n.strict || n.strict, o = null != r.weightData && null != r.weightSpecs && a, s = deserialize(convertPythonicToTs(i), t, o), null != (l = r.trainingConfig) && s.loadTrainingConfig(l), null != r.userDefinedMetadata && s.setUserDefinedMetadata(r.userDefinedMetadata), null == r.weightData) return [3, 4];
          if (null == r.weightSpecs) throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
          return u = decodeModelAndOptimizerWeights(r.weightData, r.weightSpecs), c = u.modelWeights, p = u.optimizerWeights, s.loadWeights(c, a), null != s.optimizer && p.length > 0 ? [4, s.optimizer.setWeights(p)] : [3, 3];

        case 2:
          h.sent(), h.label = 3;

        case 3:
          (0, _tfjsCore.dispose)(c), (0, _tfjsCore.dispose)(p.map(function (e) {
            return e.tensor;
          })), h.label = 4;

        case 4:
          return [2, s];
      }
    });
  });
}

function decodeModelAndOptimizerWeights(e, t) {
  var n = _tfjsCore.io.decodeWeights(e, t),
      r = {},
      i = [];

  return t.forEach(function (e) {
    "optimizer" === e.group ? i.push({
      name: e.name,
      tensor: n[e.name]
    }) : r[e.name] = n[e.name];
  }), {
    modelWeights: r,
    optimizerWeights: i
  };
}

_tfjsCore.serialization.registerClass(LayersModel);

var Sequential = function (e) {
  function t(t) {
    var n = e.call(this, {
      inputs: [],
      outputs: []
    }) || this;
    if (t = t || {}, n.trainable = !0, n.built = !1, n.name = null != t.name ? t.name : getUid("sequential_"), null != t.layers) for (var r = 0, i = t.layers; r < i.length; r++) {
      var a = i[r];
      n.add(a);
    }
    return n;
  }

  return __extends(t, e), t.prototype.checkShape = function (e) {
    if (e.inboundNodes[0].outputTensors[0].shape.some(function (e) {
      return e < 0;
    })) throw new ValueError("Negative dimension size caused by adding layer " + e.name + " with input shape [" + e.inboundNodes[0].inputTensors[0].shape + "]");
  }, t.prototype.add = function (e) {
    var n,
        r = e instanceof t || e instanceof LayersModel;

    if (r) {
      if (1 !== (n = e).outputs.length) throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (1 !== n.inputs.length) throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }

    if (0 === this.outputs.length) {
      if (0 === e.inboundNodes.length) {
        if (null == e.batchInputShape) throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        var i = Input({
          batchShape: e.batchInputShape,
          dtype: e.dtype,
          name: e.name + "_input"
        });
        e.apply(i);
      }

      if (r) this.outputs = n.outputs, this.inputs = n.inputs;else {
        if (1 !== e.inboundNodes.length) throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + e.name + " which has " + e.inboundNodes.length + " pre-existing inbound connections.");
        if (1 !== e.inboundNodes[0].outputTensors.length) throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = getSourceInputs(this.outputs[0]);
      }
      this.inboundNodes = [], new Node({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: pyListRepeat(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map(function (e) {
          return e.shape;
        }),
        outputShapes: this.outputs[0].shape
      });
    } else {
      var a = e.apply(this.outputs[0]);
      if (Array.isArray(a)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(e), this.outputs = [a], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }

    this.layers.push(e), this.built = !1;
  }, t.prototype.pop = function () {
    if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];else {
      var e = this.layers.length - 1;
      this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }, t.prototype.call = function (e, t) {
    return null == this.model && this.build(), this.model.call(e, t);
  }, t.prototype.build = function (e) {
    if (getExactlyOneShape(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new LayersModel({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
  }, t.prototype.countParams = function () {
    return this.built || this.build(), e.prototype.countParams.call(this);
  }, t.prototype.summary = function (t, n, r) {
    void 0 === r && (r = console.log), this.built || this.build(), e.prototype.summary.call(this, t, n, r);
  }, t.prototype.setWeights = function (e) {
    null == this.model && this.build(), this.model.setWeights(e);
  }, t.prototype.evaluate = function (e, t, n) {
    if (void 0 === n && (n = {}), !this.built) throw new RuntimeError("The model needs to be compiled before being used.");
    return this.model.evaluate(e, t, n);
  }, t.prototype.evaluateDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return [2, this.model.evaluateDataset(e, t)];
      });
    });
  }, t.prototype.predict = function (e, t) {
    return void 0 === t && (t = {}), null == this.model && this.build(), this.model.predict(e, t);
  }, t.prototype.predictOnBatch = function (e) {
    return null == this.model && this.build(), this.model.predictOnBatch(e);
  }, t.prototype.compile = function (e) {
    this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }, Object.defineProperty(t.prototype, "optimizer", {
    get: function () {
      return null == this.model ? void 0 : this.model.optimizer;
    },
    set: function (e) {
      this.model.optimizer = e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.fit = function (e, t, n) {
    return void 0 === n && (n = {}), __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (r) {
        if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return [2, this.model.fit(e, t, n)];
      });
    });
  }, t.prototype.fitDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return [2, this.model.fitDataset(e, t)];
      });
    });
  }, t.prototype.trainOnBatch = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        return [2, this.model.trainOnBatch(e, t)];
      });
    });
  }, t.fromConfig = function (e, n, r, i) {
    var a;
    void 0 === r && (r = {}), void 0 === i && (i = !1);
    var o = {};

    if (n instanceof Array) {
      if (null == n[0].className || "Merge" === n[0].className) throw new ValueError("Legacy serialization format not supported yet.");
      a = n;
    } else _tfjsCore.util.assert(null != n.layers, function () {
      return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
    }), a = n.layers, delete n.layers, o = n;

    var s = new e(o);
    if (!(s instanceof t)) throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: " + s);

    for (var l = 0, u = a; l < u.length; l++) {
      var c = deserialize(u[l], void 0, i);
      i && c.setFastWeightInitDuringBuild(!0), s.add(c);
    }

    return s;
  }, Object.defineProperty(t.prototype, "stopTraining", {
    get: function () {
      if (null == this.model) throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    },
    set: function (e) {
      if (null == this.model) throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    for (var e = [], t = 0, n = this.layers; t < n.length; t++) {
      var r = n[t],
          i = {};
      i.className = r.getClassName(), i.config = r.getConfig(), e.push(i);
    }

    return {
      name: this.name,
      layers: e
    };
  }, t.className = "Sequential", t;
}(LayersModel);

exports.Sequential = Sequential;

function model(e) {
  return new LayersModel(e);
}

function sequential(e) {
  return new Sequential(e);
}

function loadLayersModel(e, t) {
  return null == t && (t = {}), loadLayersModelInternal(e, t);
}

function input(e) {
  return Input(e);
}

function registerCallbackConstructor(e, t) {
  CallbackConstructorRegistry.registerCallbackConstructor(e, t);
}

_tfjsCore.serialization.registerClass(Sequential);

var Activation = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    return {};
  }, t;
}(_tfjsCore.serialization.Serializable),
    Elu = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return void 0 === t && (t = 1), elu$1(e, t);
  }, t.className = "elu", t;
}(Activation);

_tfjsCore.serialization.registerClass(Elu);

var Selu = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.selu)(e);
  }, t.className = "selu", t;
}(Activation);

_tfjsCore.serialization.registerClass(Selu);

var Relu = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.relu)(e);
  }, t.className = "relu", t;
}(Activation);

_tfjsCore.serialization.registerClass(Relu);

var Relu6 = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      return (0, _tfjsCore.minimum)(6, (0, _tfjsCore.relu)(e));
    });
  }, t.className = "relu6", t;
}(Activation);

_tfjsCore.serialization.registerClass(Relu6);

var Linear = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return e;
  }, t.className = "linear", t;
}(Activation);

_tfjsCore.serialization.registerClass(Linear);

var Sigmoid = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.sigmoid)(e);
  }, t.className = "sigmoid", t;
}(Activation);

_tfjsCore.serialization.registerClass(Sigmoid);

var HardSigmoid = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return hardSigmoid(e);
  }, t.className = "hardSigmoid", t;
}(Activation);

_tfjsCore.serialization.registerClass(HardSigmoid);

var Softplus = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.softplus)(e);
  }, t.className = "softplus", t;
}(Activation);

_tfjsCore.serialization.registerClass(Softplus);

var Softsign = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return softsign(e);
  }, t.className = "softsign", t;
}(Activation);

_tfjsCore.serialization.registerClass(Softsign);

var Tanh = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.tanh)(e);
  }, t.className = "tanh", t;
}(Activation);

_tfjsCore.serialization.registerClass(Tanh);

var Softmax = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return void 0 === t && (t = -1), (0, _tfjsCore.softmax)(e, t);
  }, t.className = "softmax", t;
}(Activation);

_tfjsCore.serialization.registerClass(Softmax);

var LogSoftmax = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return void 0 === t && (t = -1), (0, _tfjsCore.logSoftmax)(e, t);
  }, t.className = "logSoftmax", t;
}(Activation);

function serializeActivation(e) {
  return e.getClassName();
}

function deserializeActivation(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "activation");
}

function getActivation(e) {
  var t;
  return null == e ? deserializeActivation(t = {
    className: "linear",
    config: {}
  }) : "string" == typeof e ? ((t = {}).className = e, t.config = {}, deserializeActivation(t)) : e instanceof Activation ? e : deserializeActivation(e);
}

function assertObjectArgs(e) {
  if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + e);
}

_tfjsCore.serialization.registerClass(LogSoftmax);

var Regularizer = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t;
}(_tfjsCore.serialization.Serializable),
    L1L2 = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return assertObjectArgs(t), n.l1 = null == t || null == t.l1 ? .01 : t.l1, n.l2 = null == t || null == t.l2 ? .01 : t.l2, n.hasL1 = 0 !== n.l1, n.hasL2 = 0 !== n.l2, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = (0, _tfjsCore.zeros)([1]);
      return t.hasL1 && (n = (0, _tfjsCore.add)(n, (0, _tfjsCore.sum)((0, _tfjsCore.mul)(t.l1, (0, _tfjsCore.abs)(e))))), t.hasL2 && (n = (0, _tfjsCore.add)(n, (0, _tfjsCore.sum)((0, _tfjsCore.mul)(t.l2, square(e))))), n.asScalar();
    });
  }, t.prototype.getConfig = function () {
    return {
      l1: this.l1,
      l2: this.l2
    };
  }, t.fromConfig = function (e, t) {
    return new e({
      l1: t.l1,
      l2: t.l2
    });
  }, t.className = "L1L2", t;
}(Regularizer);

function l1(e) {
  return assertObjectArgs(e), new L1L2({
    l1: null != e ? e.l1 : null,
    l2: 0
  });
}

function l2(e) {
  return assertObjectArgs(e), new L1L2({
    l2: null != e ? e.l2 : null,
    l1: 0
  });
}

_tfjsCore.serialization.registerClass(L1L2);

var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  l1l2: "L1L2"
};

function serializeRegularizer(e) {
  return serializeKerasObject(e);
}

function deserializeRegularizer(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "regularizer");
}

function getRegularizer(e) {
  return null == e ? null : "string" == typeof e ? deserializeRegularizer({
    className: e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e,
    config: {}
  }) : e instanceof Regularizer ? e : deserializeRegularizer(e);
}

var ReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.supportsMasking = !0, null != t && (n.maxValue = t.maxValue), n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    e = getExactlyOneTensor(e);
    var n = (0, _tfjsCore.relu)(e);
    return null != this.maxValue && (n = (0, _tfjsCore.clipByValue)(n, 0, this.maxValue)), n;
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      maxValue: this.maxValue
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(ReLU);

var LeakyReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.DEFAULT_ALPHA = .3, null == t && (t = {}), n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return (0, _tfjsCore.leakyRelu)(n, this.alpha);
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      alpha: this.alpha
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "LeakyReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(LeakyReLU);

var PReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    if (n.DEFAULT_ALPHA_INITIALIZER = "zeros", null == t && (t = {}), n.supportsMasking = !0, n.alphaInitializer = getInitializer(t.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER), n.alphaRegularizer = getRegularizer(t.alphaRegularizer), n.alphaConstraint = getConstraint(t.alphaConstraint), null == t.sharedAxes) n.sharedAxes = null;else if (Array.isArray(t.sharedAxes)) n.sharedAxes = t.sharedAxes;else {
      if ("number" != typeof t.sharedAxes) throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got " + t.sharedAxes);
      n.sharedAxes = [t.sharedAxes];
    }
    return n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t = (e = getExactlyOneShape(e)).slice(1);
    if (null != this.sharedAxes) for (var n = 0, r = this.sharedAxes; n < r.length; n++) {
      t[(a = r[n]) - 1] = 1;
    }
    this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
    var i = {};
    if (null != this.sharedAxes) for (var a = 1; a < e.length; ++a) i[a] = e[a];
    this.inputSpec = [new InputSpec({
      ndim: e.length,
      axes: i
    })], this.built = !0;
  }, t.prototype.call = function (e, t) {
    return e = getExactlyOneTensor(e), (0, _tfjsCore.prelu)(e, this.alpha.read());
  }, t.prototype.getConfig = function () {
    var t = {
      alphaInitializer: serializeInitializer(this.alphaInitializer),
      alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
      alphaConstraint: serializeConstraint(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "PReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(PReLU);

var ELU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    if (n.DEFAULT_ALPHA = 1, null == t && (t = {}), null != t.alpha && t.alpha !== n.DEFAULT_ALPHA) throw new NotImplementedError("Non-default alpha value (" + t.alpha + ") is not supported by the ELU layer yet.");
    return n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return (0, _tfjsCore.elu)(n);
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      alpha: this.alpha
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ELU", t;
}(Layer);

_tfjsCore.serialization.registerClass(ELU);

var ThresholdedReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.DEFAULT_THETA = 1, null == t && (t = {}), n.theta = null == t.theta ? n.DEFAULT_THETA : t.theta, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return n.mul(cast$1(n.greater(this.theta), "float32"));
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      theta: this.theta
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ThresholdedReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(ThresholdedReLU);

var Softmax$1 = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.DEFAULT_AXIS = 1, null == t && (t = {}), n.softmax = new Softmax().apply, n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return this.softmax(n, this.axis);
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Softmax", t;
}(Layer);

function normalizeArray(e, t, n) {
  if ("number" == typeof e) return pyListRepeat(e, t);
  if (e.length !== t) throw new ValueError("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + e.length + " elements.");

  for (var r = 0; r < t; ++r) {
    var i = e[r];
    if (!isInteger(i)) throw new ValueError("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + JSON.stringify(e) + " including a non-integer number " + i);
  }

  return e;
}

function convOutputLength(e, t, n, r, i) {
  return void 0 === i && (i = 1), null == e ? e : (a = "same" === n ? e : e - (t + (t - 1) * (i - 1)) + 1, Math.floor((a + r - 1) / r));
  var a;
}

function deconvLength(e, t, n, r) {
  if (null == e) return null;
  if ("valid" === r) e = e * t + max$1([n - t, 0]);else {
    if ("same" !== r) throw new ValueError("Unsupport padding mode: " + r + ".");
    e *= t;
  }
  return e;
}

function preprocessConv2DInput(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return checkDataFormat(t), "channelsFirst" === t ? (0, _tfjsCore.transpose)(e, [0, 2, 3, 1]) : e;
  });
}

function preprocessConv3DInput(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return checkDataFormat(t), "channelsFirst" === t ? (0, _tfjsCore.transpose)(e, [0, 2, 3, 4, 1]) : e;
  });
}

function conv1dWithBias(e, t, n, r, i, a, o) {
  return void 0 === r && (r = 1), void 0 === i && (i = "valid"), void 0 === o && (o = 1), (0, _tfjsCore.tidy)(function () {
    if (null == a && (a = imageDataFormat()), checkDataFormat(a), 3 !== e.shape.length) throw new ValueError("The input of a conv1dWithBias operation should be 3, but is " + e.shape.length + " instead.");
    if (3 !== t.shape.length) throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is " + t.shape.length + " instead");
    if (null != n && 1 !== n.shape.length) throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is " + t.shape.length + " instead");
    if ("channelsFirst" === a && (e = (0, _tfjsCore.transpose)(e, [0, 2, 1])), "causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    var s = (0, _tfjsCore.conv1d)(e, t, r, "same" === i ? "same" : "valid", "NWC", o);
    return null != n && (s = biasAdd(s, n)), s;
  });
}

function conv2dWithBiasActivation(e, t, n, r, i, a, o, s) {
  return void 0 === r && (r = [1, 1]), void 0 === i && (i = "valid"), void 0 === s && (s = null), (0, _tfjsCore.tidy)(function () {
    if (null == a && (a = imageDataFormat()), checkDataFormat(a), 3 !== e.rank && 4 !== e.rank) throw new ValueError("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + e.rank + ".");
    if (3 !== t.rank && 4 !== t.rank) throw new ValueError("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + e.rank + ".");
    var l = preprocessConv2DInput(e, a);
    if ("causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return l = _tfjsCore.fused.conv2d({
      x: l,
      filter: t,
      strides: r,
      pad: "same" === i ? "same" : "valid",
      dilations: o,
      dataFormat: "NHWC",
      bias: n,
      activation: s
    }), "channelsFirst" === a && (l = (0, _tfjsCore.transpose)(l, [0, 3, 1, 2])), l;
  });
}

function conv3dWithBias(e, t, n, r, i, a, o) {
  return void 0 === r && (r = [1, 1, 1]), void 0 === i && (i = "valid"), (0, _tfjsCore.tidy)(function () {
    if (null == a && (a = imageDataFormat()), checkDataFormat(a), 4 !== e.rank && 5 !== e.rank) throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received " + e.rank + ".");
    if (4 !== t.rank && 5 !== t.rank) throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + e.rank + ".");
    var s = preprocessConv3DInput(e, a);
    if ("causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
    return s = (0, _tfjsCore.conv3d)(s, t, r, "same" === i ? "same" : "valid", "NDHWC", o), null != n && (s = biasAdd(s, n)), "channelsFirst" === a && (s = (0, _tfjsCore.transpose)(s, [0, 4, 1, 2, 3])), s;
  });
}

_tfjsCore.serialization.registerClass(Softmax$1);

var BaseConv = function (e) {
  function t(n, r) {
    var i = e.call(this, r) || this;
    if (i.bias = null, i.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", i.DEFAULT_BIAS_INITIALIZER = "zeros", t.verifyArgs(r), i.rank = n, assertPositiveInteger(i.rank, "rank"), 1 !== i.rank && 2 !== i.rank && 3 !== i.rank) throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 (" + i.rank + ") is not implemented yet.");
    if (i.kernelSize = normalizeArray(r.kernelSize, n, "kernelSize"), i.strides = normalizeArray(null == r.strides ? 1 : r.strides, n, "strides"), i.padding = null == r.padding ? "valid" : r.padding, checkPaddingMode(i.padding), i.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, checkDataFormat(i.dataFormat), i.activation = getActivation(r.activation), i.useBias = null == r.useBias || r.useBias, i.biasInitializer = getInitializer(r.biasInitializer || i.DEFAULT_BIAS_INITIALIZER), i.biasConstraint = getConstraint(r.biasConstraint), i.biasRegularizer = getRegularizer(r.biasRegularizer), i.activityRegularizer = getRegularizer(r.activityRegularizer), i.dilationRate = normalizeArray(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate"), 1 === i.rank && Array.isArray(i.dilationRate) && 1 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(i.dilationRate));

    if (2 === i.rank) {
      if ("number" == typeof i.dilationRate) i.dilationRate = [i.dilationRate, i.dilationRate];else if (2 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(i.dilationRate));
    } else if (3 === i.rank) if ("number" == typeof i.dilationRate) i.dilationRate = [i.dilationRate, i.dilationRate, i.dilationRate];else if (3 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(i.dilationRate));

    return i;
  }

  return __extends(t, e), t.verifyArgs = function (e) {
    if (assert("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 3)) throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.prototype.getConfig = function () {
    var t = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      biasInitializer: serializeInitializer(this.biasInitializer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      biasConstraint: serializeConstraint(this.biasConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    Conv = function (e) {
  function t(n, r) {
    var i = e.call(this, n, r) || this;
    return i.kernel = null, t.verifyArgs(r), i.filters = r.filters, assertPositiveInteger(i.filters, "filters"), i.kernelInitializer = getInitializer(r.kernelInitializer || i.DEFAULT_KERNEL_INITIALIZER), i.kernelConstraint = getConstraint(r.kernelConstraint), i.kernelRegularizer = getRegularizer(r.kernelRegularizer), i;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    e = getExactlyOneShape(e);
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n]) throw new ValueError("The channel dimension of the input should be defined. Found " + e[n]);
    var r = e[n],
        i = this.kernelSize.concat([r, this.filters]);
    this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
      ndim: this.rank + 2,
      axes: (t = {}, t[n] = r, t)
    }], this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t;
      e = getExactlyOneTensor(e);
      var r = null == n.bias ? null : n.bias.read(),
          i = mapActivationToFusedKernel(n.activation.getClassName());
      if (null != i && 2 === n.rank) t = conv2dWithBiasActivation(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, i);else {
        if (1 === n.rank) t = conv1dWithBias(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);else if (2 === n.rank) t = conv2dWithBiasActivation(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);else {
          if (3 !== n.rank) throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
          t = conv3dWithBias(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
        }
        null != n.activation && (t = n.activation.apply(t));
      }
      return t;
    });
  }, t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);

    for (var t = [], n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2), r = 0; r < n.length; ++r) {
      var i = convOutputLength(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
      t.push(i);
    }

    var a = [e[0]];
    return "channelsLast" === this.dataFormat ? (a = a.concat(t)).push(this.filters) : (a.push(this.filters), a = a.concat(t)), a;
  }, t.prototype.getConfig = function () {
    var t = {
      filters: this.filters,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.verifyArgs = function (e) {
    if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(e.filters));
  }, t;
}(BaseConv),
    Conv2D = function (e) {
  function t(n) {
    var r = e.call(this, 2, n) || this;
    return t.verifyArgs(n), r;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, t;
  }, t.verifyArgs = function (e) {
    if ("number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 2)) throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.className = "Conv2D", t;
}(Conv);

_tfjsCore.serialization.registerClass(Conv2D);

var Conv3D = function (e) {
  function t(n) {
    var r = e.call(this, 3, n) || this;
    return t.verifyArgs(n), r;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, t;
  }, t.verifyArgs = function (e) {
    if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.className = "Conv3D", t;
}(Conv);

_tfjsCore.serialization.registerClass(Conv3D);

var Conv2DTranspose = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    if (n.inputSpec = [new InputSpec({
      ndim: 4
    })], "same" !== n.padding && "valid" !== n.padding) throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n.padding);
    return n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    if (4 !== (e = getExactlyOneShape(e)).length) throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(e));
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n]) throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
    var r = e[n],
        i = this.kernelSize.concat([this.filters, r]);
    this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new InputSpec({
      ndim: 4,
      axes: (t = {}, t[n] = r, t)
    })], this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      if (4 !== t.shape.length) throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + t.shape.length);
      var r,
          i,
          a = t.shape,
          o = a[0];
      "channelsFirst" === n.dataFormat ? (r = 2, i = 3) : (r = 1, i = 2);
      var s = a[r],
          l = a[i],
          u = n.kernelSize[0],
          c = n.kernelSize[1],
          p = n.strides[0],
          h = n.strides[1],
          d = [o, deconvLength(s, p, u, n.padding), deconvLength(l, h, c, n.padding), n.filters];
      "channelsLast" !== n.dataFormat && (t = (0, _tfjsCore.transpose)(t, [0, 2, 3, 1]));
      var f = (0, _tfjsCore.conv2dTranspose)(t, n.kernel.read(), d, n.strides, n.padding);
      return "channelsLast" !== n.dataFormat && (f = (0, _tfjsCore.transpose)(f, [0, 3, 1, 2])), null != n.bias && (f = biasAdd(f, n.bias.read(), n.dataFormat)), null != n.activation && (f = n.activation.apply(f)), f;
    });
  }, t.prototype.computeOutputShape = function (e) {
    var t,
        n,
        r,
        i = (e = getExactlyOneShape(e)).slice();
    "channelsFirst" === this.dataFormat ? (t = 1, n = 2, r = 3) : (t = 3, n = 1, r = 2);
    var a = this.kernelSize[0],
        o = this.kernelSize[1],
        s = this.strides[0],
        l = this.strides[1];
    return i[t] = this.filters, i[n] = deconvLength(i[n], s, a, this.padding), i[r] = deconvLength(i[r], l, o, this.padding), i;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.dilationRate, t;
  }, t.className = "Conv2DTranspose", t;
}(Conv2D);

_tfjsCore.serialization.registerClass(Conv2DTranspose);

var SeparableConv = function (e) {
  function t(t, n) {
    var r = e.call(this, t, n) || this;
    if (r.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r.depthwiseKernel = null, r.pointwiseKernel = null, null == n.filters) throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint) throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (null != n.padding && "same" !== n.padding && "valid" !== n.padding) throw new ValueError("SeparableConv" + r.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n.padding));
    return r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier, r.depthwiseInitializer = getInitializer(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER), r.depthwiseRegularizer = getRegularizer(n.depthwiseRegularizer), r.depthwiseConstraint = getConstraint(n.depthwiseConstraint), r.pointwiseInitializer = getInitializer(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER), r.pointwiseRegularizer = getRegularizer(n.pointwiseRegularizer), r.pointwiseConstraint = getConstraint(n.pointwiseConstraint), r;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    if ((e = getExactlyOneShape(e)).length < this.rank + 2) throw new ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(e));
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n] || e[n] < 0) throw new ValueError("The channel dimension of the inputs should be defined, but found " + JSON.stringify(e[n]));

    for (var r = e[n], i = this.kernelSize.concat([r, this.depthMultiplier]), a = [], o = 0; o < this.rank; ++o) a.push(1);

    a.push(r * this.depthMultiplier, this.filters);
    this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, !0, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.inputSpec = [new InputSpec({
      ndim: this.rank + 2,
      axes: (t = {}, t[n] = r, t)
    })], this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t;
      if (e = getExactlyOneTensor(e), 1 === n.rank) throw new NotImplementedError("1D separable convolution is not implemented yet.");
      return 2 === n.rank && ("channelsFirst" === n.dataFormat && (e = (0, _tfjsCore.transpose)(e, [0, 2, 3, 1])), t = (0, _tfjsCore.separableConv2d)(e, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (t = biasAdd(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), "channelsFirst" === n.dataFormat && (t = (0, _tfjsCore.transpose)(t, [0, 3, 1, 2])), t;
    });
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t.pointwiseInitializer = serializeInitializer(this.pointwiseInitializer), t.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t.pointwiseRegularizer = serializeRegularizer(this.pointwiseRegularizer), t.depthwiseConstraint = serializeConstraint(this.depthwiseConstraint), t.pointwiseConstraint = serializeConstraint(this.pointwiseConstraint), t;
  }, t.className = "SeparableConv", t;
}(Conv),
    SeparableConv2D = function (e) {
  function t(t) {
    return e.call(this, 2, t) || this;
  }

  return __extends(t, e), t.className = "SeparableConv2D", t;
}(SeparableConv);

_tfjsCore.serialization.registerClass(SeparableConv2D);

var Conv1D = function (e) {
  function t(n) {
    var r = e.call(this, 1, n) || this;
    return t.verifyArgs(n), r.inputSpec = [{
      ndim: 3
    }], r;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, delete t.dataFormat, t;
  }, t.verifyArgs = function (e) {
    if ("number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 1)) throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.className = "Conv1D", t;
}(Conv);

_tfjsCore.serialization.registerClass(Conv1D);

var Cropping2D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return "number" == typeof t.cropping ? n.cropping = [[t.cropping, t.cropping], [t.cropping, t.cropping]] : "number" == typeof t.cropping[0] ? n.cropping = [[t.cropping[0], t.cropping[0]], [t.cropping[1], t.cropping[1]]] : n.cropping = t.cropping, n.dataFormat = void 0 === t.dataFormat ? "channelsLast" : t.dataFormat, n.inputSpec = [{
      ndim: 4
    }], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return e = getExactlyOneTensor(e), "channelsLast" === n.dataFormat ? sliceAlongAxis(sliceAlongAxis(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2), n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3) : sliceAlongAxis(sliceAlongAxis(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3), n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      cropping: this.cropping,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Cropping2D", t;
}(Layer);

_tfjsCore.serialization.registerClass(Cropping2D);

var UpSampling2D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_SIZE = [2, 2], n.inputSpec = [{
      ndim: 4
    }], n.size = null == t.size ? n.DEFAULT_SIZE : t.size, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    if ("channelsFirst" === this.dataFormat) {
      var t = null == e[2] ? null : this.size[0] * e[2],
          n = null == e[3] ? null : this.size[1] * e[3];
      return [e[0], e[1], t, n];
    }

    t = null == e[1] ? null : this.size[0] * e[1], n = null == e[2] ? null : this.size[1] * e[2];
    return [e[0], t, n, e[3]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e),
          r = t.shape;

      if ("channelsFirst" === n.dataFormat) {
        t = (0, _tfjsCore.transpose)(t, [0, 2, 3, 1]);
        var i = n.size[0] * r[2],
            a = n.size[1] * r[3],
            o = t.resizeNearestNeighbor([i, a]);
        return (0, _tfjsCore.transpose)(o, [0, 3, 1, 2]);
      }

      i = n.size[0] * r[1], a = n.size[1] * r[2];
      return t.resizeNearestNeighbor([i, a]);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      size: this.size,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "UpSampling2D", t;
}(Layer);

function depthwiseConv2d$1(e, t, n, r, i, a) {
  return void 0 === n && (n = [1, 1]), void 0 === r && (r = "valid"), (0, _tfjsCore.tidy)(function () {
    null == i && (i = imageDataFormat()), checkDataFormat(i);
    var o = preprocessConv2DInput(e, i);
    if (4 !== e.rank) throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " + e.rank + "-D");
    if (4 !== t.rank) throw new ValueError("depthwiseKernel is required to be 4-D, but is instead " + t.rank + "-D");
    return o = (0, _tfjsCore.depthwiseConv2d)(o, t, n, "same" === r ? "same" : "valid", "NHWC", a), "channelsFirst" === i && (o = (0, _tfjsCore.transpose)(o, [0, 3, 1, 2])), o;
  });
}

_tfjsCore.serialization.registerClass(UpSampling2D);

var DepthwiseConv2D = function (e) {
  function t(t) {
    var n = e.call(this, 2, t) || this;
    return n.depthwiseKernel = null, n.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, n.depthwiseInitializer = getInitializer(t.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.depthwiseConstraint = getConstraint(t.depthwiseConstraint), n.depthwiseRegularizer = getRegularizer(t.depthwiseRegularizer), n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    if ((e = getExactlyOneShape(e)).length < 4) throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(e) + ".");
    var t = "channelsFirst" === this.dataFormat ? 1 : 3;
    if (null == e[t] || e[t] < 0) throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + e[t] + ").");
    var n = e[t],
        r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = depthwiseConv2d$1(e = getExactlyOneTensor(e), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
      return n.useBias && (t = biasAdd(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), t;
    });
  }, t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        r = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
        i = convOutputLength(t, this.kernelSize[0], this.padding, this.strides[0]),
        a = convOutputLength(n, this.kernelSize[1], this.padding, this.strides[1]);
    return "channelsFirst" === this.dataFormat ? [e[0], r, i, a] : [e[0], i, a, r];
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t.depthwiseConstraint = serializeConstraint(this.depthwiseRegularizer), t;
  }, t.className = "DepthwiseConv2D", t;
}(BaseConv);

_tfjsCore.serialization.registerClass(DepthwiseConv2D);

var Dropout = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.rate = Math.max(Math.min(t.rate, 1), 0), n.noiseShape = t.noiseShape, n.seed = t.seed, n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.getNoiseShape = function (e) {
    if (null == this.noiseShape) return this.noiseShape;

    for (var t = e.shape, n = [], r = 0; r < this.noiseShape.length; ++r) n.push(null == this.noiseShape[r] ? t[r] : this.noiseShape[r]);

    return n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);

      if (0 < n.rate && n.rate < 1) {
        var i = null != t.training && t.training,
            a = n.getNoiseShape(r);
        return inTrainPhase(function () {
          return dropout$1(r, n.rate, a, n.seed);
        }, function () {
          return r;
        }, i);
      }

      return e;
    });
  }, t.prototype.getConfig = function () {
    var t = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.prototype.dispose = function () {
    return e.prototype.dispose.call(this);
  }, t.className = "Dropout", t;
}(Layer);

_tfjsCore.serialization.registerClass(Dropout);

var SpatialDropout1D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.inputSpec = [{
      ndim: 3
    }], n;
  }

  return __extends(t, e), t.prototype.getNoiseShape = function (e) {
    var t = e.shape;
    return [t[0], 1, t[2]];
  }, t.className = "SpatialDropout1D", t;
}(Dropout);

_tfjsCore.serialization.registerClass(SpatialDropout1D);

var Dense = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;

    if (n.activation = null, n.useBias = !0, n.kernel = null, n.bias = null, n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_BIAS_INITIALIZER = "zeros", null == t.batchInputShape && null == t.inputShape && null != t.inputDim) {
      var r = null;
      null != t.batchSize && (r = t.batchSize), n.batchInputShape = [r, t.inputDim];
    }

    return n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(t.activation), null != t.useBias && (n.useBias = t.useBias), n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelConstraint = getConstraint(t.kernelConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.activityRegularizer = getRegularizer(t.activityRegularizer), n.supportsMasking = !0, n.inputSpec = [{
      minNDim: 2
    }], n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t,
        n = (e = getExactlyOneShape(e))[e.length - 1];
    null == this.kernel && (this.kernel = this.addWeight("kernel", [n, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
      minNDim: 2,
      axes: (t = {}, t[-1] = n, t)
    }], this.built = !0;
  }, t.prototype.computeOutputShape = function (e) {
    var t = (e = getExactlyOneShape(e)).slice();
    return t[t.length - 1] = this.units, t;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r,
          i = getExactlyOneTensor(e),
          a = mapActivationToFusedKernel(n.activation.getClassName());
      return null != a ? r = dot(i, n.kernel.read(), a, n.bias ? n.bias.read() : null) : (r = dot(i, n.kernel.read()), null != n.bias && (r = biasAdd(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r;
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Dense", t;
}(Layer);

_tfjsCore.serialization.registerClass(Dense);

var Flatten = function (e) {
  function t(t) {
    var n = this;
    return t = t || {}, (n = e.call(this, t) || this).inputSpec = [{
      minNDim: 3
    }], n.dataFormat = t.dataFormat, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    for (var t = 0, n = (e = getExactlyOneShape(e)).slice(1); t < n.length; t++) {
      if (null == n[t]) throw new ValueError('The shape of the input to "Flatten" is not fully defined (got ' + e.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
    }

    return [e[0], arrayProd(e, 1)];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);

      if ("channelsFirst" === n.dataFormat && r.rank > 1) {
        for (var i = [0], a = 2; a < r.rank; ++a) i.push(a);

        i.push(1), r = r.transpose(i);
      }

      return batchFlatten(r);
    });
  }, t.prototype.getConfig = function () {
    var t = {};
    null != this.dataFormat && (t.dataFormat = this.dataFormat);
    var n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Flatten", t;
}(Layer);

_tfjsCore.serialization.registerClass(Flatten);

var Activation$1 = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.activation = getActivation(t.activation), n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);
      return n.activation.apply(r);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      activation: serializeActivation(this.activation)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Activation", t;
}(Layer);

_tfjsCore.serialization.registerClass(Activation$1);

var RepeatVector = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.n = t.n, n.inputSpec = [{
      ndim: 2
    }], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return [e[0], this.n, e[1]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return repeat(e = getExactlyOneTensor(e), n.n);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      n: this.n
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "RepeatVector", t;
}(Layer);

_tfjsCore.serialization.registerClass(RepeatVector);

var Reshape = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    n.targetShape = t.targetShape;

    for (var r = 0; r < n.targetShape.length; ++r) n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);

    return n;
  }

  return __extends(t, e), t.prototype.isUnknown = function (e) {
    return e < 0 || null == e;
  }, t.prototype.fixUnknownDimension = function (e, t) {
    for (var n = "Total size of new array must be unchanged.", r = t.slice(), i = 1, a = null, o = 0; o < r.length; ++o) {
      var s = r[o];

      if (this.isUnknown(s)) {
        if (null !== a) throw new ValueError("Can only specifiy one unknown dimension.");
        a = o;
      } else i *= s;
    }

    var l = arrayProd(e);

    if (null !== a) {
      if (0 === i || l % i != 0) throw new ValueError(n);
      r[a] = l / i;
    } else if (l !== i) throw new ValueError(n);

    return r;
  }, t.prototype.computeOutputShape = function (e) {
    for (var t = !1, n = 0; n < e.length; ++n) if (this.isUnknown(e[n])) {
      t = !0;
      break;
    }

    return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e),
          i = r.shape,
          a = i.slice(0, 1).concat(n.fixUnknownDimension(i.slice(1), n.targetShape));
      return r.reshape(a);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      targetShape: this.targetShape
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Reshape", t;
}(Layer);

_tfjsCore.serialization.registerClass(Reshape);

var Permute = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    if (null == t.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(t.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + t.dims + " instead.");
    var r = range(1, t.dims.length + 1);
    if (!_tfjsCore.util.arraysEqual(t.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
    return n.dims = t.dims, n.dimsIncludingBatch = [0].concat(n.dims), n.inputSpec = [new InputSpec({
      ndim: n.dims.length + 1
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    var t = (e = getExactlyOneShape(e)).slice();
    return this.dims.forEach(function (n, r) {
      t[r + 1] = e[n];
    }), t;
  }, t.prototype.call = function (e, t) {
    return (0, _tfjsCore.transpose)(getExactlyOneTensor(e), this.dimsIncludingBatch);
  }, t.prototype.getConfig = function () {
    var t = {
      dims: this.dims
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Permute", t;
}(Layer);

_tfjsCore.serialization.registerClass(Permute);

var Masking = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.supportsMasking = !0, n.maskValue = null != t ? null == t.maskValue ? 0 : t.maskValue : 0, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      maskValue: this.maskValue
    };
    return Object.assign(n, t), n;
  }, t.prototype.computeMask = function (e, t) {
    var n = getExactlyOneTensor(e);
    return (0, _tfjsCore.any)((0, _tfjsCore.notEqual)(n, this.maskValue), -1);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e),
          i = (0, _tfjsCore.any)((0, _tfjsCore.notEqual)(r, n.maskValue), -1, !0);
      return r.mul(i.asType(r.dtype));
    });
  }, t.className = "Masking", t;
}(Layer);

_tfjsCore.serialization.registerClass(Masking);

var Embedding = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;

    if (n.embeddings = null, n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == t.batchInputShape && null == t.inputShape) {
      var r = null;
      null != t.batchSize && (r = t.batchSize), null == t.inputLength ? n.batchInputShape = [r, null] : n.batchInputShape = [r].concat(toList(t.inputLength));
    }

    return n.inputDim = t.inputDim, assertPositiveInteger(n.inputDim, "inputDim"), n.outputDim = t.outputDim, assertPositiveInteger(n.outputDim, "outputDim"), n.embeddingsInitializer = getInitializer(t.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER), n.embeddingsRegularizer = getRegularizer(t.embeddingsRegularizer), n.activityRegularizer = getRegularizer(t.activityRegularizer), n.embeddingsConstraint = getConstraint(t.embeddingsConstraint), n.maskZero = t.maskZero, n.supportsMasking = t.maskZero, n.inputLength = t.inputLength, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
  }, t.prototype.warnOnIncompatibleInputShape = function (e) {}, t.prototype.computeMask = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return n.maskZero ? (e = getExactlyOneTensor(e), (0, _tfjsCore.notEqual)(e, (0, _tfjsCore.zerosLike)(e))) : null;
    });
  }, t.prototype.computeOutputShape = function (e) {
    if (e = getExactlyOneShape(e), null == this.inputLength) return e.concat([this.outputDim]);
    var t = toList(this.inputLength);
    if (t.length !== e.length - 1) throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);

    for (var n = 0, r = 0; r < t.length; ++r) {
      var i = t[r],
          a = e[r + 1];
      if (null != i && null != a && i !== a) throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
      null == i && (t[n] = a), n++;
    }

    return [e[0]].concat(t, [this.outputDim]);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);
      return "int32" !== r.dtype && (r = cast$1(r, "int32")), gather$1(n.embeddings.read(), r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)));
    });
  }, t.prototype.getConfig = function () {
    var t = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
      embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Embedding", t;
}(Layer);

_tfjsCore.serialization.registerClass(Embedding);

var Merge = function (e) {
  function t(t) {
    var n = e.call(this, t || {}) || this;
    return n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    throw new NotImplementedError();
  }, t.prototype.computeElementwiseOpOutputShape = function (e, t) {
    if (null == e || null == t) return null;
    if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
    if (0 === t.length) return e;

    for (var n = e.slice(0, e.length - t.length), r = 0; r < t.length; ++r) {
      var i = e[e.length - t.length + r],
          a = t[r];
      if (null == i || null == a || i < 0 || a < 0) n.push(null);else if (1 === i) n.push(a);else if (1 === a) n.push(i);else {
        if (i !== a) throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
        n.push(i);
      }
    }

    return n;
  }, t.prototype.build = function (e) {
    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [getExactlyOneShape(e)]), (e = e).length < 2) throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got " + e.length + " input(s).");

    for (var t = [], n = 0, r = e; n < r.length; n++) {
      null != (o = r[n]) && null !== o[0] && t.push(o[0]);
    }

    if ((t = unique(t)).length > 1) throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(e) + ".");

    for (var i = null == e[0] ? null : e[0].slice(1), a = 1; a < e.length; ++a) {
      var o = null == e[a] ? null : e[a].slice(1);
      i = this.computeElementwiseOpOutputShape(i, o);
    }

    var s = e.map(function (e) {
      return e.length;
    });
    -1 === e.indexOf(null) && 1 === unique(s).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (e = e, n.reshapeRequired) {
        var t = [],
            r = e.map(function (e) {
          return e.rank;
        });

        if (-1 === r.indexOf(null)) {
          for (var i = max$1(r), a = 0, o = e; a < o.length; a++) {
            for (var s = (h = o[a]).rank, l = 0; l < i - s; ++l) h = expandDims$1(h, 1);

            t.push(h);
          }

          return n.mergeFunction(t);
        }

        for (var u = !1, c = 0, p = e; c < p.length; c++) {
          var h;

          if (null == (s = (h = p[c]).rank)) {
            var d = h.shape,
                f = d[0],
                g = d.slice(1).concat([f]),
                m = h.reshape([f].concat(arrayProd(d.slice(1))));
            m = (m = (0, _tfjsCore.transpose)(m, [1, 0])).reshape(g), t.push(m), u = !0;
          } else if (s > 1) {
            var y = range(1, s).concat([0]);
            t.push((0, _tfjsCore.transpose)(h, y)), u = !0;
          } else t.push(h);
        }

        var v = n.mergeFunction(t),
            b = v.rank;
        if (u) if (null == b) {
          var w = v.shape;
          g = [f = w[w.length - 1]].concat(w.slice(0, w.length - 1));
          v = (0, _tfjsCore.transpose)(v.reshape([-1, f]), [1, 0]).reshape(g);
        } else if (b > 1) {
          y = [b - 1].concat(range(0, b - 1));
          v = (0, _tfjsCore.transpose)(v, y);
        }
        return v;
      }

      return n.mergeFunction(e);
    });
  }, t.prototype.computeOutputShape = function (e) {
    var t;
    t = null == (e = e)[0] ? null : e[0].slice(1);

    for (var n = 1; n < e.length; ++n) {
      var r = null == e[n] ? null : e[n].slice(1);
      t = this.computeElementwiseOpOutputShape(t, r);
    }

    for (var i = [], a = 0, o = e; a < o.length; a++) {
      null != (r = o[a]) && null !== r[0] && i.push(r[0]);
    }

    return t = 1 === (i = unique(i)).length ? i.concat(t) : [null].concat(t);
  }, t.prototype.computeMask = function (e, t) {
    return (0, _tfjsCore.tidy)(function () {
      if (null == t) return null;
      if (!Array.isArray(t)) throw new ValueError("`mask` should be an Array");
      if (!Array.isArray(e)) throw new ValueError("`inputs` should be an Array");
      if (t.length !== e.length) throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + e.length + " vs " + t.length + ")");
      if (t.every(function (e) {
        return null == e;
      })) return null;

      for (var n = (t = t.map(function (e) {
        return null == e ? e : (0, _tfjsCore.expandDims)(e, 0);
      }))[0], r = 1; r < t.length - 1; ++r) n = (0, _tfjsCore.logicalAnd)(n, t[r]);

      return n;
    });
  }, t;
}(Layer),
    Add = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = (0, _tfjsCore.add)(t, e[n]);

      return t;
    });
  }, t.className = "Add", t;
}(Merge);

_tfjsCore.serialization.registerClass(Add);

var Multiply = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = (0, _tfjsCore.mul)(t, e[n]);

      return t;
    });
  }, t.className = "Multiply", t;
}(Merge);

_tfjsCore.serialization.registerClass(Multiply);

var Average = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = (0, _tfjsCore.add)(t, e[n]);

      return (0, _tfjsCore.mul)(1 / e.length, t);
    });
  }, t.className = "Average", t;
}(Merge);

_tfjsCore.serialization.registerClass(Average);

var Maximum = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0], n = 1; n < e.length; ++n) t = (0, _tfjsCore.maximum)(t, e[n]);

      return t;
    });
  }, t.className = "Maximum", t;
}(Merge);

_tfjsCore.serialization.registerClass(Maximum);

var Minimum = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0], n = 1; n < e.length; ++n) t = (0, _tfjsCore.minimum)(t, e[n]);

      return t;
    });
  }, t.className = "Minimum", t;
}(Merge);

_tfjsCore.serialization.registerClass(Minimum);

var Concatenate = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_AXIS = -1, null == t && (t = {}), n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n.supportsMasking = !0, n.reshapeRequired = !1, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");

    for (var t = !0, n = 0, r = e = e; n < r.length; n++) {
      if (null != (c = r[n])) {
        t = !1;
        break;
      }
    }

    if (!t) {
      for (var i = [], a = 0; a < e.length; ++a) {
        var o = e[a].slice();
        o.splice(this.axis, 1);

        for (var s = !1, l = 0, u = i; l < u.length; l++) {
          var c = u[l];

          if (_tfjsCore.util.arraysEqual(c, o)) {
            s = !0;
            break;
          }
        }

        s || i.push(o);
      }

      if (i.length > 1) throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
    }
  }, t.prototype.mergeFunction = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      return concatenate(e, t.axis);
    });
  }, t.prototype.computeOutputShape = function (e) {
    if (!Array.isArray(e) || !Array.isArray(e[0])) throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");

    for (var t = e, n = t[0].slice(), r = this.axis < 0 ? n.length + this.axis : this.axis, i = 0, a = t.slice(1); i < a.length; i++) {
      var o = a[i];

      if (null == n[r] || null == o[r]) {
        n[r] = null;
        break;
      }

      n[r] += o[r];
    }

    return n;
  }, t.prototype.computeMask = function (e, t) {
    var n = this;
    if (null == t) return null;
    if (!Array.isArray(t)) throw new ValueError("`mask` should be an array for Concatenate");
    if (!Array.isArray(e)) throw new ValueError("`inputs` should be an array for Concatenate");
    if (t.length !== e.length) throw new ValueError("Mismatch in the length of mask (" + t.length + ") and the legnth of inputs (" + e.length + ")");
    return (0, _tfjsCore.tidy)(function () {
      var r = !0;
      if (t.forEach(function (e) {
        null == e || (r = !1);
      }), r) return null;

      for (var i = [], a = 0; a < e.length; ++a) null == t[a] ? i.push((0, _tfjsCore.onesLike)(e[a]).asType("bool")) : t[a].rank < e[a].rank ? i.push((0, _tfjsCore.expandDims)(t[a], -1)) : i.push(t[a]);

      var o = (0, _tfjsCore.concat)(i, n.axis);
      return (0, _tfjsCore.all)(o, -1, !1);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Concatenate", t;
}(Merge);

function interpretAxis(e, t) {
  for (; e < 0;) e += t;

  return e;
}

function batchDot(e, t, n) {
  if (e.shape.length > 3 || t.shape.length > 3) throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
  if (_tfjsCore.util.assert(e.shape.length >= 2, function () {
    return "batchDot requires the rank of x to be >= 2, but got " + e.shape.length;
  }), _tfjsCore.util.assert(e.shape.length >= 2, function () {
    return "batchDot requires the rank of y to be >= 2, but got " + t.shape.length;
  }), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
  var r = e.shape.length,
      i = t.shape.length;
  null == n && (n = [r - 1, i - 2]);
  var a = n;
  return (0, _tfjsCore.tidy)(function () {
    var n, o;

    if (r > i) {
      n = r - i;

      for (var s = [], l = 0; l < n; ++l) s.push(1);

      t = t.reshape(t.shape.concat(s));
    } else if (i > r) {
      n = i - r;

      for (s = [], l = 0; l < n; ++l) s.push(1);

      e = e.reshape(e.shape.concat(s));
    } else n = 0;

    if (2 === e.shape.length && 2 === t.shape.length) o = a[0] === a[1] ? e.mulStrict(t).sum(a[0]) : e.transpose([1, 0]).mulStrict(t).sum(a[1]);else {
      var u = a[0] !== e.shape.length - 1,
          c = a[1] === t.shape.length - 1;
      o = e.matMul(t, u, c);
    }

    if (n > 0) {
      var p = void 0,
          h = [];

      for (l = p = r > i ? r + i - 3 : r - 1; l < p + n; ++l) h.push(l);

      o = o.squeeze(h);
    }

    return 1 === o.shape.length && (o = o.expandDims(1)), o;
  });
}

_tfjsCore.serialization.registerClass(Concatenate);

var Dot = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.axes = t.axes, n.normalize = null != t.normalize && t.normalize, n.supportsMasking = !0, n.reshapeRequired = !1, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    _tfjsCore.util.assert(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
      return "A `Dot` layer should be called on a list of exactly 2 inputs.";
    });

    var t = e[0],
        n = e[1];
    if (t.length > 3 || n.length > 3) throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
    var r = this.interpretAxes(t, n);
    if (t[r[0]] !== n[r[1]]) throw new ValueError("Dimension incompatibility: " + t[r[0]] + " !== " + n[r[1]]);
  }, t.prototype.mergeFunction = function (e) {
    if (2 !== e.length) throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received " + e.length + " input(s).");
    var t,
        n = e[0],
        r = e[1];
    return t = Array.isArray(this.axes) ? this.axes.map(function (t, n) {
      return interpretAxis(t, e[n].shape.length);
    }) : [interpretAxis(this.axes, n.shape.length), interpretAxis(this.axes, r.shape.length)], this.normalize && (n = l2Normalize(n, t[0]), r = l2Normalize(r, t[1])), batchDot(n, r, t);
  }, t.prototype.interpretAxes = function (e, t) {
    return Array.isArray(this.axes) ? this.axes : [interpretAxis(this.axes, e.length), interpretAxis(this.axes, t.length)];
  }, t.prototype.computeOutputShape = function (e) {
    _tfjsCore.util.assert(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
      return "A `Dot` layer should be called on a list of exactly 2 inputs.";
    });

    var t = e[0].slice(),
        n = e[1].slice();
    if (t.length > 3 || n.length > 3) throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
    var r = this.interpretAxes(t, n);
    t.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
    var i = t.concat(n);
    return 1 === i.length && i.push(1), i;
  }, t.prototype.computeMask = function (e, t) {
    return null;
  }, t.prototype.getConfig = function () {
    var t = {
      axes: this.axes,
      normalize: this.normalize
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Dot", t;
}(Merge);

_tfjsCore.serialization.registerClass(Dot);

var GaussianNoise = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.stddev = t.stddev, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      stddev: this.stddev
    };
    return Object.assign(n, t), n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);
      return inTrainPhase(function () {
        return randomNormal$1(r.shape, 0, n.stddev).add(r);
      }, function () {
        return r;
      }, t.training || !1);
    });
  }, t.className = "GaussianNoise", t;
}(Layer);

_tfjsCore.serialization.registerClass(GaussianNoise);

var GaussianDropout = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.rate = t.rate, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      rate: this.rate
    };
    return Object.assign(n, t), n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);

      if (n.rate > 0 && n.rate < 1) {
        return inTrainPhase(function () {
          var e = Math.sqrt(n.rate / (1 - n.rate));
          return r.mul(randomNormal$1(r.shape, 1, e));
        }, function () {
          return r;
        }, t.training || !1);
      }

      return r;
    });
  }, t.className = "GaussianDropout", t;
}(Layer);

_tfjsCore.serialization.registerClass(GaussianDropout);

var AlphaDropout = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.rate = t.rate, n.noiseShape = t.noiseShape, n;
  }

  return __extends(t, e), t.prototype._getNoiseShape = function (e) {
    return this.noiseShape || getExactlyOneTensor(e).shape;
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      rate: this.rate
    };
    return Object.assign(n, t), n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (n.rate < 1 && n.rate > 0) {
        var r = n._getNoiseShape(e);

        return inTrainPhase(function () {
          var t = getExactlyOneTensor(e),
              i = -1.7580993408473766,
              a = (0, _tfjsCore.greaterEqual)((0, _tfjsCore.randomUniform)(r), n.rate);
          a = cast$1(a, "float32");
          var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(i, 2)), -.5),
              s = -o * i * n.rate;
          return t.mul(a).add(a.add(-1).mul(i)).mul(o).add(s);
        }, function () {
          return getExactlyOneTensor(e);
        }, t.training || !1);
      }

      return e;
    });
  }, t.className = "AlphaDropout", t;
}(Layer);

function batchNormalization(e, t, n, r, i, a) {
  var o;
  if (void 0 === a && (a = .001), 2 === e.rank) o = (0, _tfjsCore.batchNorm2d)(e, t, n, r, i, a);else if (3 === e.rank) o = (0, _tfjsCore.batchNorm3d)(e, t, n, r, i, a);else {
    if (4 !== e.rank) throw new NotImplementedError("batchNormalization is not implemented for array of rank " + e.rank + " yet");
    o = (0, _tfjsCore.batchNorm4d)(e, t, n, r, i, a);
  }
  return o;
}

function regularNormalizeBatchInTraining(e, t, n, r, i) {
  return void 0 === i && (i = .001), (0, _tfjsCore.tidy)(function () {
    var a = (0, _tfjsCore.moments)(e, r),
        o = a.mean,
        s = a.variance;
    return [batchNormalization(e, o, s, n, t, i), o, s];
  });
}

function broadcastNormalizeBatchInTraining(e, t, n, r, i) {
  return void 0 === i && (i = .001), (0, _tfjsCore.tidy)(function () {
    for (var a = (0, _tfjsCore.moments)(e, r), o = a.mean, s = a.variance, l = [], u = 0, c = range(0, e.rank); u < c.length; u++) {
      var p = c[u];
      -1 !== r.indexOf(p) ? l.push(1) : l.push(e.shape[p]);
    }

    var h = o.reshape(l),
        d = s.reshape(l),
        f = null == t ? null : t.reshape(l),
        g = null == n ? null : n.reshape(l);
    return [batchNormalization(e, h, d, g, f, i), o, s];
  });
}

function normalizeBatchInTraining(e, t, n, r, i) {
  return void 0 === i && (i = .001), _tfjsCore.util.arraysEqual(r.slice().sort(), range(0, e.rank - 1)) ? regularNormalizeBatchInTraining(e, t, n, r, i) : broadcastNormalizeBatchInTraining(e, t, n, r, i);
}

_tfjsCore.serialization.registerClass(AlphaDropout);

var BatchNormalization = function (e) {
  function t(t) {
    var n = this;
    return null == t && (t = {}), (n = e.call(this, t) || this).supportsMasking = !0, n.axis = null == t.axis ? -1 : t.axis, n.momentum = null == t.momentum ? .99 : t.momentum, n.epsilon = null == t.epsilon ? .001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = getInitializer(t.betaInitializer || "zeros"), n.gammaInitializer = getInitializer(t.gammaInitializer || "ones"), n.movingMeanInitializer = getInitializer(t.movingMeanInitializer || "zeros"), n.movingVarianceInitializer = getInitializer(t.movingVarianceInitializer || "ones"), n.betaConstraint = getConstraint(t.betaConstraint), n.gammaConstraint = getConstraint(t.gammaConstraint), n.betaRegularizer = getRegularizer(t.betaRegularizer), n.gammaRegularizer = getRegularizer(t.gammaRegularizer), n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    e = getExactlyOneShape(e);
    var n = this.axis >= 0 ? this.axis : this.axis + e.length,
        r = e[n];
    if (null == r) throw new ValueError("Axis " + n + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(e) + ".");
    this.inputSpec = [new InputSpec({
      ndim: e.length,
      axes: (t = {}, t[n] = r, t)
    })];
    var i = [r];
    this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, !1), this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r = null != t.training && t.training,
          i = getExactlyOneTensor(e),
          a = i.shape,
          o = a.length,
          s = range(0, o),
          l = n.axis >= 0 ? n.axis : n.axis + o;
      s.splice(l, 1);
      var u = pyListRepeat(1, o);
      u[l] = a[l];
      var c = s.slice();
      c.sort();
      var p = !_tfjsCore.util.arraysEqual(c, range(0, o).slice(0, o - 1));
      if (!r) return function () {
        if (p) {
          var e = n.movingMean.read().reshape(u),
              t = n.movingVariance.read().reshape(u),
              r = n.center ? n.beta.read().reshape(u) : null,
              a = n.scale ? n.gamma.read().reshape(u) : null;
          return batchNormalization(i, e, t, r, a, n.epsilon);
        }

        return batchNormalization(i, n.movingMean.read(), n.movingVariance.read(), null == n.beta ? null : n.beta.read(), null == n.gamma ? null : n.gamma.read(), n.epsilon);
      }();

      var h = normalizeBatchInTraining(i, n.gamma.read(), n.beta.read(), s, n.epsilon),
          d = h[0],
          f = h[1],
          g = h[2],
          m = function (e, t, n) {
        (0, _tfjsCore.tidy)(function () {
          var r = 1 - n,
              i = e.read(),
              a = i.sub(t).mul(r);
          e.write(i.sub(a));
        });
      };

      return m(n.movingMean, f, n.momentum), m(n.movingVariance, g, n.momentum), d;
    });
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: serializeInitializer(this.betaInitializer),
      gammaInitializer: serializeInitializer(this.gammaInitializer),
      movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
      movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
      betaRegularizer: serializeRegularizer(this.betaRegularizer),
      gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
      betaConstraint: serializeConstraint(this.betaConstraint),
      gammaConstraint: serializeConstraint(this.gammaConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "BatchNormalization", t;
}(Layer);

_tfjsCore.serialization.registerClass(BatchNormalization);

var LayerNormalization = function (e) {
  function t(t) {
    var n = this;

    if (null == t && (t = {}), (n = e.call(this, t) || this).axis = null == t.axis ? -1 : t.axis, "number" == typeof n.axis) {
      if (!Number.isInteger(n.axis)) throw new Error("Expected axis to be an integer, but received " + n.axis);
    } else {
      if (!Array.isArray(n.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis));

      for (var r = 0, i = n.axis; r < i.length; r++) {
        var a = i[r];
        if (!Number.isInteger(a)) throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n.axis));
      }
    }

    return n.epsilon = null == t.epsilon ? .001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = getInitializer(t.betaInitializer || "zeros"), n.gammaInitializer = getInitializer(t.gammaInitializer || "ones"), n.betaRegularizer = getRegularizer(t.betaRegularizer), n.gammaRegularizer = getRegularizer(t.gammaRegularizer), n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t = (e = getExactlyOneShape(e)).length;
    "number" == typeof this.axis && (this.axis = [this.axis]);

    for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += t);

    for (var r = 0, i = this.axis; r < i.length; r++) {
      var a = i[r];
      if (a < 0 || a >= t) throw new Error("Invalid axis: " + a);
    }

    if (this.axis.length !== unique(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
    var o = this.axis.map(function (t) {
      return e[t];
    });
    this.scale ? this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, !0) : this.beta = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this,
        r = getExactlyOneTensor(e),
        i = r.shape,
        a = i.length;
    return (0, _tfjsCore.tidy)(function () {
      for (var e = (0, _tfjsCore.moments)(r, n.axis, !0), t = e.mean, o = e.variance, s = pyListRepeat(1, a), l = 0, u = n.axis; l < u.length; l++) {
        var c = u[l];
        s[c] = i[c];
      }

      for (var p = function (e) {
        return null != e && e.shape.length !== a && n.axis !== [a - 1] ? e.reshape(s) : e;
      }, h = p(n.gamma.read()), d = p(n.beta.read()), f = [], g = [], m = 0; m < a; ++m) -1 !== n.axis.indexOf(m) ? (f.push(i[m]), g.push(1)) : (f.push(1), g.push(i[m]));

      return t = t.tile(f), o = o.tile(f), h = h.tile(g), d = d.tile(g), batchNormalization(r, t, o, d, h, n.epsilon);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: serializeInitializer(this.betaInitializer),
      gammaInitializer: serializeInitializer(this.gammaInitializer),
      betaRegularizer: serializeRegularizer(this.betaRegularizer),
      gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "LayerNormalization", t;
}(Layer);

function spatial2dPadding(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    if (4 !== e.rank) throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a " + e.rank + "-D tensor.");
    if (null == t && (t = [[1, 1], [1, 1]]), 2 !== t.length || 2 !== t[0].length || 2 !== t[1].length) throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
    if (null == n && (n = imageDataFormat()), "channelsLast" !== n && "channelsFirst" !== n) throw new ValueError("Unknown data format: " + n + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
    var r;
    return r = "channelsFirst" === n ? [[0, 0], [0, 0], t[0], t[1]] : [[0, 0], t[0], t[1], [0, 0]], (0, _tfjsCore.pad)(e, r);
  });
}

_tfjsCore.serialization.registerClass(LayerNormalization);

var ZeroPadding2D = function (e) {
  function t(t) {
    var n = this;
    if (null == t && (t = {}), (n = e.call(this, t) || this).dataFormat = null == t.dataFormat ? imageDataFormat() : t.dataFormat, null == t.padding) n.padding = [[1, 1], [1, 1]];else if ("number" == typeof t.padding) n.padding = [[t.padding, t.padding], [t.padding, t.padding]];else {
      if (t.padding = t.padding, 2 !== t.padding.length) throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + t.padding.length + " array.");
      var r = void 0,
          i = void 0;
      if ("number" == typeof t.padding[0]) r = [t.padding[0], t.padding[0]], i = [t.padding[1], t.padding[1]];else {
        if (t.padding = t.padding, 2 !== t.padding[0].length) throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + t.padding[0].length + " array.");
        if (r = t.padding[0], 2 !== t.padding[1].length) throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + t.padding[1].length + " array.");
        i = t.padding[1];
      }
      n.padding = [r, i];
    }
    return n.inputSpec = [new InputSpec({
      ndim: 4
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    var t, n;
    return e = getExactlyOneShape(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]]);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return spatial2dPadding(getExactlyOneTensor(e), n.padding, n.dataFormat);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      padding: this.padding,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ZeroPadding2D", t;
}(Layer);

function pool2d(e, t, n, r, i, a) {
  return (0, _tfjsCore.tidy)(function () {
    var o;
    checkDataFormat(i), checkPoolMode(a), checkPaddingMode(r), null == n && (n = [1, 1]), null == r && (r = "valid"), null == i && (i = imageDataFormat()), null == a && (a = "max"), e = preprocessConv2DInput(e, i);
    var s = "same" === r ? "same" : "valid";
    return o = "max" === a ? (0, _tfjsCore.maxPool)(e, t, n, s) : (0, _tfjsCore.avgPool)(e, t, n, s), "channelsFirst" === i && (o = (0, _tfjsCore.transpose)(o, [0, 3, 1, 2])), o;
  });
}

function pool3d(e, t, n, r, i, a) {
  return (0, _tfjsCore.tidy)(function () {
    var o;
    checkDataFormat(i), checkPoolMode(a), checkPaddingMode(r), null == n && (n = [1, 1, 1]), null == r && (r = "valid"), null == i && (i = imageDataFormat()), null == a && (a = "max"), e = preprocessConv3DInput(e, i);
    var s = "same" === r ? "same" : "valid";
    return o = "max" === a ? (0, _tfjsCore.maxPool3d)(e, t, n, s) : (0, _tfjsCore.avgPool3d)(e, t, n, s), "channelsFirst" === i && (o = (0, _tfjsCore.transpose)(o, [0, 4, 1, 2, 3])), o;
  });
}

_tfjsCore.serialization.registerClass(ZeroPadding2D);

var Pooling1D = function (e) {
  function t(t) {
    var n = this;
    if (null == t.poolSize && (t.poolSize = 2), n = e.call(this, t) || this, "number" == typeof t.poolSize) n.poolSize = [t.poolSize];else {
      if (!Array.isArray(t.poolSize) || 1 !== t.poolSize.length || "number" != typeof t.poolSize[0]) throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.poolSize));
      n.poolSize = t.poolSize;
    }
    if (assertPositiveInteger(n.poolSize, "poolSize"), null == t.strides) n.strides = n.poolSize;else if ("number" == typeof t.strides) n.strides = [t.strides];else {
      if (!Array.isArray(t.strides) || 1 !== t.strides.length || "number" != typeof t.strides[0]) throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.strides));
      n.strides = t.strides;
    }
    return assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, checkPaddingMode(n.padding), n.inputSpec = [new InputSpec({
      ndim: 3
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    var t = convOutputLength((e = getExactlyOneShape(e))[1], this.poolSize[0], this.padding, this.strides[0]);
    return [e[0], t, e[2]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t), e = expandDims$1(getExactlyOneTensor(e), 2);
      var r = n.poolingFunction(getExactlyOneTensor(e), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
      return (0, _tfjsCore.squeeze)(r, [2]);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    MaxPooling1D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "max");
  }, t.className = "MaxPooling1D", t;
}(Pooling1D);

_tfjsCore.serialization.registerClass(MaxPooling1D);

var AveragePooling1D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "avg");
  }, t.className = "AveragePooling1D", t;
}(Pooling1D);

_tfjsCore.serialization.registerClass(AveragePooling1D);

var Pooling2D = function (e) {
  function t(t) {
    var n = this;
    if (null == t.poolSize && (t.poolSize = [2, 2]), (n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize], null == t.strides) n.strides = n.poolSize;else if (Array.isArray(t.strides)) {
      if (2 !== t.strides.length) throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + t.strides.length + ".");
      n.strides = t.strides;
    } else n.strides = [t.strides, t.strides];
    return assertPositiveInteger(n.poolSize, "poolSize"), assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), checkPaddingMode(n.padding), n.inputSpec = [new InputSpec({
      ndim: 4
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
    return t = convOutputLength(t, this.poolSize[0], this.padding, this.strides[0]), n = convOutputLength(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return n.invokeCallHook(e, t), n.poolingFunction(getExactlyOneTensor(e), n.poolSize, n.strides, n.padding, n.dataFormat);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    MaxPooling2D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "max");
  }, t.className = "MaxPooling2D", t;
}(Pooling2D);

_tfjsCore.serialization.registerClass(MaxPooling2D);

var AveragePooling2D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "avg");
  }, t.className = "AveragePooling2D", t;
}(Pooling2D);

_tfjsCore.serialization.registerClass(AveragePooling2D);

var Pooling3D = function (e) {
  function t(t) {
    var n = this;
    if (null == t.poolSize && (t.poolSize = [2, 2, 2]), (n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize, t.poolSize], null == t.strides) n.strides = n.poolSize;else if (Array.isArray(t.strides)) {
      if (3 !== t.strides.length) throw new ValueError("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + t.strides.length + ".");
      n.strides = t.strides;
    } else n.strides = [t.strides, t.strides, t.strides];
    return assertPositiveInteger(n.poolSize, "poolSize"), assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), checkPaddingMode(n.padding), n.inputSpec = [new InputSpec({
      ndim: 5
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        r = "channelsFirst" === this.dataFormat ? e[4] : e[3];
    return t = convOutputLength(t, this.poolSize[0], this.padding, this.strides[0]), n = convOutputLength(n, this.poolSize[1], this.padding, this.strides[1]), r = convOutputLength(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, r] : [e[0], t, n, r, e[4]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return n.invokeCallHook(e, t), n.poolingFunction(getExactlyOneTensor(e), n.poolSize, n.strides, n.padding, n.dataFormat);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    MaxPooling3D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool3d(e, t, n, r, i, "max");
  }, t.className = "MaxPooling3D", t;
}(Pooling3D);

_tfjsCore.serialization.registerClass(MaxPooling3D);

var AveragePooling3D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool3d(e, t, n, r, i, "avg");
  }, t.className = "AveragePooling3D", t;
}(Pooling3D);

_tfjsCore.serialization.registerClass(AveragePooling3D);

var GlobalPooling1D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.inputSpec = [new InputSpec({
      ndim: 3
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return [e[0], e[2]];
  }, t.prototype.call = function (e, t) {
    throw new NotImplementedError();
  }, t;
}(Layer),
    GlobalAveragePooling1D = function (e) {
  function t(t) {
    return e.call(this, t || {}) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return (0, _tfjsCore.mean)(t, 1);
    });
  }, t.className = "GlobalAveragePooling1D", t;
}(GlobalPooling1D);

_tfjsCore.serialization.registerClass(GlobalAveragePooling1D);

var GlobalMaxPooling1D = function (e) {
  function t(t) {
    return e.call(this, t || {}) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return (0, _tfjsCore.max)(t, 1);
    });
  }, t.className = "GlobalMaxPooling1D", t;
}(GlobalPooling1D);

_tfjsCore.serialization.registerClass(GlobalMaxPooling1D);

var GlobalPooling2D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), n.inputSpec = [new InputSpec({
      ndim: 4
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e = e, "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]];
  }, t.prototype.call = function (e, t) {
    throw new NotImplementedError();
  }, t.prototype.getConfig = function () {
    var t = {
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    GlobalAveragePooling2D = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return "channelsLast" === n.dataFormat ? (0, _tfjsCore.mean)(t, [1, 2]) : (0, _tfjsCore.mean)(t, [2, 3]);
    });
  }, t.className = "GlobalAveragePooling2D", t;
}(GlobalPooling2D);

_tfjsCore.serialization.registerClass(GlobalAveragePooling2D);

var GlobalMaxPooling2D = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return "channelsLast" === n.dataFormat ? (0, _tfjsCore.max)(t, [1, 2]) : (0, _tfjsCore.max)(t, [2, 3]);
    });
  }, t.className = "GlobalMaxPooling2D", t;
}(GlobalPooling2D);

function standardizeArgs(e, t, n, r) {
  if (Array.isArray(e)) {
    if (null != t || null != n) throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
    null != r && (n = e.slice(e.length - r, e.length), e = e.slice(0, e.length - r)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0];
  }

  function i(e) {
    return null == e || Array.isArray(e) ? e : [e];
  }

  return {
    inputs: e,
    initialState: t = i(t),
    constants: n = i(n)
  };
}

function rnn(e, t, n, r, i, a, o, s) {
  return void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), (0, _tfjsCore.tidy)(function () {
    var l = t.shape.length;
    if (l < 3) throw new ValueError("Input should be at least 3D, but is " + l + "D.");
    var u = [1, 0].concat(range(2, l));
    if (t = (0, _tfjsCore.transpose)(t, u), null != a) throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != i && ((i = i.asType("bool").asType("float32")).rank === l - 1 && (i = (0, _tfjsCore.expandDims)(i, -1)), i = (0, _tfjsCore.transpose)(i, u)), r && (t = (0, _tfjsCore.reverse)(t, 0), null != i && (i = (0, _tfjsCore.reverse)(i, 0)));
    var c,
        p,
        h = [],
        d = n,
        f = t.shape[0],
        g = (0, _tfjsCore.unstack)(t);
    null != i && (p = (0, _tfjsCore.unstack)(i));

    for (var m, y = function (t) {
      var n = g[t],
          r = (0, _tfjsCore.tidy)(function () {
        return e(n, d);
      });
      if (null == i) c = r[0], d = r[1];else {
        var a = (0, _tfjsCore.tidy)(function () {
          var e = p[t],
              n = (0, _tfjsCore.onesLike)(e).sub(e);
          return {
            output: r[0].mul(e).addStrict(d[0].mul(n)),
            newStates: d.map(function (t, i) {
              return r[1][i].mul(e).addStrict(t.mul(n));
            })
          };
        });
        c = a.output, d = a.newStates;
      }
      s && h.push(c);
    }, v = 0; v < f; ++v) y(v);

    if (s) {
      m = (0, _tfjsCore.stack)(h, 1);
    }

    return [c, m, d];
  });
}

_tfjsCore.serialization.registerClass(GlobalMaxPooling2D);

var RNN = function (e) {
  function t(t) {
    var n,
        r = e.call(this, t) || this;
    if (null == t.cell) throw new ValueError("cell property is missing for the constructor of RNN.");
    if (null == (n = Array.isArray(t.cell) ? new StackedRNNCells({
      cells: t.cell
    }) : t.cell).stateSize) throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    return r.cell = n, r.returnSequences = null != t.returnSequences && t.returnSequences, r.returnState = null != t.returnState && t.returnState, r.goBackwards = null != t.goBackwards && t.goBackwards, r._stateful = null != t.stateful && t.stateful, r.unroll = null != t.unroll && t.unroll, r.supportsMasking = !0, r.inputSpec = [new InputSpec({
      ndim: 3
    })], r.stateSpec = null, r.states_ = null, r.numConstants = null, r.keptStates = [], r;
  }

  return __extends(t, e), t.prototype.getStates = function () {
    return null == this.states_ ? range(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (e) {
      return null;
    }) : this.states_;
  }, t.prototype.setStates = function (e) {
    this.states_ = e;
  }, t.prototype.computeOutputShape = function (e) {
    isArrayOfShapes(e) && (e = e[0]), e = e;
    var t = this.cell.stateSize;
    Array.isArray(t) || (t = [t]);
    var n,
        r = t[0];

    if (n = this.returnSequences ? [e[0], e[1], r] : [e[0], r], this.returnState) {
      for (var i = [], a = 0, o = t; a < o.length; a++) {
        var s = o[a];
        i.push([e[0], s]);
      }

      return [n].concat(i);
    }

    return n;
  }, t.prototype.computeMask = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      Array.isArray(t) && (t = t[0]);
      var e = n.returnSequences ? t : null;

      if (n.returnState) {
        var r = n.states.map(function (e) {
          return null;
        });
        return [e].concat(r);
      }

      return e;
    });
  }, Object.defineProperty(t.prototype, "states", {
    get: function () {
      if (null == this.states_) {
        for (var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [], n = 0; n < e; ++n) t.push(null);

        return t;
      }

      return this.states_;
    },
    set: function (e) {
      this.states_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.build = function (e) {
    if (null != this.numConstants) throw new NotImplementedError("Constants support is not implemented in RNN yet.");
    isArrayOfShapes(e) && (e = e[0]), e = e;
    var t = this.stateful ? e[0] : null,
        n = e[e.length - 1];
    this.inputSpec[0] = new InputSpec({
      shape: [t, null, n]
    });
    var r,
        i = [e[0]].concat(e.slice(2));

    if (this.cell.build(i), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
      if (!_tfjsCore.util.arraysEqual(this.stateSpec.map(function (e) {
        return e.shape[e.shape.length - 1];
      }), r)) throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize);
    } else this.stateSpec = r.map(function (e) {
      return new InputSpec({
        shape: [null, e]
      });
    });

    this.stateful && this.resetStates();
  }, t.prototype.resetStates = function (e, t) {
    var n = this;
    void 0 === t && (t = !1), (0, _tfjsCore.tidy)(function () {
      if (!n.stateful) throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
      var r = n.inputSpec[0].shape[0];
      if (null == r) throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (null == n.states_) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (e) {
        return (0, _tfjsCore.zeros)([r, e]);
      }) : n.states_ = [(0, _tfjsCore.zeros)([r, n.cell.stateSize])];else if (null == e) (0, _tfjsCore.dispose)(n.states_), null != n.keptStates && ((0, _tfjsCore.dispose)(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (e) {
        return (0, _tfjsCore.zeros)([r, e]);
      }) : n.states_[0] = (0, _tfjsCore.zeros)([r, n.cell.stateSize]);else {
        if (Array.isArray(e) || (e = [e]), e.length !== n.states_.length) throw new ValueError("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + e.length + " state value(s). Input received: " + e);
        !0 === t ? n.keptStates.push(n.states_.slice()) : (0, _tfjsCore.dispose)(n.states_);

        for (var i = 0; i < n.states_.length; ++i) {
          var a = e[i],
              o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[i] : n.cell.stateSize,
              s = [r, o];
          if (!_tfjsCore.util.arraysEqual(a.shape, s)) throw new ValueError("State " + i + " is incompatible with layer " + n.name + ": expected shape=" + s + ", received shape=" + a.shape);
          n.states_[i] = a;
        }
      }
      n.states_ = n.states_.map(function (e) {
        return (0, _tfjsCore.keep)(e.clone());
      });
    });
  }, t.prototype.apply = function (t, n) {
    var r = null == n ? null : n.initialState,
        i = null == n ? null : n.constants;
    null == n && (n = {});
    var a = standardizeArgs(t, r, i, this.numConstants);
    t = a.inputs, r = a.initialState, i = a.constants;
    var o = [],
        s = [];

    if (null != r) {
      n.initialState = r, o = o.concat(r), this.stateSpec = [];

      for (var l = 0, u = r; l < u.length; l++) {
        var c = u[l];
        this.stateSpec.push(new InputSpec({
          shape: c.shape
        }));
      }

      s = s.concat(this.stateSpec);
    }

    if (null != i && (n.constants = i, o = o.concat(i), this.numConstants = i.length), o[0] instanceof SymbolicTensor) {
      var p = [t].concat(o),
          h = this.inputSpec.concat(s),
          d = this.inputSpec;
      this.inputSpec = h;
      var f = e.prototype.apply.call(this, p, n);
      return this.inputSpec = d, f;
    }

    return e.prototype.apply.call(this, t, n);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r = null == t ? null : t.mask,
          i = null == t ? null : t.training,
          a = null == t ? null : t.initialState;
      e = getExactlyOneTensor(e), null == a && (a = n.stateful ? n.states_ : n.getInitialState(e));
      var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
      if (a.length !== o) throw new ValueError("RNN Layer has " + o + " state(s) but was passed " + a.length + " initial state(s).");
      n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      var s = {
        training: i
      },
          l = rnn(function (e, t) {
        var r = n.cell.call([e].concat(t), s);
        return [r[0], r.slice(1)];
      }, e, a, n.goBackwards, r, null, n.unroll, n.returnSequences),
          u = l[0],
          c = l[1],
          p = l[2];
      n.stateful && n.resetStates(p, i);
      var h = n.returnSequences ? c : u;
      return n.returnState ? [h].concat(p) : h;
    });
  }, t.prototype.getInitialState = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = (0, _tfjsCore.zeros)(e.shape);
      return n = expandDims$1(n = (0, _tfjsCore.sum)(n, [1, 2])), Array.isArray(t.cell.stateSize) ? t.cell.stateSize.map(function (e) {
        return e > 1 ? tile$1(n, [1, e]) : n;
      }) : t.cell.stateSize > 1 ? [tile$1(n, [1, t.cell.stateSize])] : [n];
    });
  }, Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.trainable ? this.cell.trainableWeights : [];
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.setFastWeightInitDuringBuild = function (t) {
    e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.cell && this.cell.setFastWeightInitDuringBuild(t);
  }, t.prototype.getConfig = function () {
    var t = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    null != this.numConstants && (t.numConstants = this.numConstants);
    var n = this.cell.getConfig();
    t.cell = {
      className: this.cell.getClassName(),
      config: n
    };
    var r = e.prototype.getConfig.call(this);
    return Object.assign(t, r), t;
  }, t.fromConfig = function (e, t, n) {
    void 0 === n && (n = {});
    var r = deserialize(t.cell, n);
    return new e(Object.assign(t, {
      cell: r
    }));
  }, t.className = "RNN", t;
}(Layer);

exports.RNN = RNN;

_tfjsCore.serialization.registerClass(RNN);

var RNNCell = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t;
}(Layer),
    SimpleRNNCell = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(null == t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([1, max$1([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = min$1([1, max$1([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    e = getExactlyOneShape(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== (e = e).length) throw new ValueError("SimpleRNNCell expects 2 input Tensors, got " + e.length + ".");
      var r = e[1];
      e = e[0];
      var i,
          a = null != t.training && t.training;
      0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(e);
      }, n.dropout, a)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(r);
      }, n.recurrentDropout, a));
      var o = n.dropoutMask,
          s = n.recurrentDropoutMask;
      i = dot(null != o ? (0, _tfjsCore.mul)(e, o) : e, n.kernel.read()), null != n.bias && (i = biasAdd(i, n.bias.read())), null != s && (r = (0, _tfjsCore.mul)(r, s));
      var l = (0, _tfjsCore.add)(i, dot(r, n.recurrentKernel.read()));
      return null != n.activation && (l = n.activation.apply(l)), [l, l];
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "SimpleRNNCell", t;
}(RNNCell);

_tfjsCore.serialization.registerClass(SimpleRNNCell);

var SimpleRNN = function (e) {
  function t(t) {
    return t.cell = new SimpleRNNCell(t), e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.call = function (t, n) {
    var r = this;
    return (0, _tfjsCore.tidy)(function () {
      null != r.cell.dropoutMask && ((0, _tfjsCore.dispose)(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && ((0, _tfjsCore.dispose)(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
      var i = null == n ? null : n.mask,
          a = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
      return e.prototype.call.call(r, t, {
        mask: i,
        training: a,
        initialState: o
      });
    });
  }, Object.defineProperty(t.prototype, "units", {
    get: function () {
      return this.cell.units;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "activation", {
    get: function () {
      return this.cell.activation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "useBias", {
    get: function () {
      return this.cell.useBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelInitializer", {
    get: function () {
      return this.cell.kernelInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentInitializer", {
    get: function () {
      return this.cell.recurrentInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasInitializer", {
    get: function () {
      return this.cell.biasInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelRegularizer", {
    get: function () {
      return this.cell.kernelRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentRegularizer", {
    get: function () {
      return this.cell.recurrentRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasRegularizer", {
    get: function () {
      return this.cell.biasRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelConstraint", {
    get: function () {
      return this.cell.kernelConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentConstraint", {
    get: function () {
      return this.cell.recurrentConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasConstraint", {
    get: function () {
      return this.cell.biasConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "dropout", {
    get: function () {
      return this.cell.dropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentDropout", {
    get: function () {
      return this.cell.recurrentDropout;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    },
        n = e.prototype.getConfig.call(this);
    return delete n.cell, Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    return new e(t);
  }, t.className = "SimpleRNN", t;
}(RNN);

_tfjsCore.serialization.registerClass(SimpleRNN);

var GRUCell = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = getActivation(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([1, max$1([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = min$1([1, max$1([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.implementation = t.implementation, n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t = (e = getExactlyOneShape(e))[e.length - 1];
    this.kernel = this.addWeight("kernel", [t, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== (e = e).length) throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " + e.length + ".");
      var r = null != t.training && t.training,
          i = e[1];
      e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(e);
      }, n.dropout, r, 3)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(i);
      }, n.recurrentDropout, r, 3));
      var a,
          o,
          s,
          l = n.dropoutMask,
          u = n.recurrentDropoutMask;
      0 < n.dropout && n.dropout < 1 && (e = (0, _tfjsCore.mul)(e, l[0]));
      var c = dot(e, n.kernel.read());
      n.useBias && (c = biasAdd(c, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (i = (0, _tfjsCore.mul)(i, u[0]));
      var p = n.recurrentKernel.read(),
          h = (0, _tfjsCore.split)(p, [2 * n.units, n.units], p.rank - 1),
          d = h[0],
          f = h[1],
          g = dot(i, d),
          m = (0, _tfjsCore.split)(c, 3, c.rank - 1),
          y = m[0],
          v = m[1],
          b = m[2],
          w = (0, _tfjsCore.split)(g, 2, g.rank - 1),
          z = w[0],
          S = w[1];
      a = n.recurrentActivation.apply((0, _tfjsCore.add)(y, z)), o = n.recurrentActivation.apply((0, _tfjsCore.add)(v, S));
      var A = dot((0, _tfjsCore.mul)(o, i), f);
      s = n.activation.apply((0, _tfjsCore.add)(b, A));

      var _ = (0, _tfjsCore.add)((0, _tfjsCore.mul)(a, i), (0, _tfjsCore.mul)((0, _tfjsCore.add)(1, (0, _tfjsCore.neg)(a)), s));

      return [_, _];
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "GRUCell", t;
}(RNNCell);

_tfjsCore.serialization.registerClass(GRUCell);

var GRU = function (e) {
  function t(t) {
    return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new GRUCell(t), e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.call = function (t, n) {
    var r = this;
    return (0, _tfjsCore.tidy)(function () {
      null != r.cell.dropoutMask && ((0, _tfjsCore.dispose)(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && ((0, _tfjsCore.dispose)(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
      var i = null == n ? null : n.mask,
          a = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
      return e.prototype.call.call(r, t, {
        mask: i,
        training: a,
        initialState: o
      });
    });
  }, Object.defineProperty(t.prototype, "units", {
    get: function () {
      return this.cell.units;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "activation", {
    get: function () {
      return this.cell.activation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentActivation", {
    get: function () {
      return this.cell.recurrentActivation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "useBias", {
    get: function () {
      return this.cell.useBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelInitializer", {
    get: function () {
      return this.cell.kernelInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentInitializer", {
    get: function () {
      return this.cell.recurrentInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasInitializer", {
    get: function () {
      return this.cell.biasInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelRegularizer", {
    get: function () {
      return this.cell.kernelRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentRegularizer", {
    get: function () {
      return this.cell.recurrentRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasRegularizer", {
    get: function () {
      return this.cell.biasRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelConstraint", {
    get: function () {
      return this.cell.kernelConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentConstraint", {
    get: function () {
      return this.cell.recurrentConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasConstraint", {
    get: function () {
      return this.cell.biasConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "dropout", {
    get: function () {
      return this.cell.dropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentDropout", {
    get: function () {
      return this.cell.recurrentDropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "implementation", {
    get: function () {
      return this.cell.implementation;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return delete n.cell, Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }, t.className = "GRU", t;
}(RNN);

_tfjsCore.serialization.registerClass(GRU);

var LSTMCell = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = getActivation(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.unitForgetBias = t.unitForgetBias, n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([1, max$1([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = min$1([1, max$1([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.implementation = t.implementation, n.stateSize = [n.units, n.units], n.dropoutMask = null, n.recurrentDropoutMask = null, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t,
        n,
        r = (e = getExactlyOneShape(e))[e.length - 1];

    if (this.kernel = this.addWeight("kernel", [r, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      if (this.unitForgetBias) {
        var i = this.biasInitializer,
            a = this.units;
        n = new ((t = function (e) {
          function t() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return __extends(t, e), t.prototype.apply = function (e, t) {
            var n = i.apply([a]),
                r = new Ones().apply([a]),
                o = i.apply([2 * a]);
            return concatAlongFirstAxis(concatAlongFirstAxis(n, r), o);
          }, t;
        }(Initializer)).className = "CustomInit", t)();
      } else n = this.biasInitializer;

      this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint);
    } else this.bias = null;

    this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r = null != t.training && t.training;
      if (3 !== (e = e).length) throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
      var i = e[1],
          a = e[2];
      e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(e);
      }, n.dropout, r, 4)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(i);
      }, n.recurrentDropout, r, 4));
      var o,
          s,
          l,
          u,
          c = n.dropoutMask,
          p = n.recurrentDropoutMask;
      0 < n.dropout && n.dropout < 1 && (e = (0, _tfjsCore.mul)(e, c[0]));
      var h = dot(e, n.kernel.read());
      0 < n.recurrentDropout && n.recurrentDropout < 1 && (i = (0, _tfjsCore.mul)(i, p[0])), h = (0, _tfjsCore.add)(h, dot(i, n.recurrentKernel.read())), n.useBias && (h = biasAdd(h, n.bias.read()));
      var d = (0, _tfjsCore.split)(h, 4, h.rank - 1),
          f = d[0],
          g = d[1],
          m = d[2],
          y = d[3];
      o = n.recurrentActivation.apply(f), s = n.recurrentActivation.apply(g), l = (0, _tfjsCore.add)((0, _tfjsCore.mul)(s, a), (0, _tfjsCore.mul)(o, n.activation.apply(m))), u = n.recurrentActivation.apply(y);
      var v = (0, _tfjsCore.mul)(u, n.activation.apply(l));
      return [v, v, l];
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "LSTMCell", t;
}(RNNCell);

_tfjsCore.serialization.registerClass(LSTMCell);

var LSTM = function (e) {
  function t(t) {
    return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new LSTMCell(t), e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.call = function (t, n) {
    var r = this;
    return (0, _tfjsCore.tidy)(function () {
      null != r.cell.dropoutMask && ((0, _tfjsCore.dispose)(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && ((0, _tfjsCore.dispose)(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
      var i = null == n ? null : n.mask,
          a = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
      return e.prototype.call.call(r, t, {
        mask: i,
        training: a,
        initialState: o
      });
    });
  }, Object.defineProperty(t.prototype, "units", {
    get: function () {
      return this.cell.units;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "activation", {
    get: function () {
      return this.cell.activation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentActivation", {
    get: function () {
      return this.cell.recurrentActivation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "useBias", {
    get: function () {
      return this.cell.useBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelInitializer", {
    get: function () {
      return this.cell.kernelInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentInitializer", {
    get: function () {
      return this.cell.recurrentInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasInitializer", {
    get: function () {
      return this.cell.biasInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "unitForgetBias", {
    get: function () {
      return this.cell.unitForgetBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelRegularizer", {
    get: function () {
      return this.cell.kernelRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentRegularizer", {
    get: function () {
      return this.cell.recurrentRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasRegularizer", {
    get: function () {
      return this.cell.biasRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelConstraint", {
    get: function () {
      return this.cell.kernelConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentConstraint", {
    get: function () {
      return this.cell.recurrentConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasConstraint", {
    get: function () {
      return this.cell.biasConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "dropout", {
    get: function () {
      return this.cell.dropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentDropout", {
    get: function () {
      return this.cell.recurrentDropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "implementation", {
    get: function () {
      return this.cell.implementation;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return delete n.cell, Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }, t.className = "LSTM", t;
}(RNN);

_tfjsCore.serialization.registerClass(LSTM);

var StackedRNNCells = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.cells = t.cells, n;
  }

  return __extends(t, e), Object.defineProperty(t.prototype, "stateSize", {
    get: function () {
      for (var e = [], t = 0, n = this.cells.slice().reverse(); t < n.length; t++) {
        var r = n[t];
        Array.isArray(r.stateSize) ? e.push.apply(e, r.stateSize) : e.push(r.stateSize);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      for (var r = (e = e).slice(1), i = [], a = 0, o = n.cells.slice().reverse(); a < o.length; a++) {
        var s = o[a];
        Array.isArray(s.stateSize) ? i.push(r.splice(0, s.stateSize.length)) : i.push(r.splice(0, 1));
      }

      i.reverse();

      for (var l, u = [], c = 0; c < n.cells.length; ++c) {
        s = n.cells[c];
        r = i[c], l = 0 === c ? [e[0]].concat(r) : [l[0]].concat(r), l = s.call(l, t), u.push(l.slice(1));
      }

      r = [];

      for (var p = 0, h = u.slice().reverse(); p < h.length; p++) {
        var d = h[p];
        r.push.apply(r, d);
      }

      return [l[0]].concat(r);
    });
  }, t.prototype.build = function (e) {
    var t;
    isArrayOfShapes(e) && (e = e[0]), e = e, this.cells.forEach(function (n, r) {
      nameScope("RNNCell_" + r, function () {
        n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t];
      });
    }), this.built = !0;
  }, t.prototype.getConfig = function () {
    for (var t = [], n = 0, r = this.cells; n < r.length; n++) {
      var i = r[n];
      t.push({
        className: i.getClassName(),
        config: i.getConfig()
      });
    }

    var a = {
      cells: t
    },
        o = e.prototype.getConfig.call(this);
    return Object.assign(a, o), a;
  }, t.fromConfig = function (e, t, n) {
    void 0 === n && (n = {});

    for (var r = [], i = 0, a = t.cells; i < a.length; i++) {
      var o = a[i];
      r.push(deserialize(o, n));
    }

    return new e({
      cells: r
    });
  }, Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      if (!this.trainable) return [];

      for (var e = [], t = 0, n = this.cells; t < n.length; t++) {
        var r = n[t];
        e.push.apply(e, r.trainableWeights);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      for (var e = [], t = 0, n = this.cells; t < n.length; t++) {
        var r = n[t];
        e.push.apply(e, r.nonTrainableWeights);
      }

      if (!this.trainable) {
        for (var i = [], a = 0, o = this.cells; a < o.length; a++) {
          r = o[a];
          i.push.apply(i, r.trainableWeights);
        }

        return i.concat(e);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getWeights = function () {
    for (var e = [], t = 0, n = this.cells; t < n.length; t++) {
      var r = n[t];
      e.push.apply(e, r.weights);
    }

    return batchGetValue(e);
  }, t.prototype.setWeights = function (e) {
    for (var t = [], n = 0, r = this.cells; n < r.length; n++) for (var i = r[n], a = i.weights.length, o = e.splice(a), s = 0; s < i.weights.length; ++s) t.push([i.weights[s], o[s]]);

    batchSetValue(t);
  }, t.className = "StackedRNNCells", t;
}(RNNCell);

function generateDropoutMask(e, t, n, r) {
  function i() {
    return dropout$1(e(), t);
  }

  if (void 0 === n && (n = null), void 0 === r && (r = 1), r > 1) {
    for (var a = [], o = 0; o < r; o++) a.push(inTrainPhase(i, e, n));

    return a.map(function (e) {
      return (0, _tfjsCore.keep)(e.clone());
    });
  }

  return (0, _tfjsCore.keep)(inTrainPhase(i, e, n).clone());
}

_tfjsCore.serialization.registerClass(StackedRNNCells);

var Wrapper = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.layer = t.layer, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    this.built = !0;
  }, Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return null != this.layer && this.layer.trainable;
    },
    set: function (e) {
      null != this.layer && (this.layer.trainable = e);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.layer.trainableWeights;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.layer.nonTrainableWeights;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "updates", {
    get: function () {
      return this.layer._updates;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "losses", {
    get: function () {
      return this.layer.losses;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getWeights = function () {
    return this.layer.getWeights();
  }, t.prototype.setWeights = function (e) {
    this.layer.setWeights(e);
  }, t.prototype.getConfig = function () {
    var t = {
      layer: {
        className: this.layer.getClassName(),
        config: this.layer.getConfig()
      }
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.prototype.setFastWeightInitDuringBuild = function (t) {
    e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.layer && this.layer.setFastWeightInitDuringBuild(t);
  }, t.fromConfig = function (e, t, n) {
    void 0 === n && (n = {});
    var r = deserialize(t.layer, n);
    delete t.layer;
    var i = {
      layer: r
    };
    return Object.assign(i, t), new e(i);
  }, t;
}(Layer),
    TimeDistributed = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.build = function (t) {
    if ((t = getExactlyOneShape(t)).length < 3) throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(t));
    this.inputSpec = [{
      shape: t
    }];
    var n = [t[0]].concat(t.slice(2));
    this.layer.built || (this.layer.build(n), this.layer.built = !0), e.prototype.build.call(this, t);
  }, t.prototype.computeOutputShape = function (e) {
    var t = [(e = getExactlyOneShape(e))[0]].concat(e.slice(2)),
        n = this.layer.computeOutputShape(t),
        r = e[1];
    return [n[0], r].concat(n.slice(1));
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return rnn(function (e, r) {
        return [getExactlyOneTensor(n.layer.call(e, t)), []];
      }, e = getExactlyOneTensor(e), [], !1, null, null, !1, !0)[1];
    });
  }, t.className = "TimeDistributed", t;
}(Wrapper);

function checkBidirectionalMergeMode(e) {
  checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", e);
}

_tfjsCore.serialization.registerClass(TimeDistributed);

var DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat",
    Bidirectional = function (e) {
  function t(t) {
    var n = e.call(this, t) || this,
        r = t.layer.getConfig(),
        i = {};
    i.className = t.layer.getClassName(), i.config = r, n.forwardLayer = deserialize(i), r.goBackwards = !0 !== r.goBackwards;
    var a = {};
    if (a.className = t.layer.getClassName(), a.config = r, n.backwardLayer = deserialize(a), n.forwardLayer.name = "forward_" + n.forwardLayer.name, n.backwardLayer.name = "backward_" + n.backwardLayer.name, n.mergeMode = void 0 === t.mergeMode ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : t.mergeMode, checkBidirectionalMergeMode(n.mergeMode), t.weights) throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
    return n._stateful = t.layer.stateful, n.returnSequences = t.layer.returnSequences, n.returnState = t.layer.returnState, n.supportsMasking = !0, n._trainable = !0, n.inputSpec = t.layer.inputSpec, n.numConstants = null, n;
  }

  return __extends(t, e), Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return this._trainable;
    },
    set: function (e) {
      this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getWeights = function () {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }, t.prototype.setWeights = function (e) {
    var t = e.length,
        n = Math.floor(t / 2);
    this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n));
  }, t.prototype.computeOutputShape = function (e) {
    var t,
        n,
        r,
        i = this.forwardLayer.computeOutputShape(e);
    return Array.isArray(i) && Array.isArray(i[0]) || (i = [i]), i = i, this.returnState ? (r = i.slice(1), t = i[0]) : t = i[0], t = t, "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [t].concat(r).concat(r.slice()) : singletonOrArray(n);
  }, t.prototype.apply = function (t, n) {
    var r = null == n ? null : n.initialState,
        i = null == n ? null : n.constants;
    null == n && (n = {});
    var a = standardizeArgs(t, r, i, this.numConstants);
    if (t = a.inputs, r = a.initialState, i = a.constants, Array.isArray(t) && (r = t.slice(1), t = t[0]), (null == r || 0 === r.length) && null == i) return e.prototype.apply.call(this, t, n);
    var o = [],
        s = [];

    if (null != r) {
      var l = r.length;
      if (l % 2 > 0) throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      n.initialState = r, o.push.apply(o, r);
      var u = r.map(function (e) {
        return new InputSpec({
          shape: e.shape
        });
      });
      this.forwardLayer.stateSpec = u.slice(0, l / 2), this.backwardLayer.stateSpec = u.slice(l / 2), s.push.apply(s, u);
    }

    if (null != i) throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");

    for (var c = o[0] instanceof SymbolicTensor, p = 0, h = o; p < h.length; p++) {
      if (h[p] instanceof SymbolicTensor !== c) throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    }

    if (c) {
      var d = [t].concat(o),
          f = this.inputSpec.concat(s),
          g = this.inputSpec;
      this.inputSpec = f;
      var m = e.prototype.apply.call(this, d, n);
      return this.inputSpec = g, m;
    }

    return e.prototype.apply.call(this, t, n);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r,
          i,
          a,
          o,
          s = t.initialState;
      if (null == s) r = n.forwardLayer.call(e, t), i = n.backwardLayer.call(e, t);else {
        var l = s.slice(0, s.length / 2),
            u = s.slice(s.length / 2);
        r = n.forwardLayer.call(e, Object.assign(t, {
          initialState: l
        })), i = n.backwardLayer.call(e, Object.assign(t, {
          initialState: u
        }));
      }
      return n.returnState && (Array.isArray(r) && (a = r.slice(1).concat(i.slice(1))), r = r[0], i = i[0]), n.returnSequences && (i = (0, _tfjsCore.reverse)(i, 1)), "concat" === n.mergeMode ? o = concatenate([r, i]) : "sum" === n.mergeMode ? o = (0, _tfjsCore.add)(r, i) : "ave" === n.mergeMode ? o = (0, _tfjsCore.mul)(.5, (0, _tfjsCore.add)(r, i)) : "mul" === n.mergeMode ? o = (0, _tfjsCore.mul)(r, i) : null == n.mergeMode && (o = [r, i]), n.returnState ? null == n.mergeMode ? o.concat(a) : [o].concat(a) : o;
    });
  }, t.prototype.resetStates = function (e) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }, t.prototype.build = function (e) {
    var t = this;
    nameScope(this.forwardLayer.name, function () {
      t.forwardLayer.build(e);
    }), nameScope(this.backwardLayer.name, function () {
      t.backwardLayer.build(e);
    }), this.built = !0;
  }, t.prototype.computeMask = function (e, t) {
    var n;

    if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
      var r = this.forwardLayer.states.map(function (e) {
        return null;
      });
      return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r);
    }

    return n;
  }, Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.setFastWeightInitDuringBuild = function (t) {
    e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t);
  }, t.prototype.getConfig = function () {
    var t = {
      mergeMode: this.mergeMode
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    var n = deserialize(t.layer);
    if (delete t.layer, null != t.numConstants) throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    var r = t;
    return r.layer = n, new e(r);
  }, t.className = "Bidirectional", t;
}(Wrapper);

function inputLayer(e) {
  return new InputLayer(e);
}

function elu$2(e) {
  return new ELU(e);
}

function reLU(e) {
  return new ReLU(e);
}

function leakyReLU(e) {
  return new LeakyReLU(e);
}

function prelu$1(e) {
  return new PReLU(e);
}

function softmax$1(e) {
  return new Softmax$1(e);
}

function thresholdedReLU(e) {
  return new ThresholdedReLU(e);
}

function conv1d$2(e) {
  return new Conv1D(e);
}

function conv2d$1(e) {
  return new Conv2D(e);
}

function conv2dTranspose$1(e) {
  return new Conv2DTranspose(e);
}

function conv3d$2(e) {
  return new Conv3D(e);
}

function separableConv2d$1(e) {
  return new SeparableConv2D(e);
}

function cropping2D(e) {
  return new Cropping2D(e);
}

function upSampling2d(e) {
  return new UpSampling2D(e);
}

function depthwiseConv2d$2(e) {
  return new DepthwiseConv2D(e);
}

function activation(e) {
  return new Activation$1(e);
}

function dense(e) {
  return new Dense(e);
}

function dropout$2(e) {
  return new Dropout(e);
}

function spatialDropout1d(e) {
  return new SpatialDropout1D(e);
}

function flatten$1(e) {
  return new Flatten(e);
}

function repeatVector(e) {
  return new RepeatVector(e);
}

function reshape(e) {
  return new Reshape(e);
}

function permute(e) {
  return new Permute(e);
}

function embedding(e) {
  return new Embedding(e);
}

function add$2(e) {
  return new Add(e);
}

function average$1(e) {
  return new Average(e);
}

function concatenate$2(e) {
  return new Concatenate(e);
}

function maximum$2(e) {
  return new Maximum(e);
}

function minimum$2(e) {
  return new Minimum(e);
}

function multiply$1(e) {
  return new Multiply(e);
}

function dot$1(e) {
  return new Dot(e);
}

function batchNormalization$1(e) {
  return new BatchNormalization(e);
}

function layerNormalization(e) {
  return new LayerNormalization(e);
}

function zeroPadding2d(e) {
  return new ZeroPadding2D(e);
}

function averagePooling1d(e) {
  return new AveragePooling1D(e);
}

function avgPool1d(e) {
  return averagePooling1d(e);
}

function avgPooling1d(e) {
  return averagePooling1d(e);
}

function averagePooling2d(e) {
  return new AveragePooling2D(e);
}

function avgPool2d(e) {
  return averagePooling2d(e);
}

function avgPooling2d(e) {
  return averagePooling2d(e);
}

function averagePooling3d(e) {
  return new AveragePooling3D(e);
}

function avgPool3d$1(e) {
  return averagePooling3d(e);
}

function avgPooling3d(e) {
  return averagePooling3d(e);
}

function globalAveragePooling1d(e) {
  return new GlobalAveragePooling1D(e);
}

function globalAveragePooling2d(e) {
  return new GlobalAveragePooling2D(e);
}

function globalMaxPooling1d(e) {
  return new GlobalMaxPooling1D(e);
}

function globalMaxPooling2d(e) {
  return new GlobalMaxPooling2D(e);
}

function maxPooling1d(e) {
  return new MaxPooling1D(e);
}

function maxPooling2d(e) {
  return new MaxPooling2D(e);
}

function maxPooling3d(e) {
  return new MaxPooling3D(e);
}

function gru(e) {
  return new GRU(e);
}

function gruCell(e) {
  return new GRUCell(e);
}

function lstm(e) {
  return new LSTM(e);
}

function lstmCell(e) {
  return new LSTMCell(e);
}

function simpleRNN(e) {
  return new SimpleRNN(e);
}

function simpleRNNCell(e) {
  return new SimpleRNNCell(e);
}

function rnn$1(e) {
  return new RNN(e);
}

function stackedRNNCells(e) {
  return new StackedRNNCells(e);
}

function bidirectional(e) {
  return new Bidirectional(e);
}

function timeDistributed(e) {
  return new TimeDistributed(e);
}

_tfjsCore.serialization.registerClass(Bidirectional);

var globalMaxPool1d = globalMaxPooling1d,
    globalMaxPool2d = globalMaxPooling2d,
    maxPool1d = maxPooling1d,
    maxPool2d = maxPooling2d;

function gaussianNoise(e) {
  return new GaussianNoise(e);
}

function gaussianDropout(e) {
  return new GaussianDropout(e);
}

function alphaDropout(e) {
  return new AlphaDropout(e);
}

function masking(e) {
  return new Masking(e);
}

var exports_layers = Object.freeze({
  inputLayer: inputLayer,
  elu: elu$2,
  reLU: reLU,
  leakyReLU: leakyReLU,
  prelu: prelu$1,
  softmax: softmax$1,
  thresholdedReLU: thresholdedReLU,
  conv1d: conv1d$2,
  conv2d: conv2d$1,
  conv2dTranspose: conv2dTranspose$1,
  conv3d: conv3d$2,
  separableConv2d: separableConv2d$1,
  cropping2D: cropping2D,
  upSampling2d: upSampling2d,
  depthwiseConv2d: depthwiseConv2d$2,
  activation: activation,
  dense: dense,
  dropout: dropout$2,
  spatialDropout1d: spatialDropout1d,
  flatten: flatten$1,
  repeatVector: repeatVector,
  reshape: reshape,
  permute: permute,
  embedding: embedding,
  add: add$2,
  average: average$1,
  concatenate: concatenate$2,
  maximum: maximum$2,
  minimum: minimum$2,
  multiply: multiply$1,
  dot: dot$1,
  batchNormalization: batchNormalization$1,
  layerNormalization: layerNormalization,
  zeroPadding2d: zeroPadding2d,
  averagePooling1d: averagePooling1d,
  avgPool1d: avgPool1d,
  avgPooling1d: avgPooling1d,
  averagePooling2d: averagePooling2d,
  avgPool2d: avgPool2d,
  avgPooling2d: avgPooling2d,
  averagePooling3d: averagePooling3d,
  avgPool3d: avgPool3d$1,
  avgPooling3d: avgPooling3d,
  globalAveragePooling1d: globalAveragePooling1d,
  globalAveragePooling2d: globalAveragePooling2d,
  globalMaxPooling1d: globalMaxPooling1d,
  globalMaxPooling2d: globalMaxPooling2d,
  maxPooling1d: maxPooling1d,
  maxPooling2d: maxPooling2d,
  maxPooling3d: maxPooling3d,
  gru: gru,
  gruCell: gruCell,
  lstm: lstm,
  lstmCell: lstmCell,
  simpleRNN: simpleRNN,
  simpleRNNCell: simpleRNNCell,
  rnn: rnn$1,
  stackedRNNCells: stackedRNNCells,
  bidirectional: bidirectional,
  timeDistributed: timeDistributed,
  globalMaxPool1d: globalMaxPool1d,
  globalMaxPool2d: globalMaxPool2d,
  maxPool1d: maxPool1d,
  maxPool2d: maxPool2d,
  Layer: Layer,
  RNN: RNN,
  RNNCell: RNNCell,
  input: input,
  gaussianNoise: gaussianNoise,
  gaussianDropout: gaussianDropout,
  alphaDropout: alphaDropout,
  masking: masking
});
exports.layers = exports_layers;

function binaryAccuracy$1(e, t) {
  return binaryAccuracy(e, t);
}

function binaryCrossentropy$2(e, t) {
  return binaryCrossentropy$1(e, t);
}

function sparseCategoricalAccuracy$1(e, t) {
  return sparseCategoricalAccuracy(e, t);
}

function categoricalAccuracy$1(e, t) {
  return categoricalAccuracy(e, t);
}

function categoricalCrossentropy$2(e, t) {
  return categoricalCrossentropy$1(e, t);
}

function precision$1(e, t) {
  return precision(e, t);
}

function recall$1(e, t) {
  return recall(e, t);
}

function cosineProximity$1(e, t) {
  return cosineProximity(e, t);
}

function meanAbsoluteError$1(e, t) {
  return meanAbsoluteError(e, t);
}

function meanAbsolutePercentageError$1(e, t) {
  return meanAbsolutePercentageError(e, t);
}

function MAPE$2(e, t) {
  return meanAbsolutePercentageError(e, t);
}

function mape$2(e, t) {
  return meanAbsolutePercentageError(e, t);
}

function meanSquaredError$1(e, t) {
  return meanSquaredError(e, t);
}

function MSE$2(e, t) {
  return meanSquaredError(e, t);
}

function mse$2(e, t) {
  return meanSquaredError(e, t);
}

var exports_metrics = Object.freeze({
  binaryAccuracy: binaryAccuracy$1,
  binaryCrossentropy: binaryCrossentropy$2,
  sparseCategoricalAccuracy: sparseCategoricalAccuracy$1,
  categoricalAccuracy: categoricalAccuracy$1,
  categoricalCrossentropy: categoricalCrossentropy$2,
  precision: precision$1,
  recall: recall$1,
  cosineProximity: cosineProximity$1,
  meanAbsoluteError: meanAbsoluteError$1,
  meanAbsolutePercentageError: meanAbsolutePercentageError$1,
  MAPE: MAPE$2,
  mape: mape$2,
  meanSquaredError: meanSquaredError$1,
  MSE: MSE$2,
  mse: mse$2
}),
    exports_models = Object.freeze({
  modelFromJSON: modelFromJSON
});
exports.models = exports_models;
exports.metrics = exports_metrics;

function l1l2(e) {
  return new L1L2(e);
}

function l1$1(e) {
  return l1(e);
}

function l2$1(e) {
  return l2(e);
}

var exports_regularizers = Object.freeze({
  l1l2: l1l2,
  l1: l1$1,
  l2: l2$1
}),
    Callback = function (e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.model = null, t;
  }

  return __extends(t, e), t.prototype.setModel = function (e) {
    if (!(e instanceof LayersModel)) throw new Error("model must be a LayersModel, not some other Container");
    this.model = e;
  }, t;
}(BaseCallback);

exports.Callback = Callback;
exports.regularizers = exports_regularizers;

function less(e, t) {
  return e < t;
}

function greater$1(e, t) {
  return e > t;
}

var EarlyStopping = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if (null == t && (t = {}), t.restoreBestWeights) throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
    return n.monitor = t.monitor || "val_loss", n.minDelta = Math.abs(t.minDelta || 0), n.patience = t.patience || 0, n.verbose = t.verbose || 0, n.mode = t.mode || "auto", n.baseline = t.baseline, -1 === ["auto", "min", "max"].indexOf(n.mode) && (console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."), n.mode = "auto"), "min" === n.mode ? n.monitorFunc = less : "max" === n.mode ? n.monitorFunc = greater$1 : -1 !== n.monitor.indexOf("acc") ? n.monitorFunc = greater$1 : n.monitorFunc = less, n.monitorFunc === less && (n.minDelta *= -1), n;
  }

  return __extends(t, e), t.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === less ? 1 / 0 : -1 / 0, [2];
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, resolveScalarsInLogs(t)];

          case 1:
            return r.sent(), null == (n = this.getMonitorValue(t)) ? [2] : (this.monitorFunc(n - this.minDelta, this.best) ? (this.best = n, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = e, this.model.stopTraining = !0)), [2]);
        }
      });
    });
  }, t.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping."), [2];
      });
    });
  }, t.prototype.getMonitorValue = function (e) {
    null == e && (e = {});
    var t = e[this.monitor];
    return null == t && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(e)), t;
  }, t;
}(Callback);

exports.EarlyStopping = EarlyStopping;

function earlyStopping(e) {
  return new EarlyStopping(e);
}

var callbacks = {
  earlyStopping: earlyStopping
};
exports.callbacks = callbacks;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"../node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadGraphModel = loadGraphModel;
exports.deregisterOp = deregisterOp;
exports.registerOp = registerOp;
exports.version_converter = exports.GraphModel = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var DataType,
    SaverDef,
    __assign = function () {
  return (__assign = Object.assign || function (e) {
    for (var t, a = 1, r = arguments.length; a < r; a++) for (var n in t = arguments[a]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);

    return e;
  }).apply(this, arguments);
};

function __awaiter(e, t, a, r) {
  return new (a || (a = Promise))(function (n, s) {
    function o(e) {
      try {
        u(r.next(e));
      } catch (e) {
        s(e);
      }
    }

    function p(e) {
      try {
        u(r.throw(e));
      } catch (e) {
        s(e);
      }
    }

    function u(e) {
      e.done ? n(e.value) : new a(function (t) {
        t(e.value);
      }).then(o, p);
    }

    u((r = r.apply(e, t || [])).next());
  });
}

function __generator(e, t) {
  var a,
      r,
      n,
      s,
      o = {
    label: 0,
    sent: function () {
      if (1 & n[0]) throw n[1];
      return n[1];
    },
    trys: [],
    ops: []
  };
  return s = {
    next: p(0),
    throw: p(1),
    return: p(2)
  }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
    return this;
  }), s;

  function p(s) {
    return function (p) {
      return function (s) {
        if (a) throw new TypeError("Generator is already executing.");

        for (; o;) try {
          if (a = 1, r && (n = 2 & s[0] ? r.return : s[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, s[1])).done) return n;

          switch (r = 0, n && (s = [2 & s[0], n.value]), s[0]) {
            case 0:
            case 1:
              n = s;
              break;

            case 4:
              return o.label++, {
                value: s[1],
                done: !1
              };

            case 5:
              o.label++, r = s[1], s = [0];
              continue;

            case 7:
              s = o.ops.pop(), o.trys.pop();
              continue;

            default:
              if (!(n = (n = o.trys).length > 0 && n[n.length - 1]) && (6 === s[0] || 2 === s[0])) {
                o = 0;
                continue;
              }

              if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
                o.label = s[1];
                break;
              }

              if (6 === s[0] && o.label < n[1]) {
                o.label = n[1], n = s;
                break;
              }

              if (n && o.label < n[2]) {
                o.label = n[2], o.ops.push(s);
                break;
              }

              n[2] && o.ops.pop(), o.trys.pop();
              continue;
          }

          s = t.call(e, o);
        } catch (e) {
          s = [6, e], r = 0;
        } finally {
          a = n = 0;
        }

        if (5 & s[0]) throw s[1];
        return {
          value: s[0] ? s[1] : void 0,
          done: !0
        };
      }([s, p]);
    };
  }
}

!function (e) {
  e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(DataType || (DataType = {})), function (e) {
  !function (e) {
    e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2";
  }(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}));
}(SaverDef || (SaverDef = {}));
var CUSTOM_OPS = {};

function registerOp(e, t) {
  var a = {
    tfOpName: e,
    category: "custom",
    inputs: [],
    attrs: [],
    customExecutor: t
  };
  CUSTOM_OPS[e] = a;
}

function getRegisteredOp(e) {
  return CUSTOM_OPS[e];
}

function deregisterOp(e) {
  delete CUSTOM_OPS[e];
}

function getParamValue(e, t, a, r) {
  var n = t.inputParams[e];

  if (n && void 0 !== n.inputIndexStart) {
    var s = n.inputIndexStart,
        o = 0 === n.inputIndexEnd ? void 0 : void 0 === n.inputIndexEnd ? s + 1 : n.inputIndexEnd;
    if ("tensor" === n.type) return getTensor(t.inputNames[n.inputIndexStart], a, r);
    if ("tensors" === n.type) return t.inputNames.slice(s, o).map(function (e) {
      return getTensor(e, a, r);
    });
    var p = Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0], a, r).dataSync());
    return "number" === n.type ? p[0] : p;
  }

  var u = t.attrParams[e];
  return u && u.value;
}

function getTensor(e, t, a) {
  var r = parseNodeName(e),
      n = r[0],
      s = r[1],
      o = a.currentContextIds.find(function (e) {
    return !!t[getNodeNameWithContextId(n, e)];
  });
  return void 0 !== o ? t[getNodeNameWithContextId(n, o)][s] : void 0;
}

function getTensorsForCurrentContenxt(e, t, a) {
  return t[getNodeNameWithContextId(e, a.currentContextId)];
}

function getNodeNameAndIndex(e, t) {
  var a = parseNodeName(e),
      r = a[0],
      n = a[1];
  return [getNodeNameWithContextId(r, t && t.currentContextId), n];
}

function getNodeNameWithContextId(e, t) {
  return t ? e + "-" + t : e;
}

function parseNodeName(e) {
  var t = e.lastIndexOf(":");
  return -1 === t ? [e, 0] : [e.substring(0, t), Number(e.substring(t + 1))];
}

function split$1(e, t) {
  for (var a = [], r = 0; r < e.length; r += t) a.push(e.slice(r, r + t));

  return a;
}

var json = [{
  tfOpName: "Add",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "AddV2",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "AddN",
  category: "arithmetic",
  inputs: [{
    start: 0,
    end: 0,
    name: "tensors",
    type: "tensors"
  }]
}, {
  tfOpName: "BiasAdd",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sub",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "RealDiv",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Div",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "DivNoNan",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "FloorDiv",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Mul",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Maximum",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }]
}, {
  tfOpName: "Minimum",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }]
}, {
  tfOpName: "Pow",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "SquaredDifference",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Mod",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "FloorMod",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    arithmetic = Object.freeze({
  json: json
}),
    json$1 = [{
  tfOpName: "Abs",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Acos",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Asin",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Atan",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Atan2",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "y",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Ceil",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ClipByValue",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "clip_value_min",
    name: "clipValueMin",
    type: "number"
  }, {
    tfName: "clip_value_max",
    name: "clipValueMax",
    type: "number"
  }]
}, {
  tfOpName: "Complex",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "real",
    type: "tensor"
  }, {
    start: 1,
    name: "imag",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ComplexAbs",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Cos",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Cosh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Elu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Exp",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Floor",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Log",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Imag",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "Tout",
    name: "outputType",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Neg",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Real",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "Tout",
    name: "outputType",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Prelu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "alpha",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Relu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Relu6",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "clipValueMin",
    name: "clipValueMin",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "clipValueMax",
    name: "clipValueMax",
    type: "number",
    defaultValue: 6
  }]
}, {
  tfOpName: "Selu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sigmoid",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sin",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sinh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sqrt",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Rsqrt",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Square",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Tan",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Tanh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sign",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Round",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Expm1",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Log1p",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Reciprocal",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Softplus",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Asinh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Acosh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Atanh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Erf",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Prod",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axes",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool",
    notSupported: !0
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LeakyRelu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "alpha",
    name: "alpha",
    type: "number",
    defaultValue: .2
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    basicMath = Object.freeze({
  json: json$1
}),
    json$2 = [{
  tfOpName: "LoopCond",
  category: "control",
  inputs: [{
    start: 0,
    name: "pred",
    type: "tensor"
  }]
}, {
  tfOpName: "Switch",
  category: "control",
  inputs: [{
    start: 0,
    name: "data",
    type: "tensor"
  }, {
    start: 1,
    name: "pred",
    type: "tensor"
  }]
}, {
  tfOpName: "Merge",
  category: "control",
  inputs: [{
    start: 0,
    end: 0,
    name: "tensors",
    type: "tensors"
  }]
}, {
  tfOpName: "Enter",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "frame_name",
    name: "frameName",
    type: "string"
  }, {
    tfName: "is_constant",
    name: "isConstant",
    type: "bool"
  }]
}, {
  tfOpName: "Exit",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "NextIteration",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArrayV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "size",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "element_shape",
    name: "elementShape",
    type: "shape"
  }, {
    tfName: "dynamic_size",
    name: "dynamicSize",
    type: "bool"
  }, {
    tfName: "clear_after_read",
    name: "clearAfterRead",
    type: "bool"
  }, {
    tfName: "identical_element_shapes",
    name: "identicalElementShapes",
    type: "bool"
  }, {
    tfName: "tensor_array_name",
    name: "name",
    type: "string"
  }]
}, {
  tfOpName: "TensorArrayWriteV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "index",
    type: "number"
  }, {
    start: 2,
    name: "tensor",
    type: "tensor"
  }, {
    start: 3,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArrayReadV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "index",
    type: "number"
  }, {
    start: 2,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArrayGatherV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "indices",
    type: "number[]"
  }, {
    start: 2,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "element_shape",
    name: "elementShape",
    type: "shape"
  }]
}, {
  tfOpName: "TensorArrayScatterV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "indices",
    type: "number[]"
  }, {
    start: 2,
    name: "tensor",
    type: "tensor"
  }, {
    start: 3,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "TensorArrayConcatV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "element_shape_except0",
    name: "elementShapeExcept0",
    type: "shape",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArraySplitV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "tensor",
    type: "tensor"
  }, {
    start: 2,
    name: "lengths",
    type: "number[]"
  }, {
    start: 3,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "TensorArraySizeV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "flowIn",
    type: "number"
  }]
}, {
  tfOpName: "TensorArrayCloseV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }]
}],
    control = Object.freeze({
  json: json$2
}),
    json$3 = [{
  tfOpName: "AvgPool",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "MaxPool",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "AvgPool3D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "MaxPool3D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Conv1D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "stride",
    name: "stride",
    type: "number"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NWC"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "dilation",
    name: "dilation",
    type: "number",
    defaultValue: 1
  }]
}, {
  tfOpName: "Conv2D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "useCudnnOnGpu",
    name: "useCudnnOnGpu",
    type: "bool"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}, {
  tfOpName: "_FusedConv2D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }, {
    start: 2,
    end: 0,
    name: "args",
    type: "tensors"
  }],
  attrs: [{
    tfName: "num_args",
    name: "numArgs",
    type: "number"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "explicit_paddings",
    name: "explicitPaddings",
    type: "number[]",
    defaultValue: []
  }, {
    tfName: "use_cudnn_on_gpu",
    name: "useCudnnOnGpu",
    type: "bool",
    defaultValue: !0
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]",
    defaultValue: [1, 1, 1, 1]
  }, {
    tfName: "fused_ops",
    name: "fusedOps",
    type: "string[]",
    defaultValue: []
  }, {
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: 1e-4
  }]
}, {
  tfOpName: "Conv2DBackpropInput",
  category: "convolution",
  inputs: [{
    start: 2,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }, {
    start: 0,
    name: "outputShape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "DepthwiseConv2d",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "input",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}, {
  tfOpName: "DepthwiseConv2dNative",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "input",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}, {
  tfOpName: "Conv3D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}],
    convolution = Object.freeze({
  json: json$3
}),
    json$4 = [{
  tfOpName: "Fill",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }, {
    start: 1,
    name: "value",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "LinSpace",
  category: "creation",
  inputs: [{
    start: 0,
    name: "start",
    type: "number"
  }, {
    start: 1,
    name: "stop",
    type: "number"
  }, {
    start: 2,
    name: "num",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "OneHot",
  category: "creation",
  inputs: [{
    start: 0,
    name: "indices",
    type: "tensor"
  }, {
    start: 1,
    name: "depth",
    type: "number"
  }, {
    start: 2,
    name: "onValue",
    type: "number",
    defaultValue: 1
  }, {
    start: 3,
    name: "offValue",
    type: "number",
    defaultValue: 0
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    notSupported: !0
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Ones",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "OnesLike",
  category: "creation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "RandomUniform",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "minval",
    name: "minval",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "maxval",
    name: "maxval",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "seed",
    name: "seed",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "seed2",
    name: "seed2",
    type: "number",
    defaultValue: 0,
    notSupported: !0
  }, {
    tfName: "T",
    name: "T",
    type: "number",
    notSupported: !0
  }]
}, {
  tfOpName: "Range",
  category: "creation",
  inputs: [{
    start: 0,
    name: "start",
    type: "number"
  }, {
    start: 1,
    name: "stop",
    type: "number"
  }, {
    start: 2,
    name: "step",
    type: "number",
    defaultValue: 0
  }],
  attrs: [{
    tfName: "Tidx",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "TruncatedNormal",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "means",
    name: "mean",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "stddev",
    name: "stdDev",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "seed",
    name: "seed",
    type: "number"
  }, {
    tfName: "seed2",
    name: "seed2",
    type: "number",
    defaultValue: 0,
    notSupported: !0
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "T",
    name: "T",
    type: "number",
    notSupported: !0
  }]
}, {
  tfOpName: "Zeros",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "ZerosLike",
  category: "creation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "Multinomial",
  category: "creation",
  inputs: [{
    start: 0,
    name: "logits",
    type: "tensor"
  }, {
    start: 1,
    name: "numSamples",
    type: "number"
  }],
  attrs: [{
    tfName: "seed",
    name: "seed",
    type: "number"
  }, {
    tfName: "seed2",
    name: "seed2",
    type: "number"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "output_dtype",
    name: "output_dtype",
    type: "dtype"
  }]
}],
    creation = Object.freeze({
  json: json$4
}),
    json$5 = [{
  tfOpName: "NonMaxSuppressionV2",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "boxes",
    type: "tensor"
  }, {
    start: 1,
    name: "scores",
    type: "tensor"
  }, {
    start: 2,
    name: "maxOutputSize",
    type: "number"
  }, {
    start: 3,
    name: "iouThreshold",
    type: "number"
  }]
}, {
  tfOpName: "NonMaxSuppressionV3",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "boxes",
    type: "tensor"
  }, {
    start: 1,
    name: "scores",
    type: "tensor"
  }, {
    start: 2,
    name: "maxOutputSize",
    type: "number"
  }, {
    start: 3,
    name: "iouThreshold",
    type: "number"
  }, {
    start: 4,
    name: "scoreThreshold",
    type: "number"
  }]
}, {
  tfOpName: "Where",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "condition",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ListDiff",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "y",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    dynamic = Object.freeze({
  json: json$5
}),
    json$6 = [{
  tfOpName: "TopKV2",
  category: "evaluation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "k",
    type: "number"
  }],
  attrs: [{
    tfName: "sorted",
    name: "sorted",
    type: "bool"
  }]
}],
    evaluation = Object.freeze({
  json: json$6
}),
    json$7 = [{
  tfOpName: "PlaceholderWithDefault",
  category: "graph",
  inputs: [{
    start: 0,
    name: "default",
    type: "tensor"
  }],
  attrs: [{
    tfName: "shape",
    name: "shape",
    type: "shape"
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "Placeholder",
  category: "graph",
  attrs: [{
    tfName: "shape",
    name: "shape",
    type: "shape"
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "Const",
  category: "graph"
}, {
  tfOpName: "Identity",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "IdentityN",
  category: "graph",
  inputs: [{
    start: 0,
    end: 0,
    name: "x",
    type: "tensors"
  }]
}, {
  tfOpName: "Snapshot",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "Rank",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "Size",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "Shape",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "ShapeN",
  category: "graph",
  inputs: [{
    start: 0,
    end: 0,
    name: "x",
    type: "tensors"
  }]
}, {
  tfOpName: "Print",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "data",
    type: "tensors"
  }],
  attrs: [{
    tfName: "message",
    name: "message",
    type: "string"
  }, {
    tfName: "first_n",
    name: "firstN",
    type: "number",
    notSupported: !0
  }, {
    tfName: "summarize",
    name: "summarize",
    type: "number",
    defaultValue: 3
  }]
}, {
  tfOpName: "NoOp",
  category: "graph",
  inputs: []
}, {
  tfOpName: "StopGradient",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "FakeQuantWithMinMaxVars",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "min",
    name: "min",
    type: "number"
  }, {
    tfName: "max",
    name: "max",
    type: "number"
  }]
}],
    graph = Object.freeze({
  json: json$7
}),
    json$8 = [{
  tfOpName: "ResizeBilinear",
  category: "image",
  inputs: [{
    start: 0,
    name: "images",
    type: "tensor"
  }, {
    start: 1,
    name: "size",
    type: "number[]"
  }],
  attrs: [{
    tfName: "align_corners",
    name: "alignCorners",
    type: "bool"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ResizeNearestNeighbor",
  category: "image",
  inputs: [{
    start: 0,
    name: "images",
    type: "tensor"
  }, {
    start: 1,
    name: "size",
    type: "number[]"
  }],
  attrs: [{
    tfName: "align_corners",
    name: "alignCorners",
    type: "bool"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "CropAndResize",
  category: "image",
  inputs: [{
    start: 0,
    name: "image",
    type: "tensor"
  }, {
    start: 1,
    name: "boxes",
    type: "tensor"
  }, {
    start: 2,
    name: "boxInd",
    type: "tensor"
  }, {
    start: 3,
    name: "cropSize",
    type: "number[]"
  }],
  attrs: [{
    tfName: "method",
    name: "method",
    type: "string"
  }, {
    tfName: "extrapolation_value",
    name: "extrapolationValue",
    type: "number"
  }]
}],
    image$1 = Object.freeze({
  json: json$8
}),
    json$9 = [{
  tfOpName: "Equal",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "NotEqual",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Greater",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "GreaterEqual",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Less",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LessEqual",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LogicalAnd",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LogicalNot",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LogicalOr",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Select",
  category: "logical",
  inputs: [{
    start: 0,
    name: "condition",
    type: "tensor"
  }, {
    start: 1,
    name: "a",
    type: "tensor"
  }, {
    start: 2,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    logical = Object.freeze({
  json: json$9
}),
    json$10 = [{
  tfOpName: "MatMul",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "transpose_a",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "transpose_b",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "BatchMatMul",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "adj_x",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "adj_y",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "BatchMatMulV2",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "adj_x",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "adj_y",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Transpose",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "perm",
    type: "number[]"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    matrices = Object.freeze({
  json: json$10
}),
    json$11 = [{
  tfOpName: "FusedBatchNorm",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "scale",
    type: "tensor"
  }, {
    start: 2,
    name: "offset",
    type: "tensor"
  }, {
    start: 3,
    name: "mean",
    type: "tensor"
  }, {
    start: 4,
    name: "variance",
    type: "tensor"
  }],
  attrs: [{
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: .001
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "FusedBatchNormV2",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "scale",
    type: "tensor"
  }, {
    start: 2,
    name: "offset",
    type: "tensor"
  }, {
    start: 3,
    name: "mean",
    type: "tensor"
  }, {
    start: 4,
    name: "variance",
    type: "tensor"
  }],
  attrs: [{
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: .001
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "FusedBatchNormV3",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "scale",
    type: "tensor"
  }, {
    start: 2,
    name: "offset",
    type: "tensor"
  }, {
    start: 3,
    name: "mean",
    type: "tensor"
  }, {
    start: 4,
    name: "variance",
    type: "tensor"
  }],
  attrs: [{
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: .001
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "LRN",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "depth_radius",
    name: "radius",
    type: "number",
    defaultValue: 5
  }, {
    tfName: "bias",
    name: "bias",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "alpha",
    name: "alpha",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "beta",
    name: "beta",
    type: "number",
    defaultValue: .5
  }]
}, {
  tfOpName: "Softmax",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "LogSoftmax",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "SparseToDense",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "sparseIndices",
    type: "tensor"
  }, {
    start: 1,
    name: "outputShape",
    type: "number[]"
  }, {
    start: 2,
    name: "sparseValues",
    type: "tensor"
  }, {
    start: 3,
    name: "defaultValue",
    type: "tensor"
  }],
  attrs: [{
    tfName: "validate_indices",
    name: "validateIndices",
    type: "bool",
    defaultValue: !0,
    notSupported: !0
  }]
}],
    normalization = Object.freeze({
  json: json$11
}),
    json$12 = [{
  tfOpName: "Max",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Mean",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Min",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Sum",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "All",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Any",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "ArgMax",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number"
  }]
}, {
  tfOpName: "ArgMin",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number"
  }]
}, {
  tfOpName: "Prod",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}],
    reduction = Object.freeze({
  json: json$12
}),
    json$13 = [{
  tfOpName: "ConcatV2",
  category: "slice_join",
  inputs: [{
    start: 0,
    end: -1,
    name: "tensors",
    type: "tensors"
  }, {
    start: -1,
    name: "axis",
    type: "number"
  }],
  attrs: [{
    tfName: "N",
    name: "n",
    type: "number",
    defaultValue: 2
  }]
}, {
  tfOpName: "Concat",
  category: "slice_join",
  inputs: [{
    start: 1,
    end: 0,
    name: "tensors",
    type: "tensors"
  }, {
    start: 0,
    name: "axis",
    type: "number"
  }],
  attrs: [{
    tfName: "N",
    name: "n",
    type: "number",
    defaultValue: 2
  }]
}, {
  tfOpName: "GatherV2",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "indices",
    type: "tensor"
  }, {
    start: 2,
    name: "axis",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Gather",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "indices",
    type: "tensor"
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "validate_indices",
    name: "validateIndices",
    type: "bool",
    notSupported: !0
  }]
}, {
  tfOpName: "Reverse",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "dims",
    type: "bool",
    notSupported: !0
  }]
}, {
  tfOpName: "ReverseV2",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }]
}, {
  tfOpName: "Slice",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "begin",
    type: "number[]"
  }, {
    start: 2,
    name: "size",
    type: "number[]"
  }]
}, {
  tfOpName: "StridedSlice",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "begin",
    type: "number[]"
  }, {
    start: 2,
    name: "end",
    type: "number[]"
  }, {
    start: 3,
    name: "strides",
    type: "number[]"
  }],
  attrs: [{
    tfName: "begin_mask",
    name: "beginMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "end_mask",
    name: "endMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "new_axis_mask",
    name: "newAxisMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "ellipsis_mask",
    name: "ellipsisMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "shrink_axis_mask",
    name: "shrinkAxisMask",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Pack",
  category: "slice_join",
  inputs: [{
    start: 0,
    end: 0,
    name: "tensors",
    type: "tensors"
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Unpack",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "num",
    name: "num",
    type: "number",
    defaultValue: 0,
    notSupported: !0
  }]
}, {
  tfOpName: "Tile",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "reps",
    type: "number[]"
  }]
}, {
  tfOpName: "Split",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "axis",
    type: "number",
    defaultValue: 0
  }, {
    start: 1,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "num_split",
    name: "numOrSizeSplits",
    type: "number",
    defaultValue: 1
  }]
}, {
  tfOpName: "SplitV",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "numOrSizeSplits",
    type: "number[]"
  }, {
    start: 2,
    name: "axis",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "ScatterNd",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "indices",
    type: "tensor"
  }, {
    start: 1,
    name: "values",
    type: "tensor"
  }, {
    start: 2,
    name: "shape",
    type: "number[]"
  }]
}, {
  tfOpName: "GatherNd",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "indices",
    type: "tensor"
  }]
}, {
  tfOpName: "SparseToDense",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "sparseIndices",
    type: "tensor"
  }, {
    start: 1,
    name: "outputShape",
    type: "number[]"
  }, {
    start: 2,
    name: "sparseValues",
    type: "tensor"
  }, {
    start: 3,
    name: "defaultValue",
    type: "tensor"
  }],
  attrs: [{
    tfName: "validate_indices",
    name: "validateIndices",
    type: "bool",
    defaultValue: !1,
    notSupported: !0
  }]
}],
    sliceJoin = Object.freeze({
  json: json$13
}),
    json$14 = [{
  tfOpName: "FFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "IFFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "RFFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "fft_length",
    type: "number",
    notSupported: !0
  }]
}, {
  tfOpName: "IRFFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "fft_length",
    type: "number",
    notSupported: !0
  }]
}],
    spectral = Object.freeze({
  json: json$14
}),
    json$15 = [{
  tfOpName: "Cast",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "SrcT",
    name: "sdtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "DstT",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "ExpandDims",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number"
  }]
}, {
  tfOpName: "Pad",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "padding",
    type: "number[]"
  }],
  attrs: [{
    tfName: "constant_value",
    name: "constantValue",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "PadV2",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "padding",
    type: "number[]"
  }, {
    start: 2,
    name: "constantValue",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Reshape",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "shape",
    type: "number[]"
  }]
}, {
  tfOpName: "Squeeze",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "axis",
    tfDeprecatedName: "squeeze_dims",
    name: "axis",
    type: "number[]"
  }]
}, {
  tfOpName: "SpaceToBatchND",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "blockShape",
    type: "number[]"
  }, {
    start: 2,
    name: "paddings",
    type: "number[]"
  }]
}, {
  tfOpName: "BatchToSpaceND",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "blockShape",
    type: "number[]"
  }, {
    start: 2,
    name: "crops",
    type: "number[]"
  }]
}, {
  tfOpName: "DepthToSpace",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "block_size",
    name: "blockSize",
    type: "number"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string"
  }]
}],
    transformation = Object.freeze({
  json: json$15
}),
    OperationMapper = function () {
  function e() {
    var e = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image$1, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation],
        t = [].concat.apply([], e.map(function (e) {
      return e.json;
    }));
    this.opMappers = t.reduce(function (e, t) {
      return e[t.tfOpName] = t, e;
    }, {});
  }

  return Object.defineProperty(e, "Instance", {
    get: function () {
      return this._instance || (this._instance = new this());
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.transformGraph = function (e) {
    var t = this,
        a = [],
        r = [],
        n = e.node.reduce(function (e, n) {
      return e[n.name] = t.mapNode(n), "Placeholder" === n.op && a.push(e[n.name]), "Const" === n.op && r.push(e[n.name]), e;
    }, {}),
        s = [],
        o = [],
        p = Object.keys(n);
    return p.forEach(function (e) {
      var t = n[e];
      t.inputNames.forEach(function (e) {
        var a = getNodeNameAndIndex(e)[0];
        t.inputs.push(n[a]), n[a].children.push(t);
      }), 0 === t.inputs.length && s.push(t);
    }), p.forEach(function (e) {
      var t = n[e];
      0 === t.children.length && o.push(t);
    }), {
      nodes: n,
      inputs: s,
      outputs: o,
      weights: r,
      placeholders: a
    };
  }, e.prototype.mapNode = function (e) {
    var t = getRegisteredOp(e.op) || this.opMappers[e.op] || {};
    null == e.attr && (e.attr = {});
    var a = {
      name: e.name,
      op: e.op,
      category: t.category,
      inputNames: (e.input || []).map(function (e) {
        return e.startsWith("^") ? e.substr(1) : e;
      }),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: e.attr
    };
    return null != t.inputs && (a.inputParams = t.inputs.reduce(function (e, t) {
      return e[t.name] = {
        type: t.type,
        inputIndexStart: t.start,
        inputIndexEnd: t.end
      }, e;
    }, {})), null != t.attrs && (a.attrParams = t.attrs.reduce(function (t, a) {
      var r = a.type,
          n = void 0;

      switch (a.type) {
        case "string":
          void 0 === (n = getStringParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "string[]":
          void 0 === (n = getStringArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "number":
          void 0 === (n = getNumberParam(e.attr, a.tfName, a.defaultValue || 0)) && a.tfDeprecatedName && (n = getNumberParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "number[]":
          void 0 === (n = getNumericArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getNumericArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "bool":
          void 0 === (n = getBoolParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "bool[]":
          void 0 === (n = getBoolArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "shape":
          void 0 === (n = getTensorShapeParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "shape[]":
          void 0 === (n = getTensorShapeArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "dtype":
          void 0 === (n = getDtypeParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "dtype[]":
          void 0 === (n = getDtypeArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "tensor":
        case "tensors":
          break;

        default:
          throw new Error("Unsupported param type: " + a.type + " for op: " + e.op);
      }

      return t[a.name] = {
        value: n,
        type: r
      }, t;
    }, {})), a;
  }, e;
}();

function decodeBase64(e) {
  var t = (0, _tfjsCore.env)().global;
  if (void 0 !== t.atob) return t.atob(e);
  if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}

function parseStringParam(e, t) {
  var a = Array.isArray(e) ? String.fromCharCode.apply(null, e) : decodeBase64(e);
  return t ? a : a.toLowerCase();
}

function getStringParam(e, t, a, r) {
  void 0 === r && (r = !1);
  var n = e[t];
  return null != n ? parseStringParam(n.s, r) : a;
}

function getBoolParam(e, t, a) {
  var r = e[t];
  return r ? r.b : a;
}

function getNumberParam(e, t, a) {
  var r = e[t] || {},
      n = null != r.i ? r.i : null != r.f ? r.f : a;
  return "number" == typeof n ? n : parseInt(n, 10);
}

function parseDtypeParam(e) {
  switch ("string" == typeof e && (e = DataType[e]), e) {
    case DataType.DT_FLOAT:
      return "float32";

    case DataType.DT_INT32:
    case DataType.DT_INT64:
      return "int32";

    case DataType.DT_BOOL:
      return "bool";

    case DataType.DT_DOUBLE:
      return "float32";

    case DataType.DT_STRING:
      return "string";

    default:
      return null;
  }
}

function getDtypeParam(e, t, a) {
  var r = e[t];
  return r && r.type ? parseDtypeParam(r.type) : a;
}

function getDtypeArrayParam(e, t, a) {
  var r = e[t];
  return r && r.list && r.list.type ? r.list.type.map(function (e) {
    return parseDtypeParam(e);
  }) : a;
}

function parseTensorShapeParam(e) {
  if (!e.unknownRank) return null != e.dim ? e.dim.map(function (e) {
    return "number" == typeof e.size ? e.size : parseInt(e.size, 10);
  }) : [];
}

function getTensorShapeParam(e, t, a) {
  var r = e[t];
  return r && r.shape ? parseTensorShapeParam(r.shape) : a;
}

function getNumericArrayParam(e, t, a) {
  var r = e[t];
  return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function (e) {
    return "number" == typeof e ? e : parseInt(e, 10);
  }) : a;
}

function getStringArrayParam(e, t, a, r) {
  void 0 === r && (r = !1);
  var n = e[t];
  return n && n.list && n.list.s ? n.list.s.map(function (e) {
    return parseStringParam(e, r);
  }) : a;
}

function getTensorShapeArrayParam(e, t, a) {
  var r = e[t];
  return r && r.list && r.list.shape ? r.list.shape.map(function (e) {
    return parseTensorShapeParam(e);
  }) : a;
}

function getBoolArrayParam(e, t, a) {
  var r = e[t];
  return r && r.list && r.list.b ? r.list.b : a;
}

var NodeValueImpl = function () {
  function e(e, t, a) {
    var r = this;
    this.node = e, this.tensorMap = t, this.context = a, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map(function (e) {
      return r.getInput(e);
    }), null != e.rawAttrs && (this.attrs = Object.keys(e.rawAttrs).reduce(function (e, t) {
      return e[t] = r.getAttr(t), e;
    }, {}));
  }

  return e.prototype.getInput = function (e) {
    return getTensor(e, this.tensorMap, this.context);
  }, e.prototype.getAttr = function (e, t) {
    var a = this.node.rawAttrs[e];
    if (null != a.tensor) return getTensor(e, this.tensorMap, this.context);
    if (null != a.i || null != a.f) return getNumberParam(this.node.rawAttrs, e, t);
    if (null != a.s) return getStringParam(this.node.rawAttrs, e, t);
    if (null != a.b) return getBoolParam(this.node.rawAttrs, e, t);
    if (null != a.shape) return getTensorShapeParam(this.node.rawAttrs, e, t);
    if (null != a.type) return getDtypeParam(this.node.rawAttrs, e, t);

    if (null != a.list) {
      if (null != a.list.i || null != a.list.f) return getNumericArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.s) return getStringArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.shape) return getTensorShapeArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.b) return getBoolArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.type) return getDtypeArrayParam(this.node.rawAttrs, e, t);
    }

    return t;
  }, e;
}(),
    executeOp = function (e, t, a) {
  switch (e.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [(0, _tfjsCore.add)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "AddN":
      return [(0, _tfjsCore.addN)(getParamValue("tensors", e, t, a))];

    case "FloorMod":
    case "Mod":
      return [(0, _tfjsCore.mod)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Mul":
      return [(0, _tfjsCore.mul)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "RealDiv":
    case "Div":
      return [(0, _tfjsCore.div)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "DivNoNan":
      return [(0, _tfjsCore.divNoNan)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "FloorDiv":
      return [(0, _tfjsCore.floorDiv)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Sub":
      return [(0, _tfjsCore.sub)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Minimum":
      return [(0, _tfjsCore.minimum)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Maximum":
      return [(0, _tfjsCore.maximum)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Pow":
      return [(0, _tfjsCore.pow)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "SquaredDifference":
      return [(0, _tfjsCore.squaredDifference)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$1 = function (e, t, a) {
  switch (e.op) {
    case "Abs":
    case "ComplexAbs":
      return [(0, _tfjsCore.abs)(getParamValue("x", e, t, a))];

    case "Acos":
      return [(0, _tfjsCore.acos)(getParamValue("x", e, t, a))];

    case "Acosh":
      return [(0, _tfjsCore.acosh)(getParamValue("x", e, t, a))];

    case "Asin":
      return [(0, _tfjsCore.asin)(getParamValue("x", e, t, a))];

    case "Asinh":
      return [(0, _tfjsCore.asinh)(getParamValue("x", e, t, a))];

    case "Atan":
      return [(0, _tfjsCore.atan)(getParamValue("x", e, t, a))];

    case "Atan2":
      return [(0, _tfjsCore.atan2)(getParamValue("x", e, t, a), getParamValue("y", e, t, a))];

    case "Atanh":
      return [(0, _tfjsCore.atanh)(getParamValue("x", e, t, a))];

    case "Ceil":
      return [(0, _tfjsCore.ceil)(getParamValue("x", e, t, a))];

    case "Complex":
      return [(0, _tfjsCore.complex)(getParamValue("real", e, t, a), getParamValue("imag", e, t, a))];

    case "Cos":
      return [(0, _tfjsCore.cos)(getParamValue("x", e, t, a))];

    case "Cosh":
      return [(0, _tfjsCore.cosh)(getParamValue("x", e, t, a))];

    case "Elu":
      return [(0, _tfjsCore.elu)(getParamValue("x", e, t, a))];

    case "Erf":
      return [(0, _tfjsCore.erf)(getParamValue("x", e, t, a))];

    case "Exp":
      return [(0, _tfjsCore.exp)(getParamValue("x", e, t, a))];

    case "Expm1":
      return [(0, _tfjsCore.expm1)(getParamValue("x", e, t, a))];

    case "Floor":
      return [(0, _tfjsCore.floor)(getParamValue("x", e, t, a))];

    case "Log":
      return [(0, _tfjsCore.log)(getParamValue("x", e, t, a))];

    case "Log1p":
      return [(0, _tfjsCore.log1p)(getParamValue("x", e, t, a))];

    case "Imag":
      return [(0, _tfjsCore.imag)(getParamValue("x", e, t, a))];

    case "Neg":
      return [(0, _tfjsCore.neg)(getParamValue("x", e, t, a))];

    case "Reciprocal":
      return [(0, _tfjsCore.reciprocal)(getParamValue("x", e, t, a))];

    case "Real":
      return [(0, _tfjsCore.real)(getParamValue("x", e, t, a))];

    case "Relu":
      return [(0, _tfjsCore.relu)(getParamValue("x", e, t, a))];

    case "Round":
      return [(0, _tfjsCore.round)(getParamValue("x", e, t, a))];

    case "Selu":
      return [(0, _tfjsCore.selu)(getParamValue("x", e, t, a))];

    case "Sigmoid":
      return [(0, _tfjsCore.sigmoid)(getParamValue("x", e, t, a))];

    case "Sin":
      return [(0, _tfjsCore.sin)(getParamValue("x", e, t, a))];

    case "Sign":
      return [(0, _tfjsCore.sign)(getParamValue("x", e, t, a))];

    case "Sinh":
      return [(0, _tfjsCore.sinh)(getParamValue("x", e, t, a))];

    case "Softplus":
      return [(0, _tfjsCore.softplus)(getParamValue("x", e, t, a))];

    case "Sqrt":
      return [(0, _tfjsCore.sqrt)(getParamValue("x", e, t, a))];

    case "Square":
      return [(0, _tfjsCore.square)(getParamValue("x", e, t, a))];

    case "Tanh":
      return [(0, _tfjsCore.tanh)(getParamValue("x", e, t, a))];

    case "Tan":
      return [(0, _tfjsCore.tan)(getParamValue("x", e, t, a))];

    case "Relu6":
    case "ClipByValue":
      return [(0, _tfjsCore.clipByValue)(getParamValue("x", e, t, a), getParamValue("clipValueMin", e, t, a), getParamValue("clipValueMax", e, t, a))];

    case "Rsqrt":
      return [(0, _tfjsCore.rsqrt)(getTensor(e.inputNames[0], t, a))];

    case "Prod":
      return [(0, _tfjsCore.prod)(getParamValue("x", e, t, a), getParamValue("axes", e, t, a))];

    case "LeakyRelu":
      return [(0, _tfjsCore.leakyRelu)(getParamValue("x", e, t, a), getParamValue("alpha", e, t, a))];

    case "Prelu":
      return [(0, _tfjsCore.prelu)(getParamValue("x", e, t, a), getParamValue("alpha", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    TensorArray = function () {
  function e(t, a, r, n, s, o, p) {
    this.name = t, this.dtype = a, this.maxSize = r, this.elementShape = n, this.identicalElementShapes = s, this.dynamicSize = o, this.clearAfterRead = p, this.tensors = [], this.closed_ = !1, this.id = e.nextId++;
  }

  return Object.defineProperty(e.prototype, "closed", {
    get: function () {
      return this.closed_;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.clearAndClose = function () {
    this.tensors.forEach(function (e) {
      return e.tensor.dispose();
    }), this.tensors = [], this.closed_ = !0;
  }, e.prototype.size = function () {
    return this.tensors.length;
  }, e.prototype.read = function (e) {
    if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e < 0 || e >= this.tensors.length) throw new Error("Tried to read from index " + e + ", but array size is: " + this.tensors.length);
    var t = this.tensors[e];
    if (t.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + e + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
    return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;
  }, e.prototype.readMany = function (e) {
    var t = this;
    return e.map(function (e) {
      return t.read(e);
    });
  }, e.prototype.write = function (e, t) {
    if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error("Tried to write to index " + e + ", but array is not resizeable and size is: " + this.maxSize);
    var a = this.tensors[e] || {};
    if (t.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ",\n          because the value dtype is " + t.dtype + ", but TensorArray dtype is " + this.dtype + ".");
    if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e + "."), a && a.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been read.");
    if (a && a.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been written.");
    a.tensor = t, a.written = !0, this.tensors[e] = a;
  }, e.prototype.writeMany = function (e, t) {
    var a = this;
    if (e.length !== t.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e.length + " is not the same as tensors size: " + t.length + ".");
    e.forEach(function (e, r) {
      return a.write(e, t[r]);
    });
  }, e.prototype.gather = function (e, t) {
    if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t);

    if (!e) {
      e = [];

      for (var a = 0; a < this.size(); a++) e.push(a);
    }

    if (0 === e.length) return (0, _tfjsCore.tensor)([], [0].concat(this.elementShape));
    var r = this.readMany(e);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), (0, _tfjsCore.stack)(r, 0);
  }, e.prototype.concat = function (e) {
    if (e && e !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e);
    if (0 === this.size()) return (0, _tfjsCore.tensor)([], [0].concat(this.elementShape));

    for (var t = [], a = 0; a < this.size(); a++) t.push(a);

    var r = this.readMany(t);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r[0].shape + ")"), (0, _tfjsCore.concat)(r, 0);
  }, e.prototype.scatter = function (e, t) {
    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
    if (e.length !== t.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e.length + " vs. " + t.shape[0]);
    var a = Math.max.apply(Math, e);
    if (!this.dynamicSize && a >= this.maxSize) throw new Error("Max index must be < array size (" + a + "  vs. " + this.maxSize + ")");
    this.writeMany(e, (0, _tfjsCore.unstack)(t, 0));
  }, e.prototype.split = function (e, t) {
    var a = this;
    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
    var r = 0,
        n = e.map(function (e) {
      return r += e;
    });
    if (r !== t.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + t.shape);
    if (!this.dynamicSize && e.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e.length + "), and the TensorArray is not marked as dynamically resizeable");
    var s = 0 === r ? 0 : t.size / r,
        o = [];
    (0, _tfjsCore.tidy)(function () {
      t = t.reshape([1, r, s]);

      for (var p = 0; p < e.length; ++p) {
        var u = [0, 0 === p ? 0 : n[p - 1], 0],
            i = [1, e[p], s];
        o[p] = (0, _tfjsCore.slice)(t, u, i).reshape(a.elementShape);
      }

      return o;
    });

    for (var p = [], u = 0; u < e.length; u++) p[u] = u;

    this.writeMany(p, o);
  }, e.prototype.assertShapesMatchAllowUndefinedSize = function (e, t, a) {
    void 0 === a && (a = ""), _tfjsCore.util.assert(this.shapesEqualAllowUndefinedSize(e, t), function () {
      return a + " Shapes " + e + " and " + t + " must match";
    });
  }, e.prototype.shapesEqualAllowUndefinedSize = function (e, t) {
    if (e.length !== t.length) return !1;

    for (var a = 0; a < e.length; a++) if (-1 !== e[a] && -1 !== t[a] && e[a] !== t[a]) return !1;

    return !0;
  }, e.nextId = 0, e;
}();

function executeOp$2(e, t, a) {
  return __awaiter(this, void 0, void 0, function () {
    var r, n, s, o, p, u, i, m, l, c, d, y, f, g, h, N, x, V, P, b, T, O, v, S, _, w, A, D, E, I, C, M, k, z, j;

    return __generator(this, function (F) {
      switch (F.label) {
        case 0:
          switch (e.op) {
            case "LoopCond":
              return [3, 1];

            case "Switch":
              return [3, 2];

            case "Merge":
              return [3, 4];

            case "Enter":
              return [3, 5];

            case "Exit":
              return [3, 6];

            case "NextIteration":
              return [3, 7];

            case "TensorArrayV3":
              return [3, 8];

            case "TensorArrayWriteV3":
              return [3, 9];

            case "TensorArrayReadV3":
              return [3, 10];

            case "TensorArrayGatherV3":
              return [3, 11];

            case "TensorArrayScatterV3":
              return [3, 12];

            case "TensorArrayConcatV3":
              return [3, 13];

            case "TensorArraySplitV3":
              return [3, 14];

            case "TensorArraySizeV3":
              return [3, 15];

            case "TensorArrayCloseV3":
              return [3, 16];
          }

          return [3, 17];

        case 1:
          return [2, [getParamValue("pred", e, t, a).clone()]];

        case 2:
          return r = getParamValue("pred", e, t, a), n = getParamValue("data", e, t, a), [4, r.data()];

        case 3:
          return [2, F.sent()[0] ? [void 0, n.clone()] : [n.clone(), void 0]];

        case 4:
          return [2, (s = e.inputNames.find(function (e) {
            return void 0 !== getTensor(e, t, a);
          })) ? [getTensor(s, t, a).clone()] : void 0];

        case 5:
          return o = getParamValue("frameName", e, t, a), p = getParamValue("tensor", e, t, a), a.enterFrame(o), [2, [p.clone()]];

        case 6:
          return u = getParamValue("tensor", e, t, a), a.exitFrame(), [2, [u.clone()]];

        case 7:
          return i = getParamValue("tensor", e, t, a), a.nextIteration(), [2, [i.clone()]];

        case 8:
          return m = getParamValue("size", e, t, a), l = getParamValue("dtype", e, t, a), c = getParamValue("elementShape", e, t, a), d = getParamValue("dynamicSize", e, t, a), y = getParamValue("clearAfterRead", e, t, a), f = getParamValue("identicalElementShapes", e, t, a), g = getParamValue("name", e, t, a), h = new TensorArray(g, l, m, c, f, d, y), a.addTensorArray(h), [2, [(0, _tfjsCore.scalar)(h.id), (0, _tfjsCore.scalar)(1)]];

        case 9:
          return N = getParamValue("tensorArrayId", e, t, a), x = getParamValue("index", e, t, a), V = getParamValue("tensor", e, t, a), a.getTensorArray(N).write(x, V), [2, [(0, _tfjsCore.scalar)(1)]];

        case 10:
          return P = getParamValue("tensorArrayId", e, t, a), b = getParamValue("index", e, t, a), [2, [a.getTensorArray(P).read(b)]];

        case 11:
          return T = getParamValue("tensorArrayId", e, t, a), O = getParamValue("indices", e, t, a), v = getParamValue("dtype", e, t, a), [2, [a.getTensorArray(T).gather(O, v)]];

        case 12:
          return S = getParamValue("tensorArrayId", e, t, a), _ = getParamValue("indices", e, t, a), w = getParamValue("tensor", e, t, a), a.getTensorArray(S).scatter(_, w), [2, [(0, _tfjsCore.scalar)(1)]];

        case 13:
          return A = getParamValue("tensorArrayId", e, t, a), D = a.getTensorArray(A), E = getParamValue("dtype", e, t, a), [2, [D.concat(E)]];

        case 14:
          return I = getParamValue("tensorArrayId", e, t, a), C = getParamValue("tensor", e, t, a), M = getParamValue("lengths", e, t, a), a.getTensorArray(I).split(M, C), [2, [(0, _tfjsCore.scalar)(1)]];

        case 15:
          return k = getParamValue("tensorArrayId", e, t, a), z = a.getTensorArray(k), [2, [(0, _tfjsCore.scalar)(z.size(), "int32")]];

        case 16:
          return j = getParamValue("tensorArrayId", e, t, a), a.getTensorArray(j).clearAndClose(), [2, [(0, _tfjsCore.scalar)(0)]];

        case 17:
          throw TypeError("Node type " + e.op + " is not implemented");
      }
    });
  });
}

var executeOp$3 = function (e, t, a) {
  var r, n;

  switch (e.op) {
    case "Conv1D":
      var s = getParamValue("stride", e, t, a),
          o = getParamValue("pad", e, t, a),
          p = getParamValue("dataFormat", e, t, a).toUpperCase(),
          u = getParamValue("dilation", e, t, a);
      return [(0, _tfjsCore.conv1d)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), s, o, p, u)];

    case "Conv2D":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), p = getParamValue("dataFormat", e, t, a).toUpperCase();
      var i = getParamValue("dilations", e, t, a);
      return [(0, _tfjsCore.conv2d)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), [s[1], s[2]], o, p, [i[1], i[2]])];

    case "_FusedConv2D":
      var m = (r = getParamValue("fusedOps", e, t, a))[0],
          l = r[1],
          c = "biasadd" === m,
          d = "prelu" === l,
          y = "fusedbatchnorm" === m,
          f = getParamValue("numArgs", e, t, a);

      if (c) {
        if (d && 2 !== f) throw new Error("Fused Conv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!d && 1 !== f) throw new Error("Fused Conv2d with BiasAdd must have one extra argument: bias.");
      }

      if (y) throw new Error("Fused Conv2d with FusedBatchNorm is not supported.");
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), p = getParamValue("dataFormat", e, t, a).toUpperCase(), i = getParamValue("dilations", e, t, a);
      var g = (n = getParamValue("args", e, t, a))[0],
          h = n[1];
      return [_tfjsCore.fused.conv2d({
        x: getParamValue("x", e, t, a),
        filter: getParamValue("filter", e, t, a),
        strides: [s[1], s[2]],
        pad: o,
        dataFormat: p,
        dilations: [i[1], i[2]],
        bias: g,
        activation: l,
        preluActivationWeights: h
      })];

    case "Conv2DBackpropInput":
    case "Conv2dTranspose":
      var N = getParamValue("outputShape", e, t, a);
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a);
      return [(0, _tfjsCore.conv2dTranspose)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), N, [s[1], s[2]], o)];

    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), i = getParamValue("dilations", e, t, a), p = getParamValue("dataFormat", e, t, a).toUpperCase();
      return [(0, _tfjsCore.depthwiseConv2d)(getParamValue("input", e, t, a), getParamValue("filter", e, t, a), [s[1], s[2]], o, p, [i[1], i[2]])];

    case "Conv3D":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), p = getParamValue("dataFormat", e, t, a).toUpperCase(), i = getParamValue("dilations", e, t, a);
      return [(0, _tfjsCore.conv3d)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), [s[1], s[2], s[3]], o, p, [i[1], i[2], i[3]])];

    case "AvgPool":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a);
      var x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.avgPool)(getParamValue("x", e, t, a), [x[1], x[2]], [s[1], s[2]], o)];

    case "MaxPool":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.maxPool)(getParamValue("x", e, t, a), [x[1], x[2]], [s[1], s[2]], o)];

    case "AvgPool3D":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.avgPool3d)(getParamValue("x", e, t, a), [x[1], x[2], x[3]], [s[1], s[2], s[3]], o)];

    case "MaxPool3D":
      s = getParamValue("strides", e, t, a), o = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.maxPool3d)(getParamValue("x", e, t, a), [x[1], x[2], x[3]], [s[1], s[2], s[3]], o)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$4 = function (e, t, a) {
  switch (e.op) {
    case "Fill":
      var r = getParamValue("shape", e, t, a),
          n = getParamValue("dtype", e, t, a),
          s = getParamValue("value", e, t, a);
      return [(0, _tfjsCore.fill)(r, s, n)];

    case "LinSpace":
      var o = getParamValue("start", e, t, a),
          p = getParamValue("stop", e, t, a),
          u = getParamValue("num", e, t, a);
      return [(0, _tfjsCore.linspace)(o, p, u)];

    case "Multinomial":
      var i = getParamValue("logits", e, t, a),
          m = getParamValue("numSamples", e, t, a),
          l = getParamValue("seed", e, t, a);
      return [(0, _tfjsCore.multinomial)(i, m, l)];

    case "OneHot":
      var c = getParamValue("indices", e, t, a),
          d = getParamValue("depth", e, t, a),
          y = getParamValue("onValue", e, t, a),
          f = getParamValue("offValue", e, t, a);
      return [(0, _tfjsCore.oneHot)(c, d, y, f)];

    case "Ones":
      return [(0, _tfjsCore.ones)(getParamValue("shape", e, t, a), getParamValue("dtype", e, t, a))];

    case "OnesLike":
      return [(0, _tfjsCore.onesLike)(getParamValue("x", e, t, a))];

    case "RandomUniform":
      return [(0, _tfjsCore.randomUniform)(getParamValue("shape", e, t, a), getParamValue("minval", e, t, a), getParamValue("maxval", e, t, a), getParamValue("dtype", e, t, a))];

    case "Range":
      o = getParamValue("start", e, t, a);
      var g = getParamValue("stop", e, t, a),
          h = getParamValue("step", e, t, a);
      return [(0, _tfjsCore.range)(o, g, h, getParamValue("dtype", e, t, a))];

    case "TruncatedNormal":
      r = getParamValue("shape", e, t, a);
      var N = getParamValue("mean", e, t, a),
          x = getParamValue("stdDev", e, t, a);
      l = getParamValue("seed", e, t, a);
      return [(0, _tfjsCore.truncatedNormal)(r, N, x, getParamValue("dtype", e, t, a), l)];

    case "Zeros":
      return [(0, _tfjsCore.zeros)(getParamValue("shape", e, t, a), getParamValue("dtype", e, t, a))];

    case "ZerosLike":
      return [(0, _tfjsCore.zerosLike)(getParamValue("x", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
};

function executeOp$5(e, t, a) {
  return __awaiter(this, void 0, void 0, function () {
    var r, n, s, o, p;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          switch (e.op) {
            case "NonMaxSuppressionV3":
            case "NonMaxSuppressionV2":
              return [3, 1];

            case "Where":
              return [3, 3];

            case "ListDiff":
              return [3, 5];
          }

          return [3, 6];

        case 1:
          return r = getParamValue("boxes", e, t, a), n = getParamValue("scores", e, t, a), s = getParamValue("maxOutputSize", e, t, a), o = getParamValue("iouThreshold", e, t, a), p = getParamValue("scoreThreshold", e, t, a), [4, _tfjsCore.image.nonMaxSuppressionAsync(r, n, s, o, p)];

        case 2:
          return [2, [u.sent()]];

        case 3:
          return [4, (0, _tfjsCore.whereAsync)(getParamValue("condition", e, t, a).asType("bool"))];

        case 4:
          return [2, [u.sent()]];

        case 5:
          return [2, (0, _tfjsCore.setdiff1dAsync)(getParamValue("x", e, t, a), getParamValue("y", e, t, a))];

        case 6:
          throw TypeError("Node type " + e.op + " is not implemented");
      }
    });
  });
}

var executeOp$6 = function (e, t, a) {
  switch (e.op) {
    case "TopKV2":
      var r = getParamValue("x", e, t, a),
          n = getParamValue("k", e, t, a),
          s = getParamValue("sorted", e, t, a),
          o = (0, _tfjsCore.topk)(r, n, s);
      return [o.values, o.indices];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$7 = function (e, t, a) {
  switch (e.op) {
    case "Const":
      return t[e.name];

    case "PlaceholderWithDefault":
      var r = getParamValue("default", e, t, a);
      return [getTensor(e.name, t, a) || r];

    case "Placeholder":
      return [getTensor(e.name, t, a)];

    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars":
      return [getParamValue("x", e, t, a).clone()];

    case "IdentityN":
      return getParamValue("x", e, t, a).map(function (e) {
        return e.clone();
      });

    case "Snapshot":
      return [getParamValue("x", e, t, a).clone()];

    case "Shape":
      return [(0, _tfjsCore.tensor1d)(getParamValue("x", e, t, a).shape, "int32")];

    case "ShapeN":
      return getParamValue("x", e, t, a).map(function (e) {
        return (0, _tfjsCore.tensor1d)(e.shape);
      });

    case "Size":
      return [(0, _tfjsCore.scalar)(getParamValue("x", e, t, a).size, "int32")];

    case "Rank":
      return [(0, _tfjsCore.scalar)(getParamValue("x", e, t, a).rank, "int32")];

    case "NoOp":
      return [(0, _tfjsCore.scalar)(1)];

    case "Print":
      var n = getParamValue("x", e, t, a),
          s = getParamValue("data", e, t, a),
          o = getParamValue("message", e, t, a),
          p = getParamValue("summarize", e, t, a);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o);

      for (var u = 0; u < s.length; u++) console.log(Array.prototype.slice.call(s[u].dataSync()).slice(0, p));

      return [n];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$8 = function (e, t, a) {
  switch (e.op) {
    case "ResizeBilinear":
      var r = getParamValue("images", e, t, a),
          n = getParamValue("size", e, t, a),
          s = getParamValue("alignCorners", e, t, a);
      return [_tfjsCore.image.resizeBilinear(r, [n[0], n[1]], s)];

    case "ResizeNearestNeighbor":
      r = getParamValue("images", e, t, a), n = getParamValue("size", e, t, a), s = getParamValue("alignCorners", e, t, a);
      return [_tfjsCore.image.resizeNearestNeighbor(r, [n[0], n[1]], s)];

    case "CropAndResize":
      var o = getParamValue("image", e, t, a),
          p = getParamValue("boxes", e, t, a),
          u = getParamValue("boxInd", e, t, a),
          i = getParamValue("cropSize", e, t, a),
          m = getParamValue("method", e, t, a),
          l = getParamValue("extrapolationValue", e, t, a);
      return [_tfjsCore.image.cropAndResize(o, p, u, i, m, l)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$9 = function (e, t, a) {
  switch (e.op) {
    case "Equal":
      return [(0, _tfjsCore.equal)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "NotEqual":
      return [(0, _tfjsCore.notEqual)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Greater":
      return [(0, _tfjsCore.greater)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "GreaterEqual":
      return [(0, _tfjsCore.greaterEqual)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Less":
      return [(0, _tfjsCore.less)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "LessEqual":
      return [(0, _tfjsCore.lessEqual)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "LogicalAnd":
      return [(0, _tfjsCore.logicalAnd)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "LogicalNot":
      return [(0, _tfjsCore.logicalNot)(getParamValue("a", e, t, a))];

    case "LogicalOr":
      return [(0, _tfjsCore.logicalOr)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Select":
      return [(0, _tfjsCore.where)(getParamValue("condition", e, t, a), getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$10 = function (e, t, a) {
  switch (e.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [(0, _tfjsCore.matMul)(getParamValue("a", e, t, a), getParamValue("b", e, t, a), getParamValue("transposeA", e, t, a), getParamValue("transposeB", e, t, a))];

    case "Transpose":
      return [(0, _tfjsCore.transpose)(getParamValue("x", e, t, a), getParamValue("perm", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$11 = function (e, t, a) {
  switch (e.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
    case "FusedBatchNormV3":
      return [(0, _tfjsCore.batchNorm)(getParamValue("x", e, t, a), getParamValue("mean", e, t, a), getParamValue("variance", e, t, a), getParamValue("offset", e, t, a), getParamValue("scale", e, t, a), getParamValue("epsilon", e, t, a))];

    case "LRN":
      return [(0, _tfjsCore.localResponseNormalization)(getParamValue("x", e, t, a), getParamValue("radius", e, t, a), getParamValue("bias", e, t, a), getParamValue("alpha", e, t, a), getParamValue("beta", e, t, a))];

    case "Softmax":
      return [(0, _tfjsCore.softmax)(getParamValue("x", e, t, a))];

    case "LogSoftmax":
      return [(0, _tfjsCore.logSoftmax)(getParamValue("x", e, t, a))];

    case "SparseToDense":
      return [(0, _tfjsCore.sparseToDense)(getParamValue("sparseIndices", e, t, a), getParamValue("outputShape", e, t, a), getParamValue("sparseValues", e, t, a), getParamValue("defaultValue", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$12 = function (e, t, a) {
  switch (e.op) {
    case "Max":
      var r = getParamValue("axis", e, t, a),
          n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.max)(getParamValue("x", e, t, a), r, n)];

    case "Mean":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.mean)(getParamValue("x", e, t, a), r, n)];

    case "Min":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.min)(getParamValue("x", e, t, a), r, n)];

    case "Sum":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.sum)(getParamValue("x", e, t, a), r, n)];

    case "All":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.all)(getParamValue("x", e, t, a), r, n)];

    case "Any":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.any)(getParamValue("x", e, t, a), r, n)];

    case "ArgMax":
      r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.argMax)(getParamValue("x", e, t, a), r)];

    case "ArgMin":
      r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.argMin)(getParamValue("x", e, t, a), r)];

    case "Prod":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.prod)(getParamValue("x", e, t, a), r, n)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$13 = function (e, t, a) {
  switch (e.op) {
    case "ConcatV2":
    case "Concat":
      var r = getParamValue("n", e, t, a),
          n = getParamValue("axis", e, t, a),
          s = getParamValue("tensors", e, t, a);
      return s = s.slice(0, r), [(0, _tfjsCore.concat)(s, n)];

    case "GatherV2":
    case "Gather":
      n = getParamValue("axis", e, t, a);
      var o = getParamValue("x", e, t, a),
          p = getParamValue("indices", e, t, a);
      return [(0, _tfjsCore.gather)(o, p.asType("int32"), n)];

    case "ReverseV2":
    case "Reverse":
      n = getParamValue("axis", e, t, a), o = getParamValue("x", e, t, a);
      return [(0, _tfjsCore.reverse)(o, n)];

    case "Slice":
      var u = getParamValue("begin", e, t, a),
          i = getParamValue("size", e, t, a);
      return [(0, _tfjsCore.slice)(getParamValue("x", e, t, a), u, i)];

    case "StridedSlice":
      u = getParamValue("begin", e, t, a);
      var m = getParamValue("end", e, t, a),
          l = getParamValue("strides", e, t, a),
          c = getParamValue("beginMask", e, t, a),
          d = getParamValue("endMask", e, t, a),
          y = getParamValue("ellipsisMask", e, t, a),
          f = getParamValue("newAxisMask", e, t, a),
          g = getParamValue("shrinkAxisMask", e, t, a),
          h = getParamValue("x", e, t, a);
      if (1 === u.length && h.shape.length > 1) for (var N = 1; N < h.shape.length; N++) u.push(0), m.push(h.shape[N]), l.push(l[0]);
      return [(0, _tfjsCore.stridedSlice)(h, u, m, l, c, d, y, f, g)];

    case "Pack":
      return (0, _tfjsCore.tidy)(function () {
        var r = getParamValue("axis", e, t, a),
            n = getParamValue("tensors", e, t, a),
            s = n[0].shape,
            o = n[0].squeeze().shape,
            p = n.map(function (e) {
          var t = _tfjsCore.util.arraysEqual(e.shape, s);

          if (!t && !_tfjsCore.util.arraysEqual(e.squeeze().shape, o)) throw new Error("the input tensors shape does not match");
          return t ? e : e.reshape(s);
        });
        return [(0, _tfjsCore.stack)(p, r)];
      });

    case "Unpack":
      return (0, _tfjsCore.tidy)(function () {
        var r = getParamValue("axis", e, t, a),
            n = getParamValue("tensor", e, t, a);
        return (0, _tfjsCore.unstack)(n, r);
      });

    case "Tile":
      var x = getParamValue("reps", e, t, a);
      return [(0, _tfjsCore.tile)(getParamValue("x", e, t, a), x)];

    case "Split":
    case "SplitV":
      n = getParamValue("axis", e, t, a);
      var V = getParamValue("numOrSizeSplits", e, t, a);
      return (0, _tfjsCore.split)(getParamValue("x", e, t, a), V, n);

    case "ScatterNd":
      p = getParamValue("indices", e, t, a);
      var P = getParamValue("values", e, t, a),
          b = getParamValue("shape", e, t, a);
      return [(0, _tfjsCore.scatterND)(p, P, b)];

    case "GatherNd":
      var T = getParamValue("x", e, t, a);
      p = getParamValue("indices", e, t, a);
      return [(0, _tfjsCore.gatherND)(T, p)];

    case "SparseToDense":
      p = getParamValue("sparseIndices", e, t, a), b = getParamValue("outputShape", e, t, a);
      var O = getParamValue("sparseValues", e, t, a),
          v = getParamValue("defaultValue", e, t, a);
      return [(0, _tfjsCore.sparseToDense)(p, O, b, O.dtype === v.dtype ? v : v.asType(O.dtype))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$14 = function (e, t, a) {
  switch (e.op) {
    case "FFT":
      return [(0, _tfjsCore.fft)(getParamValue("x", e, t, a))];

    case "IFFT":
      return [(0, _tfjsCore.ifft)(getParamValue("x", e, t, a))];

    case "RFFT":
      return [(0, _tfjsCore.rfft)(getParamValue("x", e, t, a))];

    case "IRFFT":
      return [(0, _tfjsCore.irfft)(getParamValue("x", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$15 = function (e, t, a) {
  switch (e.op) {
    case "Cast":
      return [(0, _tfjsCore.cast)(getParamValue("x", e, t, a), getParamValue("dtype", e, t, a))];

    case "ExpandDims":
      var r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.expandDims)(getParamValue("x", e, t, a), r)];

    case "Squeeze":
      r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.squeeze)(getParamValue("x", e, t, a), r)];

    case "Reshape":
      return [(0, _tfjsCore.reshape)(getParamValue("x", e, t, a), getParamValue("shape", e, t, a))];

    case "PadV2":
    case "Pad":
      return [(0, _tfjsCore.pad)(getParamValue("x", e, t, a), split$1(getParamValue("padding", e, t, a), 2), getParamValue("constantValue", e, t, a))];

    case "SpaceToBatchND":
      var n = getParamValue("blockShape", e, t, a),
          s = split$1(getParamValue("paddings", e, t, a), 2);
      return [(0, _tfjsCore.spaceToBatchND)(getParamValue("x", e, t, a), n, s)];

    case "BatchToSpaceND":
      n = getParamValue("blockShape", e, t, a);
      var o = split$1(getParamValue("crops", e, t, a), 2);
      return [(0, _tfjsCore.batchToSpaceND)(getParamValue("x", e, t, a), n, o)];

    case "DepthToSpace":
      var p = getParamValue("blockSize", e, t, a),
          u = getParamValue("dataFormat", e, t, a).toUpperCase();
      return [(0, _tfjsCore.depthToSpace)(getParamValue("x", e, t, a), p, u)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
};

function executeOp$16(e, t, a) {
  var r = function (e, t, a) {
    switch (e.category) {
      case "arithmetic":
        return executeOp(e, t, a);

      case "basic_math":
        return executeOp$1(e, t, a);

      case "control":
        return executeOp$2(e, t, a);

      case "convolution":
        return executeOp$3(e, t, a);

      case "creation":
        return executeOp$4(e, t, a);

      case "dynamic":
        return executeOp$5(e, t, a);

      case "evaluation":
        return executeOp$6(e, t, a);

      case "image":
        return executeOp$8(e, t, a);

      case "graph":
        return executeOp$7(e, t, a);

      case "logical":
        return executeOp$9(e, t, a);

      case "matrices":
        return executeOp$10(e, t, a);

      case "normalization":
        return executeOp$11(e, t, a);

      case "reduction":
        return executeOp$12(e, t, a);

      case "slice_join":
        return executeOp$13(e, t, a);

      case "spectral":
        return executeOp$14(e, t, a);

      case "transformation":
        return executeOp$15(e, t, a);

      case "custom":
        var r = getRegisteredOp(e.op);
        if (r && r.customExecutor) return r.customExecutor(new NodeValueImpl(e, t, a));
        throw TypeError("Custom op " + e.op + " is not registered.");

      default:
        throw TypeError("Unknown op '" + e.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
    }
  }(e, t, a);

  return r instanceof Promise ? r.then(function (e) {
    return [].concat(e);
  }) : [].concat(r);
}

var ExecutionContext = function () {
  function e(e, t) {
    this.weightMap = e, this.tensorArrayMap = t, this.rootContext = {
      id: 0,
      frameName: "",
      iterationId: 0
    }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }

  return e.prototype.newFrame = function (e, t) {
    return {
      id: e,
      frameName: t,
      iterationId: 0
    };
  }, Object.defineProperty(e.prototype, "currentContext", {
    get: function () {
      return this.contexts;
    },
    set: function (e) {
      this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "currentContextId", {
    get: function () {
      return this._currentContextIds[0];
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "currentContextIds", {
    get: function () {
      return this._currentContextIds;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.generateCurrentContextIds = function () {
    for (var e = [], t = 0; t < this.contexts.length - 1; t++) {
      var a = this.contexts.slice(0, this.contexts.length - t);
      e.push(this.contextIdforContexts(a));
    }

    e.push(""), this._currentContextIds = e;
  }, e.prototype.contextIdforContexts = function (e) {
    return e ? e.map(function (e) {
      return 0 === e.id && 0 === e.iterationId ? "" : e.frameName + "-" + e.iterationId;
    }).join("/") : "";
  }, e.prototype.enterFrame = function (e) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }, e.prototype.exitFrame = function () {
    if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
    this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
  }, e.prototype.nextIteration = function () {
    if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
    this.contexts = this.contexts.slice(), this.lastId++;
    var e = Object.assign({}, this.contexts[this.contexts.length - 1]);
    e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
  }, e.prototype.getWeight = function (e) {
    return this.weightMap[e];
  }, e.prototype.addTensorArray = function (e) {
    this.tensorArrayMap[e.id] = e;
  }, e.prototype.getTensorArray = function (e) {
    return this.tensorArrayMap[e];
  }, e;
}();

function getExecutionSubgraph(e, t, a) {
  for (var r = new Set(), n = [], s = null, o = null, p = new Set(), u = t.slice(); u.length > 0;) {
    var i = u.pop();
    (isControlFlow(i) || isDynamicShape(i)) && null == s && (o = (s = i).children.map(function (e) {
      return e.name;
    }).filter(function (e) {
      return r.has(e);
    })), r.add(i.name), null == a[i.name] && null == e[i.name] && (0 !== i.inputs.length ? i.inputs.forEach(function (e) {
      p.has(e.name) || (p.add(e.name), u.push(e));
    }) : n.push(i.name));
  }

  return {
    inputs: e,
    outputs: t,
    usedNodes: r,
    missingInputs: n,
    dynamicNode: s,
    syncInputs: o
  };
}

function getNodesInTopologicalOrder(e, t, a) {
  var r = a.usedNodes,
      n = a.inputs,
      s = [];
  Object.keys(n).map(function (t) {
    return e.nodes[t];
  }).forEach(function (e) {
    r.has(e.name) && s.push(e);
  }), e.weights.forEach(function (e) {
    r.has(e.name) && s.push(e);
  });

  for (var o = new Set(), p = []; s.length > 0;) {
    var u = s.pop();
    o.add(u.name), t[u.name] || p.push(u), u.children.forEach(function (e) {
      !o.has(e.name) && r.has(e.name) && e.inputs.every(function (e) {
        return o.has(e.name);
      }) && s.push(e);
    });
  }

  return p;
}

var CONTROL_FLOW_OPS = ["Switch", "Merge", "Enter", "Exit", "NextIteration"],
    DYNAMIC_SHAPE_OPS = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "Where"];

function isControlFlow(e) {
  return CONTROL_FLOW_OPS.indexOf(e.op) >= 0;
}

function isDynamicShape(e) {
  return DYNAMIC_SHAPE_OPS.indexOf(e.op) >= 0;
}

var GraphExecutor = function () {
  function e(e) {
    this.graph = e, this.compiledMap = new Map(), this._weightMap = {}, this.SEPERATOR = ",", this.placeholders = e.placeholders, this._outputs = e.outputs;
  }

  return Object.defineProperty(e.prototype, "weightMap", {
    get: function () {
      return this._weightMap;
    },
    set: function (e) {
      var t = Object.keys(e).map(function (t) {
        return e[t].map(function (e) {
          return e.id;
        });
      });
      this.weightIds = [].concat.apply([], t), this._weightMap = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputs", {
    get: function () {
      return this.placeholders.map(function (e) {
        return {
          name: e.name,
          shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
          dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
        };
      });
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputs", {
    get: function () {
      return this._outputs.map(function (e) {
        return {
          name: e.name,
          shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
          dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
        };
      });
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputNodes", {
    get: function () {
      return this.placeholders.map(function (e) {
        return e.name;
      });
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputNodes", {
    get: function () {
      return this.outputs.map(function (e) {
        return e.name;
      });
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.getCompilationKey = function (e, t) {
    var a = e.map(function (e) {
      return e.name;
    }).sort(),
        r = t.map(function (e) {
      return e.name;
    }).sort();
    return a.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR);
  }, e.prototype.compile = function (e, t) {
    var a = getExecutionSubgraph(e, t, this.weightMap),
        r = a.missingInputs,
        n = a.dynamicNode,
        s = a.syncInputs;
    if (null != n) throw new Error("This execution contains the node '" + n.name + "', which has the dynamic op '" + n.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + s + "]");

    if (r.length > 0) {
      var o = t.map(function (e) {
        return e.name;
      }),
          p = Object.keys(e);
      throw new Error("Cannot compute the outputs [" + o + "] from the provided inputs [" + p + "]. Missing the following inputs: [" + r + "]");
    }

    return getNodesInTopologicalOrder(this.graph, this.weightMap, a);
  }, e.prototype.execute = function (e, t) {
    var a = this,
        r = Object.keys(e).sort();
    this.checkInputs(e), this.checkInputShapeAndType(e), this.checkOutputs(t);
    var n = r.map(function (e) {
      return a.graph.nodes[e];
    }),
        s = t.map(function (e) {
      return a.graph.nodes[parseNodeName(e)[0]];
    }),
        o = this.getCompilationKey(n, s),
        p = this.compiledMap.get(o);
    null == p && (p = this.compile(e, s), this.compiledMap.set(o, p));
    var u = {};
    return (0, _tfjsCore.tidy)(function () {
      var r = new ExecutionContext(a._weightMap, u),
          n = __assign({}, a.weightMap);

      Object.keys(e).forEach(function (t) {
        n[t] = [e[t]];
      });

      for (var s = a.getFrozenTensorIds(n), o = {}, i = 0; i < p.length; i++) {
        var m = p[i];

        if (!n[m.name]) {
          var l = executeOp$16(m, n, r);
          if (l instanceof Promise) throw new Error("The execution of the op '" + m.op + "' returned a promise. Please use model.executeAsync() instead.");
          n[m.name] = l, a.checkTensorForDisposal(m.name, m, n, r, s, t, o);
        }
      }

      return t.map(function (e) {
        return getTensor(e, n, r);
      });
    });
  }, e.prototype.getFrozenTensorIds = function (e) {
    var t = [].concat.apply([], Object.keys(e).map(function (t) {
      return e[t];
    }).map(function (e) {
      return e.map(function (e) {
        return e.id;
      });
    }));
    return new Set(t);
  }, e.prototype.checkTensorForDisposal = function (e, t, a, r, n, s, o) {
    "control" !== t.category && -1 === s.indexOf(e) && (a[e].forEach(function (e) {
      null != e && (o[e.id] = (o[e.id] || 0) + t.children.length);
    }), t.inputs.forEach(function (e) {
      if ("control" !== e.category) {
        var t = getTensorsForCurrentContenxt(e.name, a, r);
        null != t && t.forEach(function (e) {
          if (e && !n.has(e.id)) {
            var t = o[e.id];
            1 === t ? (e.dispose(), delete o[e.id]) : null != t && o[e.id]--;
          }
        });
      }
    }));
  }, e.prototype.executeAsync = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var a,
          r,
          n,
          s,
          o,
          p,
          u = this;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            return this.checkInputs(e), this.checkInputShapeAndType(e), this.checkOutputs(t), a = {}, r = new ExecutionContext(this._weightMap, a), [4, this.executeWithControlFlow(e, r, t)];

          case 1:
            return n = i.sent(), s = t.map(function (e) {
              return getTensor(e, n, r);
            }), o = new Set(s.map(function (e) {
              return e.id;
            })), p = new Set(Object.keys(e).map(function (t) {
              return e[t].id;
            })), Object.keys(n).forEach(function (e) {
              n[e].forEach(function (e) {
                !e || e.isDisposed || o.has(e.id) || p.has(e.id) || -1 !== u.weightIds.indexOf(e.id) || e.dispose();
              });
            }), [2, s];
        }
      });
    });
  }, e.prototype.executeWithControlFlow = function (e, t, a) {
    return __awaiter(this, void 0, void 0, function () {
      var r,
          n,
          s,
          o,
          p,
          u,
          i,
          m,
          l,
          c,
          d,
          y,
          f,
          g,
          h,
          N,
          x = this;
      return __generator(this, function (V) {
        switch (V.label) {
          case 0:
            r = Object.keys(e), n = r.map(function (e) {
              return x.graph.nodes[e];
            }), s = a.map(function (e) {
              return x.graph.nodes[parseNodeName(e)[0]];
            }), o = getExecutionSubgraph(e, s, this.weightMap), p = o.usedNodes, u = o.missingInputs, i = o.dynamicNode, m = o.syncInputs, l = n.concat(this.graph.weights).map(function (e) {
              return {
                node: e,
                contexts: t.currentContext
              };
            }), c = __assign({}, this.weightMap), Object.keys(e).forEach(function (t) {
              c[t] = [e[t]];
            }), d = {}, y = this.getFrozenTensorIds(c), f = {}, V.label = 1;

          case 1:
            return l.length > 0 ? (g = this.processStack(n, l, t, c, f, y, a, d, p), [4, Promise.all(g)]) : [3, 3];

          case 2:
            return V.sent(), [3, 1];

          case 3:
            if (null == i && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (h = s.filter(function (e) {
              return !isControlFlow(e) && !getTensor(e.name, c, t);
            }).map(function (e) {
              return e.name;
            })).length > 0) throw N = "", null != i && (N = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + m + "]"), new Error("Cannot compute the outputs [" + h + "] from the provided inputs [" + r + "]. Consider providing the following inputs: [" + u + "]. " + N);
            return [2, c];
        }
      });
    });
  }, e.prototype.processStack = function (e, t, a, r, n, s, o, p, u) {
    for (var i = this, m = [], l = function () {
      var l = t.pop();
      a.currentContext = l.contexts;
      var d = "";

      if ("Enter" === l.node.op && getParamValue("isConstant", l.node, r, a) && (d = getNodeNameAndIndex(l.node.name, a)[0]), -1 === e.indexOf(l.node)) {
        var y = executeOp$16(l.node, r, a);
        d || (d = getNodeNameAndIndex(l.node.name, a)[0]);
        var f = a.currentContext;
        y instanceof Promise ? m.push(y.then(function (e) {
          return r[d] = e, a.currentContext = f, i.checkTensorForDisposal(d, l.node, r, a, s, o, p), i.processChildNodes(l.node, t, a, r, n, u), e;
        })) : (r[d] = y, c.checkTensorForDisposal(d, l.node, r, a, s, o, p), c.processChildNodes(l.node, t, a, r, n, u));
      } else c.processChildNodes(l.node, t, a, r, n, u);
    }, c = this; t.length > 0;) l();

    return m;
  }, e.prototype.processChildNodes = function (e, t, a, r, n, s) {
    e.children.forEach(function (e) {
      var o = getNodeNameAndIndex(e.name, a)[0];
      !n[o] && s.has(e.name) && ("Merge" === e.op ? e.inputNames.some(function (e) {
        return !!getTensor(e, r, a);
      }) && (n[o] = !0, t.push({
        contexts: a.currentContext,
        node: e
      })) : e.inputNames.every(function (e) {
        return !!getTensor(e, r, a);
      }) && (n[o] = !0, t.push({
        contexts: a.currentContext,
        node: e
      })));
    });
  }, e.prototype.dispose = function () {
    var e = this;
    Object.keys(this.weightMap).forEach(function (t) {
      return e.weightMap[t].forEach(function (e) {
        return e.dispose();
      });
    });
  }, e.prototype.checkInputShapeAndType = function (e) {
    var t = this;
    Object.keys(e).forEach(function (a) {
      var r = e[a],
          n = t.graph.nodes[a];

      if (n.attrParams.shape && n.attrParams.shape.value) {
        var s = n.attrParams.shape.value,
            o = s.length === r.shape.length && r.shape.every(function (e, t) {
          return -1 === s[t] || s[t] === e;
        });

        _tfjsCore.util.assert(o, function () {
          return "The shape of dict['" + n.name + "'] provided in model.execute(dict) must be [" + s + "], but was [" + r.shape + "]";
        });
      }

      n.attrParams.dtype && n.attrParams.dtype.value && _tfjsCore.util.assert(r.dtype === n.attrParams.dtype.value, function () {
        return "The dtype of dict['" + n.name + "'] provided in model.execute(dict) must be " + n.attrParams.dtype.value + ", but was " + r.dtype;
      });
    });
  }, e.prototype.checkInputs = function (e) {
    var t = this,
        a = Object.keys(e).filter(function (e) {
      return !t.graph.nodes[e];
    });
    if (a.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + a + "] that are not part of graph");
  }, e.prototype.checkOutputs = function (e) {
    var t = this;
    e.forEach(function (e) {
      var a = parseNodeName(e)[0];
      if (!t.graph.nodes[a]) throw new Error("The output '" + e + "' is not found in the graph");
    });
  }, e;
}(),
    TFHUB_SEARCH_PARAM = "?tfjs-format=file",
    DEFAULT_MODEL_NAME = "model.json",
    GraphModel = function () {
  function e(e, t) {
    void 0 === t && (t = {}), this.modelUrl = e, this.loadOptions = t, this.version = "n/a", null == t && (this.loadOptions = {});
  }

  return Object.defineProperty(e.prototype, "modelVersion", {
    get: function () {
      return this.version;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputNodes", {
    get: function () {
      return this.executor.inputNodes;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputNodes", {
    get: function () {
      return this.executor.outputNodes;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputs", {
    get: function () {
      return this.executor.inputs;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputs", {
    get: function () {
      return this.executor.outputs;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "weights", {
    get: function () {
      return this.executor.weightMap;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.findIOHandler = function () {
    var e = this.modelUrl;
    if (null != e.load) this.handler = e;else if (null != this.loadOptions.requestInit) this.handler = _tfjsCore.io.browserHTTPRequest(e, this.loadOptions);else {
      var t = _tfjsCore.io.getLoadHandlers(e, this.loadOptions.onProgress);

      if (0 === t.length) t.push(_tfjsCore.io.browserHTTPRequest(e, this.loadOptions));else if (t.length > 1) throw new Error("Found more than one (" + t.length + ") load handlers for URL '" + [e] + "'");
      this.handler = t[0];
    }
  }, e.prototype.load = function () {
    return __awaiter(this, void 0, void 0, function () {
      var e, t, a;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return [4, this.handler.load()];

          case 1:
            return e = r.sent(), t = e.modelTopology, this.version = t.versions.producer + "." + t.versions.minConsumer, a = _tfjsCore.io.decodeWeights(e.weightData, e.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a), [2, !0];
        }
      });
    });
  }, e.prototype.predict = function (e, t) {
    return this.execute(e, this.outputNodes);
  }, e.prototype.normalizeInputs = function (e) {
    if (!(e instanceof _tfjsCore.Tensor || Array.isArray(e))) return e;
    if ((e = Array.isArray(e) ? e : [e]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e.length + " input tensors.");
    return this.inputNodes.reduce(function (t, a, r) {
      return t[a] = e[r], t;
    }, {});
  }, e.prototype.normalizeOutputs = function (e) {
    return e = e || this.outputNodes, Array.isArray(e) ? e : [e];
  }, e.prototype.execute = function (e, t) {
    e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
    var a = this.executor.execute(e, t);
    return a.length > 1 ? a : a[0];
  }, e.prototype.executeAsync = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var a;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return e = this.normalizeInputs(e), t = this.normalizeOutputs(t), [4, this.executor.executeAsync(e, t)];

          case 1:
            return [2, (a = r.sent()).length > 1 ? a : a[0]];
        }
      });
    });
  }, e.prototype.convertTensorMapToTensorsMap = function (e) {
    return Object.keys(e).reduce(function (t, a) {
      return t[a] = [e[a]], t;
    }, {});
  }, e.prototype.dispose = function () {
    this.executor.dispose();
  }, e;
}();

exports.GraphModel = GraphModel;

function loadGraphModel(e, t) {
  return void 0 === t && (t = {}), __awaiter(this, void 0, void 0, function () {
    var a;
    return __generator(this, function (r) {
      switch (r.label) {
        case 0:
          if (null == e) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
          return null == t && (t = {}), t.fromTFHub && null == e.load && (e.endsWith("/") || (e += "/"), e = "" + e + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM), [4, (a = new GraphModel(e, t)).load()];

        case 1:
          return r.sent(), [2, a];
      }
    });
  });
}

var version = "1.3.2";
exports.version_converter = version;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.array = array;
exports.zip = zip;
exports.csv = csv;
exports.func = func;
exports.generator = generator;
exports.microphone = microphone;
exports.webcam = webcam;
exports.version_data = exports.URLDataSource = exports.FileDataSource = exports.TextLineDataset = exports.CSVDataset = exports.Dataset = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics = function (t, e) {
  return (extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (t, e) {
    t.__proto__ = e;
  } || function (t, e) {
    for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]);
  })(t, e);
};

function __extends(t, e) {
  function r() {
    this.constructor = t;
  }

  extendStatics(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r());
}

function __awaiter(t, e, r, n) {
  return new (r || (r = Promise))(function (i, o) {
    function a(t) {
      try {
        u(n.next(t));
      } catch (t) {
        o(t);
      }
    }

    function s(t) {
      try {
        u(n.throw(t));
      } catch (t) {
        o(t);
      }
    }

    function u(t) {
      t.done ? i(t.value) : new r(function (e) {
        e(t.value);
      }).then(a, s);
    }

    u((n = n.apply(t, e || [])).next());
  });
}

function __generator(t, e) {
  var r,
      n,
      i,
      o,
      a = {
    label: 0,
    sent: function () {
      if (1 & i[0]) throw i[1];
      return i[1];
    },
    trys: [],
    ops: []
  };
  return o = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
    return this;
  }), o;

  function s(o) {
    return function (s) {
      return function (o) {
        if (r) throw new TypeError("Generator is already executing.");

        for (; a;) try {
          if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;

          switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
            case 0:
            case 1:
              i = o;
              break;

            case 4:
              return a.label++, {
                value: o[1],
                done: !1
              };

            case 5:
              a.label++, n = o[1], o = [0];
              continue;

            case 7:
              o = a.ops.pop(), a.trys.pop();
              continue;

            default:
              if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                a = 0;
                continue;
              }

              if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                a.label = o[1];
                break;
              }

              if (6 === o[0] && a.label < i[1]) {
                a.label = i[1], i = o;
                break;
              }

              if (i && a.label < i[2]) {
                a.label = i[2], a.ops.push(o);
                break;
              }

              i[2] && a.ops.pop(), a.trys.pop();
              continue;
          }

          o = e.call(t, a);
        } catch (t) {
          o = [6, t], n = 0;
        } finally {
          r = i = 0;
        }

        if (5 & o[0]) throw o[1];
        return {
          value: o[0] ? o[1] : void 0,
          done: !0
        };
      }([o, s]);
    };
  }
}

var commonjsGlobal = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function createCommonjsModule(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var alea = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e,
            r = this,
            n = (e = 4022871197, function (t) {
          t = t.toString();

          for (var r = 0; r < t.length; r++) {
            var n = .02519603282416938 * (e += t.charCodeAt(r));
            n -= e = n >>> 0, e = (n *= e) >>> 0, e += 4294967296 * (n -= e);
          }

          return 2.3283064365386963e-10 * (e >>> 0);
        });
        r.next = function () {
          var t = 2091639 * r.s0 + 2.3283064365386963e-10 * r.c;
          return r.s0 = r.s1, r.s1 = r.s2, r.s2 = t - (r.c = 0 | t);
        }, r.c = 1, r.s0 = n(" "), r.s1 = n(" "), r.s2 = n(" "), r.s0 -= n(t), r.s0 < 0 && (r.s0 += 1), r.s1 -= n(t), r.s1 < 0 && (r.s1 += 1), r.s2 -= n(t), r.s2 < 0 && (r.s2 += 1), n = null;
      }(t),
          i = e && e.state,
          o = r.next;
      return o.int32 = function () {
        return 4294967296 * r.next() | 0;
      }, o.double = function () {
        return o() + 1.1102230246251565e-16 * (2097152 * o() | 0);
      }, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.alea = i;
  }(0, t, !1);
}),
    xor128 = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e = this,
            r = "";
        e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
          var t = e.x ^ e.x << 11;
          return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
        }, t === (0 | t) ? e.x = t : r += t;

        for (var n = 0; n < r.length + 64; n++) e.x ^= 0 | r.charCodeAt(n), e.next();
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xor128 = i;
  }(0, t, !1);
}),
    xorwow = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e = this,
            r = "";
        e.next = function () {
          var t = e.x ^ e.x >>> 2;
          return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
        }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : r += t;

        for (var n = 0; n < r.length + 64; n++) e.x ^= 0 | r.charCodeAt(n), n == r.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xorwow = i;
  }(0, t, !1);
}),
    xorshift7 = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.x = t.x.slice(), e.i = t.i, e;
    }

    function i(t, e) {
      null == t && (t = +new Date());

      var r = new function (t) {
        var e = this;
        e.next = function () {
          var t,
              r,
              n = e.x,
              i = e.i;
          return t = n[i], r = (t ^= t >>> 7) ^ t << 24, r ^= (t = n[i + 1 & 7]) ^ t >>> 10, r ^= (t = n[i + 3 & 7]) ^ t >>> 3, r ^= (t = n[i + 4 & 7]) ^ t << 7, t = n[i + 7 & 7], r ^= (t ^= t << 13) ^ t << 9, n[i] = r, e.i = i + 1 & 7, r;
        }, function (t, e) {
          var r,
              n = [];
          if (e === (0 | e)) n[0] = e;else for (e = "" + e, r = 0; r < e.length; ++r) n[7 & r] = n[7 & r] << 15 ^ e.charCodeAt(r) + n[r + 1 & 7] << 13;

          for (; n.length < 8;) n.push(0);

          for (r = 0; r < 8 && 0 === n[r]; ++r);

          for (8 == r ? n[7] = -1 : n[r], t.x = n, t.i = 0, r = 256; r > 0; --r) t.next();
        }(e, t);
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && (i.x && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xorshift7 = i;
  }(0, t, !1);
}),
    xor4096 = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;
    }

    function i(t, e) {
      null == t && (t = +new Date());

      var r = new function (t) {
        var e = this;
        e.next = function () {
          var t,
              r,
              n = e.w,
              i = e.X,
              o = e.i;
          return e.w = n = n + 1640531527 | 0, r = i[o + 34 & 127], t = i[o = o + 1 & 127], r ^= r << 13, t ^= t << 17, r ^= r >>> 15, t ^= t >>> 12, r = i[o] = r ^ t, e.i = o, r + (n ^ n >>> 16) | 0;
        }, function (t, e) {
          var r,
              n,
              i,
              o,
              a,
              s = [],
              u = 128;

          for (e === (0 | e) ? (n = e, e = null) : (e += "\0", n = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o) e && (n ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (a = n), n ^= n << 10, n ^= n >>> 15, n ^= n << 4, n ^= n >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = 0 == (r = s[127 & o] ^= n + a) ? i + 1 : 0);

          for (i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o) n = s[i + 34 & 127], r = s[i = i + 1 & 127], n ^= n << 13, r ^= r << 17, n ^= n >>> 15, r ^= r >>> 12, s[i] = n ^ r;

          t.w = a, t.X = s, t.i = i;
        }(e, t);
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && (i.X && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xor4096 = i;
  }(0, t, !1);
}),
    tychei = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e = this,
            r = "";
        e.next = function () {
          var t = e.b,
              r = e.c,
              n = e.d,
              i = e.a;
          return t = t << 25 ^ t >>> 7 ^ r, r = r - n | 0, n = n << 24 ^ n >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ r, e.c = r = r - n | 0, e.d = n << 16 ^ r >>> 16 ^ i, e.a = i - t | 0;
        }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : r += t;

        for (var n = 0; n < r.length + 20; n++) e.b ^= 0 | r.charCodeAt(n), e.next();
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.tychei = i;
  }(0, t, !1);
}),
    seedrandom = createCommonjsModule(function (t) {
  !function (e, r) {
    var n,
        i = this,
        o = 256,
        a = 6,
        s = "random",
        u = r.pow(o, a),
        c = r.pow(2, 52),
        l = 2 * c,
        h = o - 1;

    function f(t, f, v) {
      var _ = [],
          w = p(function t(e, r) {
        var n,
            i = [],
            o = typeof e;
        if (r && "object" == o) for (n in e) try {
          i.push(t(e[n], r - 1));
        } catch (t) {}
        return i.length ? i : "string" == o ? e : e + "\0";
      }((f = 1 == f ? {
        entropy: !0
      } : f || {}).entropy ? [t, m(e)] : null == t ? function () {
        try {
          var t;
          return n && (t = n.randomBytes) ? t = t(o) : (t = new Uint8Array(o), (i.crypto || i.msCrypto).getRandomValues(t)), m(t);
        } catch (t) {
          var r = i.navigator,
              a = r && r.plugins;
          return [+new Date(), i, a, i.screen, m(e)];
        }
      }() : t, 3), _),
          y = new function (t) {
        var e,
            r = t.length,
            n = this,
            i = 0,
            a = n.i = n.j = 0,
            s = n.S = [];
        r || (t = [r++]);

        for (; i < o;) s[i] = i++;

        for (i = 0; i < o; i++) s[i] = s[a = h & a + t[i % r] + (e = s[i])], s[a] = e;

        (n.g = function (t) {
          for (var e, r = 0, i = n.i, a = n.j, s = n.S; t--;) e = s[i = h & i + 1], r = r * o + s[h & (s[i] = s[a = h & a + e]) + (s[a] = e)];

          return n.i = i, n.j = a, r;
        })(o);
      }(_),
          g = function () {
        for (var t = y.g(a), e = u, r = 0; t < c;) t = (t + r) * o, e *= o, r = y.g(1);

        for (; t >= l;) t /= 2, e /= 2, r >>>= 1;

        return (t + r) / e;
      };

      return g.int32 = function () {
        return 0 | y.g(4);
      }, g.quick = function () {
        return y.g(4) / 4294967296;
      }, g.double = g, p(m(y.S), e), (f.pass || v || function (t, e, n, i) {
        return i && (i.S && d(i, y), t.state = function () {
          return d(y, {});
        }), n ? (r[s] = t, e) : t;
      })(g, w, "global" in f ? f.global : this == r, f.state);
    }

    function d(t, e) {
      return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;
    }

    function p(t, e) {
      for (var r, n = t + "", i = 0; i < n.length;) e[h & i] = h & (r ^= 19 * e[h & i]) + n.charCodeAt(i++);

      return m(e);
    }

    function m(t) {
      return String.fromCharCode.apply(0, t);
    }

    if (r["seed" + s] = f, p(r.random(), e), t.exports) {
      t.exports = f;

      try {
        n = require("crypto");
      } catch (t) {}
    } else 0;
  }([], Math);
});
seedrandom.alea = alea, seedrandom.xor128 = xor128, seedrandom.xorwow = xorwow, seedrandom.xorshift7 = xorshift7, seedrandom.xor4096 = xor4096, seedrandom.tychei = tychei;
var seedrandom$1 = seedrandom,
    seedrandom_1 = seedrandom$1.alea;

function deepMap(t, e) {
  return deepMapInternal(t, e);
}

function deepMapInternal(t, e, r, n) {
  if (void 0 === r && (r = new Map()), void 0 === n && (n = new Set()), null == t) return null;
  if (n.has(t)) throw new Error("Circular references are not supported.");
  if (r.has(t)) return r.get(t);
  var i = e(t);
  if (i.recurse && null !== i.value) throw new Error("A deep map function may not return both a value and recurse=true.");

  if (i.recurse) {
    if (isIterable(t)) {
      var o = Array.isArray(t) ? [] : {};

      for (var a in n.add(t), t) {
        var s = deepMapInternal(t[a], e, r, n);
        o[a] = s;
      }

      return n.delete(t), o;
    }

    throw new Error("Can't recurse into non-iterable type: " + t);
  }

  return r.set(t, i.value), i.value;
}

function deepZip(t, e) {
  return void 0 === e && (e = zipToList), deepZipInternal(t, e);
}

function deepZipInternal(t, e, r) {
  void 0 === r && (r = new Set());
  var n = t[0];
  if (r.has(n)) throw new Error("Circular references are not supported.");
  var i = e(t);
  if (i.recurse && null !== i.value) throw new Error("A deep zip function may not return both a value and recurse=true.");

  if (i.recurse) {
    if (isIterable(n)) {
      var o = Array.isArray(n) ? [] : {};
      r.add(n);

      var a = function (n) {
        var i = deepZipInternal(t.map(function (t) {
          return t[n];
        }), e, r);
        o[n] = i;
      };

      for (var s in n) a(s);

      return r.delete(n), o;
    }

    throw new Error("Can't recurse into non-iterable type: " + n);
  }

  return i.value;
}

function zipToList(t) {
  return null === t ? null : isIterable(t[0]) ? {
    value: null,
    recurse: !0
  } : {
    value: t,
    recurse: !1
  };
}

function deepMapAndAwaitAll(t, e) {
  return __awaiter(this, void 0, void 0, function () {
    var r, n, i, o, a, s;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          r = new Map(), deepMapInternal(t, e, r), n = 0, i = Array.from(r.keys()), u.label = 1;

        case 1:
          return n < i.length ? (o = i[n], (a = r.get(o)) instanceof Promise ? [4, a] : [3, 3]) : [3, 4];

        case 2:
          s = u.sent(), r.set(o, s), u.label = 3;

        case 3:
          return n++, [3, 1];

        case 4:
          return [2, deepMapInternal(t, e, r)];
      }
    });
  });
}

function isIterable(t) {
  return null != t && !ArrayBuffer.isView(t) && (Array.isArray(t) || "object" == typeof t && !(t instanceof _tfjsCore.Tensor));
}

function canTensorify(t) {
  return null == t || isPrimitive(t) || Array.isArray(t) || "object" == typeof t && t instanceof _tfjsCore.Tensor || _tfjsCore.util.isTypedArray(t);
}

function isPrimitive(t) {
  return null === t || "object" != typeof t && "function" != typeof t;
}

function deepClone(t) {
  return deepMap(t, cloneIfTensor);
}

function cloneIfTensor(t) {
  return t instanceof _tfjsCore.Tensor ? {
    value: t.clone(),
    recurse: !1
  } : isIterable(t) ? {
    value: null,
    recurse: !0
  } : {
    value: t,
    recurse: !1
  };
}

var RingBuffer = function () {
  function t(t) {
    if (this.capacity = t, this.begin = 0, this.end = 0, null == t) throw new RangeError("Can't create a ring buffer of unknown capacity.");
    if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
    this.data = new Array(t), this.doubledCapacity = 2 * t;
  }

  return t.prototype.wrap = function (t) {
    for (; t < 0;) t += this.doubledCapacity;

    return t % this.doubledCapacity;
  }, t.prototype.get = function (t) {
    if (t < 0) throw new RangeError("Can't get item at a negative index.");
    return this.data[t % this.capacity];
  }, t.prototype.set = function (t, e) {
    if (t < 0) throw new RangeError("Can't set item at a negative index.");
    this.data[t % this.capacity] = e;
  }, t.prototype.length = function () {
    var t = this.end - this.begin;
    return t < 0 && (t = this.doubledCapacity + t), t;
  }, t.prototype.isFull = function () {
    return this.length() === this.capacity;
  }, t.prototype.isEmpty = function () {
    return 0 === this.length();
  }, t.prototype.push = function (t) {
    if (this.isFull()) throw new RangeError("Ring buffer is full.");
    this.set(this.end, t), this.end = this.wrap(this.end + 1);
  }, t.prototype.pushAll = function (t) {
    for (var e = 0, r = t; e < r.length; e++) {
      var n = r[e];
      this.push(n);
    }
  }, t.prototype.pop = function () {
    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
    this.end = this.wrap(this.end - 1);
    var t = this.get(this.end);
    return this.set(this.end, void 0), t;
  }, t.prototype.unshift = function (t) {
    if (this.isFull()) throw new RangeError("Ring buffer is full.");
    this.begin = this.wrap(this.begin - 1), this.set(this.begin, t);
  }, t.prototype.shift = function () {
    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
    var t = this.get(this.begin);
    return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t;
  }, t.prototype.shuffleExcise = function (t) {
    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
    var e = this.wrap(this.begin + t),
        r = this.get(e);
    return this.set(e, this.pop()), r;
  }, t;
}(),
    GrowingRingBuffer = function (t) {
  function e() {
    return t.call(this, e.INITIAL_CAPACITY) || this;
  }

  return __extends(e, t), e.prototype.isFull = function () {
    return !1;
  }, e.prototype.push = function (e) {
    t.prototype.isFull.call(this) && this.expand(), t.prototype.push.call(this, e);
  }, e.prototype.unshift = function (e) {
    t.prototype.isFull.call(this) && this.expand(), t.prototype.unshift.call(this, e);
  }, e.prototype.expand = function () {
    for (var t = 2 * this.capacity, e = new Array(t), r = this.length(), n = 0; n < r; n++) e[n] = this.get(this.wrap(this.begin + n));

    this.data = e, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = r;
  }, e.INITIAL_CAPACITY = 32, e;
}(RingBuffer);

function iteratorFromItems(t) {
  return new ArrayIterator(t);
}

function iteratorFromFunction(t) {
  return new FunctionCallIterator(t);
}

function iteratorFromConcatenated(t, e) {
  return new ChainedIterator(t, e);
}

function iteratorFromZipped(t, e) {
  return void 0 === e && (e = ZipMismatchMode.FAIL), new ZipIterator(t, e);
}

var ZipMismatchMode,
    LazyIterator = function () {
  function t() {}

  return t.prototype.toArray = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return t = [], [4, this.next()];

          case 1:
            e = r.sent(), r.label = 2;

          case 2:
            return e.done ? [3, 4] : (t.push(e.value), [4, this.next()]);

          case 3:
            return e = r.sent(), [3, 2];

          case 4:
            return [2, t];
        }
      });
    });
  }, t.prototype.toArrayForTest = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return t = this.prefetch(100), e = [], [4, t.next()];

          case 1:
            r = n.sent(), n.label = 2;

          case 2:
            return r.done ? [3, 4] : (e.push(r.value), [4, t.next()]);

          case 3:
            return r = n.sent(), [3, 2];

          case 4:
            return [2, e];
        }
      });
    });
  }, t.prototype.resolveFully = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.next()];

          case 1:
            t = e.sent(), e.label = 2;

          case 2:
            return t.done ? [3, 4] : [4, this.next()];

          case 3:
            return t = e.sent(), [3, 2];

          case 4:
            return [2];
        }
      });
    });
  }, t.prototype.resolveWhile = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      var e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.next()];

          case 1:
            e = n.sent(), r = t(e.value), n.label = 2;

          case 2:
            return e.done || !r ? [3, 4] : [4, this.next()];

          case 3:
            return e = n.sent(), r = t(e.value), [3, 2];

          case 4:
            return [2];
        }
      });
    });
  }, t.prototype.handleErrors = function (t) {
    return new ErrorHandlingLazyIterator(this, t);
  }, t.prototype.filter = function (t) {
    return new FilterIterator(this, t);
  }, t.prototype.map = function (t) {
    return new MapIterator(this, t);
  }, t.prototype.mapAsync = function (t) {
    return new AsyncMapIterator(this, t);
  }, t.prototype.serialMapAsync = function (t) {
    return new AsyncMapIterator(this, t).serial();
  }, t.prototype.flatmap = function (t) {
    return new FlatmapIterator(this, t);
  }, t.prototype.forEachAsync = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2, this.map(t).resolveFully()];
      });
    });
  }, t.prototype.serialForEach = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2, this.serialMapAsync(t).resolveWhile(function (t) {
          return !0 === t;
        })];
      });
    });
  }, t.prototype.rowMajorBatch = function (t, e) {
    return void 0 === e && (e = !0), new RowMajorBatchIterator(this, t, e);
  }, t.prototype.columnMajorBatch = function (t, e, r) {
    return void 0 === e && (e = !0), void 0 === r && (r = zipToList), this.rowMajorBatch(t, e).map(function (t) {
      return deepZip(t, r);
    });
  }, t.prototype.concatenate = function (t, e) {
    return new ChainedIterator(iteratorFromItems([this, t]), e);
  }, t.prototype.take = function (t) {
    return t < 0 || null == t ? this : new TakeIterator(this, t);
  }, t.prototype.skip = function (t) {
    return t < 0 || null == t ? this : new SkipIterator(this, t);
  }, t.prototype.prefetch = function (t) {
    return new PrefetchIterator(this, t);
  }, t.prototype.shuffle = function (t, e) {
    return new ShuffleIterator(this, t, e);
  }, t.prototype.serial = function () {
    return new SerialIterator(this);
  }, t;
}(),
    ArrayIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.items = e, r.trav = 0, r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "Array of " + this.items.length + " items";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        return this.trav >= this.items.length ? [2, {
          value: null,
          done: !0
        }] : (t = this.items[this.trav], this.trav++, [2, {
          value: deepClone(t),
          done: !1
        }]);
      });
    });
  }, e;
}(LazyIterator),
    FunctionCallIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.nextFn = e, r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "Function call";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        try {
          return [2, this.nextFn()];
        } catch (t) {
          throw t.message = "Error thrown while iterating through a dataset: " + t.message, t;
        }

        return [2];
      });
    });
  }, e;
}(LazyIterator),
    SerialIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.upstream = e, r.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Serial";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, this.upstream.next()];
      });
    });
  }, e;
}(LazyIterator),
    SkipIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.maxCount = r, n.count = 0, n.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Skip";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return this.count++ < this.maxCount ? [4, this.upstream.next()] : [3, 2];

          case 1:
            return (t = e.sent()).done ? [2, t] : ((0, _tfjsCore.dispose)(t.value), [3, 0]);

          case 2:
            return [2, this.upstream.next()];
        }
      });
    });
  }, e;
}(LazyIterator),
    TakeIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.maxCount = r, n.count = 0, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Take";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return this.count++ >= this.maxCount ? [2, {
          value: null,
          done: !0
        }] : [2, this.upstream.next()];
      });
    });
  }, e;
}(LazyIterator),
    RowMajorBatchIterator = function (t) {
  function e(e, r, n) {
    void 0 === n && (n = !0);
    var i = t.call(this) || this;
    return i.upstream = e, i.batchSize = r, i.enableSmallLastBatch = n, i.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), i;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> RowMajorBatch";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            t = [], r.label = 1;

          case 1:
            return t.length < this.batchSize ? [4, this.upstream.next()] : [3, 3];

          case 2:
            return (e = r.sent()).done ? this.enableSmallLastBatch && t.length > 0 ? [2, {
              value: t,
              done: !1
            }] : [2, {
              value: null,
              done: !0
            }] : (t.push(e.value), [3, 1]);

          case 3:
            return [2, {
              value: t,
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    FilterIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.predicate = r, n.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Filter";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            return (t = e.sent()).done || this.predicate(t.value) ? [2, t] : ((0, _tfjsCore.dispose)(t.value), [3, 0]);

          case 2:
            return [2];
        }
      });
    });
  }, e;
}(LazyIterator),
    MapIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.transform = r, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Map";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i, o, a;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            if ((t = s.sent()).done) return [2, {
              value: null,
              done: !0
            }];

            for (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), r = this.transform(t.value), n = _tfjsCore.tensor_util.getTensorsInContainer(r), i = 0, o = e; i < o.length; i++) a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();

            return [2, {
              value: r,
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    ErrorHandlingLazyIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.handler = r, n.count = 0, n.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> handleErrors";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            e.label = 1;

          case 1:
            return e.trys.push([1, 3,, 4]), [4, this.upstream.next()];

          case 2:
            return [2, e.sent()];

          case 3:
            return t = e.sent(), this.handler(t) ? [3, 4] : [2, {
              value: null,
              done: !0
            }];

          case 4:
            return [3, 0];

          case 5:
            return [2];
        }
      });
    });
  }, e;
}(LazyIterator),
    AsyncMapIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.transform = r, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> AsyncMap";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i, o, a;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            return (t = s.sent()).done ? [2, {
              value: null,
              done: !0
            }] : (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), [4, this.transform(t.value)]);

          case 2:
            for (r = s.sent(), n = _tfjsCore.tensor_util.getTensorsInContainer(r), i = 0, o = e; i < o.length; i++) a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();

            return [2, {
              value: r,
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    OneToManyIterator = function (t) {
  function e() {
    var e = t.call(this) || this;
    return e.outputQueue = new GrowingRingBuffer(), e.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), e;
  }

  return __extends(e, t), e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return 0 !== this.outputQueue.length() ? [3, 2] : [4, this.pump()];

          case 1:
            return t.sent() ? [3, 0] : [2, {
              value: null,
              done: !0
            }];

          case 2:
            return [2, {
              value: this.outputQueue.shift(),
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    FlatmapIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.transform = r, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Flatmap";
  }, e.prototype.pump = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i, o, a;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            if ((t = s.sent()).done) return [2, !1];

            for (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), r = this.transform(t.value), n = _tfjsCore.tensor_util.getTensorsInContainer(r), this.outputQueue.pushAll(r), i = 0, o = e; i < o.length; i++) a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();

            return [2, !0];
        }
      });
    });
  }, e;
}(OneToManyIterator),
    ChainedIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.baseErrorHandler = r, n.lastRead = null, n.iterator = null, n.moreIterators = e, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "TODO: fill in upstream of chained summaries -> Chained";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return this.lastRead = this.readFromChain(this.lastRead), [2, this.lastRead];
      });
    });
  }, e.prototype.readFromChain = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      var e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, t];

          case 1:
            return n.sent(), null != this.iterator ? [3, 3] : [4, this.moreIterators.next()];

          case 2:
            if ((e = n.sent()).done) return [2, {
              value: null,
              done: !0
            }];
            this.iterator = e.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler)), n.label = 3;

          case 3:
            return [4, this.iterator.next()];

          case 4:
            return (r = n.sent()).done ? (this.iterator = null, [2, this.readFromChain(t)]) : [2, r];
        }
      });
    });
  }, e;
}(LazyIterator);

!function (t) {
  t[t.FAIL = 0] = "FAIL", t[t.SHORTEST = 1] = "SHORTEST", t[t.LONGEST = 2] = "LONGEST";
}(ZipMismatchMode || (ZipMismatchMode = {}));

var ZipIterator = function (t) {
  function e(e, r) {
    void 0 === r && (r = ZipMismatchMode.FAIL);
    var n = t.call(this) || this;
    return n.iterators = e, n.mismatchMode = r, n.count = 0, n.currentPromise = null, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "{TODO: fill in upstream of zip summaries} -> Zip";
  }, e.prototype.nextState = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      function e(t) {
        return t instanceof LazyIterator ? {
          value: t.next().then(function (t) {
            return r++, t.done && n++, t.value;
          }),
          recurse: !1
        } : {
          value: null,
          recurse: !0
        };
      }

      var r, n, i;
      return __generator(this, function (o) {
        switch (o.label) {
          case 0:
            return [4, t];

          case 1:
            return o.sent(), r = 0, n = 0, [4, deepMapAndAwaitAll(this.iterators, e)];

          case 2:
            if (i = o.sent(), r === n) return [2, {
              value: null,
              done: !0
            }];
            if (n > 0) switch (this.mismatchMode) {
              case ZipMismatchMode.FAIL:
                throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");

              case ZipMismatchMode.SHORTEST:
                return [2, {
                  value: null,
                  done: !0
                }];

              case ZipMismatchMode.LONGEST:
            }
            return this.count++, [2, {
              value: i,
              done: !1
            }];
        }
      });
    });
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return this.currentPromise = this.nextState(this.currentPromise), [2, this.currentPromise];
      });
    });
  }, e;
}(LazyIterator),
    PrefetchIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.bufferSize = r, n.buffer = new RingBuffer(r), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Prefetch";
  }, e.prototype.refill = function () {
    for (; !this.buffer.isFull();) {
      var t = this.upstream.next();
      this.buffer.push(t);
    }
  }, e.prototype.next = function () {
    return this.refill(), this.buffer.shift();
  }, e;
}(LazyIterator),
    ShuffleIterator = function (t) {
  function e(e, r, n) {
    var i = t.call(this, e, r) || this;
    return i.upstream = e, i.windowSize = r, i.upstreamExhausted = !1, i.random = seedrandom_1(n || _tfjsCore.util.now().toString()), i.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), i;
  }

  return __extends(e, t), e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.randomInt = function (t) {
    return Math.floor(this.random() * t);
  }, e.prototype.chooseIndex = function () {
    return this.randomInt(this.buffer.length());
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            this.upstreamExhausted || this.refill(), r.label = 1;

          case 1:
            return this.buffer.isEmpty() ? [3, 3] : (t = this.chooseIndex(), [4, this.buffer.shuffleExcise(t)]);

          case 2:
            return (e = r.sent()).done ? (this.upstreamExhausted = !0, [3, 1]) : (this.refill(), [2, e]);

          case 3:
            return [2, {
              value: null,
              done: !0
            }];
        }
      });
    });
  }, e;
}(PrefetchIterator),
    Dataset = function () {
  function t() {
    this.size = null;
  }

  return t.prototype.batch = function (t, e) {
    var r = this;
    void 0 === e && (e = !0);
    var n = this;
    return _tfjsCore.util.assert(t > 0, function () {
      return "batchSize needs to be positive, but it is\n      " + t;
    }), datasetFromIteratorFn(function () {
      return __awaiter(r, void 0, void 0, function () {
        return __generator(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, n.iterator()];

            case 1:
              return [2, r.sent().columnMajorBatch(t, e, deepBatchConcat)];
          }
        });
      });
    }, this.size === 1 / 0 || null == this.size ? this.size : e ? Math.ceil(this.size / t) : Math.floor(this.size / t));
  }, t.prototype.concatenate = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        var e, n;
        return __generator(this, function (i) {
          switch (i.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return n = (e = i.sent()).concatenate, [4, t.iterator()];

            case 2:
              return [2, n.apply(e, [i.sent()])];
          }
        });
      });
    }, this.size === 1 / 0 || t.size === 1 / 0 ? 1 / 0 : null != this.size && null != t.size ? this.size + t.size : null);
  }, t.prototype.filter = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().filter(function (e) {
                return (0, _tfjsCore.tidy)(function () {
                  return t(e);
                });
              })];
          }
        });
      });
    }, this.size === 1 / 0 ? 1 / 0 : null);
  }, t.prototype.forEachAsync = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.iterator()];

          case 1:
            return [2, e.sent().forEachAsync(t)];
        }
      });
    });
  }, t.prototype.forEach = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return (0, _tfjsCore.deprecationWarn)("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"), [2, this.forEachAsync(t)];
      });
    });
  }, t.prototype.map = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().map(function (e) {
                return (0, _tfjsCore.tidy)(function () {
                  return t(e);
                });
              })];
          }
        });
      });
    }, this.size);
  }, t.prototype.mapAsync = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().mapAsync(t)];
          }
        });
      });
    }, this.size);
  }, t.prototype.prefetch = function (t) {
    var e = this;
    if (null == t) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
    var r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().prefetch(t)];
          }
        });
      });
    }, this.size);
  }, t.prototype.repeat = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        var e = this;
        return __generator(this, function (n) {
          return [2, iteratorFromConcatenated(iteratorFromFunction(function () {
            return __awaiter(e, void 0, void 0, function () {
              var t;
              return __generator(this, function (e) {
                switch (e.label) {
                  case 0:
                    return t = {}, [4, r.iterator()];

                  case 1:
                    return [2, (t.value = e.sent(), t.done = !1, t)];
                }
              });
            });
          }).take(t))];
        });
      });
    }, null != this.size && t > 0 ? this.size * t : 0 === t ? 0 : null != this.size && (void 0 === t || t < 0) ? 1 / 0 : null);
  }, t.prototype.skip = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().skip(t)];
          }
        });
      });
    }, null != this.size && t >= 0 && this.size >= t ? this.size - t : null != this.size && (this.size < t || void 0 === t || t < 0) ? 0 : null);
  }, t.prototype.shuffle = function (t, e, r) {
    var n = this;
    if (void 0 === r && (r = !0), null == t || t < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
    var i = this,
        o = seedrandom_1(e || _tfjsCore.util.now().toString());
    return datasetFromIteratorFn(function () {
      return __awaiter(n, void 0, void 0, function () {
        var e;
        return __generator(this, function (n) {
          switch (n.label) {
            case 0:
              return e = o.int32(), r && (e += o.int32()), [4, i.iterator()];

            case 1:
              return [2, n.sent().shuffle(t, e.toString())];
          }
        });
      });
    }, this.size);
  }, t.prototype.take = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().take(t)];
          }
        });
      });
    }, null != this.size && this.size > t ? t : null != this.size && this.size <= t ? this.size : null);
  }, t.prototype.toArray = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
            return [4, this.iterator()];

          case 1:
            return [2, t.sent().toArray()];
        }
      });
    });
  }, t.prototype.toArrayForTest = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
            return [4, this.iterator()];

          case 1:
            return [2, t.sent().toArrayForTest()];
        }
      });
    });
  }, t.MAX_BUFFER_SIZE = 1e4, t;
}();

exports.Dataset = Dataset;

function datasetFromIteratorFn(t, e) {
  return void 0 === e && (e = null), new (function (r) {
    function n() {
      var t = null !== r && r.apply(this, arguments) || this;
      return t.size = e, t;
    }

    return __extends(n, r), n.prototype.iterator = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (e) {
          return [2, t()];
        });
      });
    }, n;
  }(Dataset))();
}

function array(t) {
  var e = this;
  return datasetFromIteratorFn(function () {
    return __awaiter(e, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2, iteratorFromItems(t)];
      });
    });
  }, t.length);
}

function zip(t) {
  var e,
      r = this;
  if (!isIterable(t)) throw new Error("The argument to zip() must be an object or array.");
  if (Array.isArray(t)) for (var n = 0; n < t.length; n++) e = null == e ? t[n].size : Math.min(e, t[n].size);else if (t instanceof Object) for (var i in t) e = null == e ? t[i].size : Math.min(e, t[i].size);
  return datasetFromIteratorFn(function () {
    return __awaiter(r, void 0, void 0, function () {
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, deepMapAndAwaitAll(t, function (t) {
              if (t instanceof Dataset) return {
                value: t.iterator(),
                recurse: !1
              };
              if (isIterable(t)) return {
                value: null,
                recurse: !0
              };
              throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
            })];

          case 1:
            return [2, iteratorFromZipped(e.sent(), ZipMismatchMode.SHORTEST)];
        }
      });
    });
  }, e);
}

function deepBatchConcat(t) {
  return null === t ? null : canTensorify(t[0]) ? {
    value: batchConcat(t),
    recurse: !1
  } : {
    value: null,
    recurse: !0
  };
}

function batchConcat(t) {
  if (0 === t.length) throw new Error("Can't make a batch of zero elements.");
  return t[0] instanceof _tfjsCore.Tensor ? (0, _tfjsCore.stack)(t) : (0, _tfjsCore.tensor)(t);
}

var TextLineDataset = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.input = e, r;
  }

  return __extends(e, t), e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.input.iterator()];

          case 1:
            return t = r.sent(), e = t.decodeUTF8(), [2, e.split("\n").map(function (t) {
              return t.endsWith("\r") && (t = t.slice(0, -1)), t;
            })];
        }
      });
    });
  }, e;
}(Dataset),
    CODE_QUOTE = '"',
    STATE_OUT = Symbol("out"),
    STATE_FIELD = Symbol("field"),
    STATE_QUOTE = Symbol("quote"),
    STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote"),
    STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote"),
    CSVDataset = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.input = e, n.hasHeader = !0, n.fullColumnNames = null, n.columnNamesValidated = !1, n.columnConfigs = null, n.configuredColumnsOnly = !1, n.delimiter = ",", n.delimWhitespace = !1, n.base = new TextLineDataset(e), r || (r = {}), n.hasHeader = !1 !== r.hasHeader, n.fullColumnNames = r.columnNames, n.columnConfigs = r.columnConfigs, n.configuredColumnsOnly = r.configuredColumnsOnly, r.delimWhitespace ? (_tfjsCore.util.assert(null == r.delimiter, function () {
      return "Delimiter should not be provided when delimWhitespace is true.";
    }), n.delimWhitespace = !0, n.delimiter = " ") : n.delimiter = r.delimiter ? r.delimiter : ",", n;
  }

  return __extends(e, t), e.prototype.columnNames = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];

          case 1:
            t.sent(), t.label = 2;

          case 2:
            return [2, this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames];
        }
      });
    });
  }, e.prototype.setColumnNames = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r,
          n,
          i,
          o,
          a = this;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.maybeReadHeaderLine()];

          case 1:
            if (t = s.sent(), !this.fullColumnNames && !t) throw new Error("Column names must be provided if there is no header line.");
            if (this.fullColumnNames && t && _tfjsCore.util.assert(t.length === this.fullColumnNames.length, function () {
              return "The length of provided columnNames (" + a.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ").";
            }), this.fullColumnNames || (this.fullColumnNames = t), e = this.fullColumnNames.reduce(function (t, e) {
              return t[e] = t[e] + 1 || 1, t;
            }, {}), r = Object.keys(e).filter(function (t) {
              return e[t] > 1;
            }), _tfjsCore.util.assert(0 === r.length, function () {
              return "Duplicate column names found: " + r.toString();
            }), this.columnConfigs) for (n = 0, i = Object.keys(this.columnConfigs); n < i.length; n++) if (o = i[n], -1 === this.fullColumnNames.indexOf(o)) throw new Error('The key "' + o + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
            return this.columnNamesValidated = !0, [2];
        }
      });
    });
  }, e.prototype.maybeReadHeaderLine = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return this.hasHeader ? [4, this.base.iterator()] : [3, 3];

          case 1:
            return [4, r.sent().next()];

          case 2:
            if ((t = r.sent()).done) throw new Error("No data was found for CSV parsing.");
            return e = t.value, [2, this.parseRow(e, !1)];

          case 3:
            return [2, null];
        }
      });
    });
  }, e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e = this;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];

          case 1:
            r.sent(), r.label = 2;

          case 2:
            return [4, this.base.iterator()];

          case 3:
            return t = r.sent(), this.hasHeader && (t = t.skip(1)), [2, t.map(function (t) {
              return e.makeDataElement(t);
            })];
        }
      });
    });
  }, e.prototype.makeDataElement = function (t) {
    for (var e = this.parseRow(t), r = {}, n = {}, i = 0; i < this.fullColumnNames.length; i++) {
      var o = this.fullColumnNames[i],
          a = this.columnConfigs ? this.columnConfigs[o] : null;

      if (!this.configuredColumnsOnly || a) {
        var s = e[i],
            u = null;
        if ("" === s) {
          if (a && void 0 !== a.default) u = a.default;else {
            if (a && (a.required || a.isLabel)) throw new Error("Required column " + o + " is empty in this line: " + t);
            u = void 0;
          }
        } else {
          var c = Number(s);
          if (isNaN(c)) u = a && "bool" === a.dtype ? this.getBoolean(s) : s;else if (a && a.dtype) switch (a.dtype) {
            case "float32":
              u = c;
              break;

            case "int32":
              u = Math.floor(c);
              break;

            case "bool":
              u = this.getBoolean(s);
              break;

            default:
              u = c;
          } else u = c;
        }
        a && a.isLabel ? n[o] = u : r[o] = u;
      }
    }

    return 0 === Object.keys(n).length ? r : {
      xs: r,
      ys: n
    };
  }, e.prototype.getBoolean = function (t) {
    return "1" === t || "true" === t.toLowerCase() ? 1 : 0;
  }, e.prototype.parseRow = function (t, e) {
    void 0 === e && (e = !0);

    for (var r = [], n = 0, i = t.length, o = STATE_OUT, a = 0; a < i; a++) switch (o) {
      case STATE_OUT:
        switch (t.charAt(a)) {
          case CODE_QUOTE:
            n = a + 1, o = STATE_QUOTE;
            break;

          case this.delimiter:
            if (n = a + 1, " " === this.delimiter && this.delimWhitespace) break;
            r.push(""), o = STATE_OUT;
            break;

          default:
            o = STATE_FIELD, n = a;
        }

        break;

      case STATE_FIELD:
        switch (t.charAt(a)) {
          case this.delimiter:
            r.push(t.substring(n, a)), o = STATE_OUT, n = a + 1;
        }

        break;

      case STATE_QUOTE:
        switch (t.charAt(a)) {
          case CODE_QUOTE:
            o = STATE_QUOTE_AFTER_QUOTE;
        }

        break;

      case STATE_QUOTE_AFTER_QUOTE:
        switch (t.charAt(a)) {
          case this.delimiter:
            r.push(t.substring(n, a - 1)), o = STATE_OUT, n = a + 1;
            break;

          case CODE_QUOTE:
            o = STATE_QUOTE;
            break;

          default:
            o = STATE_WITHIN_QUOTE_IN_QUOTE;
        }

        break;

      case STATE_WITHIN_QUOTE_IN_QUOTE:
        switch (t.charAt(a)) {
          case CODE_QUOTE:
            o = STATE_QUOTE;
        }

    }

    if (o === STATE_QUOTE_AFTER_QUOTE ? r.push(t.substring(n, i - 1)) : r.push(t.substring(n)), e && r.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + r);
    return r;
  }, e;
}(Dataset),
    MicrophoneIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    r.microphoneConfig = e, r.isClosed = !1, r.fftSize = e.fftSize || 1024;
    var n = Math.log2(r.fftSize);
    if (r.fftSize < 0 || n < 4 || n > 14 || !Number.isInteger(n)) throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + r.fftSize);
    if (r.numFrames = e.numFramesPerSpectrogram || 43, r.sampleRateHz = e.sampleRateHz, r.columnTruncateLength = e.columnTruncateLength || r.fftSize, r.audioTrackConstraints = e.audioTrackConstraints, r.smoothingTimeConstant = e.smoothingTimeConstant || 0, r.includeSpectrogram = !1 !== e.includeSpectrogram, r.includeWaveform = !0 === e.includeWaveform, !r.includeSpectrogram && !r.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
    return r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "microphone";
  }, e.create = function (t) {
    return void 0 === t && (t = {}), __awaiter(this, void 0, void 0, function () {
      var r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            if ((0, _tfjsCore.env)().get("IS_NODE")) throw new Error("microphone API is only supported in browser environment.");
            return [4, (r = new e(t)).start()];

          case 1:
            return n.sent(), [2, r];
        }
      });
    });
  }, e.prototype.start = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            return i.trys.push([0, 2,, 3]), t = this, [4, navigator.mediaDevices.getUserMedia({
              audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
              video: !1
            })];

          case 1:
            return t.stream = i.sent(), [3, 3];

          case 2:
            throw e = i.sent(), new Error("Error thrown while initializing video stream: " + e.message);

          case 3:
            if (!this.stream) throw new Error("Could not obtain audio from microphone.");

            if (r = window.AudioContext || window.webkitAudioContext, this.audioContext = new r(), this.sampleRateHz) {
              if (this.audioContext.sampleRate !== this.sampleRateHz) throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate);
            } else this.sampleRateHz = this.audioContext.sampleRate;

            return n = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), [2];
        }
      });
    });
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i;
      return __generator(this, function (o) {
        switch (o.label) {
          case 0:
            return this.isClosed ? [2, {
              value: null,
              done: !0
            }] : [4, this.getAudioData()];

          case 1:
            return r = o.sent(), this.includeSpectrogram && (n = this.flattenQueue(r.freqDataQueue), t = this.getTensorFromAudioDataArray(n, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i = this.flattenQueue(r.timeDataQueue), e = this.getTensorFromAudioDataArray(i, [this.numFrames * this.fftSize, 1])), [2, {
              value: {
                spectrogram: t,
                waveform: e
              },
              done: !1
            }];
        }
      });
    });
  }, e.prototype.capture = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.next()];

          case 1:
            return [2, t.sent().value];
        }
      });
    });
  }, e.prototype.getAudioData = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r,
          n = this;
      return __generator(this, function (i) {
        return t = [], e = [], r = 0, [2, new Promise(function (i) {
          var o = setInterval(function () {
            n.includeSpectrogram && (n.analyser.getFloatFrequencyData(n.freqData), n.freqData[0] === -1 / 0 && i({
              freqDataQueue: t,
              timeDataQueue: e
            }), t.push(n.freqData.slice(0, n.columnTruncateLength))), n.includeWaveform && (n.analyser.getFloatTimeDomainData(n.timeData), e.push(n.timeData.slice())), ++r === n.numFrames && (clearInterval(o), i({
              freqDataQueue: t,
              timeDataQueue: e
            }));
          }, n.fftSize / n.sampleRateHz * 1e3);
        })];
      });
    });
  }, e.prototype.stop = function () {
    this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
  }, e.prototype.toArray = function () {
    throw new Error("Can not convert infinite audio stream to array.");
  }, e.prototype.getSampleRate = function () {
    return this.sampleRateHz;
  }, e.prototype.flattenQueue = function (t) {
    var e = t[0].length,
        r = new Float32Array(t.length * e);
    return t.forEach(function (t, n) {
      return r.set(t, n * e);
    }), r;
  }, e.prototype.getTensorFromAudioDataArray = function (t, e) {
    var r = new Float32Array(_tfjsCore.util.sizeFromShape(e));
    return r.set(t, r.length - t.length), (0, _tfjsCore.tensor)(r, e);
  }, e;
}(LazyIterator),
    WebcamIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    if (n.webcamVideoElement = e, n.webcamConfig = r, n.isClosed = !0, n.resize = !1, n.needToResize()) if (n.resize = !0, n.cropSize = [n.webcamConfig.resizeHeight, n.webcamConfig.resizeWidth], n.cropBoxInd = (0, _tfjsCore.tensor1d)([0], "int32"), n.webcamConfig.centerCrop) {
      var i = 1 * n.webcamConfig.resizeWidth / n.webcamVideoElement.width,
          o = 1 * n.webcamConfig.resizeHeight / n.webcamVideoElement.height,
          a = (1 - i) / 2,
          s = (1 - o) / 2,
          u = a + i,
          c = o + s;
      n.cropBox = (0, _tfjsCore.tensor2d)([s, a, c, u], [1, 4]);
    } else n.cropBox = (0, _tfjsCore.tensor2d)([0, 0, 1, 1], [1, 4]);
    return n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "webcam";
  }, e.create = function (t, r) {
    return void 0 === r && (r = {}), __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            if ((0, _tfjsCore.env)().get("IS_NODE")) throw new Error("tf.data.webcam is only supported in browser environment.");

            if (!t) {
              if (t = document.createElement("video"), !r.resizeWidth || !r.resizeHeight) throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
              t.width = r.resizeWidth, t.height = r.resizeHeight;
            }

            return [4, (n = new e(t, r)).start()];

          case 1:
            return i.sent(), [2, n];
        }
      });
    });
  }, e.prototype.start = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r = this;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            this.webcamConfig.facingMode && _tfjsCore.util.assert("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function () {
              return "Invalid webcam facing mode: " + r.webcamConfig.facingMode + ". Please provide 'user' or 'environment'";
            }), n.label = 1;

          case 1:
            return n.trys.push([1, 3,, 4]), t = this, [4, navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: this.webcamConfig.deviceId,
                facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                width: this.webcamVideoElement.width,
                height: this.webcamVideoElement.height
              }
            })];

          case 2:
            return t.stream = n.sent(), [3, 4];

          case 3:
            throw (e = n.sent()).message = "Error thrown while initializing video stream: " + e.message, e;

          case 4:
            if (!this.stream) throw new Error("Could not obtain video from webcam.");

            try {
              this.webcamVideoElement.srcObject = this.stream;
            } catch (t) {
              console.log(t), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
            }

            return this.webcamVideoElement.play(), this.isClosed = !1, [2, new Promise(function (t) {
              r.webcamVideoElement.onloadedmetadata = function () {
                t();
              };
            })];
        }
      });
    });
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        if (this.isClosed) return [2, {
          value: null,
          done: !0
        }];

        try {
          t = _tfjsCore.browser.fromPixels(this.webcamVideoElement);
        } catch (t) {
          throw new Error("Error thrown converting video to pixels: " + JSON.stringify(t));
        }

        if (!this.resize) return [2, {
          value: t,
          done: !1
        }];

        try {
          return [2, {
            value: this.cropAndResizeFrame(t),
            done: !1
          }];
        } catch (t) {
          throw new Error("Error thrown cropping the video: " + t.message);
        } finally {
          t.dispose();
        }

        return [2];
      });
    });
  }, e.prototype.needToResize = function () {
    return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight);
  }, e.prototype.cropAndResizeFrame = function (t) {
    var e = this;
    return (0, _tfjsCore.tidy)(function () {
      var r,
          n = t.toFloat().expandDims(0),
          i = (r = _tfjsCore.image.cropAndResize(n, e.cropBox, e.cropBoxInd, e.cropSize, "bilinear")).shape;

      return r.reshape(i.slice(1));
    });
  }, e.prototype.capture = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.next()];

          case 1:
            return [2, t.sent().value];
        }
      });
    });
  }, e.prototype.stop = function () {
    this.stream.getTracks().forEach(function (t) {
      return t.stop();
    });

    try {
      this.webcamVideoElement.srcObject = null;
    } catch (t) {
      console.log(t), this.webcamVideoElement.src = null;
    }

    this.isClosed = !0;
  }, e.prototype.toArray = function () {
    throw new Error("Can not convert infinite video stream to array.");
  }, e;
}(LazyIterator),
    DataSource = function () {
  return function () {};
}(),
    StringIterator = function (t) {
  function e() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return __extends(e, t), e.prototype.split = function (t) {
    return new SplitIterator(this, t);
  }, e;
}(LazyIterator),
    SplitIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.impl = new SplitIteratorImpl(e, r), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.impl.summary();
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, this.impl.next()];
      });
    });
  }, e;
}(StringIterator),
    SplitIteratorImpl = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.separator = r, n.carryover = "", n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Split('" + this.separator + "')";
  }, e.prototype.pump = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i;
      return __generator(this, function (o) {
        switch (o.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            if ((t = o.sent()).done) return "" === this.carryover ? [2, !1] : (this.outputQueue.push(this.carryover), this.carryover = "", [2, !0]);

            for ((e = t.value.split(this.separator))[0] = this.carryover + e[0], r = 0, n = e.slice(0, -1); r < n.length; r++) i = n[r], this.outputQueue.push(i);

            return this.carryover = e[e.length - 1], [2, !0];
        }
      });
    });
  }, e;
}(OneToManyIterator),
    ByteChunkIterator = function (t) {
  function e() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return __extends(e, t), e.prototype.decodeUTF8 = function () {
    return new Utf8Iterator(this);
  }, e;
}(LazyIterator),
    Utf8Iterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.upstream = e, r.impl = new Utf8IteratorImpl(e), r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.impl.summary();
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, this.impl.next()];
      });
    });
  }, e;
}(StringIterator),
    Utf8IteratorImpl = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    if (r.upstream = e, (0, _tfjsCore.env)().get("IS_BROWSER")) r.decoder = new TextDecoder("utf-8");else {
      var n = require("string_decoder").StringDecoder;

      r.decoder = new n("utf8");
    }
    return r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Utf8";
  }, e.prototype.pump = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            return (t = n.sent()).done ? [2, !1] : (e = t.value, r = (0, _tfjsCore.env)().get("IS_BROWSER") ? this.decoder.decode(e, {
              stream: !0
            }) : this.decoder.write(Buffer.from(e.buffer)), this.outputQueue.push(r), [2, !0]);
        }
      });
    });
  }, e;
}(OneToManyIterator),
    FileChunkIterator = function (t) {
  function e(e, r) {
    void 0 === r && (r = {});
    var n = t.call(this) || this;
    return n.file = e, n.options = r, _tfjsCore.util.assert(e instanceof Uint8Array || !!(0, _tfjsCore.env)().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), function () {
      return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
    }), n.offset = r.offset || 0, n.chunkSize = r.chunkSize || 1048576, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "FileChunks " + this.file;
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r = this;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? [2, {
              value: null,
              done: !0
            }] : (t = new Promise(function (t, e) {
              var n = r.offset + r.chunkSize;
              if (r.file instanceof Uint8Array) t(new Uint8Array(r.file.slice(r.offset, n)));else {
                var i = new FileReader();
                i.onload = function (r) {
                  var n = i.result;
                  if (n instanceof ArrayBuffer && (n = new Uint8Array(n)), !(n instanceof Uint8Array)) return e(new TypeError("FileReader returned unknown type."));
                  t(n);
                }, i.onabort = function (t) {
                  return e(new Error("Aborted"));
                }, i.onerror = function (t) {
                  return e(new Error(t.type));
                };
                var o = r.file.slice(r.offset, n);
                i.readAsArrayBuffer(o);
              }
              r.offset = n;
            }), e = {}, [4, t]);

          case 1:
            return [2, (e.value = n.sent(), e.done = !1, e)];
        }
      });
    });
  }, e;
}(ByteChunkIterator);

exports.CSVDataset = CSVDataset;
exports.TextLineDataset = TextLineDataset;

function urlChunkIterator(t, e) {
  return void 0 === e && (e = {}), __awaiter(this, void 0, void 0, function () {
    var r, n, i, o, a;
    return __generator(this, function (s) {
      switch (s.label) {
        case 0:
          return "string" == typeof t ? r = t : (r = t.url, n = getRequestInitFromRequest(t)), [4, _tfjsCore.util.fetch(r, n)];

        case 1:
          return (i = s.sent()).ok ? (a = Uint8Array.bind, [4, i.arrayBuffer()]) : [3, 3];

        case 2:
          return o = new (a.apply(Uint8Array, [void 0, s.sent()]))(), [2, new FileChunkIterator(o, e)];

        case 3:
          throw new Error(i.statusText);
      }
    });
  });
}

var getRequestInitFromRequest = function (t) {
  return {
    method: t.method,
    headers: t.headers,
    body: t.body,
    mode: t.mode,
    credentials: t.credentials,
    cache: t.cache,
    redirect: t.redirect,
    referrer: t.referrer,
    integrity: t.integrity
  };
};

function isLocalPath(t) {
  return "string" == typeof t && "file://" === t.substr(0, 7);
}

var FileDataSource = function (t) {
  function e(e, r) {
    void 0 === r && (r = {});
    var n = t.call(this) || this;
    return n.input = e, n.options = r, n;
  }

  return __extends(e, t), e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        return isLocalPath(this.input) && (0, _tfjsCore.env)().get("IS_NODE") && (t = require("fs"), this.input = t.readFileSync(this.input.substr(7))), [2, new FileChunkIterator(this.input, this.options)];
      });
    });
  }, e;
}(DataSource),
    URLDataSource = function (t) {
  function e(e, r) {
    void 0 === r && (r = {});
    var n = t.call(this) || this;
    return n.url = e, n.fileOptions = r, n;
  }

  return __extends(e, t), e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return isLocalPath(this.url) ? [2, new FileDataSource(this.url, this.fileOptions).iterator()] : [2, urlChunkIterator(this.url, this.fileOptions)];
      });
    });
  }, e;
}(DataSource);

exports.URLDataSource = URLDataSource;
exports.FileDataSource = FileDataSource;

function csv(t, e) {
  return void 0 === e && (e = {}), new CSVDataset(new URLDataSource(t), e);
}

function func(t) {
  var e = this,
      r = iteratorFromFunction(t);
  return datasetFromIteratorFn(function () {
    return __awaiter(e, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, r];
      });
    });
  });
}

function generator(t) {
  var e = this;
  return datasetFromIteratorFn(function () {
    return __awaiter(e, void 0, void 0, function () {
      var e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, t()];

          case 1:
            return e = r.sent(), [2, iteratorFromFunction(function () {
              return e.next();
            })];
        }
      });
    });
  });
}

function webcam(t, e) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (r) {
      return [2, WebcamIterator.create(t, e)];
    });
  });
}

function microphone(t) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (e) {
      return [2, MicrophoneIterator.create(t)];
    });
  });
}

var version = "1.3.2";
exports.version_data = version;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","crypto":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","string_decoder":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs/dist/tf.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  data: true
};
exports.data = exports.version = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

Object.keys(_tfjsCore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tfjsCore[key];
    }
  });
});

var _tfjsLayers = require("@tensorflow/tfjs-layers");

Object.keys(_tfjsLayers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tfjsLayers[key];
    }
  });
});

var _tfjsConverter = require("@tensorflow/tfjs-converter");

Object.keys(_tfjsConverter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tfjsConverter[key];
    }
  });
});

var tfjsData = _interopRequireWildcard(require("@tensorflow/tfjs-data"));

exports.data = tfjsData;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @tensorflow/tfjs Copyright 2019 Google
var version = "1.3.2",
    version$1 = {
  "tfjs-core": _tfjsCore.version_core,
  "tfjs-data": tfjsData.version_data,
  "tfjs-layers": _tfjsLayers.version_layers,
  "tfjs-converter": _tfjsConverter.version_converter,
  tfjs: version
};
exports.version = version$1;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","@tensorflow/tfjs-layers":"../node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js","@tensorflow/tfjs-converter":"../node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js","@tensorflow/tfjs-data":"../node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/progress/lib/node-progress.js":[function(require,module,exports) {
var process = require("process");
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Expose `ProgressBar`.
 */
exports = module.exports = ProgressBar;
/**
 * Initialize a `ProgressBar` with the given `fmt` string and `options` or
 * `total`.
 *
 * Options:
 *
 *   - `curr` current completed index
 *   - `total` total number of ticks to complete
 *   - `width` the displayed width of the progress bar defaulting to total
 *   - `stream` the output stream defaulting to stderr
 *   - `head` head character defaulting to complete character
 *   - `complete` completion character defaulting to "="
 *   - `incomplete` incomplete character defaulting to "-"
 *   - `renderThrottle` minimum time between updates in milliseconds defaulting to 16
 *   - `callback` optional function to call when the progress bar completes
 *   - `clear` will clear the progress bar upon termination
 *
 * Tokens:
 *
 *   - `:bar` the progress bar itself
 *   - `:current` current tick number
 *   - `:total` total ticks
 *   - `:elapsed` time elapsed in seconds
 *   - `:percent` completion percentage
 *   - `:eta` eta in seconds
 *   - `:rate` rate of ticks per second
 *
 * @param {string} fmt
 * @param {object|number} options or total
 * @api public
 */

function ProgressBar(fmt, options) {
  this.stream = options.stream || process.stderr;

  if (typeof options == 'number') {
    var total = options;
    options = {};
    options.total = total;
  } else {
    options = options || {};
    if ('string' != typeof fmt) throw new Error('format required');
    if ('number' != typeof options.total) throw new Error('total required');
  }

  this.fmt = fmt;
  this.curr = options.curr || 0;
  this.total = options.total;
  this.width = options.width || this.total;
  this.clear = options.clear;
  this.chars = {
    complete: options.complete || '=',
    incomplete: options.incomplete || '-',
    head: options.head || options.complete || '='
  };
  this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
  this.lastRender = -Infinity;

  this.callback = options.callback || function () {};

  this.tokens = {};
  this.lastDraw = '';
}
/**
 * "tick" the progress bar with optional `len` and optional `tokens`.
 *
 * @param {number|object} len or tokens
 * @param {object} tokens
 * @api public
 */


ProgressBar.prototype.tick = function (len, tokens) {
  if (len !== 0) len = len || 1; // swap tokens

  if ('object' == typeof len) tokens = len, len = 1;
  if (tokens) this.tokens = tokens; // start time for eta

  if (0 == this.curr) this.start = new Date();
  this.curr += len; // try to render

  this.render(); // progress complete

  if (this.curr >= this.total) {
    this.render(undefined, true);
    this.complete = true;
    this.terminate();
    this.callback(this);
    return;
  }
};
/**
 * Method to render the progress bar with optional `tokens` to place in the
 * progress bar's `fmt` field.
 *
 * @param {object} tokens
 * @api public
 */


ProgressBar.prototype.render = function (tokens, force) {
  force = force !== undefined ? force : false;
  if (tokens) this.tokens = tokens;
  if (!this.stream.isTTY) return;
  var now = Date.now();
  var delta = now - this.lastRender;

  if (!force && delta < this.renderThrottle) {
    return;
  } else {
    this.lastRender = now;
  }

  var ratio = this.curr / this.total;
  ratio = Math.min(Math.max(ratio, 0), 1);
  var percent = Math.floor(ratio * 100);
  var incomplete, complete, completeLength;
  var elapsed = new Date() - this.start;
  var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
  var rate = this.curr / (elapsed / 1000);
  /* populate the bar template with percentages and timestamps */

  var str = this.fmt.replace(':current', this.curr).replace(':total', this.total).replace(':elapsed', isNaN(elapsed) ? '0.0' : (elapsed / 1000).toFixed(1)).replace(':eta', isNaN(eta) || !isFinite(eta) ? '0.0' : (eta / 1000).toFixed(1)).replace(':percent', percent.toFixed(0) + '%').replace(':rate', Math.round(rate));
  /* compute the available space (non-zero) for the bar */

  var availableSpace = Math.max(0, this.stream.columns - str.replace(':bar', '').length);

  if (availableSpace && process.platform === 'win32') {
    availableSpace = availableSpace - 1;
  }

  var width = Math.min(this.width, availableSpace);
  /* TODO: the following assumes the user has one ':bar' token */

  completeLength = Math.round(width * ratio);
  complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
  incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
  /* add head to the complete string */

  if (completeLength > 0) complete = complete.slice(0, -1) + this.chars.head;
  /* fill in the actual progress bar */

  str = str.replace(':bar', complete + incomplete);
  /* replace the extra tokens */

  if (this.tokens) for (var key in this.tokens) str = str.replace(':' + key, this.tokens[key]);

  if (this.lastDraw !== str) {
    this.stream.cursorTo(0);
    this.stream.write(str);
    this.stream.clearLine(1);
    this.lastDraw = str;
  }
};
/**
 * "update" the progress bar to represent an exact percentage.
 * The ratio (between 0 and 1) specified will be multiplied by `total` and
 * floored, representing the closest available "tick." For example, if a
 * progress bar has a length of 3 and `update(0.5)` is called, the progress
 * will be set to 1.
 *
 * A ratio of 0.5 will attempt to set the progress to halfway.
 *
 * @param {number} ratio The ratio (between 0 and 1 inclusive) to set the
 *   overall completion to.
 * @api public
 */


ProgressBar.prototype.update = function (ratio, tokens) {
  var goal = Math.floor(ratio * this.total);
  var delta = goal - this.curr;
  this.tick(delta, tokens);
};
/**
 * "interrupt" the progress bar and write a message above it.
 * @param {string} message The message to write.
 * @api public
 */


ProgressBar.prototype.interrupt = function (message) {
  // clear the current line
  this.stream.clearLine(); // move the cursor to the start of the line

  this.stream.cursorTo(0); // write the message text

  this.stream.write(message); // terminate the line after writing the message

  this.stream.write('\n'); // re-display the progress bar with its lastDraw

  this.stream.write(this.lastDraw);
};
/**
 * Terminates a progress bar.
 *
 * @api public
 */


ProgressBar.prototype.terminate = function () {
  if (this.clear) {
    if (this.stream.clearLine) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
    }
  } else {
    this.stream.write('\n');
  }
};
},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/progress/index.js":[function(require,module,exports) {
module.exports = require('./lib/node-progress');
},{"./lib/node-progress":"../node_modules/progress/lib/node-progress.js"}],"../node_modules/@tensorflow/tfjs-core/dist/backends/backend.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EPSILON_FLOAT32 = 1e-7;
exports.EPSILON_FLOAT16 = 1e-4;
/** Convenient class for storing tensor-related data. */
var DataStorage = /** @class */ (function () {
    function DataStorage(backend, dataMover) {
        this.backend = backend;
        this.dataMover = dataMover;
        this.data = new WeakMap();
        this.dataIdsCount = 0;
    }
    DataStorage.prototype.get = function (dataId) {
        if (!this.data.has(dataId)) {
            this.dataMover.moveData(this.backend, dataId);
        }
        return this.data.get(dataId);
    };
    DataStorage.prototype.set = function (dataId, value) {
        this.dataIdsCount++;
        this.data.set(dataId, value);
    };
    DataStorage.prototype.has = function (dataId) {
        return this.data.has(dataId);
    };
    DataStorage.prototype.delete = function (dataId) {
        this.dataIdsCount--;
        return this.data.delete(dataId);
    };
    DataStorage.prototype.numDataIds = function () {
        return this.dataIdsCount;
    };
    return DataStorage;
}());
exports.DataStorage = DataStorage;
/**
 * The interface that defines the kernels that should be implemented when
 * adding a new backend. New backends don't need to implement every one of the
 * methods, this can be done gradually (throw an error for unimplemented
 * methods).
 */
var KernelBackend = /** @class */ (function () {
    function KernelBackend() {
    }
    KernelBackend.prototype.time = function (f) {
        return notYetImplemented('time');
    };
    KernelBackend.prototype.read = function (dataId) {
        return notYetImplemented('read');
    };
    KernelBackend.prototype.readSync = function (dataId) {
        return notYetImplemented('readSync');
    };
    KernelBackend.prototype.numDataIds = function () {
        return notYetImplemented('numDataIds');
    };
    KernelBackend.prototype.disposeData = function (dataId) {
        return notYetImplemented('disposeData');
    };
    KernelBackend.prototype.fromPixels = function (pixels, numChannels) {
        return notYetImplemented('fromPixels');
    };
    KernelBackend.prototype.write = function (values, shape, dtype) {
        return notYetImplemented('write');
    };
    KernelBackend.prototype.move = function (dataId, values, shape, dtype) {
        return notYetImplemented('move');
    };
    KernelBackend.prototype.memory = function () {
        return notYetImplemented('memory');
    };
    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
    KernelBackend.prototype.floatPrecision = function () {
        return notYetImplemented('floatPrecision');
    };
    /** Returns the smallest representable number.  */
    KernelBackend.prototype.epsilon = function () {
        return this.floatPrecision() === 32 ? exports.EPSILON_FLOAT32 : exports.EPSILON_FLOAT16;
    };
    KernelBackend.prototype.batchMatMul = function (a, b, transposeA, transposeB) {
        return notYetImplemented('batchMatMul');
    };
    KernelBackend.prototype.fusedBatchMatMul = function (_a) {
        var a = _a.a, b = _a.b, transposeA = _a.transposeA, transposeB = _a.transposeB, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;
        return notYetImplemented('fusedBatchMatMul');
    };
    KernelBackend.prototype.slice = function (x, begin, size) {
        return notYetImplemented('slice');
    };
    KernelBackend.prototype.stridedSlice = function (x, begin, end, strides) {
        return notYetImplemented('stridedSlice');
    };
    KernelBackend.prototype.unstack = function (x, axis) {
        return notYetImplemented('unstack');
    };
    KernelBackend.prototype.reverse = function (a, axis) {
        return notYetImplemented('reverse');
    };
    KernelBackend.prototype.concat = function (tensors, axis) {
        return notYetImplemented('concat');
    };
    KernelBackend.prototype.neg = function (a) {
        return notYetImplemented('neg');
    };
    KernelBackend.prototype.add = function (a, b) {
        return notYetImplemented('add');
    };
    KernelBackend.prototype.addN = function (tensors) {
        return notYetImplemented('addN');
    };
    KernelBackend.prototype.subtract = function (a, b) {
        return notYetImplemented('subtract');
    };
    KernelBackend.prototype.multiply = function (a, b) {
        return notYetImplemented('multiply');
    };
    KernelBackend.prototype.realDivide = function (a, b) {
        return notYetImplemented('realDivide');
    };
    KernelBackend.prototype.floorDiv = function (a, b) {
        return notYetImplemented('floorDiv');
    };
    KernelBackend.prototype.sum = function (x, axes) {
        return notYetImplemented('sum');
    };
    KernelBackend.prototype.prod = function (x, axes) {
        return notYetImplemented('prod');
    };
    KernelBackend.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {
        return notYetImplemented('unsortedSegmentSum');
    };
    KernelBackend.prototype.argMin = function (x, axis) {
        return notYetImplemented('argMin');
    };
    KernelBackend.prototype.argMax = function (x, axis) {
        return notYetImplemented('argMax');
    };
    KernelBackend.prototype.equal = function (a, b) {
        return notYetImplemented('equal');
    };
    KernelBackend.prototype.notEqual = function (a, b) {
        return notYetImplemented('notEqual');
    };
    KernelBackend.prototype.less = function (a, b) {
        return notYetImplemented('less');
    };
    KernelBackend.prototype.lessEqual = function (a, b) {
        return notYetImplemented('lessEqual');
    };
    KernelBackend.prototype.greater = function (a, b) {
        return notYetImplemented('greater');
    };
    KernelBackend.prototype.greaterEqual = function (a, b) {
        return notYetImplemented('greaterEqual');
    };
    KernelBackend.prototype.logicalNot = function (a) {
        return notYetImplemented('logicalNot');
    };
    KernelBackend.prototype.logicalAnd = function (a, b) {
        return notYetImplemented('logicalAnd');
    };
    KernelBackend.prototype.logicalOr = function (a, b) {
        return notYetImplemented('logicalOr');
    };
    KernelBackend.prototype.where = function (condition) {
        return notYetImplemented('where');
    };
    KernelBackend.prototype.select = function (condition, a, b) {
        return notYetImplemented('select');
    };
    KernelBackend.prototype.topk = function (x, k, sorted) {
        return notYetImplemented('topk');
    };
    KernelBackend.prototype.min = function (x, axes) {
        return notYetImplemented('min');
    };
    KernelBackend.prototype.minimum = function (a, b) {
        return notYetImplemented('minimum');
    };
    KernelBackend.prototype.mod = function (a, b) {
        return notYetImplemented('mod');
    };
    KernelBackend.prototype.max = function (x, axes) {
        return notYetImplemented('max');
    };
    KernelBackend.prototype.maximum = function (a, b) {
        return notYetImplemented('maximum');
    };
    KernelBackend.prototype.all = function (x, axes) {
        return notYetImplemented('all');
    };
    KernelBackend.prototype.any = function (x, axes) {
        return notYetImplemented('any');
    };
    KernelBackend.prototype.squaredDifference = function (a, b) {
        return notYetImplemented('squaredDifference');
    };
    KernelBackend.prototype.ceil = function (x) {
        return notYetImplemented('ceil');
    };
    KernelBackend.prototype.floor = function (x) {
        return notYetImplemented('floor');
    };
    KernelBackend.prototype.round = function (x) {
        return notYetImplemented('round');
    };
    KernelBackend.prototype.sign = function (x) {
        return notYetImplemented('sign');
    };
    KernelBackend.prototype.isNaN = function (x) {
        return notYetImplemented('isNaN');
    };
    KernelBackend.prototype.isInf = function (x) {
        return notYetImplemented('isInf');
    };
    KernelBackend.prototype.isFinite = function (x) {
        return notYetImplemented('isFinite');
    };
    KernelBackend.prototype.pow = function (a, b) {
        return notYetImplemented('pow');
    };
    KernelBackend.prototype.exp = function (x) {
        return notYetImplemented('exp');
    };
    KernelBackend.prototype.expm1 = function (x) {
        return notYetImplemented('expm1');
    };
    KernelBackend.prototype.log = function (x) {
        return notYetImplemented('log');
    };
    KernelBackend.prototype.log1p = function (x) {
        return notYetImplemented('log1p');
    };
    KernelBackend.prototype.sqrt = function (x) {
        return notYetImplemented('sqrt');
    };
    KernelBackend.prototype.rsqrt = function (x) {
        return notYetImplemented('rsqrt');
    };
    KernelBackend.prototype.square = function (x) {
        return notYetImplemented('square');
    };
    KernelBackend.prototype.reciprocal = function (x) {
        return notYetImplemented('reciprocal');
    };
    KernelBackend.prototype.relu = function (x) {
        return notYetImplemented('relu');
    };
    KernelBackend.prototype.relu6 = function (x) {
        return notYetImplemented('relu6');
    };
    KernelBackend.prototype.prelu = function (x, a) {
        return notYetImplemented('prelu');
    };
    KernelBackend.prototype.elu = function (x) {
        return notYetImplemented('elu');
    };
    KernelBackend.prototype.eluDer = function (dy, y) {
        return notYetImplemented('eluDer');
    };
    KernelBackend.prototype.selu = function (x) {
        return notYetImplemented('selu');
    };
    KernelBackend.prototype.int = function (x) {
        return notYetImplemented('int');
    };
    KernelBackend.prototype.clip = function (x, min, max) {
        return notYetImplemented('clip');
    };
    KernelBackend.prototype.abs = function (x) {
        return notYetImplemented('abs');
    };
    KernelBackend.prototype.complexAbs = function (x) {
        return notYetImplemented('complexAbs');
    };
    KernelBackend.prototype.sigmoid = function (x) {
        return notYetImplemented('sigmoid');
    };
    KernelBackend.prototype.softplus = function (x) {
        return notYetImplemented('softplus');
    };
    KernelBackend.prototype.sin = function (x) {
        return notYetImplemented('sin');
    };
    KernelBackend.prototype.cos = function (x) {
        return notYetImplemented('cos');
    };
    KernelBackend.prototype.tan = function (x) {
        return notYetImplemented('tan');
    };
    KernelBackend.prototype.asin = function (x) {
        return notYetImplemented('asin');
    };
    KernelBackend.prototype.acos = function (x) {
        return notYetImplemented('acos');
    };
    KernelBackend.prototype.atan = function (x) {
        return notYetImplemented('atan');
    };
    KernelBackend.prototype.atan2 = function (a, b) {
        return notYetImplemented('atan2');
    };
    KernelBackend.prototype.sinh = function (x) {
        return notYetImplemented('sinh');
    };
    KernelBackend.prototype.cosh = function (x) {
        return notYetImplemented('cosh');
    };
    KernelBackend.prototype.tanh = function (x) {
        return notYetImplemented('tanh');
    };
    KernelBackend.prototype.asinh = function (x) {
        return notYetImplemented('asinh');
    };
    KernelBackend.prototype.acosh = function (x) {
        return notYetImplemented('acosh');
    };
    KernelBackend.prototype.atanh = function (x) {
        return notYetImplemented('atanh');
    };
    KernelBackend.prototype.erf = function (x) {
        return notYetImplemented('erf');
    };
    KernelBackend.prototype.step = function (x, alpha) {
        return notYetImplemented('step');
    };
    KernelBackend.prototype.fusedConv2d = function (_a) {
        var input = _a.input, filter = _a.filter, convInfo = _a.convInfo, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;
        return notYetImplemented('fusedConv2d');
    };
    KernelBackend.prototype.conv2d = function (x, filter, convInfo) {
        return notYetImplemented('conv2d');
    };
    KernelBackend.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        return notYetImplemented('conv2dDerInput');
    };
    KernelBackend.prototype.conv2dDerFilter = function (x, dY, convInfo) {
        return notYetImplemented('conv2dDerFilter');
    };
    KernelBackend.prototype.fusedDepthwiseConv2D = function (_a) {
        var input = _a.input, filter = _a.filter, convInfo = _a.convInfo, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;
        return notYetImplemented('fusedDepthwiseConv2D');
    };
    KernelBackend.prototype.depthwiseConv2D = function (input, filter, convInfo) {
        return notYetImplemented('depthwiseConv2D');
    };
    KernelBackend.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        return notYetImplemented('depthwiseConv2DDerInput');
    };
    KernelBackend.prototype.depthwiseConv2DDerFilter = function (x, dY, convInfo) {
        return notYetImplemented('depthwiseConv2DDerFilter');
    };
    KernelBackend.prototype.conv3d = function (x, filter, convInfo) {
        return notYetImplemented('conv3d');
    };
    KernelBackend.prototype.conv3dDerInput = function (dy, filter, convInfo) {
        return notYetImplemented('conv3dDerInput');
    };
    KernelBackend.prototype.conv3dDerFilter = function (x, dY, convInfo) {
        return notYetImplemented('conv3dDerFilter');
    };
    KernelBackend.prototype.maxPool = function (x, convInfo) {
        return notYetImplemented('maxPool');
    };
    KernelBackend.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        return notYetImplemented('maxPoolBackprop');
    };
    KernelBackend.prototype.avgPool = function (x, convInfo) {
        return notYetImplemented('avgPool');
    };
    KernelBackend.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        return notYetImplemented('avgPoolBackprop');
    };
    KernelBackend.prototype.avgPool3d = function (x, convInfo) {
        return notYetImplemented('avgPool3d');
    };
    KernelBackend.prototype.avgPool3dBackprop = function (dy, x, convInfo) {
        return notYetImplemented('avgPool3dBackprop');
    };
    KernelBackend.prototype.maxPool3d = function (x, convInfo) {
        return notYetImplemented('maxPool3d');
    };
    KernelBackend.prototype.maxPool3dBackprop = function (dy, x, y, convInfo) {
        return notYetImplemented('maxPool3dBackprop');
    };
    KernelBackend.prototype.reshape = function (x, shape) {
        return notYetImplemented('reshape');
    };
    KernelBackend.prototype.cast = function (x, dtype) {
        return notYetImplemented('cast');
    };
    KernelBackend.prototype.tile = function (x, reps) {
        return notYetImplemented('tile');
    };
    KernelBackend.prototype.pad = function (x, paddings, constantValue) {
        return notYetImplemented('pad');
    };
    KernelBackend.prototype.transpose = function (x, perm) {
        return notYetImplemented('transpose');
    };
    KernelBackend.prototype.gather = function (x, indices, axis) {
        return notYetImplemented('gather');
    };
    KernelBackend.prototype.gatherND = function (x, indices) {
        return notYetImplemented('gatherND');
    };
    KernelBackend.prototype.scatterND = function (indices, updates, shape) {
        return notYetImplemented('scatterND');
    };
    KernelBackend.prototype.batchToSpaceND = function (x, blockShape, crops) {
        return notYetImplemented('batchToSpaceND');
    };
    KernelBackend.prototype.spaceToBatchND = function (x, blockShape, paddings) {
        return notYetImplemented('spaceToBatchND');
    };
    KernelBackend.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        return notYetImplemented('resizeBilinear');
    };
    KernelBackend.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        return notYetImplemented('resizeBilinearBackprop');
    };
    KernelBackend.prototype.resizeNearestNeighbor = function (x, newHEight, newWidth, alignCorners) {
        return notYetImplemented('resizeNearestNeighbor');
    };
    KernelBackend.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {
        return notYetImplemented('resizeNearestNeighborBackprop');
    };
    KernelBackend.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        return notYetImplemented('batchNormalization');
    };
    KernelBackend.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        return notYetImplemented('localResponseNormalization4D');
    };
    KernelBackend.prototype.LRNGrad = function (dy, inputImage, outputImage, radius, bias, alpha, beta) {
        return notYetImplemented('LRNGrad');
    };
    KernelBackend.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        return notYetImplemented('multinomial');
    };
    KernelBackend.prototype.oneHot = function (indices, depth, onValue, offValue) {
        return notYetImplemented('oneHot');
    };
    KernelBackend.prototype.cumsum = function (x, axis, exclusive, reverse) {
        return notYetImplemented('cumsum');
    };
    KernelBackend.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
        return notYetImplemented('nonMaxSuppression');
    };
    KernelBackend.prototype.fft = function (x) {
        return notYetImplemented('fft');
    };
    KernelBackend.prototype.ifft = function (x) {
        return notYetImplemented('ifft');
    };
    KernelBackend.prototype.complex = function (real, imag) {
        return notYetImplemented('complex');
    };
    KernelBackend.prototype.real = function (input) {
        return notYetImplemented('real');
    };
    KernelBackend.prototype.imag = function (input) {
        return notYetImplemented('imag');
    };
    KernelBackend.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {
        return notYetImplemented('cropAndResize');
    };
    KernelBackend.prototype.depthToSpace = function (x, blockSize, dataFormat) {
        return notYetImplemented('depthToSpace');
    };
    // Aligns with the "SplitV" kernel in TensorFlow.
    KernelBackend.prototype.split = function (value, sizeSplits, axis) {
        return notYetImplemented('split');
    };
    KernelBackend.prototype.sparseToDense = function (sparseIndices, sparseValues, outputShape, defaultValue) {
        return notYetImplemented('sparseToDense');
    };
    KernelBackend.prototype.diag = function (x) {
        return notYetImplemented('diag');
    };
    KernelBackend.prototype.fill = function (shape, value, dtype) {
        return notYetImplemented('fill');
    };
    KernelBackend.prototype.onesLike = function (x) {
        return notYetImplemented('onesLike');
    };
    KernelBackend.prototype.zerosLike = function (x) {
        return notYetImplemented('zerosLike');
    };
    KernelBackend.prototype.linspace = function (start, stop, num) {
        return notYetImplemented('linspace');
    };
    KernelBackend.prototype.dispose = function () {
        return notYetImplemented('dispose');
    };
    return KernelBackend;
}());
exports.KernelBackend = KernelBackend;
function notYetImplemented(kernelName) {
    throw new Error("'" + kernelName + "' not yet implemented or not found in the registry. " +
        "Did you forget to import the kernel?");
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
},{"./support/isBuffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/support/isBufferBrowser.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/node_modules/inherits/inherits_browser.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js":[function(require,module,exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],"../node_modules/@tensorflow/tfjs-node/dist/int64_tensors.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfjs_1 = require("@tensorflow/tfjs");

var os_1 = require("os");

var INT32_MAX = 2147483648;
/**
 * Node.js-specific tensor type: int64-type scalar.
 *
 * This class is created for a specific purpose: to support
 * writing `step`s to TensorBoard via op-kernel bindings.
 * `step` is required to have an int64 dtype, but TensorFlow.js
 * (tfjs-core) doesn't have a built-in int64 dtype. This is
 * related to a lack of `Int64Array` or `Uint64Array` typed
 * array in basic JavaScript.
 *
 * This class is introduced as a workaround.
 */

var Int64Scalar =
/** @class */
function () {
  function Int64Scalar(value) {
    this.value = value;
    this.dtype = 'int64';
    this.rank = 1; // The reason why we need to check endianness of the machine here is
    // negative int64 values and the way in which we represent them
    // using Int32Arrays in JavaScript. We represent each int64 value with
    // two consecutive elements of an Int32Array. For positive values,
    // the high part is simply zero; for negative values, the high part
    // should be -1. The ordering of the low and high parts assumes
    // little endian (i.e., least significant digits appear first).
    // This assumption is checked by the lines below.

    if (Int64Scalar.endiannessOkay_ == null) {
      if (os_1.endianness() !== 'LE') {
        throw new Error("Int64Scalar does not support endianness of this machine: " + ("" + os_1.endianness()));
      }

      Int64Scalar.endiannessOkay_ = true;
    }

    tfjs_1.util.assert(value > -INT32_MAX && value < INT32_MAX - 1, function () {
      return "Got a value outside of the bound of values supported for int64 " + ("dtype ([-" + INT32_MAX + ", " + (INT32_MAX - 1) + "]): " + value);
    });
    tfjs_1.util.assert(Number.isInteger(value), function () {
      return "Expected value to be an integer, but got " + value;
    }); // We use two int32 elements to represent a int64 value. This assumes
    // little endian, which is checked above.

    var highPart = value >= 0 ? 0 : -1;
    var lowPart = value % INT32_MAX;
    this.valueArray_ = new Int32Array([lowPart, highPart]);
  }

  Object.defineProperty(Int64Scalar.prototype, "shape", {
    get: function get() {
      return [];
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Int64Scalar.prototype, "valueArray", {
    /** Get the Int32Array that represents the int64 value. */
    get: function get() {
      return this.valueArray_;
    },
    enumerable: true,
    configurable: true
  });
  return Int64Scalar;
}();

exports.Int64Scalar = Int64Scalar;
},{"@tensorflow/tfjs":"../node_modules/@tensorflow/tfjs/dist/tf.esm.js","os":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js"}],"../node_modules/@tensorflow/tfjs-node/dist/nodejs_kernel_backend.js":[function(require,module,exports) {
var process = require("process");
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfc = require("@tensorflow/tfjs-core");

var tfjs_core_1 = require("@tensorflow/tfjs-core"); // tslint:disable-next-line: no-imports-from-dist


var backend_1 = require("@tensorflow/tfjs-core/dist/backends/backend");

var util_1 = require("util");

var int64_tensors_1 = require("./int64_tensors");

var NodeJSKernelBackend =
/** @class */
function (_super) {
  __extends(NodeJSKernelBackend, _super);

  function NodeJSKernelBackend(binding, packageName) {
    var _this = _super.call(this) || this;

    _this.binding = binding;
    _this.isGPUPackage = packageName === '@tensorflow/tfjs-node-gpu';
    _this.isUsingGpuDevice = _this.binding.isUsingGpuDevice();
    _this.tensorMap = new tfc.DataStorage(_this, tfc.engine());
    return _this;
  }

  NodeJSKernelBackend.prototype.getDTypeInteger = function (dtype) {
    switch (dtype) {
      case 'float32':
        return this.binding.TF_FLOAT;

      case 'int32':
        return this.binding.TF_INT32;

      case 'bool':
        return this.binding.TF_BOOL;

      case 'complex64':
        return this.binding.TF_COMPLEX64;

      case 'string':
        return this.binding.TF_STRING;

      default:
        throw new Error("Unsupported DType: " + dtype);
    }
  };

  NodeJSKernelBackend.prototype.typeAttributeFromTensor = function (value) {
    return this.getDTypeInteger(value.dtype);
  }; // Creates a new Tensor and maps the dataId to the passed in ID.


  NodeJSKernelBackend.prototype.createOutputTensor = function (metadata) {
    var newId = {};
    this.tensorMap.set(newId, {
      shape: metadata.shape,
      dtype: metadata.dtype,
      id: metadata.id,
      values: null
    });
    var dtype;

    switch (metadata.dtype) {
      case this.binding.TF_FLOAT:
        dtype = 'float32';
        break;

      case this.binding.TF_INT32:
        dtype = 'int32';
        break;

      case this.binding.TF_BOOL:
        dtype = 'bool';
        break;

      case this.binding.TF_COMPLEX64:
        dtype = 'complex64';
        break;

      case this.binding.TF_STRING:
        dtype = 'string';
        break;

      case this.binding.TF_RESOURCE:
        // NOTE(cais): We currently represent resource-type Tensors
        // as string of ubytes.
        dtype = 'string';
        break;

      case this.binding.TF_UINT8:
        // TensorFlow uses UINT8 as dtype for image tensor. UINT8 is not
        // supported in TFJS yet, cast it to int32.
        dtype = 'int32';
        break;

      default:
        throw new Error("Unknown dtype enum " + metadata.dtype);
    }

    return tfc.engine().makeTensorFromDataId(newId, metadata.shape, dtype);
  }; // Prepares Tensor instances for Op execution.


  NodeJSKernelBackend.prototype.getInputTensorIds = function (tensors) {
    var ids = [];

    for (var i = 0; i < tensors.length; i++) {
      if (tensors[i] instanceof int64_tensors_1.Int64Scalar) {
        // Then `tensors[i]` is a Int64Scalar, which we currently represent
        // using an `Int32Array`.
        var value = tensors[i].valueArray;
        var id = this.binding.createTensor([], this.binding.TF_INT64, value);
        ids.push(id);
      } else {
        var info = this.tensorMap.get(tensors[i].dataId); // TODO - what about ID in this case? Handle in write()??

        if (info.values != null) {
          // Values were delayed to write into the TensorHandle. Do that before
          // Op execution and clear stored values.
          info.id = this.binding.createTensor(info.shape, info.dtype, info.values);
          info.values = null;
        }

        ids.push(info.id);
      }
    }

    return ids;
  };

  NodeJSKernelBackend.prototype.createReductionOpAttrs = function (tensor) {
    return [{
      name: 'keep_dims',
      type: this.binding.TF_ATTR_BOOL,
      value: false
    }, createTypeOpAttr('T', tensor.dtype), createTypeOpAttr('Tidx', 'int32')];
  };

  NodeJSKernelBackend.prototype.executeSingleInput = function (name, input) {
    var opAttrs = [createTypeOpAttr('T', input.dtype)];
    return this.executeSingleOutput(name, opAttrs, [input]);
  };

  NodeJSKernelBackend.prototype.floatPrecision = function () {
    return 32;
  };

  NodeJSKernelBackend.prototype.epsilon = function () {
    return backend_1.EPSILON_FLOAT32;
  };
  /**
   * Executes a TensorFlow Eager Op that provides one output Tensor.
   * @param name The name of the Op to execute.
   * @param opAttrs The list of Op attributes required to execute.
   * @param inputs The list of input Tensors for the Op.
   * @return A resulting Tensor from Op execution.
   */


  NodeJSKernelBackend.prototype.executeSingleOutput = function (name, opAttrs, inputs) {
    var outputMetadata = this.binding.executeOp(name, opAttrs, this.getInputTensorIds(inputs), 1);
    return this.createOutputTensor(outputMetadata[0]);
  };
  /**
   * Executes a TensorFlow Eager Op that provides multiple output Tensors.
   * @param name The name of the Op to execute.
   * @param opAttrs The list of Op attributes required to execute.
   * @param inputs The list of input Tensors for the Op.
   * @param numOutputs The number of output Tensors for Op execution.
   * @return A resulting Tensor array from Op execution.
   */


  NodeJSKernelBackend.prototype.executeMultipleOutputs = function (name, opAttrs, inputs, numOutputs) {
    var _this = this;

    var outputMetadata = this.binding.executeOp(name, opAttrs, this.getInputTensorIds(inputs), numOutputs);
    return outputMetadata.map(function (m) {
      return _this.createOutputTensor(m);
    });
  };

  NodeJSKernelBackend.prototype.numDataIds = function () {
    return this.tensorMap.numDataIds();
  };

  NodeJSKernelBackend.prototype.dispose = function () {};

  NodeJSKernelBackend.prototype.read = function (dataId) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , this.readSync(dataId)];
      });
    });
  };

  NodeJSKernelBackend.prototype.readSync = function (dataId) {
    if (!this.tensorMap.has(dataId)) {
      throw new Error("Tensor " + dataId + " was not registered!");
    }

    var info = this.tensorMap.get(dataId);

    if (info.values != null) {
      return info.values;
    } else {
      return this.binding.tensorDataSync(info.id);
    }
  };

  NodeJSKernelBackend.prototype.disposeData = function (dataId) {
    // No-op if already disposed.
    if (!this.tensorMap.has(dataId)) {
      return;
    }

    var id = this.tensorMap.get(dataId).id;

    if (id != null && id >= 0) {
      this.binding.deleteTensor(id);
    }

    this.tensorMap.delete(dataId);
  };

  NodeJSKernelBackend.prototype.move = function (dataId, values, shape, dtype) {
    this.tensorMap.set(dataId, {
      shape: shape,
      dtype: getTFDType(dtype),
      values: values,
      id: -1
    });
  };

  NodeJSKernelBackend.prototype.write = function (values, shape, dtype) {
    var dataId = {};
    this.move(dataId, values, shape, dtype);
    return dataId;
  };

  NodeJSKernelBackend.prototype.fill = function (shape, value, dtype) {
    // TODO(cais, nkreeger): Investigate whether this can be made into
    // a dtype helper method. The underlying op kernel doesn't accept undefined
    // or null dtype.
    if (dtype == null) {
      if (typeof value === 'number') {
        dtype = 'float32';
      } else {
        dtype = 'string';
      }
    }

    var shapeTensor = tfjs_core_1.tensor1d(shape, 'int32');
    var valueTensor = tfjs_core_1.scalar(value, dtype);
    var opAttrs = [{
      name: 'T',
      type: this.binding.TF_ATTR_TYPE,
      value: this.getDTypeInteger(dtype)
    }, {
      name: 'index_type',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_INT32
    }];
    return this.executeSingleOutput('Fill', opAttrs, [shapeTensor, valueTensor]);
  };

  NodeJSKernelBackend.prototype.onesLike = function (x) {
    var opAttrs = [{
      name: 'T',
      type: this.binding.TF_ATTR_TYPE,
      value: this.getDTypeInteger(x.dtype)
    }];
    return this.executeSingleOutput('OnesLike', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.zerosLike = function (x) {
    var opAttrs = [{
      name: 'T',
      type: this.binding.TF_ATTR_TYPE,
      value: this.getDTypeInteger(x.dtype)
    }];
    return this.executeSingleOutput('ZerosLike', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.stridedSlice = function (x, begin, end, strides) {
    var beginTensor = tfjs_core_1.tensor1d(begin, 'int32');

    for (var axis = 0; axis < end.length; axis++) {
      // Unlike Numpy, when the strides are negative, TF C uses -n-1 instead of
      // -1 as the "end" in order to include the first element.
      if (strides[axis] < 0 && end[axis] === -1) {
        end[axis] -= x.shape[axis];
      }
    }

    var endTensor = tfjs_core_1.tensor1d(end, 'int32');
    var stridesTensor = tfjs_core_1.tensor1d(strides, 'int32'); // All of the masks have already been accounted for in the high level op,
    // so the backend does NOT need to deal with masks.

    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Index', 'int32'), {
      name: 'begin_mask',
      type: this.binding.TF_ATTR_INT,
      value: 0
    }, {
      name: 'end_mask',
      type: this.binding.TF_ATTR_INT,
      value: 0
    }, {
      name: 'ellipsis_mask',
      type: this.binding.TF_ATTR_INT,
      value: 0
    }, {
      name: 'new_axis_mask',
      type: this.binding.TF_ATTR_INT,
      value: 0
    }, {
      name: 'shrink_axis_mask',
      type: this.binding.TF_ATTR_INT,
      value: 0
    }];
    return this.executeSingleOutput('StridedSlice', opAttrs, [x, beginTensor, endTensor, stridesTensor]);
  };

  NodeJSKernelBackend.prototype.unstack = function (x, axis) {
    if (axis >= x.shape.length) {
      throw new Error("Invalid axis supplied: " + axis + " shape length: " + x.shape.length);
    }

    var num = x.shape[axis];
    var opAttrs = [{
      name: 'num',
      type: this.binding.TF_ATTR_INT,
      value: num
    }, createTypeOpAttr('T', x.dtype), {
      name: 'axis',
      type: this.binding.TF_ATTR_INT,
      value: axis
    }];
    return this.executeMultipleOutputs('Unpack', opAttrs, [x], num);
  };

  NodeJSKernelBackend.prototype.batchMatMul = function (a, b, transposeA, transposeB) {
    var opAttrs = [createTypeOpAttr('T', a.dtype), {
      name: 'adj_x',
      type: this.binding.TF_ATTR_BOOL,
      value: transposeA
    }, {
      name: 'adj_y',
      type: this.binding.TF_ATTR_BOOL,
      value: transposeB
    }];
    return this.executeSingleOutput('BatchMatMul', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.applyActivation = function (input, activation, preluActivationWeights) {
    var result = input;

    if (activation != null) {
      if (activation === 'linear') {// No-op
      } else if (activation === 'relu') {
        result = this.relu(result);
      } else if (activation === 'prelu') {
        result = this.prelu(result, preluActivationWeights);
      } else if (activation === 'elu') {
        result = this.elu(result);
      } else if (activation === 'relu6') {
        result = this.relu6(result);
      } else {
        throw new Error("Activation: " + activation + " has not been implemented for the Node.js backend");
      }
    }

    return result;
  };

  NodeJSKernelBackend.prototype.fusedConv2d = function (_a) {
    var input = _a.input,
        filter = _a.filter,
        convInfo = _a.convInfo,
        bias = _a.bias,
        activation = _a.activation,
        preluActivationWeights = _a.preluActivationWeights;
    var result = this.conv2d(input, filter, convInfo);

    if (bias != null) {
      result = this.add(result, bias);
    }

    result = this.applyActivation(result, activation, preluActivationWeights);
    return result;
  };

  NodeJSKernelBackend.prototype.fusedBatchMatMul = function (_a) {
    var a = _a.a,
        b = _a.b,
        transposeA = _a.transposeA,
        transposeB = _a.transposeB,
        bias = _a.bias,
        activation = _a.activation,
        preluActivationWeights = _a.preluActivationWeights; // Core TensorFlow does not have a fused BatchMatMul op. Combine calls to
    // achieve the same results:

    var result = this.batchMatMul(a, b, transposeA, transposeB);

    if (bias != null) {
      result = this.add(result, bias);
    }

    result = this.applyActivation(result, activation, preluActivationWeights);
    return result;
  };

  NodeJSKernelBackend.prototype.slice = function (x, begin, size) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Index', 'int32')]; // Bind tensor values

    var beginTensor = tfjs_core_1.tensor1d(begin, 'int32');
    var sizeTensor = tfjs_core_1.tensor1d(size, 'int32');
    return this.executeSingleOutput('Slice', opAttrs, [x, beginTensor, sizeTensor]);
  };

  NodeJSKernelBackend.prototype.reverse = function (a, axis) {
    var opAttrs = [createTypeOpAttr('Tidx', 'int32'), createTypeOpAttr('T', a.dtype)];
    var axisTensor = tfjs_core_1.tensor1d(axis, 'int32');
    return this.executeSingleOutput('ReverseV2', opAttrs, [a, axisTensor]);
  };

  NodeJSKernelBackend.prototype.concat = function (tensors, axis) {
    var opAttrs = [{
      name: 'N',
      type: this.binding.TF_ATTR_INT,
      value: tensors.length
    }, {
      name: 'Tidx',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_INT32
    }, createTensorsTypeOpAttr('T', tensors)];
    var inputs = Array.from(tensors);
    inputs.push(tfjs_core_1.scalar(axis, 'int32'));
    return this.executeSingleOutput('ConcatV2', opAttrs, inputs);
  };

  NodeJSKernelBackend.prototype.neg = function (a) {
    return this.executeSingleInput('Neg', a);
  };

  NodeJSKernelBackend.prototype.diag = function (x) {
    return this.executeSingleInput('Diag', x);
  };

  NodeJSKernelBackend.prototype.add = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Add', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.select = function (condition, a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Select', opAttrs, [condition, a, b]);
  };

  NodeJSKernelBackend.prototype.addN = function (tensors) {
    var opAttrs = [createTypeOpAttr('T', tensors[0].dtype), {
      name: 'N',
      type: this.binding.TF_ATTR_INT,
      value: tensors.length
    }];
    return this.executeSingleOutput('AddN', opAttrs, tensors);
  };

  NodeJSKernelBackend.prototype.subtract = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Sub', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.multiply = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Mul', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.realDivide = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('RealDiv', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.floorDiv = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('FloorDiv', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.divide = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Div', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.divNoNan = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('DivNoNan', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tindices', 'int32'), createTypeOpAttr('Tnumsegments', 'int32')];
    return this.executeSingleOutput('UnsortedSegmentSum', opAttrs, [x, segmentIds, tfjs_core_1.scalar(numSegments, 'int32')]);
  };

  NodeJSKernelBackend.prototype.sum = function (x, axes) {
    var axisTensor = tfjs_core_1.tensor1d(axes, 'int32');
    return this.executeSingleOutput('Sum', this.createReductionOpAttrs(x), [x, axisTensor]);
  };

  NodeJSKernelBackend.prototype.prod = function (x, axes) {
    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');
    var opAttrs = [{
      name: 'keep_dims',
      type: this.binding.TF_ATTR_BOOL,
      value: false
    }, createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tidx', 'int32')];
    return this.executeSingleOutput('Prod', opAttrs, [x, axesTensor]);
  };

  NodeJSKernelBackend.prototype.argMin = function (x, axis) {
    var xInput = x.dtype === 'bool' ? x.toInt() : x;
    var axisScalar = tfjs_core_1.scalar(axis, 'int32');
    var opAttrs = [createTypeOpAttr('T', xInput.dtype), createTypeOpAttr('Tidx', 'int32'), createTypeOpAttr('output_type', 'int32')];
    return this.executeSingleOutput('ArgMin', opAttrs, [xInput, axisScalar]);
  };

  NodeJSKernelBackend.prototype.argMax = function (x, axis) {
    var xInput = x.dtype === 'bool' ? x.toInt() : x;
    var axisScalar = tfjs_core_1.scalar(axis, 'int32');
    var opAttrs = [createTypeOpAttr('T', xInput.dtype), createTypeOpAttr('Tidx', 'int32'), createTypeOpAttr('output_type', 'int32')];
    return this.executeSingleOutput('ArgMax', opAttrs, [xInput, axisScalar]);
  };

  NodeJSKernelBackend.prototype.equal = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Equal', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.notEqual = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('NotEqual', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.less = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Less', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.lessEqual = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('LessEqual', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.greater = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Greater', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.greaterEqual = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('GreaterEqual', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.logicalNot = function (a) {
    return this.executeSingleOutput('LogicalNot', [], [a]);
  };

  NodeJSKernelBackend.prototype.logicalAnd = function (a, b) {
    return this.executeSingleOutput('LogicalAnd', [], [a, b]);
  };

  NodeJSKernelBackend.prototype.logicalOr = function (a, b) {
    return this.executeSingleOutput('LogicalOr', [], [a, b]);
  };

  NodeJSKernelBackend.prototype.where = function (condition) {
    return this.executeSingleOutput('Where', [], [condition]);
  };

  NodeJSKernelBackend.prototype.topKValues = function (x, k) {
    throw new Error('Method not implemented.');
  };

  NodeJSKernelBackend.prototype.topKIndices = function (x, k) {
    throw new Error('Method not implemented.');
  };

  NodeJSKernelBackend.prototype.topk = function (x, k, sorted) {
    var kCount = util_1.isNullOrUndefined(k) ? 1 : k;
    var isSorted = util_1.isNullOrUndefined(sorted) ? true : sorted;
    var opAttrs = [{
      name: 'sorted',
      type: this.binding.TF_ATTR_BOOL,
      value: isSorted
    }, createTypeOpAttr('T', x.dtype)];
    var kTensor = tfjs_core_1.scalar(kCount, 'int32'); // 'TopKV2' has two-hard coded output attributes:

    return this.executeMultipleOutputs('TopKV2', opAttrs, [x, kTensor], 2);
  };

  NodeJSKernelBackend.prototype.min = function (x, axes) {
    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');
    return this.executeSingleOutput('Min', this.createReductionOpAttrs(x), [x, axesTensor]);
  };

  NodeJSKernelBackend.prototype.minimum = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Minimum', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.max = function (x, axes) {
    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');
    return this.executeSingleOutput('Max', this.createReductionOpAttrs(x), [x, axesTensor]);
  };

  NodeJSKernelBackend.prototype.maximum = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype))];
    return this.executeSingleOutput('Maximum', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.all = function (x, axes) {
    var opAttrs = [{
      name: 'keep_dims',
      type: this.binding.TF_ATTR_BOOL,
      value: false
    }, createTypeOpAttr('Tidx', 'int32')];
    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');
    return this.executeSingleOutput('All', opAttrs, [x, axesTensor]);
  };

  NodeJSKernelBackend.prototype.any = function (x, axes) {
    var opAttrs = [{
      name: 'keep_dims',
      type: this.binding.TF_ATTR_BOOL,
      value: false
    }, createTypeOpAttr('Tidx', 'int32')];
    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');
    return this.executeSingleOutput('Any', opAttrs, [x, axesTensor]);
  };

  NodeJSKernelBackend.prototype.ceil = function (x) {
    return this.executeSingleInput('Ceil', x);
  };

  NodeJSKernelBackend.prototype.floor = function (x) {
    return this.executeSingleInput('Floor', x);
  };

  NodeJSKernelBackend.prototype.pow = function (a, b) {
    var dtype = tfjs_core_1.backend_util.upcastType(a.dtype, b.dtype);
    var opAttrs = [createTypeOpAttr('T', dtype)];
    return this.executeSingleOutput('Pow', opAttrs, [a.cast(dtype), b.cast(dtype)]);
  };

  NodeJSKernelBackend.prototype.exp = function (x) {
    var xTensor = x.dtype === 'int32' ? x.toFloat() : x;
    return this.executeSingleInput('Exp', xTensor);
  };

  NodeJSKernelBackend.prototype.log = function (x) {
    return this.executeSingleInput('Log', x);
  };

  NodeJSKernelBackend.prototype.log1p = function (x) {
    return this.executeSingleInput('Log1p', x);
  };

  NodeJSKernelBackend.prototype.sqrt = function (x) {
    return this.executeSingleInput('Sqrt', x);
  };

  NodeJSKernelBackend.prototype.square = function (x) {
    return this.executeSingleInput('Square', x);
  };

  NodeJSKernelBackend.prototype.relu = function (x) {
    return this.executeSingleInput('Relu', x);
  };

  NodeJSKernelBackend.prototype.relu6 = function (x) {
    return this.executeSingleInput('Relu6', x);
  };

  NodeJSKernelBackend.prototype.prelu = function (x, a) {
    var pos = this.relu(x);
    var neg = a.mul(x.sub(this.abs(x))).mul(0.5);
    return pos.add(neg);
  };

  NodeJSKernelBackend.prototype.elu = function (x) {
    return this.executeSingleInput('Elu', x);
  };

  NodeJSKernelBackend.prototype.eluDer = function (dy, y) {
    var opAttrs = [createTypeOpAttr('T', y.dtype)];
    return this.executeSingleOutput('EluGrad', opAttrs, [dy, y]);
  };

  NodeJSKernelBackend.prototype.selu = function (x) {
    return this.executeSingleInput('Selu', x);
  };

  NodeJSKernelBackend.prototype.int = function (x) {
    throw new Error('Method not implemented.');
  };

  NodeJSKernelBackend.prototype.clip = function (x, min, max) {
    var xMin = this.minimum(x, tfjs_core_1.scalar(max));
    return this.maximum(xMin, tfjs_core_1.scalar(min));
  };

  NodeJSKernelBackend.prototype.abs = function (x) {
    return this.executeSingleInput('Abs', x);
  };

  NodeJSKernelBackend.prototype.complexAbs = function (x) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tout', 'float32')];
    return this.executeSingleOutput('ComplexAbs', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.sigmoid = function (x) {
    return this.executeSingleInput('Sigmoid', x);
  };

  NodeJSKernelBackend.prototype.sin = function (x) {
    return this.executeSingleInput('Sin', x);
  };

  NodeJSKernelBackend.prototype.cos = function (x) {
    return this.executeSingleInput('Cos', x);
  };

  NodeJSKernelBackend.prototype.tan = function (x) {
    return this.executeSingleInput('Tan', x);
  };

  NodeJSKernelBackend.prototype.asin = function (x) {
    return this.executeSingleInput('Asin', x);
  };

  NodeJSKernelBackend.prototype.acos = function (x) {
    return this.executeSingleInput('Acos', x);
  };

  NodeJSKernelBackend.prototype.atan = function (x) {
    return this.executeSingleInput('Atan', x);
  };

  NodeJSKernelBackend.prototype.sinh = function (x) {
    return this.executeSingleInput('Sinh', x);
  };

  NodeJSKernelBackend.prototype.cosh = function (x) {
    return this.executeSingleInput('Cosh', x);
  };

  NodeJSKernelBackend.prototype.tanh = function (x) {
    return this.executeSingleInput('Tanh', x);
  };

  NodeJSKernelBackend.prototype.mod = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', a.dtype)];
    return this.executeSingleOutput('FloorMod', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.round = function (x) {
    return this.executeSingleInput('Round', x);
  };

  NodeJSKernelBackend.prototype.sign = function (x) {
    return this.executeSingleInput('Sign', x);
  };

  NodeJSKernelBackend.prototype.isNaN = function (x) {
    return this.executeSingleInput('IsNan', x);
  };

  NodeJSKernelBackend.prototype.isInf = function (x) {
    return this.executeSingleInput('IsInf', x);
  };

  NodeJSKernelBackend.prototype.isFinite = function (x) {
    return this.executeSingleInput('IsFinite', x);
  };

  NodeJSKernelBackend.prototype.rsqrt = function (x) {
    return this.executeSingleInput('Rsqrt', x);
  };

  NodeJSKernelBackend.prototype.reciprocal = function (x) {
    return this.executeSingleInput('Reciprocal', x);
  };

  NodeJSKernelBackend.prototype.asinh = function (x) {
    return this.executeSingleInput('Asinh', x);
  };

  NodeJSKernelBackend.prototype.acosh = function (x) {
    return this.executeSingleInput('Acosh', x);
  };

  NodeJSKernelBackend.prototype.atanh = function (x) {
    return this.executeSingleInput('Atanh', x);
  };

  NodeJSKernelBackend.prototype.erf = function (x) {
    return this.executeSingleInput('Erf', x);
  };

  NodeJSKernelBackend.prototype.squaredDifference = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', a.dtype)];
    return this.executeSingleOutput('SquaredDifference', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.expm1 = function (x) {
    return this.executeSingleInput('Expm1', x);
  };

  NodeJSKernelBackend.prototype.softplus = function (x) {
    return this.executeSingleInput('Softplus', x);
  };

  NodeJSKernelBackend.prototype.atan2 = function (a, b) {
    var opAttrs = [createTypeOpAttr('T', a.dtype)];
    return this.executeSingleOutput('Atan2', opAttrs, [a, b]);
  };

  NodeJSKernelBackend.prototype.step = function (x, alpha) {
    var dtype = x.dtype;
    var nans = this.isNaN(x);
    var stepNoNans = this.select(this.greater(x, tfjs_core_1.scalar(0, dtype)), tfjs_core_1.ones(x.shape), tfjs_core_1.fill(x.shape, alpha, dtype));
    return this.select(nans, x, stepNoNans);
  };

  NodeJSKernelBackend.prototype.conv2d = function (x, filter, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'use_cudnn_on_gpu',
      type: this.binding.TF_ATTR_BOOL,
      value: true
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    return this.executeSingleOutput('Conv2D', opAttrs, [x, filter]);
  };

  NodeJSKernelBackend.prototype.conv2dDerInput = function (dy, filter, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', 'float32'), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'use_cudnn_on_gpu',
      type: this.binding.TF_ATTR_BOOL,
      value: true
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    var inputSizes = tfjs_core_1.tensor1d(convInfo.inShape, 'int32');
    return this.executeSingleOutput('Conv2DBackpropInput', opAttrs, [inputSizes, filter, dy]);
  };

  NodeJSKernelBackend.prototype.conv2dDerFilter = function (x, dy, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', 'float32'), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'use_cudnn_on_gpu',
      type: this.binding.TF_ATTR_BOOL,
      value: true
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    var filterSizes = tfjs_core_1.tensor1d(convInfo.filterShape, 'int32');
    return this.executeSingleOutput('Conv2DBackpropFilter', opAttrs, [x, filterSizes, dy]);
  };

  NodeJSKernelBackend.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', 'float32'), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    var inputSizes = tfjs_core_1.tensor1d(convInfo.inShape, 'int32');
    return this.executeSingleOutput('DepthwiseConv2dNativeBackpropInput', opAttrs, [inputSizes, filter, dy]);
  };

  NodeJSKernelBackend.prototype.depthwiseConv2DDerFilter = function (x, dY, convInfo) {
    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', 'float32'), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    var filterSizes = tfjs_core_1.tensor1d(convInfo.filterShape, 'int32');
    return this.executeSingleOutput('DepthwiseConv2dNativeBackpropFilter', opAttrs, [x, filterSizes, dY]);
  };

  NodeJSKernelBackend.prototype.fusedDepthwiseConv2D = function (_a) {
    var input = _a.input,
        filter = _a.filter,
        convInfo = _a.convInfo,
        bias = _a.bias,
        activation = _a.activation,
        preluActivationWeights = _a.preluActivationWeights;
    var result = this.depthwiseConv2D(input, filter, convInfo);

    if (bias != null) {
      result = this.add(result, bias);
    }

    result = this.applyActivation(result, activation, preluActivationWeights);
    return result;
  };

  NodeJSKernelBackend.prototype.depthwiseConv2D = function (input, filter, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', input.dtype), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    return this.executeSingleOutput('DepthwiseConv2dNative', opAttrs, [input, filter]);
  };

  NodeJSKernelBackend.prototype.conv3d = function (x, filter, convInfo) {
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';

    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {
      throw new Error('CPU Dilation depth must be 1');
    }

    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    return this.executeSingleOutput('Conv3D', opAttrs, [x, filter]);
  };

  NodeJSKernelBackend.prototype.conv3dDerInput = function (dy, filter, convInfo) {
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';

    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {
      throw new Error('CPU Dilation depth must be 1');
    }

    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', dy.dtype), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }, createTypeOpAttr('Tshape', 'int32')];
    var inputSizes = tfjs_core_1.tensor1d(convInfo.inShape, 'int32');
    return this.executeSingleOutput('Conv3DBackpropInputV2', opAttrs, [inputSizes, filter, dy]);
  };

  NodeJSKernelBackend.prototype.conv3dDerFilter = function (x, dY, convInfo) {
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';

    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {
      throw new Error('CPU Dilation depth must be 1');
    }

    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'dilations',
      type: this.binding.TF_ATTR_INT,
      value: dilations
    }];
    var filterSizes = tfjs_core_1.tensor1d(convInfo.filterShape, 'int32');
    return this.executeSingleOutput('Conv3DBackpropFilterV2', opAttrs, [x, filterSizes, dY]);
  };

  NodeJSKernelBackend.prototype.maxPool = function (x, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    return this.executeSingleOutput('MaxPool', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding type was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    return this.executeSingleOutput('MaxPoolGrad', opAttrs, [x, y, dy]);
  };

  NodeJSKernelBackend.prototype.avgPool = function (x, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    return this.executeSingleOutput('AvgPool', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.avgPoolBackprop = function (dy, x, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding type was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    var origInputShape = tfjs_core_1.tensor1d(x.shape, 'int32');
    return this.executeSingleOutput('AvgPoolGrad', opAttrs, [origInputShape, dy]);
  };

  NodeJSKernelBackend.prototype.avgPool3d = function (x, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    return this.executeSingleOutput('AvgPool3D', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.avgPool3dBackprop = function (dy, x, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding type was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    var origInputShape = tfjs_core_1.tensor1d(x.shape, 'int32');
    return this.executeSingleOutput('AvgPool3DGrad', opAttrs, [origInputShape, dy]);
  };

  NodeJSKernelBackend.prototype.maxPool3d = function (x, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    return this.executeSingleOutput('MaxPool3D', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.maxPool3dBackprop = function (dy, x, y, convInfo) {
    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {
      throw new Error("TF Backend supports only 'valid' and 'same' padding " + ("while padding type was " + convInfo.padInfo.type));
    }

    var ksize = [1, convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth, 1];
    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];
    var padding = convInfo.padInfo.type;
    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'ksize',
      type: this.binding.TF_ATTR_INT,
      value: ksize
    }, {
      name: 'strides',
      type: this.binding.TF_ATTR_INT,
      value: strides
    }, {
      name: 'padding',
      type: this.binding.TF_ATTR_STRING,
      value: padding
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    return this.executeSingleOutput('MaxPool3DGrad', opAttrs, [x, y, dy]);
  };

  NodeJSKernelBackend.prototype.reshape = function (x, shape) {
    var shapeTensor = tfjs_core_1.tensor1d(shape, 'int32');
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tshape', shapeTensor.dtype)];
    return this.executeSingleOutput('Reshape', opAttrs, [x, shapeTensor]);
  };

  NodeJSKernelBackend.prototype.cast = function (x, dtype) {
    var opAttrs = [createTypeOpAttr('SrcT', x.dtype), createTypeOpAttr('DstT', dtype), {
      name: 'Truncate',
      type: this.binding.TF_ATTR_BOOL,
      value: false
    }];
    return this.executeSingleOutput('Cast', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.tile = function (x, reps) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tmultiples', 'int32')];
    var multiples = tfjs_core_1.tensor1d(reps, 'int32');
    return this.executeSingleOutput('Tile', opAttrs, [x, multiples]);
  };

  NodeJSKernelBackend.prototype.pad = function (x, paddings, constantValue) {
    // Bind tensor values
    var paddingsTensor = tfjs_core_1.tensor2d(paddings, [paddings.length, 2], 'int32');
    var constantTensor = tfjs_core_1.scalar(constantValue, x.dtype);
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tpaddings', paddingsTensor.dtype)];
    return this.executeSingleOutput('PadV2', opAttrs, [x, paddingsTensor, constantTensor]);
  };

  NodeJSKernelBackend.prototype.transpose = function (x, perm) {
    var permTensor = tfjs_core_1.tensor1d(perm, 'int32');
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tperm', 'int32')];
    return this.executeSingleOutput('Transpose', opAttrs, [x, permTensor]);
  };

  NodeJSKernelBackend.prototype.gather = function (x, indices, axis) {
    var axisTensor = tfjs_core_1.scalar(axis, 'int32');
    var opAttrs = [createTypeOpAttr('Tparams', x.dtype), createTypeOpAttr('Tindices', indices.dtype), createTypeOpAttr('Taxis', 'int32')];
    return this.executeSingleOutput('GatherV2', opAttrs, [x, indices, axisTensor]);
  };

  NodeJSKernelBackend.prototype.gatherND = function (x, indices) {
    var opAttrs = [createTypeOpAttr('Tparams', x.dtype), createTypeOpAttr('Tindices', 'int32')];
    return this.executeSingleOutput('GatherNd', opAttrs, [x, indices]);
  };

  NodeJSKernelBackend.prototype.scatterND = function (indices, updates, shape) {
    var opAttrs = [createTypeOpAttr('T', updates.dtype), createTypeOpAttr('Tindices', 'int32')];
    var shapeTensor = tfjs_core_1.tensor1d(shape, 'int32');
    return this.executeSingleOutput('ScatterNd', opAttrs, [indices, updates, shapeTensor]);
  };

  NodeJSKernelBackend.prototype.batchToSpaceND = function (x, blockShape, crops) {
    var blockShapeTensor = tfjs_core_1.tensor1d(blockShape, 'int32');
    var cropsTensor = tfjs_core_1.tensor2d(crops, [crops.length, crops[0].length], 'int32');
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tblock_shape', 'int32'), createTypeOpAttr('Tcrops', cropsTensor.dtype)];
    return this.executeSingleOutput('BatchToSpaceND', opAttrs, [x, blockShapeTensor, cropsTensor]);
  };

  NodeJSKernelBackend.prototype.spaceToBatchND = function (x, blockShape, paddings) {
    var blockShapeTensor = tfjs_core_1.tensor1d(blockShape, 'int32');
    var paddingsTensor = tfjs_core_1.tensor2d(paddings, [paddings.length, paddings[0].length], 'int32');
    var opAttrs = [createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tblock_shape', 'int32'), createTypeOpAttr('Tpaddings', paddingsTensor.dtype)];
    return this.executeSingleOutput('SpaceToBatchND', opAttrs, [x, blockShapeTensor, paddingsTensor]);
  };

  NodeJSKernelBackend.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'align_corners',
      type: this.binding.TF_ATTR_BOOL,
      value: alignCorners
    }];
    var size = tfjs_core_1.tensor1d([newHeight, newWidth], 'int32');
    return this.executeSingleOutput('ResizeBilinear', opAttrs, [x, size]);
  };

  NodeJSKernelBackend.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'align_corners',
      type: this.binding.TF_ATTR_BOOL,
      value: alignCorners
    }];
    return this.executeSingleOutput('ResizeBilinearGrad', opAttrs, [dy, x]);
  };

  NodeJSKernelBackend.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'align_corners',
      type: this.binding.TF_ATTR_BOOL,
      value: alignCorners
    }];
    var size = tfjs_core_1.tensor1d([newHeight, newWidth], 'int32');
    return this.executeSingleOutput('ResizeNearestNeighbor', opAttrs, [x, size]);
  };

  NodeJSKernelBackend.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'align_corners',
      type: this.binding.TF_ATTR_BOOL,
      value: alignCorners
    }];
    var _a = x.shape,
        origHeight = _a[1],
        origWidth = _a[2];
    var size = tfjs_core_1.tensor1d([origHeight, origWidth], 'int32');
    return this.executeSingleOutput('ResizeNearestNeighborGrad', opAttrs, [dy, size]);
  };

  NodeJSKernelBackend.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
    if (mean.rank > 1) {
      // Fused batch norm doesn't work with high-dim mean/var/scale/offset.
      var inv = tfjs_core_1.rsqrt(variance.add(tfjs_core_1.scalar(varianceEpsilon)));

      if (scale != null) {
        inv = inv.mul(scale);
      }

      var xNorm = x.sub(mean).mul(inv);
      return offset != null ? xNorm.add(offset) : xNorm;
    }

    var dataFormat = 'NHWC';
    var depth = x.shape[3];
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'epsilon',
      type: this.binding.TF_ATTR_FLOAT,
      value: varianceEpsilon
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }, {
      name: 'is_training',
      type: this.binding.TF_ATTR_BOOL,
      value: false
    }];
    var numOutputs = 5;

    if (scale == null) {
      scale = tfjs_core_1.fill([depth], 1);
    }

    if (offset == null) {
      offset = tfjs_core_1.fill([depth], 0);
    }

    return this.executeMultipleOutputs('FusedBatchNorm', opAttrs, [x, scale, offset, mean, variance], numOutputs)[0];
  };

  NodeJSKernelBackend.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
    var opAttrs = [createTypeOpAttr('T', x.dtype), {
      name: 'depth_radius',
      type: this.binding.TF_ATTR_INT,
      value: radius
    }, {
      name: 'bias',
      type: this.binding.TF_ATTR_FLOAT,
      value: bias
    }, {
      name: 'alpha',
      type: this.binding.TF_ATTR_FLOAT,
      value: alpha
    }, {
      name: 'beta',
      type: this.binding.TF_ATTR_FLOAT,
      value: beta
    }];
    return this.executeSingleOutput('LRN', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.LRNGrad = function (dy, inputImage, outputImage, radius, bias, alpha, beta) {
    var opAttrs = [createTypeOpAttr('T', dy.dtype), {
      name: 'depth_radius',
      type: this.binding.TF_ATTR_INT,
      value: radius
    }, {
      name: 'bias',
      type: this.binding.TF_ATTR_FLOAT,
      value: bias
    }, {
      name: 'alpha',
      type: this.binding.TF_ATTR_FLOAT,
      value: alpha
    }, {
      name: 'beta',
      type: this.binding.TF_ATTR_FLOAT,
      value: beta
    }];
    return this.executeSingleOutput('LRNGrad', opAttrs, [dy, inputImage, outputImage]);
  };

  NodeJSKernelBackend.prototype.multinomial = function (logits, normalized, numSamples, seed) {
    if (normalized) {
      throw new Error('TF Node backend does not support normalized logits ' + 'passed to multinomial');
    }

    var opAttrs = [createTypeOpAttr('T', logits.dtype), createTypeOpAttr('output_dtype', 'int32'), {
      name: 'seed',
      type: this.binding.TF_ATTR_INT,
      value: seed
    }, {
      name: 'seed2',
      type: this.binding.TF_ATTR_INT,
      value: seed * seed
    }];
    return this.executeSingleOutput('Multinomial', opAttrs, [logits, tfjs_core_1.scalar(numSamples, 'int32')]);
  };

  NodeJSKernelBackend.prototype.oneHot = function (indices, depth, onValue, offValue) {
    var depthTensor = tfjs_core_1.scalar(depth, 'int32');
    var onValueTensor = tfjs_core_1.scalar(onValue, 'int32');
    var offValueTensor = tfjs_core_1.scalar(offValue, 'int32');
    var opAttrs = [{
      name: 'axis',
      type: this.binding.TF_ATTR_INT,
      value: -1
    }, createTypeOpAttr('T', indices.dtype), createTypeOpAttr('TI', indices.dtype)];
    return this.executeSingleOutput('OneHot', opAttrs, [indices, depthTensor, onValueTensor, offValueTensor]);
  };

  NodeJSKernelBackend.prototype.cumsum = function (x, axis, exclusive, reverse) {
    var axisTensor = tfjs_core_1.scalar(axis, 'int32');
    var opAttrs = [{
      name: 'exclusive',
      type: this.binding.TF_ATTR_BOOL,
      value: exclusive
    }, {
      name: 'reverse',
      type: this.binding.TF_ATTR_BOOL,
      value: reverse
    }, createTypeOpAttr('T', x.dtype), createTypeOpAttr('Tidx', 'int32')];
    return this.executeSingleOutput('Cumsum', opAttrs, [x, axisTensor]);
  };

  NodeJSKernelBackend.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    var opAttrs = [createTypeOpAttr('T', boxes.dtype)];
    var maxOutputSizeTensor = tfjs_core_1.scalar(maxOutputSize, 'int32');
    var iouThresholdTensor = tfjs_core_1.scalar(iouThreshold);
    var scoreThresholdTensor = tfjs_core_1.scalar(scoreThreshold);
    return this.executeSingleOutput('NonMaxSuppressionV3', opAttrs, [boxes, scores, maxOutputSizeTensor, iouThresholdTensor, scoreThresholdTensor]);
  };

  NodeJSKernelBackend.prototype.fft = function (x) {
    var opAttrs = [createTypeOpAttr('Tcomplex', x.dtype)];
    return this.executeSingleOutput('FFT', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.ifft = function (x) {
    var opAttrs = [createTypeOpAttr('Tcomplex', x.dtype)];
    return this.executeSingleOutput('IFFT', opAttrs, [x]);
  };

  NodeJSKernelBackend.prototype.complex = function (real, imag) {
    var opAttrs = [createTensorsTypeOpAttr('T', real), {
      name: 'Tout',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_COMPLEX64
    }];
    var inputs = [real, imag];
    return this.executeSingleOutput('Complex', opAttrs, inputs);
  };

  NodeJSKernelBackend.prototype.real = function (input) {
    var opAttrs = [createTensorsTypeOpAttr('T', input), {
      name: 'Tout',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_FLOAT
    }];
    var inputs = [input];
    return this.executeSingleOutput('Real', opAttrs, inputs);
  };

  NodeJSKernelBackend.prototype.imag = function (input) {
    var opAttrs = [{
      name: 'T',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_COMPLEX64
    }, {
      name: 'Tout',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_FLOAT
    }];
    var inputs = [input];
    return this.executeSingleOutput('Imag', opAttrs, inputs);
  };

  NodeJSKernelBackend.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {
    var opAttrs = [createTypeOpAttr('T', image.dtype), {
      name: 'method',
      type: this.binding.TF_ATTR_STRING,
      value: method
    }, {
      name: 'extrapolation_value',
      type: this.binding.TF_ATTR_FLOAT,
      value: extrapolationValue
    }];
    var cropSizeTensor = tfjs_core_1.tensor1d(cropSize, 'int32');
    return this.executeSingleOutput('CropAndResize', opAttrs, [image, boxes, boxIndex, cropSizeTensor]);
  };

  NodeJSKernelBackend.prototype.depthToSpace = function (x, blockSize, dataFormat) {
    var opAttrs = [createTensorsTypeOpAttr('T', x), {
      name: 'block_size',
      type: this.binding.TF_ATTR_INT,
      value: blockSize < 2 ? 2 : blockSize
    }, {
      name: 'data_format',
      type: this.binding.TF_ATTR_STRING,
      value: dataFormat
    }];
    var inputs = [x];
    return this.executeSingleOutput('DepthToSpace', opAttrs, inputs);
  };

  NodeJSKernelBackend.prototype.split = function (value, sizeSplits, axis) {
    var opAttrs = [{
      name: 'num_split',
      type: this.binding.TF_ATTR_INT,
      value: sizeSplits.length
    }, createTensorsTypeOpAttr('T', value), {
      name: 'Tlen',
      type: this.binding.TF_ATTR_TYPE,
      value: this.binding.TF_INT32
    }];
    var inputs = [value];
    inputs.push(tfjs_core_1.tensor1d(sizeSplits, 'int32'));
    inputs.push(tfjs_core_1.scalar(axis, 'int32'));
    return this.executeMultipleOutputs('SplitV', opAttrs, inputs, sizeSplits.length);
  };

  NodeJSKernelBackend.prototype.sparseToDense = function (sparseIndices, sparseValues, outputShape, defaultValue) {
    var opAttrs = [{
      name: 'validate_indices',
      type: this.binding.TF_ATTR_BOOL,
      value: true
    }, createTypeOpAttr('T', sparseValues.dtype), createTypeOpAttr('Tindices', sparseIndices.dtype)];
    var outputShapeTensor = tfjs_core_1.tensor1d(outputShape, 'int32');
    return this.executeSingleOutput('SparseToDense', opAttrs, [sparseIndices, outputShapeTensor, sparseValues, defaultValue]);
  };

  NodeJSKernelBackend.prototype.linspace = function (start, stop, num) {
    var opAttrs = [createTypeOpAttr('T', 'float32'), createTypeOpAttr('Tidx', 'int32')];
    var inputs = [tfjs_core_1.scalar(start, 'float32'), tfjs_core_1.scalar(stop, 'float32'), tfjs_core_1.scalar(num, 'int32')];
    return this.executeSingleOutput('LinSpace', opAttrs, inputs);
  };

  NodeJSKernelBackend.prototype.fromPixels = function (pixels, numChannels) {
    if (pixels == null) {
      throw new Error('pixels passed to fromPixels() can not be null');
    } // tslint:disable-next-line:no-any


    if (pixels.getContext == null) {
      throw new Error('When running in node, pixels must be an HTMLCanvasElement ' + 'like the one returned by the `canvas` npm package');
    }

    var vals = // tslint:disable-next-line:no-any
    pixels.getContext('2d').getImageData(0, 0, pixels.width, pixels.height).data;
    var values;

    if (numChannels === 4) {
      values = new Int32Array(vals);
    } else {
      var numPixels = pixels.width * pixels.height;
      values = new Int32Array(numPixels * numChannels);

      for (var i = 0; i < numPixels; i++) {
        for (var channel = 0; channel < numChannels; ++channel) {
          values[i * numChannels + channel] = vals[i * 4 + channel];
        }
      }
    }

    var outShape = [pixels.height, pixels.width, numChannels];
    return tfjs_core_1.tensor3d(values, outShape, 'int32');
  };

  NodeJSKernelBackend.prototype.decodeJpeg = function (contents, channels, ratio, fancyUpscaling, tryRecoverTruncated, acceptableFraction, dctMethod) {
    var opAttrs = [{
      name: 'channels',
      type: this.binding.TF_ATTR_INT,
      value: channels
    }, {
      name: 'ratio',
      type: this.binding.TF_ATTR_INT,
      value: ratio
    }, {
      name: 'fancy_upscaling',
      type: this.binding.TF_ATTR_BOOL,
      value: fancyUpscaling
    }, {
      name: 'try_recover_truncated',
      type: this.binding.TF_ATTR_BOOL,
      value: tryRecoverTruncated
    }, {
      name: 'acceptable_fraction',
      type: this.binding.TF_ATTR_FLOAT,
      value: acceptableFraction
    }, {
      name: 'dct_method',
      type: this.binding.TF_ATTR_STRING,
      value: dctMethod
    }];
    var inputArgs = [tfjs_core_1.scalar(contents, 'string')];
    return this.executeSingleOutput('DecodeJpeg', opAttrs, inputArgs);
  };

  NodeJSKernelBackend.prototype.decodePng = function (contents, channels) {
    var opAttrs = [{
      name: 'channels',
      type: this.binding.TF_ATTR_INT,
      value: channels
    }];
    var inputArgs = [tfjs_core_1.scalar(contents, 'string')];
    return this.executeSingleOutput('DecodePng', opAttrs, inputArgs);
  };

  NodeJSKernelBackend.prototype.decodeBmp = function (contents, channels) {
    var opAttrs = [{
      name: 'channels',
      type: this.binding.TF_ATTR_INT,
      value: channels
    }];
    var inputArgs = [tfjs_core_1.scalar(contents, 'string')];
    return this.executeSingleOutput('DecodeBmp', opAttrs, inputArgs);
  };

  NodeJSKernelBackend.prototype.decodeGif = function (contents) {
    var inputArgs = [tfjs_core_1.scalar(contents, 'string')];
    return this.executeSingleOutput('DecodeGif', [], inputArgs);
  };

  NodeJSKernelBackend.prototype.executeEncodeImageOp = function (name, opAttrs, imageData, imageShape) {
    var inputTensorId = this.binding.createTensor(imageShape, this.binding.TF_UINT8, imageData);
    var outputMetadata = this.binding.executeOp(name, opAttrs, [inputTensorId], 1);
    var outputTensorInfo = outputMetadata[0]; // prevent the tensor data from being converted to a UTF8 string, since
    // the encoded data is not valid UTF8

    outputTensorInfo.dtype = this.binding.TF_UINT8;
    return this.createOutputTensor(outputTensorInfo);
  };

  NodeJSKernelBackend.prototype.encodeJpeg = function (imageData, imageShape, format, quality, progressive, optimizeSize, chromaDownsampling, densityUnit, xDensity, yDensity, xmpMetadata) {
    var opAttrs = [{
      name: 'format',
      type: this.binding.TF_ATTR_STRING,
      value: format
    }, {
      name: 'quality',
      type: this.binding.TF_ATTR_INT,
      value: quality
    }, {
      name: 'progressive',
      type: this.binding.TF_ATTR_BOOL,
      value: progressive
    }, {
      name: 'optimize_size',
      type: this.binding.TF_ATTR_BOOL,
      value: optimizeSize
    }, {
      name: 'chroma_downsampling',
      type: this.binding.TF_ATTR_BOOL,
      value: chromaDownsampling
    }, {
      name: 'density_unit',
      type: this.binding.TF_ATTR_STRING,
      value: densityUnit
    }, {
      name: 'x_density',
      type: this.binding.TF_ATTR_INT,
      value: xDensity
    }, {
      name: 'y_density',
      type: this.binding.TF_ATTR_INT,
      value: yDensity
    }, {
      name: 'xmp_metadata',
      type: this.binding.TF_ATTR_STRING,
      value: xmpMetadata
    }];
    return this.executeEncodeImageOp('EncodeJpeg', opAttrs, imageData, imageShape);
  };

  NodeJSKernelBackend.prototype.encodePng = function (imageData, imageShape, compression) {
    var opAttrs = [{
      name: 'compression',
      type: this.binding.TF_ATTR_INT,
      value: compression
    }];
    return this.executeEncodeImageOp('EncodePng', opAttrs, imageData, imageShape);
  };

  NodeJSKernelBackend.prototype.deleteSavedModel = function (id) {
    this.binding.deleteSavedModel(id);
  };

  NodeJSKernelBackend.prototype.loadSavedModelMetaGraph = function (path, tags) {
    return this.binding.loadSavedModel(path, tags);
  };

  NodeJSKernelBackend.prototype.runSavedModel = function (id, inputs, inputOpNames, outputOpNames) {
    var _this = this;

    var outputMetadata = this.binding.runSavedModel(id, this.getInputTensorIds(inputs), inputOpNames.join(','), outputOpNames.join(','));
    return outputMetadata.map(function (m) {
      return _this.createOutputTensor(m);
    });
  }; // ------------------------------------------------------------
  // TensorBoard-related (tfjs-node-specific) backend kernels.


  NodeJSKernelBackend.prototype.summaryWriter = function (logdir) {
    var opAttrs = [{
      name: 'shared_name',
      type: this.binding.TF_ATTR_STRING,
      value: "logdir:" + logdir
    }, {
      name: 'container',
      type: this.binding.TF_ATTR_STRING,
      value: ''
    }];
    var writerResource = this.executeSingleOutput('SummaryWriter', opAttrs, []);
    return writerResource;
  };

  NodeJSKernelBackend.prototype.createSummaryFileWriter = function (resourceHandle, logdir, maxQueue, flushMillis, filenameSuffix) {
    var inputArgs = [resourceHandle, tfjs_core_1.scalar(logdir), tfjs_core_1.scalar(maxQueue == null ? 10 : maxQueue, 'int32'), tfjs_core_1.scalar(flushMillis == null ? 2 * 60 * 1000 : flushMillis, 'int32'), tfjs_core_1.scalar(filenameSuffix == null ? '.v2' : filenameSuffix)];
    this.executeMultipleOutputs('CreateSummaryFileWriter', [], inputArgs, 0);
  };

  NodeJSKernelBackend.prototype.writeScalarSummary = function (resourceHandle, step, name, value) {
    var _this = this;

    tfjs_core_1.tidy(function () {
      tfjs_core_1.util.assert(Number.isInteger(step), function () {
        return "step is expected to be an integer, but is instead " + step;
      });
      var inputArgs = [resourceHandle, new int64_tensors_1.Int64Scalar(step), tfjs_core_1.scalar(name, 'string')];
      var typeAttr;

      if (typeof value === 'number') {
        inputArgs.push(tfjs_core_1.scalar(value));
        typeAttr = _this.binding.TF_FLOAT;
      } else {
        // `value` is a Scalar.
        tfjs_core_1.util.assert(value.rank === 0, function () {
          return "A non-scalar tensor (rank " + value.rank + ") is passed to " + "writeScalarSummary()";
        });
        inputArgs.push(value);
        typeAttr = _this.typeAttributeFromTensor(value);
      }

      var opAttrs = [{
        name: 'T',
        type: _this.binding.TF_ATTR_TYPE,
        value: typeAttr
      }];

      _this.binding.executeOp('WriteScalarSummary', opAttrs, _this.getInputTensorIds(inputArgs), 0);
    });
  };

  NodeJSKernelBackend.prototype.flushSummaryWriter = function (resourceHandle) {
    var inputArgs = [resourceHandle];
    this.executeMultipleOutputs('FlushSummaryWriter', [], inputArgs, 0);
  }; // ~ TensorBoard-related (tfjs-node-specific) backend kernels.
  // ------------------------------------------------------------


  NodeJSKernelBackend.prototype.memory = function () {
    // Due to automatic garbage collection, the numbers are unreliable.
    // TODO(kreeger): Since there is finalization in C, count the true
    // number of undisposed tensors.
    return {
      unreliable: true
    };
  };

  NodeJSKernelBackend.prototype.time = function (f) {
    return __awaiter(this, void 0, void 0, function () {
      var start, elapsed;
      return __generator(this, function (_a) {
        start = process.hrtime();
        f();
        elapsed = process.hrtime(start);
        return [2
        /*return*/
        , {
          kernelMs: elapsed[0] * 1000 + elapsed[1] / 1000000
        }];
      });
    });
  };

  return NodeJSKernelBackend;
}(tfjs_core_1.KernelBackend);

exports.NodeJSKernelBackend = NodeJSKernelBackend;
/** Returns an instance of the Node.js backend. */

function nodeBackend() {
  return tfc.findBackend('tensorflow');
}

exports.nodeBackend = nodeBackend;
/** Returns the TF dtype for a given DataType. */

function getTFDType(dataType) {
  var binding = nodeBackend().binding;

  switch (dataType) {
    case 'float32':
      return binding.TF_FLOAT;

    case 'int32':
      return binding.TF_INT32;

    case 'bool':
      return binding.TF_BOOL;

    case 'complex64':
      return binding.TF_COMPLEX64;

    case 'string':
      return binding.TF_STRING;
    // tslint:disable-next-line:no-any

    case 'int64':
      // int64 is not a generally supported dtype in TensorFlow.js
      // (tfjs-core). However, it needs to be included here for the purpose of
      // writing the `step` value to TensorBoard via WriteScalarSummary and
      // other op kernels.
      return binding.TF_INT64;

    default:
      var errorMessage = "Unknown dtype: " + dataType;
      throw new Error(errorMessage);
  }
}

exports.getTFDType = getTFDType;
/**
 * Creates a TFEOpAttr for a 'type' OpDef attribute.
 * @deprecated Please use createTensorsTypeOpAttr() going forward.
 */

function createTypeOpAttr(attrName, dtype) {
  return {
    name: attrName,
    type: nodeBackend().binding.TF_ATTR_TYPE,
    value: getTFDType(dtype)
  };
}

exports.createTypeOpAttr = createTypeOpAttr;
/**
 * Creates a TFEOpAttr for a 'type' OpDef attribute from a Tensor or list of
 * Tensors.
 */

function createTensorsTypeOpAttr(attrName, tensors) {
  if (util_1.isNullOrUndefined(tensors)) {
    throw new Error('Invalid input tensors value.');
  }

  return {
    name: attrName,
    type: nodeBackend().binding.TF_ATTR_TYPE,
    value: getTFDTypeForInputs(tensors)
  };
}

exports.createTensorsTypeOpAttr = createTensorsTypeOpAttr;
/** Returns the dtype number for a single or list of input Tensors. */

function getTFDTypeForInputs(tensors) {
  if (util_1.isNullOrUndefined(tensors)) {
    throw new Error('Invalid input tensors value.');
  }

  if (util_1.isArray(tensors)) {
    for (var i = 0; i < tensors.length; i++) {
      return getTFDType(tensors[i].dtype);
    }

    return -1;
  } else {
    return getTFDType(tensors.dtype);
  }
}

function ensureTensorflowBackend() {
  tfc.util.assert(tfc.getBackend() === 'tensorflow', function () {
    return "Expect the current backend to be \"tensorflow\", but got \"" + tfc.getBackend() + "\"";
  });
}

exports.ensureTensorflowBackend = ensureTensorflowBackend;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","@tensorflow/tfjs-core/dist/backends/backend":"../node_modules/@tensorflow/tfjs-core/dist/backends/backend.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","./int64_tensors":"../node_modules/@tensorflow/tfjs-node/dist/int64_tensors.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/@tensorflow/tfjs-node/dist/tensorboard.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfjs_1 = require("@tensorflow/tfjs");

var nodejs_kernel_backend_1 = require("./nodejs_kernel_backend");

var SummaryFileWriter =
/** @class */
function () {
  function SummaryFileWriter(resourceHandle) {
    this.resourceHandle = resourceHandle;
    nodejs_kernel_backend_1.ensureTensorflowBackend();
    this.backend = nodejs_kernel_backend_1.nodeBackend();
  }
  /**
   * Write a scalar summary.
   *
   * @param name A name of the summary. The summary tag for TensorBoard will be
   *   this name.
   * @param value A real numeric scalar value, as `tf.Scalar` or a JavaScript
   *   `number`.
   * @param step Required `int64`-castable, monotically-increasing step value.
   * @param description Optinal long-form description for this summary, as a
   *   `string`. *Not implemented yet*.
   */


  SummaryFileWriter.prototype.scalar = function (name, value, step, description) {
    // N.B.: Unlike the Python TensorFlow API, step is a required parameter,
    // because the construct of global step does not exist in TensorFlow.js.
    if (description != null) {
      throw new Error('scalar() does not support description yet');
    }

    this.backend.writeScalarSummary(this.resourceHandle, step, name, value);
  };
  /**
   * Force summary writer to send all buffered data to storage.
   */


  SummaryFileWriter.prototype.flush = function () {
    this.backend.flushSummaryWriter(this.resourceHandle);
  };

  return SummaryFileWriter;
}();

exports.SummaryFileWriter = SummaryFileWriter;
/**
 * Use a cache for `SummaryFileWriter` instance.
 *
 * Using multiple instances of `SummaryFileWriter` pointing to the same
 * logdir has potential problems. Using this cache avoids those problems.
 */

var summaryFileWriterCache = {};
/**
 * Create a summary file writer for TensorBoard.
 *
 * Example:
 * ```js
 * const tf = require('@tensorflow/tfjs-node');
 *
 * const summaryWriter = tf.node.summaryFileWriter('/tmp/tfjs_tb_logdir');
 *
 * for (let step = 0; step < 100; ++step) {
 *  summaryWriter.scalar('dummyValue', Math.sin(2 * Math.PI * step / 8), step);
 * }
 * ```
 *
 * @param logdir Log directory in which the summary data will be written.
 * @param maxQueue Maximum queue length (default: `10`).
 * @param flushMillis Flush every __ milliseconds (default: `120e3`, i.e,
 *   `120` seconds).
 * @param filenameSuffix Suffix of the protocol buffer file names to be
 *   written in the `logdir` (default: `.v2`).
 * @returns An instance of `SummaryFileWriter`.
 */

/**
 * @doc {heading: 'TensorBoard', namespace: 'node'}
 */

function summaryFileWriter(logdir, maxQueue, flushMillis, filenameSuffix) {
  if (maxQueue === void 0) {
    maxQueue = 10;
  }

  if (flushMillis === void 0) {
    flushMillis = 120000;
  }

  if (filenameSuffix === void 0) {
    filenameSuffix = '.v2';
  }

  tfjs_1.util.assert(logdir != null && typeof logdir === 'string' && logdir.length > 0, function () {
    return "Invalid logdir: " + logdir + ". Expected a non-empty string for logdir.";
  });

  if (!(logdir in summaryFileWriterCache)) {
    nodejs_kernel_backend_1.ensureTensorflowBackend();
    var backend = nodejs_kernel_backend_1.nodeBackend();
    var writerResource = backend.summaryWriter(logdir);
    backend.createSummaryFileWriter(writerResource, logdir, maxQueue, flushMillis, filenameSuffix);
    summaryFileWriterCache[logdir] = new SummaryFileWriter(writerResource);
  }

  return summaryFileWriterCache[logdir];
}

exports.summaryFileWriter = summaryFileWriter;
},{"@tensorflow/tfjs":"../node_modules/@tensorflow/tfjs/dist/tf.esm.js","./nodejs_kernel_backend":"../node_modules/@tensorflow/tfjs-node/dist/nodejs_kernel_backend.js"}],"../node_modules/@tensorflow/tfjs-node/dist/callbacks.js":[function(require,module,exports) {
var process = require("process");
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfjs_1 = require("@tensorflow/tfjs");

var path = require("path");

var ProgressBar = require("progress");

var tensorboard_1 = require("./tensorboard"); // A helper class created for testing with the jasmine `spyOn` method, which
// operates only on member methods of objects.
// tslint:disable-next-line:no-any


exports.progressBarHelper = {
  ProgressBar: ProgressBar,
  log: console.log
};
/**
 * Terminal-based progress bar callback for tf.Model.fit().
 */

var ProgbarLogger =
/** @class */
function (_super) {
  __extends(ProgbarLogger, _super);
  /**
   * Construtor of LoggingCallback.
   */


  function ProgbarLogger() {
    var _this = _super.call(this, {
      onTrainBegin: function onTrainBegin(logs) {
        return __awaiter(_this, void 0, void 0, function () {
          var samples, batchSize, steps;
          return __generator(this, function (_a) {
            samples = this.params.samples;
            batchSize = this.params.batchSize;
            steps = this.params.steps;

            if (samples != null || steps != null) {
              this.numTrainBatchesPerEpoch = samples != null ? Math.ceil(samples / batchSize) : steps;
            } else {
              // Undetermined number of batches per epoch, e.g., due to
              // `fitDataset()` without `batchesPerEpoch`.
              this.numTrainBatchesPerEpoch = 0;
            }

            return [2
            /*return*/
            ];
          });
        });
      },
      onEpochBegin: function onEpochBegin(epoch, logs) {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            exports.progressBarHelper.log("Epoch " + (epoch + 1) + " / " + this.params.epochs);
            this.currentEpochBegin = tfjs_1.util.now();
            this.epochDurationMillis = null;
            this.usPerStep = null;
            this.batchesInLatestEpoch = 0;
            this.terminalWidth = process.stderr.columns;
            return [2
            /*return*/
            ];
          });
        });
      },
      onBatchEnd: function onBatchEnd(batch, logs) {
        return __awaiter(_this, void 0, void 0, function () {
          var maxMetricsStringLength, tickTokens;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.batchesInLatestEpoch++;

                if (batch === 0) {
                  this.progressBar = new exports.progressBarHelper.ProgressBar('eta=:eta :bar :placeholderForLossesAndMetrics', {
                    width: Math.floor(0.5 * this.terminalWidth),
                    total: this.numTrainBatchesPerEpoch + 1,
                    head: ">",
                    renderThrottle: this.RENDER_THROTTLE_MS
                  });
                }

                maxMetricsStringLength = Math.floor(this.terminalWidth * 0.5 - 12);
                tickTokens = {
                  placeholderForLossesAndMetrics: this.formatLogsAsMetricsContent(logs, maxMetricsStringLength)
                };

                if (this.numTrainBatchesPerEpoch === 0) {
                  // Undetermined number of batches per epoch.
                  this.progressBar.tick(0, tickTokens);
                } else {
                  this.progressBar.tick(tickTokens);
                }

                return [4
                /*yield*/
                , tfjs_1.nextFrame()];

              case 1:
                _a.sent();

                if (batch === this.numTrainBatchesPerEpoch - 1) {
                  this.epochDurationMillis = tfjs_1.util.now() - this.currentEpochBegin;
                  this.usPerStep = this.params.samples != null ? this.epochDurationMillis / this.params.samples * 1e3 : this.epochDurationMillis / this.batchesInLatestEpoch * 1e3;
                }

                return [2
                /*return*/
                ];
            }
          });
        });
      },
      onEpochEnd: function onEpochEnd(epoch, logs) {
        return __awaiter(_this, void 0, void 0, function () {
          var lossesAndMetricsString;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (this.epochDurationMillis == null) {
                  // In cases where the number of batches per epoch is not determined,
                  // the calculation of the per-step duration is done at the end of the
                  // epoch. N.B., this includes the time spent on validation.
                  this.epochDurationMillis = tfjs_1.util.now() - this.currentEpochBegin;
                  this.usPerStep = this.epochDurationMillis / this.batchesInLatestEpoch * 1e3;
                }

                this.progressBar.tick({
                  placeholderForLossesAndMetrics: ''
                });
                lossesAndMetricsString = this.formatLogsAsMetricsContent(logs);
                exports.progressBarHelper.log(this.epochDurationMillis.toFixed(0) + "ms " + (this.usPerStep.toFixed(0) + "us/step - ") + ("" + lossesAndMetricsString));
                return [4
                /*yield*/
                , tfjs_1.nextFrame()];

              case 1:
                _a.sent();

                return [2
                /*return*/
                ];
            }
          });
        });
      }
    }) || this;

    _this.RENDER_THROTTLE_MS = 50;
    return _this;
  }

  ProgbarLogger.prototype.formatLogsAsMetricsContent = function (logs, maxMetricsLength) {
    var metricsContent = '';
    var keys = Object.keys(logs).sort();

    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
      var key = keys_1[_i];

      if (this.isFieldRelevant(key)) {
        var value = logs[key];
        metricsContent += key + "=" + getSuccinctNumberDisplay(value) + " ";
      }
    }

    if (maxMetricsLength != null && metricsContent.length > maxMetricsLength) {
      // Cut off metrics strings that are too long to avoid new lines being
      // constantly created.
      metricsContent = metricsContent.slice(0, maxMetricsLength - 3) + '...';
    }

    return metricsContent;
  };

  ProgbarLogger.prototype.isFieldRelevant = function (key) {
    return key !== 'batch' && key !== 'size';
  };

  return ProgbarLogger;
}(tfjs_1.CustomCallback);

exports.ProgbarLogger = ProgbarLogger;
var BASE_NUM_DIGITS = 2;
var MAX_NUM_DECIMAL_PLACES = 4;
/**
 * Get a succint string representation of a number.
 *
 * Uses decimal notation if the number isn't too small.
 * Otherwise, use engineering notation.
 *
 * @param x Input number.
 * @return Succinct string representing `x`.
 */

function getSuccinctNumberDisplay(x) {
  var decimalPlaces = getDisplayDecimalPlaces(x);
  return decimalPlaces > MAX_NUM_DECIMAL_PLACES ? x.toExponential(BASE_NUM_DIGITS) : x.toFixed(decimalPlaces);
}

exports.getSuccinctNumberDisplay = getSuccinctNumberDisplay;
/**
 * Determine the number of decimal places to display.
 *
 * @param x Number to display.
 * @return Number of decimal places to display for `x`.
 */

function getDisplayDecimalPlaces(x) {
  if (!Number.isFinite(x) || x === 0 || x > 1 || x < -1) {
    return BASE_NUM_DIGITS;
  } else {
    return BASE_NUM_DIGITS - Math.floor(Math.log10(Math.abs(x)));
  }
}

exports.getDisplayDecimalPlaces = getDisplayDecimalPlaces;
/**
 * Callback for logging to TensorBoard durnig training.
 *
 * Users are expected to access this class through the `tensorBoardCallback()`
 * factory method instead.
 */

var TensorBoardCallback =
/** @class */
function (_super) {
  __extends(TensorBoardCallback, _super);

  function TensorBoardCallback(logdir, args) {
    if (logdir === void 0) {
      logdir = './logs';
    }

    var _this = _super.call(this, {
      onBatchEnd: function onBatchEnd(batch, logs) {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            this.batchesSeen++;

            if (this.args.updateFreq !== 'epoch') {
              this.logMetrics(logs, 'batch_', this.batchesSeen);
            }

            return [2
            /*return*/
            ];
          });
        });
      },
      onEpochEnd: function onEpochEnd(epoch, logs) {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            this.epochsSeen++;
            this.logMetrics(logs, 'epoch_', this.epochsSeen);
            return [2
            /*return*/
            ];
          });
        });
      },
      onTrainEnd: function onTrainEnd(logs) {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            if (this.trainWriter != null) {
              this.trainWriter.flush();
            }

            if (this.valWriter != null) {
              this.valWriter.flush();
            }

            return [2
            /*return*/
            ];
          });
        });
      }
    }) || this;

    _this.logdir = logdir;
    _this.args = args == null ? {} : args;

    if (_this.args.updateFreq == null) {
      _this.args.updateFreq = 'epoch';
    }

    tfjs_1.util.assert(['batch', 'epoch'].indexOf(_this.args.updateFreq) !== -1, function () {
      return "Expected updateFreq to be 'batch' or 'epoch', but got " + ("" + _this.args.updateFreq);
    });
    _this.batchesSeen = 0;
    _this.epochsSeen = 0;
    return _this;
  }

  TensorBoardCallback.prototype.logMetrics = function (logs, prefix, step) {
    for (var key in logs) {
      if (key === 'batch' || key === 'size' || key === 'num_steps') {
        continue;
      }

      var VAL_PREFIX = 'val_';

      if (key.startsWith(VAL_PREFIX)) {
        this.ensureValWriterCreated();
        var scalarName = prefix + key.slice(VAL_PREFIX.length);
        this.valWriter.scalar(scalarName, logs[key], step);
      } else {
        this.ensureTrainWriterCreated();
        this.trainWriter.scalar("" + prefix + key, logs[key], step);
      }
    }
  };

  TensorBoardCallback.prototype.ensureTrainWriterCreated = function () {
    this.trainWriter = tensorboard_1.summaryFileWriter(path.join(this.logdir, 'train'));
  };

  TensorBoardCallback.prototype.ensureValWriterCreated = function () {
    this.valWriter = tensorboard_1.summaryFileWriter(path.join(this.logdir, 'val'));
  };

  return TensorBoardCallback;
}(tfjs_1.CustomCallback);

exports.TensorBoardCallback = TensorBoardCallback;
/**
 * Callback for logging to TensorBoard durnig training.
 *
 * Writes the loss and metric values (if any) to the specified log directory
 * (`logdir`) which can be ingested and visualized by TensorBoard.
 * This callback is usually passed as a callback to `tf.Model.fit()` or
 * `tf.Model.fitDataset()` calls during model training. The frequency at which
 * the values are logged can be controlled with the `updateFreq` field of the
 * configuration object (2nd argument).
 *
 * Usage example:
 * ```js
 * // Constructor a toy multilayer-perceptron regressor for demo purpose.
 * const model = tf.sequential();
 * model.add(
 *     tf.layers.dense({units: 100, activation: 'relu', inputShape: [200]}));
 * model.add(tf.layers.dense({units: 1}));
 * model.compile({
 *   loss: 'meanSquaredError',
 *   optimizer: 'sgd',
 *   metrics: ['MAE']
 * });
 *
 * // Generate some random fake data for demo purpose.
 * const xs = tf.randomUniform([10000, 200]);
 * const ys = tf.randomUniform([10000, 1]);
 * const valXs = tf.randomUniform([1000, 200]);
 * const valYs = tf.randomUniform([1000, 1]);
 *
 * // Start model training process.
 * await model.fit(xs, ys, {
 *   epochs: 100,
 *   validationData: [valXs, valYs],
 *    // Add the tensorBoard callback here.
 *   callbacks: tf.node.tensorBoard('/tmp/fit_logs_1')
 * });
 * ```
 *
 * Then you can use the following commands to point tensorboard
 * to the logdir:
 *
 * ```sh
 * pip install tensorboard  # Unless you've already installed it.
 * tensorboard --logdir /tmp/fit_logs_1
 * ```
 *
 * @param logdir Directory to which the logs will be written.
 * @param args Optional configuration arguments.
 * @returns An instance of `TensorBoardCallback`, which is a subclass of
 *   `tf.CustomCallback`.
 */

/**
 * @doc {heading: 'TensorBoard', namespace: 'node'}
 */

function tensorBoard(logdir, args) {
  if (logdir === void 0) {
    logdir = './logs';
  }

  return new TensorBoardCallback(logdir, args);
}

exports.tensorBoard = tensorBoard;
},{"@tensorflow/tfjs":"../node_modules/@tensorflow/tfjs/dist/tf.esm.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","progress":"../node_modules/progress/index.js","./tensorboard":"../node_modules/@tensorflow/tfjs-node/dist/tensorboard.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/@tensorflow/tfjs-node/dist/io/io_utils.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Convert an ArrayBuffer to a Buffer.
 */

function toBuffer(ab) {
  var view = new Uint8Array(ab);
  return Buffer.from(view); // copies data
}

exports.toBuffer = toBuffer;
/**
 * Convert a Buffer or an Array of Buffers to an ArrayBuffer.
 *
 * If the input is an Array of Buffers, they will be concatenated in the
 * specified order to form the output ArrayBuffer.
 */

function toArrayBuffer(buf) {
  if (Array.isArray(buf)) {
    // An Array of Buffers.
    var totalLength = 0;

    for (var _i = 0, buf_1 = buf; _i < buf_1.length; _i++) {
      var buffer = buf_1[_i];
      totalLength += buffer.length;
    }

    var ab = new ArrayBuffer(totalLength);
    var view = new Uint8Array(ab);
    var pos = 0;

    for (var _a = 0, buf_2 = buf; _a < buf_2.length; _a++) {
      var buffer = buf_2[_a];
      pos += buffer.copy(view, pos);
    }

    return ab;
  } else {
    // A single Buffer. Return a copy of the underlying ArrayBuffer slice.
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
}

exports.toArrayBuffer = toArrayBuffer; // TODO(cais): Use explicit tfc.io.ModelArtifactsInfo return type below once it
// is available.

/**
 * Populate ModelArtifactsInfo fields for a model with JSON topology.
 * @param modelArtifacts
 * @returns A ModelArtifactsInfo object.
 */

function getModelArtifactsInfoForJSON(modelArtifacts) {
  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
    throw new Error('Expected JSON model topology, received ArrayBuffer.');
  }

  return {
    dateSaved: new Date(),
    modelTopologyType: 'JSON',
    modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : Buffer.byteLength(JSON.stringify(modelArtifacts.modelTopology), 'utf8'),
    weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : Buffer.byteLength(JSON.stringify(modelArtifacts.weightSpecs), 'utf8'),
    weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
  };
}

exports.getModelArtifactsInfoForJSON = getModelArtifactsInfoForJSON;
},{"buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs-node/dist/io/file_system.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfc = require("@tensorflow/tfjs-core");

var fs = require("fs");

var path_1 = require("path");

var util_1 = require("util");

var io_utils_1 = require("./io_utils");

var stat = util_1.promisify(fs.stat);
var writeFile = util_1.promisify(fs.writeFile);
var readFile = util_1.promisify(fs.readFile);
var mkdir = util_1.promisify(fs.mkdir);

function doesNotExistHandler(name) {
  return function (e) {
    switch (e.code) {
      case 'ENOENT':
        throw new Error(name + " " + e.path + " does not exist: loading failed");

      default:
        throw e;
    }
  };
}

var NodeFileSystem =
/** @class */
function () {
  /**
   * Constructor of the NodeFileSystem IOHandler.
   * @param path A single path or an Array of paths.
   *   For saving: expects a single path pointing to an existing or nonexistent
   *     directory. If the directory does not exist, it will be
   *     created.
   *   For loading:
   *     - If the model has JSON topology (e.g., `tf.Model`), a single path
   *       pointing to the JSON file (usually named `model.json`) is expected.
   *       The JSON file is expected to contain `modelTopology` and/or
   *       `weightsManifest`. If `weightManifest` exists, the values of the
   *       weights will be loaded from relative paths (relative to the directory
   *       of `model.json`) as contained in `weightManifest`.
   *     - If the model has binary (protocol buffer GraphDef) topology,
   *       an Array of two paths is expected: the first path should point to the
   *       .pb file and the second path should point to the weight manifest
   *       JSON file.
   */
  function NodeFileSystem(path) {
    this.MODEL_JSON_FILENAME = 'model.json';
    this.WEIGHTS_BINARY_FILENAME = 'weights.bin';
    this.MODEL_BINARY_FILENAME = 'tensorflowjs.pb';

    if (Array.isArray(path)) {
      tfc.util.assert(path.length === 2, function () {
        return 'file paths must have a length of 2, ' + ("(actual length is " + path.length + ").");
      });
      this.path = path.map(function (p) {
        return path_1.resolve(p);
      });
    } else {
      this.path = path_1.resolve(path);
    }
  }

  NodeFileSystem.prototype.save = function (modelArtifacts) {
    return __awaiter(this, void 0, void 0, function () {
      var weightsBinPath, weightsManifest, modelJSON, modelJSONPath;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (Array.isArray(this.path)) {
              throw new Error('Cannot perform saving to multiple paths.');
            }

            return [4
            /*yield*/
            , this.createOrVerifyDirectory()];

          case 1:
            _a.sent();

            if (!(modelArtifacts.modelTopology instanceof ArrayBuffer)) return [3
            /*break*/
            , 2];
            throw new Error('NodeFileSystem.save() does not support saving model topology ' + 'in binary format yet.');

          case 2:
            weightsBinPath = path_1.join(this.path, this.WEIGHTS_BINARY_FILENAME);
            weightsManifest = [{
              paths: [this.WEIGHTS_BINARY_FILENAME],
              weights: modelArtifacts.weightSpecs
            }];
            modelJSON = {
              modelTopology: modelArtifacts.modelTopology,
              weightsManifest: weightsManifest,
              format: modelArtifacts.format,
              generatedBy: modelArtifacts.generatedBy,
              convertedBy: modelArtifacts.convertedBy
            };

            if (modelArtifacts.trainingConfig != null) {
              modelJSON.trainingConfig = modelArtifacts.trainingConfig;
            }

            if (modelArtifacts.userDefinedMetadata != null) {
              modelJSON.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
            }

            modelJSONPath = path_1.join(this.path, this.MODEL_JSON_FILENAME);
            return [4
            /*yield*/
            , writeFile(modelJSONPath, JSON.stringify(modelJSON), 'utf8')];

          case 3:
            _a.sent();

            return [4
            /*yield*/
            , writeFile(weightsBinPath, Buffer.from(modelArtifacts.weightData), 'binary')];

          case 4:
            _a.sent();

            return [2
            /*return*/
            , {
              // TODO(cais): Use explicit tfc.io.ModelArtifactsInfo type below once it
              // is available.
              // tslint:disable-next-line:no-any
              modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts)
            }];
        }
      });
    });
  };

  NodeFileSystem.prototype.load = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , Array.isArray(this.path) ? this.loadBinaryModel() : this.loadJSONModel()];
      });
    });
  };

  NodeFileSystem.prototype.loadBinaryModel = function () {
    return __awaiter(this, void 0, void 0, function () {
      var topologyPath, weightManifestPath, topology, weightManifest, modelTopology, weightsManifest, _a, _b, modelArtifacts, _c, weightSpecs, weightData;

      return __generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            topologyPath = this.path[0];
            weightManifestPath = this.path[1];
            return [4
            /*yield*/
            , stat(topologyPath).catch(doesNotExistHandler('Topology Path'))];

          case 1:
            topology = _d.sent();
            return [4
            /*yield*/
            , stat(weightManifestPath).catch(doesNotExistHandler('Weight Manifest Path'))];

          case 2:
            weightManifest = _d.sent(); // `this.path` can be either a directory or a file. If it is a file, assume
            // it is model.json file.

            if (!topology.isFile()) {
              throw new Error('File specified for topology is not a file!');
            }

            if (!weightManifest.isFile()) {
              throw new Error('File specified for the weight manifest is not a file!');
            }

            return [4
            /*yield*/
            , readFile(this.path[0])];

          case 3:
            modelTopology = _d.sent();
            _b = (_a = JSON).parse;
            return [4
            /*yield*/
            , readFile(this.path[1], 'utf8')];

          case 4:
            weightsManifest = _b.apply(_a, [_d.sent()]);
            modelArtifacts = {
              modelTopology: modelTopology
            };
            return [4
            /*yield*/
            , this.loadWeights(weightsManifest, this.path[1])];

          case 5:
            _c = _d.sent(), weightSpecs = _c[0], weightData = _c[1];
            modelArtifacts.weightSpecs = weightSpecs;
            modelArtifacts.weightData = weightData;
            return [2
            /*return*/
            , modelArtifacts];
        }
      });
    });
  };

  NodeFileSystem.prototype.loadJSONModel = function () {
    return __awaiter(this, void 0, void 0, function () {
      var path, info, modelJSON, _a, _b, modelArtifacts, _c, weightSpecs, weightData;

      return __generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            path = this.path;
            return [4
            /*yield*/
            , stat(path).catch(doesNotExistHandler('Path'))];

          case 1:
            info = _d.sent();
            if (!info.isFile()) return [3
            /*break*/
            , 5];
            _b = (_a = JSON).parse;
            return [4
            /*yield*/
            , readFile(path, 'utf8')];

          case 2:
            modelJSON = _b.apply(_a, [_d.sent()]);
            modelArtifacts = {
              modelTopology: modelJSON.modelTopology,
              format: modelJSON.format,
              generatedBy: modelJSON.generatedBy,
              convertedBy: modelJSON.convertedBy
            };
            if (!(modelJSON.weightsManifest != null)) return [3
            /*break*/
            , 4];
            return [4
            /*yield*/
            , this.loadWeights(modelJSON.weightsManifest, path)];

          case 3:
            _c = _d.sent(), weightSpecs = _c[0], weightData = _c[1];
            modelArtifacts.weightSpecs = weightSpecs;
            modelArtifacts.weightData = weightData;
            _d.label = 4;

          case 4:
            if (modelJSON.trainingConfig != null) {
              modelArtifacts.trainingConfig = modelJSON.trainingConfig;
            }

            if (modelJSON.userDefinedMetadata != null) {
              modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
            }

            return [2
            /*return*/
            , modelArtifacts];

          case 5:
            throw new Error('The path to load from must be a file. Loading from a directory ' + 'is not supported.');
        }
      });
    });
  };

  NodeFileSystem.prototype.loadWeights = function (weightsManifest, path) {
    return __awaiter(this, void 0, void 0, function () {
      var dirName, buffers, weightSpecs, _i, weightsManifest_1, group, _a, _b, path_2, weightFilePath, buffer;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            dirName = path_1.dirname(path);
            buffers = [];
            weightSpecs = [];
            _i = 0, weightsManifest_1 = weightsManifest;
            _c.label = 1;

          case 1:
            if (!(_i < weightsManifest_1.length)) return [3
            /*break*/
            , 7];
            group = weightsManifest_1[_i];
            _a = 0, _b = group.paths;
            _c.label = 2;

          case 2:
            if (!(_a < _b.length)) return [3
            /*break*/
            , 5];
            path_2 = _b[_a];
            weightFilePath = path_1.join(dirName, path_2);
            return [4
            /*yield*/
            , readFile(weightFilePath).catch(doesNotExistHandler('Weight file'))];

          case 3:
            buffer = _c.sent();
            buffers.push(buffer);
            _c.label = 4;

          case 4:
            _a++;
            return [3
            /*break*/
            , 2];

          case 5:
            weightSpecs.push.apply(weightSpecs, group.weights);
            _c.label = 6;

          case 6:
            _i++;
            return [3
            /*break*/
            , 1];

          case 7:
            return [2
            /*return*/
            , [weightSpecs, io_utils_1.toArrayBuffer(buffers)]];
        }
      });
    });
  };
  /**
   * For each item in `this.path`, creates a directory at the path or verify
   * that the path exists as a directory.
   */


  NodeFileSystem.prototype.createOrVerifyDirectory = function () {
    return __awaiter(this, void 0, void 0, function () {
      var paths, _i, paths_1, path, e_1;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            paths = Array.isArray(this.path) ? this.path : [this.path];
            _i = 0, paths_1 = paths;
            _a.label = 1;

          case 1:
            if (!(_i < paths_1.length)) return [3
            /*break*/
            , 9];
            path = paths_1[_i];
            _a.label = 2;

          case 2:
            _a.trys.push([2, 4,, 8]);

            return [4
            /*yield*/
            , mkdir(path)];

          case 3:
            _a.sent();

            return [3
            /*break*/
            , 8];

          case 4:
            e_1 = _a.sent();
            if (!(e_1.code === 'EEXIST')) return [3
            /*break*/
            , 6];
            return [4
            /*yield*/
            , stat(path)];

          case 5:
            if (_a.sent().isFile()) {
              throw new Error("Path " + path + " exists as a file. The path must be " + "nonexistent or point to a directory.");
            }

            return [3
            /*break*/
            , 7];

          case 6:
            throw e_1;

          case 7:
            return [3
            /*break*/
            , 8];

          case 8:
            _i++;
            return [3
            /*break*/
            , 1];

          case 9:
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  NodeFileSystem.URL_SCHEME = 'file://';
  return NodeFileSystem;
}();

exports.NodeFileSystem = NodeFileSystem;

exports.nodeFileSystemRouter = function (url) {
  if (Array.isArray(url)) {
    if (url.every(function (urlElement) {
      return urlElement.startsWith(NodeFileSystem.URL_SCHEME);
    })) {
      return new NodeFileSystem(url.map(function (urlElement) {
        return urlElement.slice(NodeFileSystem.URL_SCHEME.length);
      }));
    } else {
      return null;
    }
  } else {
    if (url.startsWith(NodeFileSystem.URL_SCHEME)) {
      return new NodeFileSystem(url.slice(NodeFileSystem.URL_SCHEME.length));
    } else {
      return null;
    }
  }
}; // Registration of `nodeFileSystemRouter` is done in index.ts.

/**
 * Factory function for Node.js native file system IO Handler.
 *
 * @param path A single path or an Array of paths.
 *   For saving: expects a single path pointing to an existing or nonexistent
 *     directory. If the directory does not exist, it will be
 *     created.
 *   For loading:
 *     - If the model has JSON topology (e.g., `tf.Model`), a single path
 *       pointing to the JSON file (usually named `model.json`) is expected.
 *       The JSON file is expected to contain `modelTopology` and/or
 *       `weightsManifest`. If `weightManifest` exists, the values of the
 *       weights will be loaded from relative paths (relative to the directory
 *       of `model.json`) as contained in `weightManifest`.
 *     - If the model has binary (protocol buffer GraphDef) topology,
 *       an Array of two paths is expected: the first path should point to the
 *        .pb file and the second path should point to the weight manifest
 *       JSON file.
 */


function fileSystem(path) {
  return new NodeFileSystem(path);
}

exports.fileSystem = fileSystem;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","./io_utils":"../node_modules/@tensorflow/tfjs-node/dist/io/io_utils.js","buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs-node/dist/io/node_http.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfjs_core_1 = require("@tensorflow/tfjs-core");
/**
 * Factory function for HTTP IO Handler in Node.js.
 *
 * @param path URL path or an array of them.
 * @param requestInit Request init for the HTTP IOHandler. May include fields
 *   such as "credentials" and "cache". (Optional)
 * @param weightPathPrefix A path prefix for weight loading . (Optional).
 */


function nodeHTTPRequest(path, requestInit, weightPathPrefix) {
  return tfjs_core_1.io.browserHTTPRequest(path, {
    requestInit: requestInit,
    weightPathPrefix: weightPathPrefix
  });
}

exports.nodeHTTPRequest = nodeHTTPRequest;

exports.nodeHTTPRequestRouter = function (url) {
  var isHTTP = true;

  if (Array.isArray(url)) {
    isHTTP = url.every(function (urlItem) {
      return tfjs_core_1.io.isHTTPScheme(urlItem);
    });
  } else {
    isHTTP = tfjs_core_1.io.isHTTPScheme(url);
  }

  if (isHTTP) {
    return nodeHTTPRequest(url);
  }

  return null;
};
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"../node_modules/@tensorflow/tfjs-node/dist/io/index.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Public exports from the `io` module.
 */

var file_system_1 = require("./file_system");

exports.fileSystem = file_system_1.fileSystem;

var node_http_1 = require("./node_http");

exports.nodeHTTPRequest = node_http_1.nodeHTTPRequest;
},{"./file_system":"../node_modules/@tensorflow/tfjs-node/dist/io/file_system.js","./node_http":"../node_modules/@tensorflow/tfjs-node/dist/io/node_http.js"}],"../node_modules/@tensorflow/tfjs-node/dist/version.js":[function(require,module,exports) {
"use strict";
/** @license See the LICENSE file. */

Object.defineProperty(exports, "__esModule", {
  value: true
}); // This code is auto-generated, do not modify this file!

var version = '1.3.2';
exports.version = version;
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/node-libs-browser/node_modules/punycode/punycode.js":[function(require,module,exports) {
var global = arguments[3];
var define;
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/url/util.js":[function(require,module,exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/querystring-es3/decode.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict'; // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/querystring-es3/encode.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/querystring-es3/index.js":[function(require,module,exports) {
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');
},{"./decode":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/querystring-es3/decode.js","./encode":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/querystring-es3/encode.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/url/url.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"punycode":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/node-libs-browser/node_modules/punycode/punycode.js","./util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/url/util.js","querystring":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/querystring-es3/index.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = $getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];

  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);

  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process-nextick-args/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/core-util-is/lib/util.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/BufferList.js":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/safe-buffer/index.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process-nextick-args/index.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process-nextick-args/index.js","core-util-is":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/core-util-is/lib/util.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js","util-deprecate":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util-deprecate/browser.js","./internal/streams/stream":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/safe-buffer/index.js","./internal/streams/destroy":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_duplex.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process-nextick-args/index.js","core-util-is":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/core-util-is/lib/util.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js","./_stream_readable":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_writable.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/safe-buffer/index.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process-nextick-args/index.js","isarray":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/isarray/index.js","events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","./internal/streams/stream":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/safe-buffer/index.js","core-util-is":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/core-util-is/lib/util.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/BufferList":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/string_decoder/lib/string_decoder.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/core-util-is/lib/util.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/core-util-is/lib/util.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_passthrough.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/writable-browser.js":[function(require,module,exports) {
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_writable.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/duplex-browser.js":[function(require,module,exports) {
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/lib/_stream_duplex.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/transform.js":[function(require,module,exports) {
module.exports = require('./readable').Transform

},{"./readable":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/readable-browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/passthrough.js":[function(require,module,exports) {
module.exports = require('./readable').PassThrough

},{"./readable":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/readable-browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/stream-browserify/index.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/inherits/inherits_browser.js","readable-stream/readable.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/readable-browser.js","readable-stream/writable.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/writable-browser.js","readable-stream/duplex.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/duplex-browser.js","readable-stream/transform.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/transform.js","readable-stream/passthrough.js":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/readable-stream/passthrough.js"}],"../node_modules/abbrev/abbrev.js":[function(require,module,exports) {
module.exports = exports = abbrev.abbrev = abbrev

abbrev.monkeyPatch = monkeyPatch

function monkeyPatch () {
  Object.defineProperty(Array.prototype, 'abbrev', {
    value: function () { return abbrev(this) },
    enumerable: false, configurable: true, writable: true
  })

  Object.defineProperty(Object.prototype, 'abbrev', {
    value: function () { return abbrev(Object.keys(this)) },
    enumerable: false, configurable: true, writable: true
  })
}

function abbrev (list) {
  if (arguments.length !== 1 || !Array.isArray(list)) {
    list = Array.prototype.slice.call(arguments, 0)
  }
  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {
    args[i] = typeof list[i] === "string" ? list[i] : String(list[i])
  }

  // sort them lexicographically, so that they're next to their nearest kin
  args = args.sort(lexSort)

  // walk through each, seeing how much it has in common with the next and previous
  var abbrevs = {}
    , prev = ""
  for (var i = 0, l = args.length ; i < l ; i ++) {
    var current = args[i]
      , next = args[i + 1] || ""
      , nextMatches = true
      , prevMatches = true
    if (current === next) continue
    for (var j = 0, cl = current.length ; j < cl ; j ++) {
      var curChar = current.charAt(j)
      nextMatches = nextMatches && curChar === next.charAt(j)
      prevMatches = prevMatches && curChar === prev.charAt(j)
      if (!nextMatches && !prevMatches) {
        j ++
        break
      }
    }
    prev = current
    if (j === cl) {
      abbrevs[current] = current
      continue
    }
    for (var a = current.substr(0, j) ; j <= cl ; j ++) {
      abbrevs[a] = current
      a += current.charAt(j)
    }
  }
  return abbrevs
}

function lexSort (a, b) {
  return a === b ? 0 : a > b ? 1 : -1
}

},{}],"../node_modules/os-tmpdir/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var isWindows = process.platform === 'win32';
var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/; // https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43

module.exports = function () {
  var path;

  if (isWindows) {
    path = undefined || undefined || (undefined || undefined) + '\\temp';
  } else {
    path = "/var/folders/4d/qc8sxs2j2z51xjr4fxnrnpzm0000gn/T/" || undefined || undefined || '/tmp';
  }

  if (trailingSlashRe.test(path)) {
    path = path.slice(0, -1);
  }

  return path;
};
},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/os-homedir/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var os = require('os');

function homedir() {
  var env = process.env;
  var home = env.HOME;
  var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;

  if (process.platform === 'win32') {
    return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
  }

  if (process.platform === 'darwin') {
    return home || (user ? '/Users/' + user : null);
  }

  if (process.platform === 'linux') {
    return home || (process.getuid() === 0 ? '/root' : user ? '/home/' + user : null);
  }

  return home || null;
}

module.exports = typeof os.homedir === 'function' ? os.homedir : homedir;
},{"os":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/osenv/osenv.js":[function(require,module,exports) {
var process = require("process");
var isWindows = process.platform === 'win32';

var path = require('path');

var exec = require('child_process').exec;

var osTmpdir = require('os-tmpdir');

var osHomedir = require('os-homedir'); // looking up envs is a bit costly.
// Also, sometimes we want to have a fallback
// Pass in a callback to wait for the fallback on failures
// After the first lookup, always returns the same thing.


function memo(key, lookup, fallback) {
  var fell = false;
  var falling = false;

  exports[key] = function (cb) {
    var val = lookup();

    if (!val && !fell && !falling && fallback) {
      fell = true;
      falling = true;
      exec(fallback, function (er, output, stderr) {
        falling = false;
        if (er) return; // oh well, we tried

        val = output.trim();
      });
    }

    exports[key] = function (cb) {
      if (cb) process.nextTick(cb.bind(null, null, val));
      return val;
    };

    if (cb && !falling) process.nextTick(cb.bind(null, null, val));
    return val;
  };
}

memo('user', function () {
  return isWindows ? undefined + '\\' + undefined : "jsmney";
}, 'whoami');
memo('prompt', function () {
  return isWindows ? undefined : "\\u@\\[\\033[32m\\]\\w\\[\\033[33m\\]$(git_branch)\\[\\033[00m\\]$ ";
});
memo('hostname', function () {
  return isWindows ? undefined : undefined;
}, 'hostname');
memo('tmpdir', function () {
  return osTmpdir();
});
memo('home', function () {
  return osHomedir();
});
memo('path', function () {
  return ("/anaconda3/bin:/anaconda3/condabin:/Users/jsmney/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Postgres.app/Contents/Versions/latest/bin:/Applications/Visual Studio Code.app/Contents/Resources/app/bin" || undefined || undefined).split(isWindows ? ';' : ':');
});
memo('editor', function () {
  return undefined || undefined || (isWindows ? 'notepad.exe' : 'vi');
});
memo('shell', function () {
  return isWindows ? undefined || 'cmd' : "/usr/local/bin/zsh" || 'bash';
});
},{"path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","child_process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","os-tmpdir":"../node_modules/os-tmpdir/index.js","os-homedir":"../node_modules/os-homedir/index.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/nopt/lib/nopt.js":[function(require,module,exports) {
var process = require("process");
// info about each config option.
var debug = undefined || undefined ? function () {
  console.error.apply(console, arguments);
} : function () {};

var url = require("url"),
    path = require("path"),
    Stream = require("stream").Stream,
    abbrev = require("abbrev"),
    osenv = require("osenv");

module.exports = exports = nopt;
exports.clean = clean;
exports.typeDefs = {
  String: {
    type: String,
    validate: validateString
  },
  Boolean: {
    type: Boolean,
    validate: validateBoolean
  },
  url: {
    type: url,
    validate: validateUrl
  },
  Number: {
    type: Number,
    validate: validateNumber
  },
  path: {
    type: path,
    validate: validatePath
  },
  Stream: {
    type: Stream,
    validate: validateStream
  },
  Date: {
    type: Date,
    validate: validateDate
  }
};

function nopt(types, shorthands, args, slice) {
  args = args || process.argv;
  types = types || {};
  shorthands = shorthands || {};
  if (typeof slice !== "number") slice = 2;
  debug(types, shorthands, args, slice);
  args = args.slice(slice);
  var data = {},
      key,
      argv = {
    remain: [],
    cooked: args,
    original: args.slice(0)
  };
  parse(args, data, argv.remain, types, shorthands); // now data is full

  clean(data, types, exports.typeDefs);
  data.argv = argv;
  Object.defineProperty(data.argv, 'toString', {
    value: function () {
      return this.original.map(JSON.stringify).join(" ");
    },
    enumerable: false
  });
  return data;
}

function clean(data, types, typeDefs) {
  typeDefs = typeDefs || exports.typeDefs;
  var remove = {},
      typeDefault = [false, true, null, String, Array];
  Object.keys(data).forEach(function (k) {
    if (k === "argv") return;
    var val = data[k],
        isArray = Array.isArray(val),
        type = types[k];
    if (!isArray) val = [val];
    if (!type) type = typeDefault;
    if (type === Array) type = typeDefault.concat(Array);
    if (!Array.isArray(type)) type = [type];
    debug("val=%j", val);
    debug("types=", type);
    val = val.map(function (val) {
      // if it's an unknown value, then parse false/true/null/numbers/dates
      if (typeof val === "string") {
        debug("string %j", val);
        val = val.trim();

        if (val === "null" && ~type.indexOf(null) || val === "true" && (~type.indexOf(true) || ~type.indexOf(Boolean)) || val === "false" && (~type.indexOf(false) || ~type.indexOf(Boolean))) {
          val = JSON.parse(val);
          debug("jsonable %j", val);
        } else if (~type.indexOf(Number) && !isNaN(val)) {
          debug("convert to number", val);
          val = +val;
        } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {
          debug("convert to date", val);
          val = new Date(val);
        }
      }

      if (!types.hasOwnProperty(k)) {
        return val;
      } // allow `--no-blah` to set 'blah' to null if null is allowed


      if (val === false && ~type.indexOf(null) && !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
        val = null;
      }

      var d = {};
      d[k] = val;
      debug("prevalidated val", d, val, types[k]);

      if (!validate(d, k, val, types[k], typeDefs)) {
        if (exports.invalidHandler) {
          exports.invalidHandler(k, val, types[k], data);
        } else if (exports.invalidHandler !== false) {
          debug("invalid: " + k + "=" + val, types[k]);
        }

        return remove;
      }

      debug("validated val", d, val, types[k]);
      return d[k];
    }).filter(function (val) {
      return val !== remove;
    });
    if (!val.length) delete data[k];else if (isArray) {
      debug(isArray, data[k], val);
      data[k] = val;
    } else data[k] = val[0];
    debug("k=%s val=%j", k, val, data[k]);
  });
}

function validateString(data, k, val) {
  data[k] = String(val);
}

function validatePath(data, k, val) {
  if (val === true) return false;
  if (val === null) return true;
  val = String(val);
  var isWin = process.platform === 'win32',
      homePattern = isWin ? /^~(\/|\\)/ : /^~\//,
      home = osenv.home();

  if (home && val.match(homePattern)) {
    data[k] = path.resolve(home, val.substr(2));
  } else {
    data[k] = path.resolve(val);
  }

  return true;
}

function validateNumber(data, k, val) {
  debug("validate Number %j %j %j", k, val, isNaN(val));
  if (isNaN(val)) return false;
  data[k] = +val;
}

function validateDate(data, k, val) {
  var s = Date.parse(val);
  debug("validate Date %j %j %j", k, val, s);
  if (isNaN(s)) return false;
  data[k] = new Date(val);
}

function validateBoolean(data, k, val) {
  if (val instanceof Boolean) val = val.valueOf();else if (typeof val === "string") {
    if (!isNaN(val)) val = !!+val;else if (val === "null" || val === "false") val = false;else val = true;
  } else val = !!val;
  data[k] = val;
}

function validateUrl(data, k, val) {
  val = url.parse(String(val));
  if (!val.host) return false;
  data[k] = val.href;
}

function validateStream(data, k, val) {
  if (!(val instanceof Stream)) return false;
  data[k] = val;
}

function validate(data, k, val, type, typeDefs) {
  // arrays are lists of types.
  if (Array.isArray(type)) {
    for (var i = 0, l = type.length; i < l; i++) {
      if (type[i] === Array) continue;
      if (validate(data, k, val, type[i], typeDefs)) return true;
    }

    delete data[k];
    return false;
  } // an array of anything?


  if (type === Array) return true; // NaN is poisonous.  Means that something is not allowed.

  if (type !== type) {
    debug("Poison NaN", k, val, type);
    delete data[k];
    return false;
  } // explicit list of values


  if (val === type) {
    debug("Explicitly allowed %j", val); // if (isArray) (data[k] = data[k] || []).push(val)
    // else data[k] = val

    data[k] = val;
    return true;
  } // now go through the list of typeDefs, validate against each one.


  var ok = false,
      types = Object.keys(typeDefs);

  for (var i = 0, l = types.length; i < l; i++) {
    debug("test type %j %j %j", k, val, types[i]);
    var t = typeDefs[types[i]];

    if (t && (type && type.name && t.type && t.type.name ? type.name === t.type.name : type === t.type)) {
      var d = {};
      ok = false !== t.validate(d, k, val);
      val = d[k];

      if (ok) {
        // if (isArray) (data[k] = data[k] || []).push(val)
        // else data[k] = val
        data[k] = val;
        break;
      }
    }
  }

  debug("OK? %j (%j %j %j)", ok, k, val, types[i]);
  if (!ok) delete data[k];
  return ok;
}

function parse(args, data, remain, types, shorthands) {
  debug("parse", args, data, remain);
  var key = null,
      abbrevs = abbrev(Object.keys(types)),
      shortAbbr = abbrev(Object.keys(shorthands));

  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    debug("arg", arg);

    if (arg.match(/^-{2,}$/)) {
      // done with keys.
      // the rest are args.
      remain.push.apply(remain, args.slice(i + 1));
      args[i] = "--";
      break;
    }

    var hadEq = false;

    if (arg.charAt(0) === "-" && arg.length > 1) {
      var at = arg.indexOf('=');

      if (at > -1) {
        hadEq = true;
        var v = arg.substr(at + 1);
        arg = arg.substr(0, at);
        args.splice(i, 1, arg, v);
      } // see if it's a shorthand
      // if so, splice and back up to re-parse it.


      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);
      debug("arg=%j shRes=%j", arg, shRes);

      if (shRes) {
        debug(arg, shRes);
        args.splice.apply(args, [i, 1].concat(shRes));

        if (arg !== shRes[0]) {
          i--;
          continue;
        }
      }

      arg = arg.replace(/^-+/, "");
      var no = null;

      while (arg.toLowerCase().indexOf("no-") === 0) {
        no = !no;
        arg = arg.substr(3);
      }

      if (abbrevs[arg]) arg = abbrevs[arg];
      var argType = types[arg];
      var isTypeArray = Array.isArray(argType);

      if (isTypeArray && argType.length === 1) {
        isTypeArray = false;
        argType = argType[0];
      }

      var isArray = argType === Array || isTypeArray && argType.indexOf(Array) !== -1; // allow unknown things to be arrays if specified multiple times.

      if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
        if (!Array.isArray(data[arg])) data[arg] = [data[arg]];
        isArray = true;
      }

      var val,
          la = args[i + 1];
      var isBool = typeof no === 'boolean' || argType === Boolean || isTypeArray && argType.indexOf(Boolean) !== -1 || typeof argType === 'undefined' && !hadEq || la === "false" && (argType === null || isTypeArray && ~argType.indexOf(null));

      if (isBool) {
        // just set and move along
        val = !no; // however, also support --bool true or --bool false

        if (la === "true" || la === "false") {
          val = JSON.parse(la);
          la = null;
          if (no) val = !val;
          i++;
        } // also support "foo":[Boolean, "bar"] and "--foo bar"


        if (isTypeArray && la) {
          if (~argType.indexOf(la)) {
            // an explicit type
            val = la;
            i++;
          } else if (la === "null" && ~argType.indexOf(null)) {
            // null allowed
            val = null;
            i++;
          } else if (!la.match(/^-{2,}[^-]/) && !isNaN(la) && ~argType.indexOf(Number)) {
            // number
            val = +la;
            i++;
          } else if (!la.match(/^-[^-]/) && ~argType.indexOf(String)) {
            // string
            val = la;
            i++;
          }
        }

        if (isArray) (data[arg] = data[arg] || []).push(val);else data[arg] = val;
        continue;
      }

      if (argType === String) {
        if (la === undefined) {
          la = "";
        } else if (la.match(/^-{1,2}[^-]+/)) {
          la = "";
          i--;
        }
      }

      if (la && la.match(/^-{2,}$/)) {
        la = undefined;
        i--;
      }

      val = la === undefined ? true : la;
      if (isArray) (data[arg] = data[arg] || []).push(val);else data[arg] = val;
      i++;
      continue;
    }

    remain.push(arg);
  }
}

function resolveShort(arg, shorthands, shortAbbr, abbrevs) {
  // handle single-char shorthands glommed together, like
  // npm ls -glp, but only if there is one dash, and only if
  // all of the chars are single-char shorthands, and it's
  // not a match to some other abbrev.
  arg = arg.replace(/^-+/, ''); // if it's an exact known option, then don't go any further

  if (abbrevs[arg] === arg) return null; // if it's an exact known shortopt, same deal

  if (shorthands[arg]) {
    // make it an array, if it's a list of words
    if (shorthands[arg] && !Array.isArray(shorthands[arg])) shorthands[arg] = shorthands[arg].split(/\s+/);
    return shorthands[arg];
  } // first check to see if this arg is a set of single-char shorthands


  var singles = shorthands.___singles;

  if (!singles) {
    singles = Object.keys(shorthands).filter(function (s) {
      return s.length === 1;
    }).reduce(function (l, r) {
      l[r] = true;
      return l;
    }, {});
    shorthands.___singles = singles;
    debug('shorthand singles', singles);
  }

  var chrs = arg.split("").filter(function (c) {
    return singles[c];
  });
  if (chrs.join("") === arg) return chrs.map(function (c) {
    return shorthands[c];
  }).reduce(function (l, r) {
    return l.concat(r);
  }, []); // if it's an arg abbrev, and not a literal shorthand, then prefer the arg

  if (abbrevs[arg] && !shorthands[arg]) return null; // if it's an abbr for a shorthand, then use that

  if (shortAbbr[arg]) arg = shortAbbr[arg]; // make it an array, if it's a list of words

  if (shorthands[arg] && !Array.isArray(shorthands[arg])) shorthands[arg] = shorthands[arg].split(/\s+/);
  return shorthands[arg];
}
},{"url":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/url/url.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","stream":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/stream-browserify/index.js","abbrev":"../node_modules/abbrev/abbrev.js","osenv":"../node_modules/osenv/osenv.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/are-we-there-yet/tracker-base.js":[function(require,module,exports) {
'use strict'
var EventEmitter = require('events').EventEmitter
var util = require('util')

var trackerId = 0
var TrackerBase = module.exports = function (name) {
  EventEmitter.call(this)
  this.id = ++trackerId
  this.name = name
}
util.inherits(TrackerBase, EventEmitter)

},{"events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js"}],"../node_modules/are-we-there-yet/tracker.js":[function(require,module,exports) {
'use strict'
var util = require('util')
var TrackerBase = require('./tracker-base.js')

var Tracker = module.exports = function (name, todo) {
  TrackerBase.call(this, name)
  this.workDone = 0
  this.workTodo = todo || 0
}
util.inherits(Tracker, TrackerBase)

Tracker.prototype.completed = function () {
  return this.workTodo === 0 ? 0 : this.workDone / this.workTodo
}

Tracker.prototype.addWork = function (work) {
  this.workTodo += work
  this.emit('change', this.name, this.completed(), this)
}

Tracker.prototype.completeWork = function (work) {
  this.workDone += work
  if (this.workDone > this.workTodo) this.workDone = this.workTodo
  this.emit('change', this.name, this.completed(), this)
}

Tracker.prototype.finish = function () {
  this.workTodo = this.workDone = 1
  this.emit('change', this.name, 1, this)
}

},{"util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","./tracker-base.js":"../node_modules/are-we-there-yet/tracker-base.js"}],"../node_modules/process-nextick-args/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js"}],"../node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/core-util-is/lib/util.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"../node_modules/readable-stream/lib/internal/streams/BufferList.js":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"../node_modules/safe-buffer/index.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"}],"../node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"../node_modules/process-nextick-args/index.js"}],"../node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"../node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"../node_modules/process-nextick-args/index.js","core-util-is":"../node_modules/core-util-is/lib/util.js","inherits":"../node_modules/inherits/inherits_browser.js","util-deprecate":"../node_modules/util-deprecate/browser.js","./internal/streams/stream":"../node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"../node_modules/safe-buffer/index.js","./internal/streams/destroy":"../node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"../node_modules/readable-stream/lib/_stream_duplex.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"../node_modules/process-nextick-args/index.js","core-util-is":"../node_modules/core-util-is/lib/util.js","inherits":"../node_modules/inherits/inherits_browser.js","./_stream_readable":"../node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"../node_modules/readable-stream/lib/_stream_writable.js"}],"../node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"../node_modules/safe-buffer/index.js"}],"../node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"../node_modules/process-nextick-args/index.js","isarray":"../node_modules/isarray/index.js","events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","./internal/streams/stream":"../node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"../node_modules/safe-buffer/index.js","core-util-is":"../node_modules/core-util-is/lib/util.js","inherits":"../node_modules/inherits/inherits_browser.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/BufferList":"../node_modules/readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"../node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"../node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"../node_modules/string_decoder/lib/string_decoder.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"../node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"../node_modules/core-util-is/lib/util.js","inherits":"../node_modules/inherits/inherits_browser.js"}],"../node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"../node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"../node_modules/core-util-is/lib/util.js","inherits":"../node_modules/inherits/inherits_browser.js"}],"../node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"../node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"../node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"../node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"../node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"../node_modules/readable-stream/lib/_stream_passthrough.js"}],"../node_modules/delegates/index.js":[function(require,module,exports) {

/**
 * Expose `Delegator`.
 */

module.exports = Delegator;

/**
 * Initialize a delegator.
 *
 * @param {Object} proto
 * @param {String} target
 * @api public
 */

function Delegator(proto, target) {
  if (!(this instanceof Delegator)) return new Delegator(proto, target);
  this.proto = proto;
  this.target = target;
  this.methods = [];
  this.getters = [];
  this.setters = [];
  this.fluents = [];
}

/**
 * Delegate method `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.method = function(name){
  var proto = this.proto;
  var target = this.target;
  this.methods.push(name);

  proto[name] = function(){
    return this[target][name].apply(this[target], arguments);
  };

  return this;
};

/**
 * Delegator accessor `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.access = function(name){
  return this.getter(name).setter(name);
};

/**
 * Delegator getter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.getter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.getters.push(name);

  proto.__defineGetter__(name, function(){
    return this[target][name];
  });

  return this;
};

/**
 * Delegator setter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.setter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.setters.push(name);

  proto.__defineSetter__(name, function(val){
    return this[target][name] = val;
  });

  return this;
};

/**
 * Delegator fluent accessor
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.fluent = function (name) {
  var proto = this.proto;
  var target = this.target;
  this.fluents.push(name);

  proto[name] = function(val){
    if ('undefined' != typeof val) {
      this[target][name] = val;
      return this;
    } else {
      return this[target][name];
    }
  };

  return this;
};

},{}],"../node_modules/are-we-there-yet/tracker-stream.js":[function(require,module,exports) {
'use strict'
var util = require('util')
var stream = require('readable-stream')
var delegate = require('delegates')
var Tracker = require('./tracker.js')

var TrackerStream = module.exports = function (name, size, options) {
  stream.Transform.call(this, options)
  this.tracker = new Tracker(name, size)
  this.name = name
  this.id = this.tracker.id
  this.tracker.on('change', delegateChange(this))
}
util.inherits(TrackerStream, stream.Transform)

function delegateChange (trackerStream) {
  return function (name, completion, tracker) {
    trackerStream.emit('change', name, completion, trackerStream)
  }
}

TrackerStream.prototype._transform = function (data, encoding, cb) {
  this.tracker.completeWork(data.length ? data.length : 1)
  this.push(data)
  cb()
}

TrackerStream.prototype._flush = function (cb) {
  this.tracker.finish()
  cb()
}

delegate(TrackerStream.prototype, 'tracker')
  .method('completed')
  .method('addWork')
  .method('finish')

},{"util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","readable-stream":"../node_modules/readable-stream/readable-browser.js","delegates":"../node_modules/delegates/index.js","./tracker.js":"../node_modules/are-we-there-yet/tracker.js"}],"../node_modules/are-we-there-yet/tracker-group.js":[function(require,module,exports) {
'use strict'
var util = require('util')
var TrackerBase = require('./tracker-base.js')
var Tracker = require('./tracker.js')
var TrackerStream = require('./tracker-stream.js')

var TrackerGroup = module.exports = function (name) {
  TrackerBase.call(this, name)
  this.parentGroup = null
  this.trackers = []
  this.completion = {}
  this.weight = {}
  this.totalWeight = 0
  this.finished = false
  this.bubbleChange = bubbleChange(this)
}
util.inherits(TrackerGroup, TrackerBase)

function bubbleChange (trackerGroup) {
  return function (name, completed, tracker) {
    trackerGroup.completion[tracker.id] = completed
    if (trackerGroup.finished) return
    trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup)
  }
}

TrackerGroup.prototype.nameInTree = function () {
  var names = []
  var from = this
  while (from) {
    names.unshift(from.name)
    from = from.parentGroup
  }
  return names.join('/')
}

TrackerGroup.prototype.addUnit = function (unit, weight) {
  if (unit.addUnit) {
    var toTest = this
    while (toTest) {
      if (unit === toTest) {
        throw new Error(
          'Attempted to add tracker group ' +
          unit.name + ' to tree that already includes it ' +
          this.nameInTree(this))
      }
      toTest = toTest.parentGroup
    }
    unit.parentGroup = this
  }
  this.weight[unit.id] = weight || 1
  this.totalWeight += this.weight[unit.id]
  this.trackers.push(unit)
  this.completion[unit.id] = unit.completed()
  unit.on('change', this.bubbleChange)
  if (!this.finished) this.emit('change', unit.name, this.completion[unit.id], unit)
  return unit
}

TrackerGroup.prototype.completed = function () {
  if (this.trackers.length === 0) return 0
  var valPerWeight = 1 / this.totalWeight
  var completed = 0
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var trackerId = this.trackers[ii].id
    completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId]
  }
  return completed
}

TrackerGroup.prototype.newGroup = function (name, weight) {
  return this.addUnit(new TrackerGroup(name), weight)
}

TrackerGroup.prototype.newItem = function (name, todo, weight) {
  return this.addUnit(new Tracker(name, todo), weight)
}

TrackerGroup.prototype.newStream = function (name, todo, weight) {
  return this.addUnit(new TrackerStream(name, todo), weight)
}

TrackerGroup.prototype.finish = function () {
  this.finished = true
  if (!this.trackers.length) this.addUnit(new Tracker(), 1, true)
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var tracker = this.trackers[ii]
    tracker.finish()
    tracker.removeListener('change', this.bubbleChange)
  }
  this.emit('change', this.name, 1, this)
}

var buffer = '                                  '
TrackerGroup.prototype.debug = function (depth) {
  depth = depth || 0
  var indent = depth ? buffer.substr(0, depth) : ''
  var output = indent + (this.name || 'top') + ': ' + this.completed() + '\n'
  this.trackers.forEach(function (tracker) {
    if (tracker instanceof TrackerGroup) {
      output += tracker.debug(depth + 1)
    } else {
      output += indent + ' ' + tracker.name + ': ' + tracker.completed() + '\n'
    }
  })
  return output
}

},{"util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","./tracker-base.js":"../node_modules/are-we-there-yet/tracker-base.js","./tracker.js":"../node_modules/are-we-there-yet/tracker.js","./tracker-stream.js":"../node_modules/are-we-there-yet/tracker-stream.js"}],"../node_modules/are-we-there-yet/index.js":[function(require,module,exports) {
'use strict'
exports.TrackerGroup = require('./tracker-group.js')
exports.Tracker = require('./tracker.js')
exports.TrackerStream = require('./tracker-stream.js')

},{"./tracker-group.js":"../node_modules/are-we-there-yet/tracker-group.js","./tracker.js":"../node_modules/are-we-there-yet/tracker.js","./tracker-stream.js":"../node_modules/are-we-there-yet/tracker-stream.js"}],"../node_modules/console-control-strings/index.js":[function(require,module,exports) {
'use strict'

// These tables borrowed from `ansi`

var prefix = '\x1b['

exports.up = function up (num) {
  return prefix + (num || '') + 'A'
}

exports.down = function down (num) {
  return prefix + (num || '') + 'B'
}

exports.forward = function forward (num) {
  return prefix + (num || '') + 'C'
}

exports.back = function back (num) {
  return prefix + (num || '') + 'D'
}

exports.nextLine = function nextLine (num) {
  return prefix + (num || '') + 'E'
}

exports.previousLine = function previousLine (num) {
  return prefix + (num || '') + 'F'
}

exports.horizontalAbsolute = function horizontalAbsolute (num) {
  if (num == null) throw new Error('horizontalAboslute requires a column to position to')
  return prefix + num + 'G'
}

exports.eraseData = function eraseData () {
  return prefix + 'J'
}

exports.eraseLine = function eraseLine () {
  return prefix + 'K'
}

exports.goto = function (x, y) {
  return prefix + y + ';' + x + 'H'
}

exports.gotoSOL = function () {
  return '\r'
}

exports.beep = function () {
  return '\x07'
}

exports.hideCursor = function hideCursor () {
  return prefix + '?25l'
}

exports.showCursor = function showCursor () {
  return prefix + '?25h'
}

var colors = {
  reset: 0,
// styles
  bold: 1,
  italic: 3,
  underline: 4,
  inverse: 7,
// resets
  stopBold: 22,
  stopItalic: 23,
  stopUnderline: 24,
  stopInverse: 27,
// colors
  white: 37,
  black: 30,
  blue: 34,
  cyan: 36,
  green: 32,
  magenta: 35,
  red: 31,
  yellow: 33,
  bgWhite: 47,
  bgBlack: 40,
  bgBlue: 44,
  bgCyan: 46,
  bgGreen: 42,
  bgMagenta: 45,
  bgRed: 41,
  bgYellow: 43,

  grey: 90,
  brightBlack: 90,
  brightRed: 91,
  brightGreen: 92,
  brightYellow: 93,
  brightBlue: 94,
  brightMagenta: 95,
  brightCyan: 96,
  brightWhite: 97,

  bgGrey: 100,
  bgBrightBlack: 100,
  bgBrightRed: 101,
  bgBrightGreen: 102,
  bgBrightYellow: 103,
  bgBrightBlue: 104,
  bgBrightMagenta: 105,
  bgBrightCyan: 106,
  bgBrightWhite: 107
}

exports.color = function color (colorWith) {
  if (arguments.length !== 1 || !Array.isArray(colorWith)) {
    colorWith = Array.prototype.slice.call(arguments)
  }
  return prefix + colorWith.map(colorNameToCode).join(';') + 'm'
}

function colorNameToCode (color) {
  if (colors[color] != null) return colors[color]
  throw new Error('Unknown color or style name: ' + color)
}

},{}],"../node_modules/ansi-regex/index.js":[function(require,module,exports) {
'use strict';

module.exports = function () {
  return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};
},{}],"../node_modules/strip-ansi/index.js":[function(require,module,exports) {
'use strict';

var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
  return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};
},{"ansi-regex":"../node_modules/ansi-regex/index.js"}],"../node_modules/code-point-at/index.js":[function(require,module,exports) {
/* eslint-disable babel/new-cap, xo/throw-new-error */
'use strict';

module.exports = function (str, pos) {
  if (str === null || str === undefined) {
    throw TypeError();
  }

  str = String(str);
  var size = str.length;
  var i = pos ? Number(pos) : 0;

  if (Number.isNaN(i)) {
    i = 0;
  }

  if (i < 0 || i >= size) {
    return undefined;
  }

  var first = str.charCodeAt(i);

  if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) {
    var second = str.charCodeAt(i + 1);

    if (second >= 0xDC00 && second <= 0xDFFF) {
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }

  return first;
};
},{}],"../node_modules/number-is-nan/index.js":[function(require,module,exports) {
'use strict';

module.exports = Number.isNaN || function (x) {
  return x !== x;
};
},{}],"../node_modules/is-fullwidth-code-point/index.js":[function(require,module,exports) {
'use strict';

var numberIsNan = require('number-is-nan');

module.exports = function (x) {
  if (numberIsNan(x)) {
    return false;
  } // https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1369
  // code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (x >= 0x1100 && (x <= 0x115f || // Hangul Jamo
  0x2329 === x || // LEFT-POINTING ANGLE BRACKET
  0x232a === x || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2e80 <= x && x <= 0x3247 && x !== 0x303f || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= x && x <= 0x4dbf || // CJK Unified Ideographs .. Yi Radicals
  0x4e00 <= x && x <= 0xa4c6 || // Hangul Jamo Extended-A
  0xa960 <= x && x <= 0xa97c || // Hangul Syllables
  0xac00 <= x && x <= 0xd7a3 || // CJK Compatibility Ideographs
  0xf900 <= x && x <= 0xfaff || // Vertical Forms
  0xfe10 <= x && x <= 0xfe19 || // CJK Compatibility Forms .. Small Form Variants
  0xfe30 <= x && x <= 0xfe6b || // Halfwidth and Fullwidth Forms
  0xff01 <= x && x <= 0xff60 || 0xffe0 <= x && x <= 0xffe6 || // Kana Supplement
  0x1b000 <= x && x <= 0x1b001 || // Enclosed Ideographic Supplement
  0x1f200 <= x && x <= 0x1f251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= x && x <= 0x3fffd)) {
    return true;
  }

  return false;
};
},{"number-is-nan":"../node_modules/number-is-nan/index.js"}],"../node_modules/string-width/index.js":[function(require,module,exports) {
'use strict';

var stripAnsi = require('strip-ansi');

var codePointAt = require('code-point-at');

var isFullwidthCodePoint = require('is-fullwidth-code-point'); // https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1345


module.exports = function (str) {
  if (typeof str !== 'string' || str.length === 0) {
    return 0;
  }

  var width = 0;
  str = stripAnsi(str);

  for (var i = 0; i < str.length; i++) {
    var code = codePointAt(str, i); // ignore control characters

    if (code <= 0x1f || code >= 0x7f && code <= 0x9f) {
      continue;
    } // surrogates


    if (code >= 0x10000) {
      i++;
    }

    if (isFullwidthCodePoint(code)) {
      width += 2;
    } else {
      width++;
    }
  }

  return width;
};
},{"strip-ansi":"../node_modules/strip-ansi/index.js","code-point-at":"../node_modules/code-point-at/index.js","is-fullwidth-code-point":"../node_modules/is-fullwidth-code-point/index.js"}],"../node_modules/wide-align/align.js":[function(require,module,exports) {
'use strict'
var stringWidth = require('string-width')

exports.center = alignCenter
exports.left = alignLeft
exports.right = alignRight

// lodash's way of generating pad characters.

function createPadding (width) {
  var result = ''
  var string = ' '
  var n = width
  do {
    if (n % 2) {
      result += string;
    }
    n = Math.floor(n / 2);
    string += string;
  } while (n);

  return result;
}

function alignLeft (str, width) {
  var trimmed = str.trimRight()
  if (trimmed.length === 0 && str.length >= width) return str
  var padding = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    padding = createPadding(width - strWidth)
  }

  return trimmed + padding
}

function alignRight (str, width) {
  var trimmed = str.trimLeft()
  if (trimmed.length === 0 && str.length >= width) return str
  var padding = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    padding = createPadding(width - strWidth)
  }

  return padding + trimmed
}

function alignCenter (str, width) {
  var trimmed = str.trim()
  if (trimmed.length === 0 && str.length >= width) return str
  var padLeft = ''
  var padRight = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    var padLeftBy = parseInt((width - strWidth) / 2, 10) 
    padLeft = createPadding(padLeftBy)
    padRight = createPadding(width - (strWidth + padLeftBy))
  }

  return padLeft + trimmed + padRight
}

},{"string-width":"../node_modules/string-width/index.js"}],"../node_modules/aproba/index.js":[function(require,module,exports) {
'use strict'

function isArguments (thingy) {
  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee')
}

var types = {
  '*': {label: 'any', check: function () { return true }},
  A: {label: 'array', check: function (thingy) { return Array.isArray(thingy) || isArguments(thingy) }},
  S: {label: 'string', check: function (thingy) { return typeof thingy === 'string' }},
  N: {label: 'number', check: function (thingy) { return typeof thingy === 'number' }},
  F: {label: 'function', check: function (thingy) { return typeof thingy === 'function' }},
  O: {label: 'object', check: function (thingy) { return typeof thingy === 'object' && thingy != null && !types.A.check(thingy) && !types.E.check(thingy) }},
  B: {label: 'boolean', check: function (thingy) { return typeof thingy === 'boolean' }},
  E: {label: 'error', check: function (thingy) { return thingy instanceof Error }},
  Z: {label: 'null', check: function (thingy) { return thingy == null }}
}

function addSchema (schema, arity) {
  var group = arity[schema.length] = arity[schema.length] || []
  if (group.indexOf(schema) === -1) group.push(schema)
}

var validate = module.exports = function (rawSchemas, args) {
  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length)
  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas')
  if (!args) throw missingRequiredArg(1, 'args')
  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas)
  if (!types.A.check(args)) throw invalidType(1, ['array'], args)
  var schemas = rawSchemas.split('|')
  var arity = {}

  schemas.forEach(function (schema) {
    for (var ii = 0; ii < schema.length; ++ii) {
      var type = schema[ii]
      if (!types[type]) throw unknownType(ii, type)
    }
    if (/E.*E/.test(schema)) throw moreThanOneError(schema)
    addSchema(schema, arity)
    if (/E/.test(schema)) {
      addSchema(schema.replace(/E.*$/, 'E'), arity)
      addSchema(schema.replace(/E/, 'Z'), arity)
      if (schema.length === 1) addSchema('', arity)
    }
  })
  var matching = arity[args.length]
  if (!matching) {
    throw wrongNumberOfArgs(Object.keys(arity), args.length)
  }
  for (var ii = 0; ii < args.length; ++ii) {
    var newMatching = matching.filter(function (schema) {
      var type = schema[ii]
      var typeCheck = types[type].check
      return typeCheck(args[ii])
    })
    if (!newMatching.length) {
      var labels = matching.map(function (schema) {
        return types[schema[ii]].label
      }).filter(function (schema) { return schema != null })
      throw invalidType(ii, labels, args[ii])
    }
    matching = newMatching
  }
}

function missingRequiredArg (num) {
  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1))
}

function unknownType (num, type) {
  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1))
}

function invalidType (num, expectedTypes, value) {
  var valueType
  Object.keys(types).forEach(function (typeCode) {
    if (types[typeCode].check(value)) valueType = types[typeCode].label
  })
  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' +
    englishList(expectedTypes) + ' but got ' + valueType)
}

function englishList (list) {
  return list.join(', ').replace(/, ([^,]+)$/, ' or $1')
}

function wrongNumberOfArgs (expected, got) {
  var english = englishList(expected)
  var args = expected.every(function (ex) { return ex.length === 1 })
    ? 'argument'
    : 'arguments'
  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got)
}

function moreThanOneError (schema) {
  return newException('ETOOMANYERRORTYPES',
    'Only one error type per argument signature is allowed, more than one found in "' + schema + '"')
}

function newException (code, msg) {
  var e = new Error(msg)
  e.code = code
  if (Error.captureStackTrace) Error.captureStackTrace(e, validate)
  return e
}

},{}],"../node_modules/object-assign/index.js":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};
},{}],"../node_modules/gauge/wide-truncate.js":[function(require,module,exports) {
'use strict'
var stringWidth = require('string-width')
var stripAnsi = require('strip-ansi')

module.exports = wideTruncate

function wideTruncate (str, target) {
  if (stringWidth(str) === 0) return str
  if (target <= 0) return ''
  if (stringWidth(str) <= target) return str

  // We compute the number of bytes of ansi sequences here and add
  // that to our initial truncation to ensure that we don't slice one
  // that we want to keep in half.
  var noAnsi = stripAnsi(str)
  var ansiSize = str.length + noAnsi.length
  var truncated = str.slice(0, target + ansiSize)

  // we have to shrink the result to account for our ansi sequence buffer
  // (if an ansi sequence was truncated) and double width characters.
  while (stringWidth(truncated) > target) {
    truncated = truncated.slice(0, -1)
  }
  return truncated
}

},{"string-width":"../node_modules/string-width/index.js","strip-ansi":"../node_modules/strip-ansi/index.js"}],"../node_modules/gauge/error.js":[function(require,module,exports) {
'use strict'
var util = require('util')

var User = exports.User = function User (msg) {
  var err = new Error(msg)
  Error.captureStackTrace(err, User)
  err.code = 'EGAUGE'
  return err
}

exports.MissingTemplateValue = function MissingTemplateValue (item, values) {
  var err = new User(util.format('Missing template value "%s"', item.type))
  Error.captureStackTrace(err, MissingTemplateValue)
  err.template = item
  err.values = values
  return err
}

exports.Internal = function Internal (msg) {
  var err = new Error(msg)
  Error.captureStackTrace(err, Internal)
  err.code = 'EGAUGEINTERNAL'
  return err
}

},{"util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js"}],"../node_modules/gauge/template-item.js":[function(require,module,exports) {
'use strict'
var stringWidth = require('string-width')

module.exports = TemplateItem

function isPercent (num) {
  if (typeof num !== 'string') return false
  return num.slice(-1) === '%'
}

function percent (num) {
  return Number(num.slice(0, -1)) / 100
}

function TemplateItem (values, outputLength) {
  this.overallOutputLength = outputLength
  this.finished = false
  this.type = null
  this.value = null
  this.length = null
  this.maxLength = null
  this.minLength = null
  this.kerning = null
  this.align = 'left'
  this.padLeft = 0
  this.padRight = 0
  this.index = null
  this.first = null
  this.last = null
  if (typeof values === 'string') {
    this.value = values
  } else {
    for (var prop in values) this[prop] = values[prop]
  }
  // Realize percents
  if (isPercent(this.length)) {
    this.length = Math.round(this.overallOutputLength * percent(this.length))
  }
  if (isPercent(this.minLength)) {
    this.minLength = Math.round(this.overallOutputLength * percent(this.minLength))
  }
  if (isPercent(this.maxLength)) {
    this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength))
  }
  return this
}

TemplateItem.prototype = {}

TemplateItem.prototype.getBaseLength = function () {
  var length = this.length
  if (length == null && typeof this.value === 'string' && this.maxLength == null && this.minLength == null) {
    length = stringWidth(this.value)
  }
  return length
}

TemplateItem.prototype.getLength = function () {
  var length = this.getBaseLength()
  if (length == null) return null
  return length + this.padLeft + this.padRight
}

TemplateItem.prototype.getMaxLength = function () {
  if (this.maxLength == null) return null
  return this.maxLength + this.padLeft + this.padRight
}

TemplateItem.prototype.getMinLength = function () {
  if (this.minLength == null) return null
  return this.minLength + this.padLeft + this.padRight
}


},{"string-width":"../node_modules/string-width/index.js"}],"../node_modules/gauge/render-template.js":[function(require,module,exports) {
'use strict'
var align = require('wide-align')
var validate = require('aproba')
var objectAssign = require('object-assign')
var wideTruncate = require('./wide-truncate')
var error = require('./error')
var TemplateItem = require('./template-item')

function renderValueWithValues (values) {
  return function (item) {
    return renderValue(item, values)
  }
}

var renderTemplate = module.exports = function (width, template, values) {
  var items = prepareItems(width, template, values)
  var rendered = items.map(renderValueWithValues(values)).join('')
  return align.left(wideTruncate(rendered, width), width)
}

function preType (item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1)
  return 'pre' + cappedTypeName
}

function postType (item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1)
  return 'post' + cappedTypeName
}

function hasPreOrPost (item, values) {
  if (!item.type) return
  return values[preType(item)] || values[postType(item)]
}

function generatePreAndPost (baseItem, parentValues) {
  var item = objectAssign({}, baseItem)
  var values = Object.create(parentValues)
  var template = []
  var pre = preType(item)
  var post = postType(item)
  if (values[pre]) {
    template.push({value: values[pre]})
    values[pre] = null
  }
  item.minLength = null
  item.length = null
  item.maxLength = null
  template.push(item)
  values[item.type] = values[item.type]
  if (values[post]) {
    template.push({value: values[post]})
    values[post] = null
  }
  return function ($1, $2, length) {
    return renderTemplate(length, template, values)
  }
}

function prepareItems (width, template, values) {
  function cloneAndObjectify (item, index, arr) {
    var cloned = new TemplateItem(item, width)
    var type = cloned.type
    if (cloned.value == null) {
      if (!(type in values)) {
        if (cloned.default == null) {
          throw new error.MissingTemplateValue(cloned, values)
        } else {
          cloned.value = cloned.default
        }
      } else {
        cloned.value = values[type]
      }
    }
    if (cloned.value == null || cloned.value === '') return null
    cloned.index = index
    cloned.first = index === 0
    cloned.last = index === arr.length - 1
    if (hasPreOrPost(cloned, values)) cloned.value = generatePreAndPost(cloned, values)
    return cloned
  }

  var output = template.map(cloneAndObjectify).filter(function (item) { return item != null })

  var outputLength = 0
  var remainingSpace = width
  var variableCount = output.length

  function consumeSpace (length) {
    if (length > remainingSpace) length = remainingSpace
    outputLength += length
    remainingSpace -= length
  }

  function finishSizing (item, length) {
    if (item.finished) throw new error.Internal('Tried to finish template item that was already finished')
    if (length === Infinity) throw new error.Internal('Length of template item cannot be infinity')
    if (length != null) item.length = length
    item.minLength = null
    item.maxLength = null
    --variableCount
    item.finished = true
    if (item.length == null) item.length = item.getBaseLength()
    if (item.length == null) throw new error.Internal('Finished template items must have a length')
    consumeSpace(item.getLength())
  }

  output.forEach(function (item) {
    if (!item.kerning) return
    var prevPadRight = item.first ? 0 : output[item.index - 1].padRight
    if (!item.first && prevPadRight < item.kerning) item.padLeft = item.kerning - prevPadRight
    if (!item.last) item.padRight = item.kerning
  })

  // Finish any that have a fixed (literal or intuited) length
  output.forEach(function (item) {
    if (item.getBaseLength() == null) return
    finishSizing(item)
  })

  var resized = 0
  var resizing
  var hunkSize
  do {
    resizing = false
    hunkSize = Math.round(remainingSpace / variableCount)
    output.forEach(function (item) {
      if (item.finished) return
      if (!item.maxLength) return
      if (item.getMaxLength() < hunkSize) {
        finishSizing(item, item.maxLength)
        resizing = true
      }
    })
  } while (resizing && resized++ < output.length)
  if (resizing) throw new error.Internal('Resize loop iterated too many times while determining maxLength')

  resized = 0
  do {
    resizing = false
    hunkSize = Math.round(remainingSpace / variableCount)
    output.forEach(function (item) {
      if (item.finished) return
      if (!item.minLength) return
      if (item.getMinLength() >= hunkSize) {
        finishSizing(item, item.minLength)
        resizing = true
      }
    })
  } while (resizing && resized++ < output.length)
  if (resizing) throw new error.Internal('Resize loop iterated too many times while determining minLength')

  hunkSize = Math.round(remainingSpace / variableCount)
  output.forEach(function (item) {
    if (item.finished) return
    finishSizing(item, hunkSize)
  })

  return output
}

function renderFunction (item, values, length) {
  validate('OON', arguments)
  if (item.type) {
    return item.value(values, values[item.type + 'Theme'] || {}, length)
  } else {
    return item.value(values, {}, length)
  }
}

function renderValue (item, values) {
  var length = item.getBaseLength()
  var value = typeof item.value === 'function' ? renderFunction(item, values, length) : item.value
  if (value == null || value === '') return ''
  var alignWith = align[item.align] || align.left
  var leftPadding = item.padLeft ? align.left('', item.padLeft) : ''
  var rightPadding = item.padRight ? align.right('', item.padRight) : ''
  var truncated = wideTruncate(String(value), length)
  var aligned = alignWith(truncated, length)
  return leftPadding + aligned + rightPadding
}

},{"wide-align":"../node_modules/wide-align/align.js","aproba":"../node_modules/aproba/index.js","object-assign":"../node_modules/object-assign/index.js","./wide-truncate":"../node_modules/gauge/wide-truncate.js","./error":"../node_modules/gauge/error.js","./template-item":"../node_modules/gauge/template-item.js"}],"../node_modules/gauge/plumbing.js":[function(require,module,exports) {
'use strict'
var consoleControl = require('console-control-strings')
var renderTemplate = require('./render-template.js')
var validate = require('aproba')

var Plumbing = module.exports = function (theme, template, width) {
  if (!width) width = 80
  validate('OAN', [theme, template, width])
  this.showing = false
  this.theme = theme
  this.width = width
  this.template = template
}
Plumbing.prototype = {}

Plumbing.prototype.setTheme = function (theme) {
  validate('O', [theme])
  this.theme = theme
}

Plumbing.prototype.setTemplate = function (template) {
  validate('A', [template])
  this.template = template
}

Plumbing.prototype.setWidth = function (width) {
  validate('N', [width])
  this.width = width
}

Plumbing.prototype.hide = function () {
  return consoleControl.gotoSOL() + consoleControl.eraseLine()
}

Plumbing.prototype.hideCursor = consoleControl.hideCursor

Plumbing.prototype.showCursor = consoleControl.showCursor

Plumbing.prototype.show = function (status) {
  var values = Object.create(this.theme)
  for (var key in status) {
    values[key] = status[key]
  }

  return renderTemplate(this.width, this.template, values).trim() +
         consoleControl.color('reset') +
         consoleControl.eraseLine() + consoleControl.gotoSOL()
}

},{"console-control-strings":"../node_modules/console-control-strings/index.js","./render-template.js":"../node_modules/gauge/render-template.js","aproba":"../node_modules/aproba/index.js"}],"../node_modules/has-unicode/index.js":[function(require,module,exports) {
"use strict";

var os = require("os");

var hasUnicode = module.exports = function () {
  // Recent Win32 platforms (>XP) CAN support unicode in the console but
  // don't have to, and in non-english locales often use traditional local
  // code pages. There's no way, short of windows system calls or execing
  // the chcp command line program to figure this out. As such, we default
  // this to false and encourage your users to override it via config if
  // appropriate.
  if (os.type() == "Windows_NT") {
    return false;
  }

  var isUTF8 = /UTF-?8$/i;
  var ctype = undefined || undefined || "en_US.UTF-8";
  return isUTF8.test(ctype);
};
},{"os":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js"}],"../node_modules/gauge/has-color.js":[function(require,module,exports) {
var process = require("process");
'use strict';

module.exports = isWin32() || isColorTerm();

function isWin32() {
  return process.platform === 'win32';
}

function isColorTerm() {
  var termHasColor = /^screen|^xterm|^vt100|color|ansi|cygwin|linux/i;
  return !!"truecolor" || termHasColor.test("xterm-256color");
}
},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/object-assign/index.js":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/node_modules/util/util.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
},{"./support/isBuffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/node_modules/util/support/isBufferBrowser.js","inherits":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/node_modules/inherits/inherits_browser.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/assert.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"object-assign":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/object-assign/index.js","util/":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/node_modules/util/util.js"}],"../node_modules/signal-exit/signals.js":[function(require,module,exports) {
var process = require("process");
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
]

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  )
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  )
}

},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/signal-exit/index.js":[function(require,module,exports) {
var process = require("process");
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
var assert = require('assert')
var signals = require('./signals.js')

var EE = require('events')
/* istanbul ignore if */
if (typeof EE !== 'function') {
  EE = EE.EventEmitter
}

var emitter
if (process.__signal_exit_emitter__) {
  emitter = process.__signal_exit_emitter__
} else {
  emitter = process.__signal_exit_emitter__ = new EE()
  emitter.count = 0
  emitter.emitted = {}
}

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity)
  emitter.infinite = true
}

module.exports = function (cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

  if (loaded === false) {
    load()
  }

  var ev = 'exit'
  if (opts && opts.alwaysLast) {
    ev = 'afterexit'
  }

  var remove = function () {
    emitter.removeListener(ev, cb)
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) {
      unload()
    }
  }
  emitter.on(ev, cb)

  return remove
}

module.exports.unload = unload
function unload () {
  if (!loaded) {
    return
  }
  loaded = false

  signals.forEach(function (sig) {
    try {
      process.removeListener(sig, sigListeners[sig])
    } catch (er) {}
  })
  process.emit = originalProcessEmit
  process.reallyExit = originalProcessReallyExit
  emitter.count -= 1
}

function emit (event, code, signal) {
  if (emitter.emitted[event]) {
    return
  }
  emitter.emitted[event] = true
  emitter.emit(event, code, signal)
}

// { <signal>: <listener fn>, ... }
var sigListeners = {}
signals.forEach(function (sig) {
  sigListeners[sig] = function listener () {
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig)
    if (listeners.length === emitter.count) {
      unload()
      emit('exit', null, sig)
      /* istanbul ignore next */
      emit('afterexit', null, sig)
      /* istanbul ignore next */
      process.kill(process.pid, sig)
    }
  }
})

module.exports.signals = function () {
  return signals
}

module.exports.load = load

var loaded = false

function load () {
  if (loaded) {
    return
  }
  loaded = true

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1

  signals = signals.filter(function (sig) {
    try {
      process.on(sig, sigListeners[sig])
      return true
    } catch (er) {
      return false
    }
  })

  process.emit = processEmit
  process.reallyExit = processReallyExit
}

var originalProcessReallyExit = process.reallyExit
function processReallyExit (code) {
  process.exitCode = code || 0
  emit('exit', process.exitCode, null)
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null)
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode)
}

var originalProcessEmit = process.emit
function processEmit (ev, arg) {
  if (ev === 'exit') {
    if (arg !== undefined) {
      process.exitCode = arg
    }
    var ret = originalProcessEmit.apply(this, arguments)
    emit('exit', process.exitCode, null)
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null)
    return ret
  } else {
    return originalProcessEmit.apply(this, arguments)
  }
}

},{"assert":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/assert.js","./signals.js":"../node_modules/signal-exit/signals.js","events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/gauge/spin.js":[function(require,module,exports) {
'use strict'

module.exports = function spin (spinstr, spun) {
  return spinstr[spun % spinstr.length]
}

},{}],"../node_modules/gauge/progress-bar.js":[function(require,module,exports) {
'use strict'
var validate = require('aproba')
var renderTemplate = require('./render-template.js')
var wideTruncate = require('./wide-truncate')
var stringWidth = require('string-width')

module.exports = function (theme, width, completed) {
  validate('ONN', [theme, width, completed])
  if (completed < 0) completed = 0
  if (completed > 1) completed = 1
  if (width <= 0) return ''
  var sofar = Math.round(width * completed)
  var rest = width - sofar
  var template = [
    {type: 'complete', value: repeat(theme.complete, sofar), length: sofar},
    {type: 'remaining', value: repeat(theme.remaining, rest), length: rest}
  ]
  return renderTemplate(width, template, theme)
}

// lodash's way of repeating
function repeat (string, width) {
  var result = ''
  var n = width
  do {
    if (n % 2) {
      result += string
    }
    n = Math.floor(n / 2)
    /*eslint no-self-assign: 0*/
    string += string
  } while (n && stringWidth(result) < width)

  return wideTruncate(result, width)
}

},{"aproba":"../node_modules/aproba/index.js","./render-template.js":"../node_modules/gauge/render-template.js","./wide-truncate":"../node_modules/gauge/wide-truncate.js","string-width":"../node_modules/string-width/index.js"}],"../node_modules/gauge/base-theme.js":[function(require,module,exports) {
'use strict'
var spin = require('./spin.js')
var progressBar = require('./progress-bar.js')

module.exports = {
  activityIndicator: function (values, theme, width) {
    if (values.spun == null) return
    return spin(theme, values.spun)
  },
  progressbar: function (values, theme, width) {
    if (values.completed == null) return
    return progressBar(theme, width, values.completed)
  }
}

},{"./spin.js":"../node_modules/gauge/spin.js","./progress-bar.js":"../node_modules/gauge/progress-bar.js"}],"../node_modules/gauge/theme-set.js":[function(require,module,exports) {
var process = require("process");
'use strict'
var objectAssign = require('object-assign')

module.exports = function () {
  return ThemeSetProto.newThemeSet()
}

var ThemeSetProto = {}

ThemeSetProto.baseTheme = require('./base-theme.js')

ThemeSetProto.newTheme = function (parent, theme) {
  if (!theme) {
    theme = parent
    parent = this.baseTheme
  }
  return objectAssign({}, parent, theme)
}

ThemeSetProto.getThemeNames = function () {
  return Object.keys(this.themes)
}

ThemeSetProto.addTheme = function (name, parent, theme) {
  this.themes[name] = this.newTheme(parent, theme)
}

ThemeSetProto.addToAllThemes = function (theme) {
  var themes = this.themes
  Object.keys(themes).forEach(function (name) {
    objectAssign(themes[name], theme)
  })
  objectAssign(this.baseTheme, theme)
}

ThemeSetProto.getTheme = function (name) {
  if (!this.themes[name]) throw this.newMissingThemeError(name)
  return this.themes[name]
}

ThemeSetProto.setDefault = function (opts, name) {
  if (name == null) {
    name = opts
    opts = {}
  }
  var platform = opts.platform == null ? 'fallback' : opts.platform
  var hasUnicode = !!opts.hasUnicode
  var hasColor = !!opts.hasColor
  if (!this.defaults[platform]) this.defaults[platform] = {true: {}, false: {}}
  this.defaults[platform][hasUnicode][hasColor] = name
}

ThemeSetProto.getDefault = function (opts) {
  if (!opts) opts = {}
  var platformName = opts.platform || process.platform
  var platform = this.defaults[platformName] || this.defaults.fallback
  var hasUnicode = !!opts.hasUnicode
  var hasColor = !!opts.hasColor
  if (!platform) throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
  if (!platform[hasUnicode][hasColor]) {
    if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
      hasUnicode = false
    } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
      hasColor = false
    } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
      hasUnicode = false
      hasColor = false
    } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
      hasUnicode = false
    } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
      hasColor = false
    } else if (platform === this.defaults.fallback) {
      throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
    }
  }
  if (platform[hasUnicode][hasColor]) {
    return this.getTheme(platform[hasUnicode][hasColor])
  } else {
    return this.getDefault(objectAssign({}, opts, {platform: 'fallback'}))
  }
}

ThemeSetProto.newMissingThemeError = function newMissingThemeError (name) {
  var err = new Error('Could not find a gauge theme named "' + name + '"')
  Error.captureStackTrace.call(err, newMissingThemeError)
  err.theme = name
  err.code = 'EMISSINGTHEME'
  return err
}

ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError (platformName, hasUnicode, hasColor) {
  var err = new Error(
    'Could not find a gauge theme for your platform/unicode/color use combo:\n' +
    '    platform = ' + platformName + '\n' +
    '    hasUnicode = ' + hasUnicode + '\n' +
    '    hasColor = ' + hasColor)
  Error.captureStackTrace.call(err, newMissingDefaultThemeError)
  err.platform = platformName
  err.hasUnicode = hasUnicode
  err.hasColor = hasColor
  err.code = 'EMISSINGTHEME'
  return err
}

ThemeSetProto.newThemeSet = function () {
  var themeset = function (opts) {
    return themeset.getDefault(opts)
  }
  return objectAssign(themeset, ThemeSetProto, {
    themes: objectAssign({}, this.themes),
    baseTheme: objectAssign({}, this.baseTheme),
    defaults: JSON.parse(JSON.stringify(this.defaults || {}))
  })
}


},{"object-assign":"../node_modules/object-assign/index.js","./base-theme.js":"../node_modules/gauge/base-theme.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/gauge/themes.js":[function(require,module,exports) {
'use strict'
var consoleControl = require('console-control-strings')
var ThemeSet = require('./theme-set.js')

var themes = module.exports = new ThemeSet()

themes.addTheme('ASCII', {
  preProgressbar: '[',
  postProgressbar: ']',
  progressbarTheme: {
    complete: '#',
    remaining: '.'
  },
  activityIndicatorTheme: '-\\|/',
  preSubsection: '>'
})

themes.addTheme('colorASCII', themes.getTheme('ASCII'), {
  progressbarTheme: {
    preComplete: consoleControl.color('inverse'),
    complete: ' ',
    postComplete: consoleControl.color('stopInverse'),
    preRemaining: consoleControl.color('brightBlack'),
    remaining: '.',
    postRemaining: consoleControl.color('reset')
  }
})

themes.addTheme('brailleSpinner', {
  preProgressbar: 'â¸¨',
  postProgressbar: 'â¸©',
  progressbarTheme: {
    complete: 'â',
    remaining: 'â '
  },
  activityIndicatorTheme: 'â â â ¹â ¸â ¼â ´â ¦â §â â ',
  preSubsection: '>'
})

themes.addTheme('colorBrailleSpinner', themes.getTheme('brailleSpinner'), {
  progressbarTheme: {
    preComplete: consoleControl.color('inverse'),
    complete: ' ',
    postComplete: consoleControl.color('stopInverse'),
    preRemaining: consoleControl.color('brightBlack'),
    remaining: 'â',
    postRemaining: consoleControl.color('reset')
  }
})

themes.setDefault({}, 'ASCII')
themes.setDefault({hasColor: true}, 'colorASCII')
themes.setDefault({platform: 'darwin', hasUnicode: true}, 'brailleSpinner')
themes.setDefault({platform: 'darwin', hasUnicode: true, hasColor: true}, 'colorBrailleSpinner')

},{"console-control-strings":"../node_modules/console-control-strings/index.js","./theme-set.js":"../node_modules/gauge/theme-set.js"}],"../node_modules/gauge/set-interval.js":[function(require,module,exports) {
'use strict'
// this exists so we can replace it during testing
module.exports = setInterval

},{}],"../node_modules/gauge/process.js":[function(require,module,exports) {
var process = require("process");
'use strict'
// this exists so we can replace it during testing
module.exports = process

},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/gauge/set-immediate.js":[function(require,module,exports) {

'use strict'
var process = require('./process')
try {
  module.exports = setImmediate
} catch (ex) {
  module.exports = process.nextTick
}

},{"./process":"../node_modules/gauge/process.js"}],"../node_modules/gauge/index.js":[function(require,module,exports) {

'use strict'
var Plumbing = require('./plumbing.js')
var hasUnicode = require('has-unicode')
var hasColor = require('./has-color.js')
var onExit = require('signal-exit')
var defaultThemes = require('./themes')
var setInterval = require('./set-interval.js')
var process = require('./process.js')
var setImmediate = require('./set-immediate')

module.exports = Gauge

function callWith (obj, method) {
  return function () {
    return method.call(obj)
  }
}

function Gauge (arg1, arg2) {
  var options, writeTo
  if (arg1 && arg1.write) {
    writeTo = arg1
    options = arg2 || {}
  } else if (arg2 && arg2.write) {
    writeTo = arg2
    options = arg1 || {}
  } else {
    writeTo = process.stderr
    options = arg1 || arg2 || {}
  }

  this._status = {
    spun: 0,
    section: '',
    subsection: ''
  }
  this._paused = false // are we paused for back pressure?
  this._disabled = true // are all progress bar updates disabled?
  this._showing = false // do we WANT the progress bar on screen
  this._onScreen = false // IS the progress bar on screen
  this._needsRedraw = false // should we print something at next tick?
  this._hideCursor = options.hideCursor == null ? true : options.hideCursor
  this._fixedFramerate = options.fixedFramerate == null
    ? !(/^v0\.8\./.test(process.version))
    : options.fixedFramerate
  this._lastUpdateAt = null
  this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval

  this._themes = options.themes || defaultThemes
  this._theme = options.theme
  var theme = this._computeTheme(options.theme)
  var template = options.template || [
    {type: 'progressbar', length: 20},
    {type: 'activityIndicator', kerning: 1, length: 1},
    {type: 'section', kerning: 1, default: ''},
    {type: 'subsection', kerning: 1, default: ''}
  ]
  this.setWriteTo(writeTo, options.tty)
  var PlumbingClass = options.Plumbing || Plumbing
  this._gauge = new PlumbingClass(theme, template, this.getWidth())

  this._$$doRedraw = callWith(this, this._doRedraw)
  this._$$handleSizeChange = callWith(this, this._handleSizeChange)

  this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit
  this._removeOnExit = null

  if (options.enabled || (options.enabled == null && this._tty && this._tty.isTTY)) {
    this.enable()
  } else {
    this.disable()
  }
}
Gauge.prototype = {}

Gauge.prototype.isEnabled = function () {
  return !this._disabled
}

Gauge.prototype.setTemplate = function (template) {
  this._gauge.setTemplate(template)
  if (this._showing) this._requestRedraw()
}

Gauge.prototype._computeTheme = function (theme) {
  if (!theme) theme = {}
  if (typeof theme === 'string') {
    theme = this._themes.getTheme(theme)
  } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
    var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode
    var useColor = theme.hasColor == null ? hasColor : theme.hasColor
    theme = this._themes.getDefault({hasUnicode: useUnicode, hasColor: useColor, platform: theme.platform})
  }
  return theme
}

Gauge.prototype.setThemeset = function (themes) {
  this._themes = themes
  this.setTheme(this._theme)
}

Gauge.prototype.setTheme = function (theme) {
  this._gauge.setTheme(this._computeTheme(theme))
  if (this._showing) this._requestRedraw()
  this._theme = theme
}

Gauge.prototype._requestRedraw = function () {
  this._needsRedraw = true
  if (!this._fixedFramerate) this._doRedraw()
}

Gauge.prototype.getWidth = function () {
  return ((this._tty && this._tty.columns) || 80) - 1
}

Gauge.prototype.setWriteTo = function (writeTo, tty) {
  var enabled = !this._disabled
  if (enabled) this.disable()
  this._writeTo = writeTo
  this._tty = tty ||
    (writeTo === process.stderr && process.stdout.isTTY && process.stdout) ||
    (writeTo.isTTY && writeTo) ||
    this._tty
  if (this._gauge) this._gauge.setWidth(this.getWidth())
  if (enabled) this.enable()
}

Gauge.prototype.enable = function () {
  if (!this._disabled) return
  this._disabled = false
  if (this._tty) this._enableEvents()
  if (this._showing) this.show()
}

Gauge.prototype.disable = function () {
  if (this._disabled) return
  if (this._showing) {
    this._lastUpdateAt = null
    this._showing = false
    this._doRedraw()
    this._showing = true
  }
  this._disabled = true
  if (this._tty) this._disableEvents()
}

Gauge.prototype._enableEvents = function () {
  if (this._cleanupOnExit) {
    this._removeOnExit = onExit(callWith(this, this.disable))
  }
  this._tty.on('resize', this._$$handleSizeChange)
  if (this._fixedFramerate) {
    this.redrawTracker = setInterval(this._$$doRedraw, this._updateInterval)
    if (this.redrawTracker.unref) this.redrawTracker.unref()
  }
}

Gauge.prototype._disableEvents = function () {
  this._tty.removeListener('resize', this._$$handleSizeChange)
  if (this._fixedFramerate) clearInterval(this.redrawTracker)
  if (this._removeOnExit) this._removeOnExit()
}

Gauge.prototype.hide = function (cb) {
  if (this._disabled) return cb && process.nextTick(cb)
  if (!this._showing) return cb && process.nextTick(cb)
  this._showing = false
  this._doRedraw()
  cb && setImmediate(cb)
}

Gauge.prototype.show = function (section, completed) {
  this._showing = true
  if (typeof section === 'string') {
    this._status.section = section
  } else if (typeof section === 'object') {
    var sectionKeys = Object.keys(section)
    for (var ii = 0; ii < sectionKeys.length; ++ii) {
      var key = sectionKeys[ii]
      this._status[key] = section[key]
    }
  }
  if (completed != null) this._status.completed = completed
  if (this._disabled) return
  this._requestRedraw()
}

Gauge.prototype.pulse = function (subsection) {
  this._status.subsection = subsection || ''
  this._status.spun ++
  if (this._disabled) return
  if (!this._showing) return
  this._requestRedraw()
}

Gauge.prototype._handleSizeChange = function () {
  this._gauge.setWidth(this._tty.columns - 1)
  this._requestRedraw()
}

Gauge.prototype._doRedraw = function () {
  if (this._disabled || this._paused) return
  if (!this._fixedFramerate) {
    var now = Date.now()
    if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) return
    this._lastUpdateAt = now
  }
  if (!this._showing && this._onScreen) {
    this._onScreen = false
    var result = this._gauge.hide()
    if (this._hideCursor) {
      result += this._gauge.showCursor()
    }
    return this._writeTo.write(result)
  }
  if (!this._showing && !this._onScreen) return
  if (this._showing && !this._onScreen) {
    this._onScreen = true
    this._needsRedraw = true
    if (this._hideCursor) {
      this._writeTo.write(this._gauge.hideCursor())
    }
  }
  if (!this._needsRedraw) return
  if (!this._writeTo.write(this._gauge.show(this._status))) {
    this._paused = true
    this._writeTo.on('drain', callWith(this, function () {
      this._paused = false
      this._doRedraw()
    }))
  }
}

},{"./plumbing.js":"../node_modules/gauge/plumbing.js","has-unicode":"../node_modules/has-unicode/index.js","./has-color.js":"../node_modules/gauge/has-color.js","signal-exit":"../node_modules/signal-exit/index.js","./themes":"../node_modules/gauge/themes.js","./set-interval.js":"../node_modules/gauge/set-interval.js","./process.js":"../node_modules/gauge/process.js","./set-immediate":"../node_modules/gauge/set-immediate.js"}],"../node_modules/set-blocking/index.js":[function(require,module,exports) {
var process = require("process");
module.exports = function (blocking) {
  [process.stdout, process.stderr].forEach(function (stream) {
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
      stream._handle.setBlocking(blocking)
    }
  })
}

},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/npmlog/log.js":[function(require,module,exports) {
var process = require("process");
'use strict'
var Progress = require('are-we-there-yet')
var Gauge = require('gauge')
var EE = require('events').EventEmitter
var log = exports = module.exports = new EE()
var util = require('util')

var setBlocking = require('set-blocking')
var consoleControl = require('console-control-strings')

setBlocking(true)
var stream = process.stderr
Object.defineProperty(log, 'stream', {
  set: function (newStream) {
    stream = newStream
    if (this.gauge) this.gauge.setWriteTo(stream, stream)
  },
  get: function () {
    return stream
  }
})

// by default, decide based on tty-ness.
var colorEnabled
log.useColor = function () {
  return colorEnabled != null ? colorEnabled : stream.isTTY
}

log.enableColor = function () {
  colorEnabled = true
  this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled})
}
log.disableColor = function () {
  colorEnabled = false
  this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled})
}

// default level
log.level = 'info'

log.gauge = new Gauge(stream, {
  enabled: false, // no progress bars unless asked
  theme: {hasColor: log.useColor()},
  template: [
    {type: 'progressbar', length: 20},
    {type: 'activityIndicator', kerning: 1, length: 1},
    {type: 'section', default: ''},
    ':',
    {type: 'logline', kerning: 1, default: ''}
  ]
})

log.tracker = new Progress.TrackerGroup()

// we track this separately as we may need to temporarily disable the
// display of the status bar for our own loggy purposes.
log.progressEnabled = log.gauge.isEnabled()

var unicodeEnabled

log.enableUnicode = function () {
  unicodeEnabled = true
  this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled})
}

log.disableUnicode = function () {
  unicodeEnabled = false
  this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled})
}

log.setGaugeThemeset = function (themes) {
  this.gauge.setThemeset(themes)
}

log.setGaugeTemplate = function (template) {
  this.gauge.setTemplate(template)
}

log.enableProgress = function () {
  if (this.progressEnabled) return
  this.progressEnabled = true
  this.tracker.on('change', this.showProgress)
  if (this._pause) return
  this.gauge.enable()
}

log.disableProgress = function () {
  if (!this.progressEnabled) return
  this.progressEnabled = false
  this.tracker.removeListener('change', this.showProgress)
  this.gauge.disable()
}

var trackerConstructors = ['newGroup', 'newItem', 'newStream']

var mixinLog = function (tracker) {
  // mixin the public methods from log into the tracker
  // (except: conflicts and one's we handle specially)
  Object.keys(log).forEach(function (P) {
    if (P[0] === '_') return
    if (trackerConstructors.filter(function (C) { return C === P }).length) return
    if (tracker[P]) return
    if (typeof log[P] !== 'function') return
    var func = log[P]
    tracker[P] = function () {
      return func.apply(log, arguments)
    }
  })
  // if the new tracker is a group, make sure any subtrackers get
  // mixed in too
  if (tracker instanceof Progress.TrackerGroup) {
    trackerConstructors.forEach(function (C) {
      var func = tracker[C]
      tracker[C] = function () { return mixinLog(func.apply(tracker, arguments)) }
    })
  }
  return tracker
}

// Add tracker constructors to the top level log object
trackerConstructors.forEach(function (C) {
  log[C] = function () { return mixinLog(this.tracker[C].apply(this.tracker, arguments)) }
})

log.clearProgress = function (cb) {
  if (!this.progressEnabled) return cb && process.nextTick(cb)
  this.gauge.hide(cb)
}

log.showProgress = function (name, completed) {
  if (!this.progressEnabled) return
  var values = {}
  if (name) values.section = name
  var last = log.record[log.record.length - 1]
  if (last) {
    values.subsection = last.prefix
    var disp = log.disp[last.level] || last.level
    var logline = this._format(disp, log.style[last.level])
    if (last.prefix) logline += ' ' + this._format(last.prefix, this.prefixStyle)
    logline += ' ' + last.message.split(/\r?\n/)[0]
    values.logline = logline
  }
  values.completed = completed || this.tracker.completed()
  this.gauge.show(values)
}.bind(log) // bind for use in tracker's on-change listener

// temporarily stop emitting, but don't drop
log.pause = function () {
  this._paused = true
  if (this.progressEnabled) this.gauge.disable()
}

log.resume = function () {
  if (!this._paused) return
  this._paused = false

  var b = this._buffer
  this._buffer = []
  b.forEach(function (m) {
    this.emitLog(m)
  }, this)
  if (this.progressEnabled) this.gauge.enable()
}

log._buffer = []

var id = 0
log.record = []
log.maxRecordSize = 10000
log.log = function (lvl, prefix, message) {
  var l = this.levels[lvl]
  if (l === undefined) {
    return this.emit('error', new Error(util.format(
      'Undefined log level: %j', lvl)))
  }

  var a = new Array(arguments.length - 2)
  var stack = null
  for (var i = 2; i < arguments.length; i++) {
    var arg = a[i - 2] = arguments[i]

    // resolve stack traces to a plain string.
    if (typeof arg === 'object' && arg &&
        (arg instanceof Error) && arg.stack) {

      Object.defineProperty(arg, 'stack', {
        value: stack = arg.stack + '',
        enumerable: true,
        writable: true
      })
    }
  }
  if (stack) a.unshift(stack + '\n')
  message = util.format.apply(util, a)

  var m = { id: id++,
            level: lvl,
            prefix: String(prefix || ''),
            message: message,
            messageRaw: a }

  this.emit('log', m)
  this.emit('log.' + lvl, m)
  if (m.prefix) this.emit(m.prefix, m)

  this.record.push(m)
  var mrs = this.maxRecordSize
  var n = this.record.length - mrs
  if (n > mrs / 10) {
    var newSize = Math.floor(mrs * 0.9)
    this.record = this.record.slice(-1 * newSize)
  }

  this.emitLog(m)
}.bind(log)

log.emitLog = function (m) {
  if (this._paused) {
    this._buffer.push(m)
    return
  }
  if (this.progressEnabled) this.gauge.pulse(m.prefix)
  var l = this.levels[m.level]
  if (l === undefined) return
  if (l < this.levels[this.level]) return
  if (l > 0 && !isFinite(l)) return

  // If 'disp' is null or undefined, use the lvl as a default
  // Allows: '', 0 as valid disp
  var disp = log.disp[m.level] != null ? log.disp[m.level] : m.level
  this.clearProgress()
  m.message.split(/\r?\n/).forEach(function (line) {
    if (this.heading) {
      this.write(this.heading, this.headingStyle)
      this.write(' ')
    }
    this.write(disp, log.style[m.level])
    var p = m.prefix || ''
    if (p) this.write(' ')
    this.write(p, this.prefixStyle)
    this.write(' ' + line + '\n')
  }, this)
  this.showProgress()
}

log._format = function (msg, style) {
  if (!stream) return

  var output = ''
  if (this.useColor()) {
    style = style || {}
    var settings = []
    if (style.fg) settings.push(style.fg)
    if (style.bg) settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1))
    if (style.bold) settings.push('bold')
    if (style.underline) settings.push('underline')
    if (style.inverse) settings.push('inverse')
    if (settings.length) output += consoleControl.color(settings)
    if (style.beep) output += consoleControl.beep()
  }
  output += msg
  if (this.useColor()) {
    output += consoleControl.color('reset')
  }
  return output
}

log.write = function (msg, style) {
  if (!stream) return

  stream.write(this._format(msg, style))
}

log.addLevel = function (lvl, n, style, disp) {
  // If 'disp' is null or undefined, use the lvl as a default
  if (disp == null) disp = lvl
  this.levels[lvl] = n
  this.style[lvl] = style
  if (!this[lvl]) {
    this[lvl] = function () {
      var a = new Array(arguments.length + 1)
      a[0] = lvl
      for (var i = 0; i < arguments.length; i++) {
        a[i + 1] = arguments[i]
      }
      return this.log.apply(this, a)
    }.bind(this)
  }
  this.disp[lvl] = disp
}

log.prefixStyle = { fg: 'magenta' }
log.headingStyle = { fg: 'white', bg: 'black' }

log.style = {}
log.levels = {}
log.disp = {}
log.addLevel('silly', -Infinity, { inverse: true }, 'sill')
log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb')
log.addLevel('info', 2000, { fg: 'green' })
log.addLevel('timing', 2500, { fg: 'green', bg: 'black' })
log.addLevel('http', 3000, { fg: 'green', bg: 'black' })
log.addLevel('notice', 3500, { fg: 'blue', bg: 'black' })
log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN')
log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!')
log.addLevel('silent', Infinity)

// allow 'error' prefix
log.on('error', function () {})

},{"are-we-there-yet":"../node_modules/are-we-there-yet/index.js","gauge":"../node_modules/gauge/index.js","events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","set-blocking":"../node_modules/set-blocking/index.js","console-control-strings":"../node_modules/console-control-strings/index.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/fs.realpath/old.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var pathModule = require('path');

var isWindows = process.platform === 'win32';

var fs = require('fs'); // JavaScript implementation of realpath, ported from node pre-v6


var DEBUG = undefined && /fs/.test(undefined);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;

  if (DEBUG) {
    var backtrace = new Error();
    callback = debugCallback;
  } else callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
          var msg = 'fs: missing callback ' + (err.stack || err.message);
          if (process.traceDeprecation) console.trace(msg);else console.error(msg);
        }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize; // Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']

if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
} // Regex to find the device root, including trailing slash. E.g. 'c:\\'.


if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {}; // current character position in p

  var pos; // the partial path so far, including a trailing slash if any

  var current; // the partial path without a trailing slash (except when pointing at a root)

  var base; // the partial path scanned in the previous round, with slash

  var previous;
  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = ''; // On windows, check that the root exists. On unix there is no need.

    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  } // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.


  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex; // continue if not a symlink

    if (knownHard[base] || cache && cache[base] === base) {
      continue;
    }

    var resolvedLink;

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);

      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      } // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.


      var linkTarget = null;

      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);

        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }

      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }

      resolvedLink = pathModule.resolve(previous, linkTarget); // track this, if given a cache.

      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    } // resolve the link, then start over


    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;
  return p;
};

exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  } // make p is absolute


  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {}; // current character position in p

  var pos; // the partial path so far, including a trailing slash if any

  var current; // the partial path without a trailing slash (except when pointing at a root)

  var base; // the partial path scanned in the previous round, with slash

  var previous;
  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = ''; // On windows, check that the root exists. On unix there is no need.

    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function (err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  } // walk down the path, swapping out linked pathparts for their real
  // values


  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    } // find the next part


    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex; // continue if not a symlink

    if (knownHard[base] || cache && cache[base] === base) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err); // if not a symlink, skip to the next path part

    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    } // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.


    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);

      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }

    fs.stat(base, function (err) {
      if (err) return cb(err);
      fs.readlink(base, function (err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);
    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};
},{"path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/fs.realpath/index.js":[function(require,module,exports) {
var process = require("process");
module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = require('fs')
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = require('./old.js')

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}

},{"fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","./old.js":"../node_modules/fs.realpath/old.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/concat-map/index.js":[function(require,module,exports) {
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],"../node_modules/balanced-match/index.js":[function(require,module,exports) {
'use strict';
module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

},{}],"../node_modules/brace-expansion/index.js":[function(require,module,exports) {
var concatMap = require('concat-map');
var balanced = require('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}


},{"concat-map":"../node_modules/concat-map/index.js","balanced-match":"../node_modules/balanced-match/index.js"}],"../node_modules/minimatch/minimatch.js":[function(require,module,exports) {
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = require('path')
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

},{"path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","brace-expansion":"../node_modules/brace-expansion/index.js"}],"../node_modules/path-is-absolute/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

function posix(path) {
  return path.charAt(0) === '/';
}

function win32(path) {
  // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
  var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
  var result = splitDeviceRe.exec(path);
  var device = result[1] || '';
  var isUnc = Boolean(device && device.charAt(1) !== ':'); // UNC paths are always absolute

  return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;
},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/glob/common.js":[function(require,module,exports) {
var process = require("process");
exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = require("path")
var minimatch = require("minimatch")
var isAbsolute = require("path-is-absolute")
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

},{"path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","minimatch":"../node_modules/minimatch/minimatch.js","path-is-absolute":"../node_modules/path-is-absolute/index.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/glob/sync.js":[function(require,module,exports) {
var process = require("process");
module.exports = globSync
globSync.GlobSync = GlobSync

var fs = require('fs')
var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var Glob = require('./glob.js').Glob
var util = require('util')
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var common = require('./common.js')
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

},{"fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","fs.realpath":"../node_modules/fs.realpath/index.js","minimatch":"../node_modules/minimatch/minimatch.js","./glob.js":"../node_modules/glob/glob.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","assert":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/assert.js","path-is-absolute":"../node_modules/path-is-absolute/index.js","./common.js":"../node_modules/glob/common.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/wrappy/wrappy.js":[function(require,module,exports) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],"../node_modules/once/once.js":[function(require,module,exports) {
var wrappy = require('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":"../node_modules/wrappy/wrappy.js"}],"../node_modules/inflight/inflight.js":[function(require,module,exports) {
var process = require("process");
var wrappy = require('wrappy')
var reqs = Object.create(null)
var once = require('once')

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}

},{"wrappy":"../node_modules/wrappy/wrappy.js","once":"../node_modules/once/once.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/glob/glob.js":[function(require,module,exports) {
var process = require("process");
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = require('fs')
var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var inherits = require('inherits')
var EE = require('events').EventEmitter
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var globSync = require('./sync.js')
var common = require('./common.js')
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = require('inflight')
var util = require('util')
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = require('once')

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}

},{"fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","fs.realpath":"../node_modules/fs.realpath/index.js","minimatch":"../node_modules/minimatch/minimatch.js","inherits":"../node_modules/inherits/inherits_browser.js","events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","assert":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/assert.js","path-is-absolute":"../node_modules/path-is-absolute/index.js","./sync.js":"../node_modules/glob/sync.js","./common.js":"../node_modules/glob/common.js","inflight":"../node_modules/inflight/inflight.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","once":"../node_modules/once/once.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/rimraf/rimraf.js":[function(require,module,exports) {
var process = require("process");
module.exports = rimraf
rimraf.sync = rimrafSync

var assert = require("assert")
var path = require("path")
var fs = require("fs")
var glob = undefined
try {
  glob = require("glob")
} catch (_err) {
  // treat glob as optional.
}
var _0666 = parseInt('666', 8)

var defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  if (options.disableGlob !== true && glob === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, _0666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, _0666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  var retries = isWindows ? 100 : 1
  var i = 0
  do {
    var threw = true
    try {
      var ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}

},{"assert":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/assert/assert.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","glob":"../node_modules/glob/glob.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/node-pre-gyp/lib/util/napi.js":[function(require,module,exports) {
var process = require("process");
"use strict";

var fs = require('fs');
var rm = require('rimraf');
var log = require('npmlog');

module.exports = exports;

var versionArray = process.version
	.substr(1)
	.replace(/-.*$/, '')
	.split('.')
	.map(function(item) {
		return +item;
	});

var napi_multiple_commands = [
	'build',
	'clean',
	'configure',
	'package',
	'publish',
	'reveal',
	'testbinary',
	'testpackage',
	'unpublish'
];

var napi_build_version_tag = 'napi_build_version=';

module.exports.get_napi_version = function(target) { // target may be undefined
	// returns the non-zero numeric napi version or undefined if napi is not supported.
	// correctly supporting target requires an updated cross-walk
	var version = process.versions.napi; // can be undefined
	if (!version) { // this code should never need to be updated
		if (versionArray[0] === 9 && versionArray[1] >= 3) version = 2; // 9.3.0+
		else if (versionArray[0] === 8) version = 1; // 8.0.0+
	}
	return version;
};

module.exports.get_napi_version_as_string = function(target) {
	// returns the napi version as a string or an empty string if napi is not supported.
	var version = module.exports.get_napi_version(target);
	return version ? ''+version : '';
};

module.exports.validate_package_json = function(package_json, opts) { // throws Error

	var binary = package_json.binary;
	var module_path_ok = pathOK(binary.module_path);
	var remote_path_ok = pathOK(binary.remote_path);
	var package_name_ok = pathOK(binary.package_name);
	var napi_build_versions = module.exports.get_napi_build_versions(package_json,opts,true);
	var napi_build_versions_raw = module.exports.get_napi_build_versions_raw(package_json);

	if (napi_build_versions) {
		napi_build_versions.forEach(function(napi_build_version){
			if (!(parseInt(napi_build_version,10) === napi_build_version && napi_build_version > 0)) {
				throw new Error("All values specified in napi_versions must be positive integers.");
			}
		});
	}

	if (napi_build_versions && (!module_path_ok || (!remote_path_ok && !package_name_ok))) {
		throw new Error("When napi_versions is specified; module_path and either remote_path or " +
			"package_name must contain the substitution string '{napi_build_version}`.");
	}

	if ((module_path_ok || remote_path_ok || package_name_ok) && !napi_build_versions_raw) {
		throw new Error("When the substitution string '{napi_build_version}` is specified in " +
			"module_path, remote_path, or package_name; napi_versions must also be specified.");
	}

	if (napi_build_versions && !module.exports.get_best_napi_build_version(package_json, opts) && 
	module.exports.build_napi_only(package_json)) {
		throw new Error(
			'The N-API version of this Node instance is ' + module.exports.get_napi_version(opts ? opts.target : undefined) + '. ' +
			'This module supports N-API version(s) ' + module.exports.get_napi_build_versions_raw(package_json) + '. ' +
			'This Node instance cannot run this module.');
	}

	if (napi_build_versions_raw && !napi_build_versions && module.exports.build_napi_only(package_json)) {
		throw new Error(
			'The N-API version of this Node instance is ' + module.exports.get_napi_version(opts ? opts.target : undefined) + '. ' +
			'This module supports N-API version(s) ' + module.exports.get_napi_build_versions_raw(package_json) + '. ' +
			'This Node instance cannot run this module.');
	}

};

function pathOK (path) {
	return path && (path.indexOf('{napi_build_version}') !== -1 || path.indexOf('{node_napi_label}') !== -1);
}

module.exports.expand_commands = function(package_json, opts, commands) {
	var expanded_commands = [];
	var napi_build_versions = module.exports.get_napi_build_versions(package_json, opts);
	commands.forEach(function(command){
		if (napi_build_versions && command.name === 'install') {
			var napi_build_version = module.exports.get_best_napi_build_version(package_json, opts);
			var args = napi_build_version ? [ napi_build_version_tag+napi_build_version ] : [ ];
			expanded_commands.push ({ name: command.name, args: args });
		} else if (napi_build_versions && napi_multiple_commands.indexOf(command.name) !== -1) {
			napi_build_versions.forEach(function(napi_build_version){
				var args = command.args.slice();
				args.push (napi_build_version_tag+napi_build_version);
				expanded_commands.push ({ name: command.name, args: args });
			});
		} else {
			expanded_commands.push (command);
		}
	});
	return expanded_commands;
};

module.exports.get_napi_build_versions = function(package_json, opts, warnings) { // opts may be undefined
	var napi_build_versions = [];
	var supported_napi_version = module.exports.get_napi_version(opts ? opts.target : undefined);
	// remove duplicates, verify each napi version can actaully be built
	if (package_json.binary && package_json.binary.napi_versions) {
		package_json.binary.napi_versions.forEach(function(napi_version) {
			var duplicated = napi_build_versions.indexOf(napi_version) !== -1;
			if (!duplicated && supported_napi_version && napi_version <= supported_napi_version) {
				napi_build_versions.push(napi_version);
			} else if (warnings && !duplicated && supported_napi_version) {
				log.info('This Node instance does not support builds for N-API version', napi_version);
			}
		});
	}
	if (opts && opts["build-latest-napi-version-only"]) {
		var latest_version = 0;
		napi_build_versions.forEach(function(napi_version) {
			if (napi_version > latest_version) latest_version = napi_version;
		});
		napi_build_versions = latest_version ? [ latest_version ] : [];
	}
	return napi_build_versions.length ? napi_build_versions : undefined;
};

module.exports.get_napi_build_versions_raw = function(package_json) {
	var napi_build_versions = [];
	// remove duplicates
	if (package_json.binary && package_json.binary.napi_versions) {
		package_json.binary.napi_versions.forEach(function(napi_version) {
			if (napi_build_versions.indexOf(napi_version) === -1) {
				napi_build_versions.push(napi_version);
			}
		});
	}
	return napi_build_versions.length ? napi_build_versions : undefined;
};

module.exports.get_command_arg = function(napi_build_version) {
	return napi_build_version_tag + napi_build_version;
};

module.exports.get_napi_build_version_from_command_args = function(command_args) {
	for (var i = 0; i < command_args.length; i++) {
		var arg = command_args[i];
		if (arg.indexOf(napi_build_version_tag) === 0) {
			return parseInt(arg.substr(napi_build_version_tag.length),10);
		}
	}
	return undefined;
};

module.exports.swap_build_dir_out = function(napi_build_version) {
	if (napi_build_version) {
		rm.sync(module.exports.get_build_dir(napi_build_version));
		fs.renameSync('build', module.exports.get_build_dir(napi_build_version));
	}
};

module.exports.swap_build_dir_in = function(napi_build_version) {
	if (napi_build_version) {
		rm.sync('build');
		fs.renameSync(module.exports.get_build_dir(napi_build_version), 'build');
	}
};

module.exports.get_build_dir = function(napi_build_version) {
	return 'build-tmp-napi-v'+napi_build_version;
};

module.exports.get_best_napi_build_version = function(package_json, opts) {
	var best_napi_build_version = 0;
	var napi_build_versions = module.exports.get_napi_build_versions (package_json, opts);
	if (napi_build_versions) {
		var our_napi_version = module.exports.get_napi_version(opts ? opts.target : undefined);
		napi_build_versions.forEach(function(napi_build_version){
			if (napi_build_version > best_napi_build_version &&
				napi_build_version <= our_napi_version) {
				best_napi_build_version = napi_build_version;
			}
		});
	}
	return best_napi_build_version === 0 ? undefined : best_napi_build_version;
};

module.exports.build_napi_only = function(package_json) {
	return package_json.binary && package_json.binary.package_name && 
	package_json.binary.package_name.indexOf('{node_napi_label}') === -1;
};
},{"fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","rimraf":"../node_modules/rimraf/rimraf.js","npmlog":"../node_modules/npmlog/log.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/semver/semver.js":[function(require,module,exports) {
var process = require("process");
exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if (typeof process === 'object' && process.env && undefined && /\bsemver\b/i.test(undefined)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function () {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var R = 0; // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
src[FULL] = '^' + FULLPLAIN + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';
var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])'; // Tilde ranges.
// Meaning is "reasonably at or greater than"

var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';
var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

var LONECARET = R++;
src[LONECARET] = '(?:\\^)';
var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';
var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[LOOSE] : re[FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a === b;

    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1];

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[STAR], '');
} // This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  var match = version.match(re[COERCE]);

  if (match == null) {
    return null;
  }

  return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
}
},{"process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/detect-libc/lib/detect-libc.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var platform = require('os').platform();

var spawnSync = require('child_process').spawnSync;

var readdirSync = require('fs').readdirSync;

var GLIBC = 'glibc';
var MUSL = 'musl';
var spawnOptions = {
  encoding: 'utf8',
  env: process.env
};

if (!spawnSync) {
  spawnSync = function () {
    return {
      status: 126,
      stdout: '',
      stderr: ''
    };
  };
}

function contains(needle) {
  return function (haystack) {
    return haystack.indexOf(needle) !== -1;
  };
}

function versionFromMuslLdd(out) {
  return out.split(/[\r\n]+/)[1].trim().split(/\s/)[1];
}

function safeReaddirSync(path) {
  try {
    return readdirSync(path);
  } catch (e) {}

  return [];
}

var family = '';
var version = '';
var method = '';

if (platform === 'linux') {
  // Try getconf
  var glibc = spawnSync('getconf', ['GNU_LIBC_VERSION'], spawnOptions);

  if (glibc.status === 0) {
    family = GLIBC;
    version = glibc.stdout.trim().split(' ')[1];
    method = 'getconf';
  } else {
    // Try ldd
    var ldd = spawnSync('ldd', ['--version'], spawnOptions);

    if (ldd.status === 0 && ldd.stdout.indexOf(MUSL) !== -1) {
      family = MUSL;
      version = versionFromMuslLdd(ldd.stdout);
      method = 'ldd';
    } else if (ldd.status === 1 && ldd.stderr.indexOf(MUSL) !== -1) {
      family = MUSL;
      version = versionFromMuslLdd(ldd.stderr);
      method = 'ldd';
    } else {
      // Try filesystem (family only)
      var lib = safeReaddirSync('/lib');

      if (lib.some(contains('-linux-gnu'))) {
        family = GLIBC;
        method = 'filesystem';
      } else if (lib.some(contains('libc.musl-'))) {
        family = MUSL;
        method = 'filesystem';
      } else if (lib.some(contains('ld-musl-'))) {
        family = MUSL;
        method = 'filesystem';
      } else {
        var usrSbin = safeReaddirSync('/usr/sbin');

        if (usrSbin.some(contains('glibc'))) {
          family = GLIBC;
          method = 'filesystem';
        }
      }
    }
  }
}

var isNonGlibcLinux = family !== '' && family !== GLIBC;
module.exports = {
  GLIBC: GLIBC,
  MUSL: MUSL,
  family: family,
  version: version,
  method: method,
  isNonGlibcLinux: isNonGlibcLinux
};
},{"os":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js","child_process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/node-pre-gyp/lib/util/abi_crosswalk.json":[function(require,module,exports) {
module.exports = {
  "0.1.14": {
    "node_abi": null,
    "v8": "1.3"
  },
  "0.1.15": {
    "node_abi": null,
    "v8": "1.3"
  },
  "0.1.16": {
    "node_abi": null,
    "v8": "1.3"
  },
  "0.1.17": {
    "node_abi": null,
    "v8": "1.3"
  },
  "0.1.18": {
    "node_abi": null,
    "v8": "1.3"
  },
  "0.1.19": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.20": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.21": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.22": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.23": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.24": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.25": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.26": {
    "node_abi": null,
    "v8": "2.0"
  },
  "0.1.27": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.28": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.29": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.30": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.31": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.32": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.33": {
    "node_abi": null,
    "v8": "2.1"
  },
  "0.1.90": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.91": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.92": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.93": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.94": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.95": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.96": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.97": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.98": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.99": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.100": {
    "node_abi": null,
    "v8": "2.2"
  },
  "0.1.101": {
    "node_abi": null,
    "v8": "2.3"
  },
  "0.1.102": {
    "node_abi": null,
    "v8": "2.3"
  },
  "0.1.103": {
    "node_abi": null,
    "v8": "2.3"
  },
  "0.1.104": {
    "node_abi": null,
    "v8": "2.3"
  },
  "0.2.0": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.2.1": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.2.2": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.2.3": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.2.4": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.2.5": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.2.6": {
    "node_abi": 1,
    "v8": "2.3"
  },
  "0.3.0": {
    "node_abi": 1,
    "v8": "2.5"
  },
  "0.3.1": {
    "node_abi": 1,
    "v8": "2.5"
  },
  "0.3.2": {
    "node_abi": 1,
    "v8": "3.0"
  },
  "0.3.3": {
    "node_abi": 1,
    "v8": "3.0"
  },
  "0.3.4": {
    "node_abi": 1,
    "v8": "3.0"
  },
  "0.3.5": {
    "node_abi": 1,
    "v8": "3.0"
  },
  "0.3.6": {
    "node_abi": 1,
    "v8": "3.0"
  },
  "0.3.7": {
    "node_abi": 1,
    "v8": "3.0"
  },
  "0.3.8": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.0": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.1": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.2": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.3": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.4": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.5": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.6": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.7": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.8": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.9": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.10": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.11": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.4.12": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.5.0": {
    "node_abi": 1,
    "v8": "3.1"
  },
  "0.5.1": {
    "node_abi": 1,
    "v8": "3.4"
  },
  "0.5.2": {
    "node_abi": 1,
    "v8": "3.4"
  },
  "0.5.3": {
    "node_abi": 1,
    "v8": "3.4"
  },
  "0.5.4": {
    "node_abi": 1,
    "v8": "3.5"
  },
  "0.5.5": {
    "node_abi": 1,
    "v8": "3.5"
  },
  "0.5.6": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.5.7": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.5.8": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.5.9": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.5.10": {
    "node_abi": 1,
    "v8": "3.7"
  },
  "0.6.0": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.1": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.2": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.3": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.4": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.5": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.6": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.7": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.8": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.9": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.10": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.11": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.12": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.13": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.14": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.15": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.16": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.17": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.18": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.19": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.20": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.6.21": {
    "node_abi": 1,
    "v8": "3.6"
  },
  "0.7.0": {
    "node_abi": 1,
    "v8": "3.8"
  },
  "0.7.1": {
    "node_abi": 1,
    "v8": "3.8"
  },
  "0.7.2": {
    "node_abi": 1,
    "v8": "3.8"
  },
  "0.7.3": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.4": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.5": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.6": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.7": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.8": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.9": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.7.10": {
    "node_abi": 1,
    "v8": "3.9"
  },
  "0.7.11": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.7.12": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.0": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.1": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.2": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.3": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.4": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.5": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.6": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.7": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.8": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.9": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.10": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.11": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.12": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.13": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.14": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.15": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.16": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.17": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.18": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.19": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.20": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.21": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.22": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.23": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.24": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.25": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.26": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.27": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.8.28": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.9.0": {
    "node_abi": 1,
    "v8": "3.11"
  },
  "0.9.1": {
    "node_abi": 10,
    "v8": "3.11"
  },
  "0.9.2": {
    "node_abi": 10,
    "v8": "3.11"
  },
  "0.9.3": {
    "node_abi": 10,
    "v8": "3.13"
  },
  "0.9.4": {
    "node_abi": 10,
    "v8": "3.13"
  },
  "0.9.5": {
    "node_abi": 10,
    "v8": "3.13"
  },
  "0.9.6": {
    "node_abi": 10,
    "v8": "3.15"
  },
  "0.9.7": {
    "node_abi": 10,
    "v8": "3.15"
  },
  "0.9.8": {
    "node_abi": 10,
    "v8": "3.15"
  },
  "0.9.9": {
    "node_abi": 11,
    "v8": "3.15"
  },
  "0.9.10": {
    "node_abi": 11,
    "v8": "3.15"
  },
  "0.9.11": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.9.12": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.0": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.1": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.2": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.3": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.4": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.5": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.6": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.7": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.8": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.9": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.10": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.11": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.12": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.13": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.14": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.15": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.16": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.17": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.18": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.19": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.20": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.21": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.22": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.23": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.24": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.25": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.26": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.27": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.28": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.29": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.30": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.31": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.32": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.33": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.34": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.35": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.36": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.37": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.38": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.39": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.40": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.41": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.42": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.43": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.44": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.45": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.46": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.47": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.10.48": {
    "node_abi": 11,
    "v8": "3.14"
  },
  "0.11.0": {
    "node_abi": 12,
    "v8": "3.17"
  },
  "0.11.1": {
    "node_abi": 12,
    "v8": "3.18"
  },
  "0.11.2": {
    "node_abi": 12,
    "v8": "3.19"
  },
  "0.11.3": {
    "node_abi": 12,
    "v8": "3.19"
  },
  "0.11.4": {
    "node_abi": 12,
    "v8": "3.20"
  },
  "0.11.5": {
    "node_abi": 12,
    "v8": "3.20"
  },
  "0.11.6": {
    "node_abi": 12,
    "v8": "3.20"
  },
  "0.11.7": {
    "node_abi": 12,
    "v8": "3.20"
  },
  "0.11.8": {
    "node_abi": 13,
    "v8": "3.21"
  },
  "0.11.9": {
    "node_abi": 13,
    "v8": "3.22"
  },
  "0.11.10": {
    "node_abi": 13,
    "v8": "3.22"
  },
  "0.11.11": {
    "node_abi": 14,
    "v8": "3.22"
  },
  "0.11.12": {
    "node_abi": 14,
    "v8": "3.22"
  },
  "0.11.13": {
    "node_abi": 14,
    "v8": "3.25"
  },
  "0.11.14": {
    "node_abi": 14,
    "v8": "3.26"
  },
  "0.11.15": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.11.16": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.0": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.1": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.2": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.3": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.4": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.5": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.6": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.7": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.8": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.9": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.10": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.11": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.12": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.13": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.14": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.15": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.16": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.17": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "0.12.18": {
    "node_abi": 14,
    "v8": "3.28"
  },
  "1.0.0": {
    "node_abi": 42,
    "v8": "3.31"
  },
  "1.0.1": {
    "node_abi": 42,
    "v8": "3.31"
  },
  "1.0.2": {
    "node_abi": 42,
    "v8": "3.31"
  },
  "1.0.3": {
    "node_abi": 42,
    "v8": "4.1"
  },
  "1.0.4": {
    "node_abi": 42,
    "v8": "4.1"
  },
  "1.1.0": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.2.0": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.3.0": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.4.1": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.4.2": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.4.3": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.5.0": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.5.1": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.6.0": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.6.1": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.6.2": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.6.3": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.6.4": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.7.1": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.8.1": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.8.2": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.8.3": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "1.8.4": {
    "node_abi": 43,
    "v8": "4.1"
  },
  "2.0.0": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.0.1": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.0.2": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.1.0": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.2.0": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.2.1": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.3.0": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.3.1": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.3.2": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.3.3": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.3.4": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.4.0": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "2.5.0": {
    "node_abi": 44,
    "v8": "4.2"
  },
  "3.0.0": {
    "node_abi": 45,
    "v8": "4.4"
  },
  "3.1.0": {
    "node_abi": 45,
    "v8": "4.4"
  },
  "3.2.0": {
    "node_abi": 45,
    "v8": "4.4"
  },
  "3.3.0": {
    "node_abi": 45,
    "v8": "4.4"
  },
  "3.3.1": {
    "node_abi": 45,
    "v8": "4.4"
  },
  "4.0.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.1.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.1.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.1.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.3": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.4": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.5": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.2.6": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.3.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.3.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.3.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.3": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.4": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.5": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.6": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.4.7": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.5.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.6.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.6.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.6.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.7.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.7.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.7.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.7.3": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.2": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.3": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.4": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.5": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.6": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.8.7": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.9.0": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "4.9.1": {
    "node_abi": 46,
    "v8": "4.5"
  },
  "5.0.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.1.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.1.1": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.2.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.3.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.4.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.4.1": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.5.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.6.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.7.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.7.1": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.8.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.9.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.9.1": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.10.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.10.1": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.11.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.11.1": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "5.12.0": {
    "node_abi": 47,
    "v8": "4.6"
  },
  "6.0.0": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.1.0": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.2.0": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.2.1": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.2.2": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.3.0": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.3.1": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.4.0": {
    "node_abi": 48,
    "v8": "5.0"
  },
  "6.5.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.6.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.7.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.8.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.8.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.9.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.9.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.9.2": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.9.3": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.9.4": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.9.5": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.10.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.10.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.10.2": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.10.3": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.11.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.11.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.11.2": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.11.3": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.11.4": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.11.5": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.12.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.12.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.12.2": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.12.3": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.13.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.13.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.14.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.14.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.14.2": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.14.3": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.14.4": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.15.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.15.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.16.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.17.0": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "6.17.1": {
    "node_abi": 48,
    "v8": "5.1"
  },
  "7.0.0": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.1.0": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.2.0": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.2.1": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.3.0": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.4.0": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.5.0": {
    "node_abi": 51,
    "v8": "5.4"
  },
  "7.6.0": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.7.0": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.7.1": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.7.2": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.7.3": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.7.4": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.8.0": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.9.0": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.10.0": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "7.10.1": {
    "node_abi": 51,
    "v8": "5.5"
  },
  "8.0.0": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.1.0": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.1.1": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.1.2": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.1.3": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.1.4": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.2.0": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.2.1": {
    "node_abi": 57,
    "v8": "5.8"
  },
  "8.3.0": {
    "node_abi": 57,
    "v8": "6.0"
  },
  "8.4.0": {
    "node_abi": 57,
    "v8": "6.0"
  },
  "8.5.0": {
    "node_abi": 57,
    "v8": "6.0"
  },
  "8.6.0": {
    "node_abi": 57,
    "v8": "6.0"
  },
  "8.7.0": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.8.0": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.8.1": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.9.0": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.9.1": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.9.2": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.9.3": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.9.4": {
    "node_abi": 57,
    "v8": "6.1"
  },
  "8.10.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.11.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.11.1": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.11.2": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.11.3": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.11.4": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.12.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.13.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.14.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.14.1": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.15.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.15.1": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "8.16.0": {
    "node_abi": 57,
    "v8": "6.2"
  },
  "9.0.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.1.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.2.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.2.1": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.3.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.4.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.5.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.6.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.6.1": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.7.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.7.1": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.8.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.9.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.10.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.10.1": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.11.0": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.11.1": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "9.11.2": {
    "node_abi": 59,
    "v8": "6.2"
  },
  "10.0.0": {
    "node_abi": 64,
    "v8": "6.6"
  },
  "10.1.0": {
    "node_abi": 64,
    "v8": "6.6"
  },
  "10.2.0": {
    "node_abi": 64,
    "v8": "6.6"
  },
  "10.2.1": {
    "node_abi": 64,
    "v8": "6.6"
  },
  "10.3.0": {
    "node_abi": 64,
    "v8": "6.6"
  },
  "10.4.0": {
    "node_abi": 64,
    "v8": "6.7"
  },
  "10.4.1": {
    "node_abi": 64,
    "v8": "6.7"
  },
  "10.5.0": {
    "node_abi": 64,
    "v8": "6.7"
  },
  "10.6.0": {
    "node_abi": 64,
    "v8": "6.7"
  },
  "10.7.0": {
    "node_abi": 64,
    "v8": "6.7"
  },
  "10.8.0": {
    "node_abi": 64,
    "v8": "6.7"
  },
  "10.9.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.10.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.11.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.12.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.13.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.14.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.14.1": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.14.2": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.15.0": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.15.1": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.15.2": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "10.15.3": {
    "node_abi": 64,
    "v8": "6.8"
  },
  "11.0.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.1.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.2.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.3.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.4.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.5.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.6.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.7.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.8.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.9.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.10.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.10.1": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.11.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.12.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.13.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "11.14.0": {
    "node_abi": 67,
    "v8": "7.0"
  },
  "12.0.0": {
    "node_abi": 72,
    "v8": "7.4"
  }
};
},{}],"../node_modules/node-pre-gyp/lib/util/versioning.js":[function(require,module,exports) {
var process = require("process");
"use strict";

module.exports = exports;

var path = require('path');

var semver = require('semver');

var url = require('url');

var detect_libc = require('detect-libc');

var napi = require('./napi.js');

var abi_crosswalk; // This is used for unit testing to provide a fake
// ABI crosswalk that emulates one that is not updated
// for the current version

if (undefined) {
  abi_crosswalk = require(undefined);
} else {
  abi_crosswalk = require('./abi_crosswalk.json');
}

var major_versions = {};
Object.keys(abi_crosswalk).forEach(function (v) {
  var major = v.split('.')[0];

  if (!major_versions[major]) {
    major_versions[major] = v;
  }
});

function get_electron_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error("get_electron_abi requires valid runtime arg");
  }

  if (typeof target_version === 'undefined') {
    // erroneous CLI call
    throw new Error("Empty target version is not supported if electron is the target.");
  } // Electron guarantees that patch version update won't break native modules.


  var sem_ver = semver.parse(target_version);
  return runtime + '-v' + sem_ver.major + '.' + sem_ver.minor;
}

module.exports.get_electron_abi = get_electron_abi;

function get_node_webkit_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error("get_node_webkit_abi requires valid runtime arg");
  }

  if (typeof target_version === 'undefined') {
    // erroneous CLI call
    throw new Error("Empty target version is not supported if node-webkit is the target.");
  }

  return runtime + '-v' + target_version;
}

module.exports.get_node_webkit_abi = get_node_webkit_abi;

function get_node_abi(runtime, versions) {
  if (!runtime) {
    throw new Error("get_node_abi requires valid runtime arg");
  }

  if (!versions) {
    throw new Error("get_node_abi requires valid process.versions object");
  }

  var sem_ver = semver.parse(versions.node);

  if (sem_ver.major === 0 && sem_ver.minor % 2) {
    // odd series
    // https://github.com/mapbox/node-pre-gyp/issues/124
    return runtime + '-v' + versions.node;
  } else {
    // process.versions.modules added in >= v0.10.4 and v0.11.7
    // https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e
    return versions.modules ? runtime + '-v' + +versions.modules : 'v8-' + versions.v8.split('.').slice(0, 2).join('.');
  }
}

module.exports.get_node_abi = get_node_abi;

function get_runtime_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error("get_runtime_abi requires valid runtime arg");
  }

  if (runtime === 'node-webkit') {
    return get_node_webkit_abi(runtime, target_version || process.versions['node-webkit']);
  } else if (runtime === 'electron') {
    return get_electron_abi(runtime, target_version || process.versions.electron);
  } else {
    if (runtime != 'node') {
      throw new Error("Unknown Runtime: '" + runtime + "'");
    }

    if (!target_version) {
      return get_node_abi(runtime, process.versions);
    } else {
      var cross_obj; // abi_crosswalk generated with ./scripts/abi_crosswalk.js

      if (abi_crosswalk[target_version]) {
        cross_obj = abi_crosswalk[target_version];
      } else {
        var target_parts = target_version.split('.').map(function (i) {
          return +i;
        });

        if (target_parts.length != 3) {
          // parse failed
          throw new Error("Unknown target version: " + target_version);
        }
        /*
            The below code tries to infer the last known ABI compatible version
            that we have recorded in the abi_crosswalk.json when an exact match
            is not possible. The reasons for this to exist are complicated:
                - We support passing --target to be able to allow developers to package binaries for versions of node
                 that are not the same one as they are running. This might also be used in combination with the
                 --target_arch or --target_platform flags to also package binaries for alternative platforms
               - When --target is passed we can't therefore determine the ABI (process.versions.modules) from the node
                 version that is running in memory
               - So, therefore node-pre-gyp keeps an "ABI crosswalk" (lib/util/abi_crosswalk.json) to be able to look
                 this info up for all versions
               - But we cannot easily predict what the future ABI will be for released versions
               - And node-pre-gyp needs to be a `bundledDependency` in apps that depend on it in order to work correctly
                 by being fully available at install time.
               - So, the speed of node releases and the bundled nature of node-pre-gyp mean that a new node-pre-gyp release
                 need to happen for every node.js/io.js/node-webkit/nw.js/atom-shell/etc release that might come online if
                 you want the `--target` flag to keep working for the latest version
               - Which is impractical ^^
               - Hence the below code guesses about future ABI to make the need to update node-pre-gyp less demanding.
             In practice then you can have a dependency of your app like `node-sqlite3` that bundles a `node-pre-gyp` that
            only knows about node v0.10.33 in the `abi_crosswalk.json` but target node v0.10.34 (which is assumed to be
            ABI compatible with v0.10.33).
             TODO: use semver module instead of custom version parsing
        */


        var major = target_parts[0];
        var minor = target_parts[1];
        var patch = target_parts[2]; // io.js: yeah if node.js ever releases 1.x this will break
        // but that is unlikely to happen: https://github.com/iojs/io.js/pull/253#issuecomment-69432616

        if (major === 1) {
          // look for last release that is the same major version
          // e.g. we assume io.js 1.x is ABI compatible with >= 1.0.0
          while (true) {
            if (minor > 0) --minor;
            if (patch > 0) --patch;
            var new_iojs_target = '' + major + '.' + minor + '.' + patch;

            if (abi_crosswalk[new_iojs_target]) {
              cross_obj = abi_crosswalk[new_iojs_target];
              console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
              console.log('Warning: but node-pre-gyp successfully choose ' + new_iojs_target + ' as ABI compatible target');
              break;
            }

            if (minor === 0 && patch === 0) {
              break;
            }
          }
        } else if (major >= 2) {
          // look for last release that is the same major version
          if (major_versions[major]) {
            cross_obj = abi_crosswalk[major_versions[major]];
            console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
            console.log('Warning: but node-pre-gyp successfully choose ' + major_versions[major] + ' as ABI compatible target');
          }
        } else if (major === 0) {
          // node.js
          if (target_parts[1] % 2 === 0) {
            // for stable/even node.js series
            // look for the last release that is the same minor release
            // e.g. we assume node 0.10.x is ABI compatible with >= 0.10.0
            while (--patch > 0) {
              var new_node_target = '' + major + '.' + minor + '.' + patch;

              if (abi_crosswalk[new_node_target]) {
                cross_obj = abi_crosswalk[new_node_target];
                console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
                console.log('Warning: but node-pre-gyp successfully choose ' + new_node_target + ' as ABI compatible target');
                break;
              }
            }
          }
        }
      }

      if (!cross_obj) {
        throw new Error("Unsupported target version: " + target_version);
      } // emulate process.versions


      var versions_obj = {
        node: target_version,
        v8: cross_obj.v8 + '.0',
        // abi_crosswalk uses 1 for node versions lacking process.versions.modules
        // process.versions.modules added in >= v0.10.4 and v0.11.7
        modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : undefined
      };
      return get_node_abi(runtime, versions_obj);
    }
  }
}

module.exports.get_runtime_abi = get_runtime_abi;
var required_parameters = ['module_name', 'module_path', 'host'];

function validate_config(package_json, opts) {
  var msg = package_json.name + ' package.json is not node-pre-gyp ready:\n';
  var missing = [];

  if (!package_json.main) {
    missing.push('main');
  }

  if (!package_json.version) {
    missing.push('version');
  }

  if (!package_json.name) {
    missing.push('name');
  }

  if (!package_json.binary) {
    missing.push('binary');
  }

  var o = package_json.binary;
  required_parameters.forEach(function (p) {
    if (missing.indexOf('binary') > -1) {
      missing.pop('binary');
    }

    if (!o || o[p] === undefined || o[p] === "") {
      missing.push('binary.' + p);
    }
  });

  if (missing.length >= 1) {
    throw new Error(msg + "package.json must declare these properties: \n" + missing.join('\n'));
  }

  if (o) {
    // enforce https over http
    var protocol = url.parse(o.host).protocol;

    if (protocol === 'http:') {
      throw new Error("'host' protocol (" + protocol + ") is invalid - only 'https:' is accepted");
    }
  }

  napi.validate_package_json(package_json, opts);
}

module.exports.validate_config = validate_config;

function eval_template(template, opts) {
  Object.keys(opts).forEach(function (key) {
    var pattern = '{' + key + '}';

    while (template.indexOf(pattern) > -1) {
      template = template.replace(pattern, opts[key]);
    }
  });
  return template;
} // url.resolve needs single trailing slash
// to behave correctly, otherwise a double slash
// may end up in the url which breaks requests
// and a lacking slash may not lead to proper joining


function fix_slashes(pathname) {
  if (pathname.slice(-1) != '/') {
    return pathname + '/';
  }

  return pathname;
} // remove double slashes
// note: path.normalize will not work because
// it will convert forward to back slashes


function drop_double_slashes(pathname) {
  return pathname.replace(/\/\//g, '/');
}

function get_process_runtime(versions) {
  var runtime = 'node';

  if (versions['node-webkit']) {
    runtime = 'node-webkit';
  } else if (versions.electron) {
    runtime = 'electron';
  }

  return runtime;
}

module.exports.get_process_runtime = get_process_runtime;
var default_package_name = '{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz';
var default_remote_path = '';

module.exports.evaluate = function (package_json, options, napi_build_version) {
  options = options || {};
  validate_config(package_json, options); // options is a suitable substitute for opts in this case

  var v = package_json.version;
  var module_version = semver.parse(v);
  var runtime = options.runtime || get_process_runtime(process.versions);
  var opts = {
    name: package_json.name,
    configuration: Boolean(options.debug) ? 'Debug' : 'Release',
    debug: options.debug,
    module_name: package_json.binary.module_name,
    version: module_version.version,
    prerelease: module_version.prerelease.length ? module_version.prerelease.join('.') : '',
    build: module_version.build.length ? module_version.build.join('.') : '',
    major: module_version.major,
    minor: module_version.minor,
    patch: module_version.patch,
    runtime: runtime,
    node_abi: get_runtime_abi(runtime, options.target),
    node_abi_napi: napi.get_napi_version(options.target) ? 'napi' : get_runtime_abi(runtime, options.target),
    napi_version: napi.get_napi_version(options.target),
    // non-zero numeric, undefined if unsupported
    napi_build_version: napi_build_version || '',
    node_napi_label: napi_build_version ? 'napi-v' + napi_build_version : get_runtime_abi(runtime, options.target),
    target: options.target || '',
    platform: options.target_platform || process.platform,
    target_platform: options.target_platform || process.platform,
    arch: options.target_arch || process.arch,
    target_arch: options.target_arch || process.arch,
    libc: options.target_libc || detect_libc.family || 'unknown',
    module_main: package_json.main,
    toolset: options.toolset || '' // address https://github.com/mapbox/node-pre-gyp/issues/119

  }; // support host mirror with npm config `--{module_name}_binary_host_mirror`
  // e.g.: https://github.com/node-inspector/v8-profiler/blob/master/package.json#L25
  // > npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/

  var host = process.env['npm_config_' + opts.module_name + '_binary_host_mirror'] || package_json.binary.host;
  opts.host = fix_slashes(eval_template(host, opts));
  opts.module_path = eval_template(package_json.binary.module_path, opts); // now we resolve the module_path to ensure it is absolute so that binding.gyp variables work predictably

  if (options.module_root) {
    // resolve relative to known module root: works for pre-binding require
    opts.module_path = path.join(options.module_root, opts.module_path);
  } else {
    // resolve relative to current working directory: works for node-pre-gyp commands
    opts.module_path = path.resolve(opts.module_path);
  }

  opts.module = path.join(opts.module_path, opts.module_name + '.node');
  opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path, opts))) : default_remote_path;
  var package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;
  opts.package_name = eval_template(package_name, opts);
  opts.staged_tarball = path.join('build/stage', opts.remote_path, opts.package_name);
  opts.hosted_path = url.resolve(opts.host, opts.remote_path);
  opts.hosted_tarball = url.resolve(opts.hosted_path, opts.package_name);
  return opts;
};
},{"path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","semver":"../node_modules/semver/semver.js","url":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/url/url.js","detect-libc":"../node_modules/detect-libc/lib/detect-libc.js","./napi.js":"../node_modules/node-pre-gyp/lib/util/napi.js","./abi_crosswalk.json":"../node_modules/node-pre-gyp/lib/util/abi_crosswalk.json","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/node-pre-gyp/lib/pre-binding.js":[function(require,module,exports) {
"use strict";

var versioning = require('../lib/util/versioning.js');
var napi = require('../lib/util/napi.js');
var existsSync = require('fs').existsSync || require('path').existsSync;
var path = require('path');

module.exports = exports;

exports.usage = 'Finds the require path for the node-pre-gyp installed module';

exports.validate = function(package_json,opts) {
    versioning.validate_config(package_json,opts);
};

exports.find = function(package_json_path,opts) {
   if (!existsSync(package_json_path)) {
        throw new Error("package.json does not exist at " + package_json_path);
   }
   var package_json = require(package_json_path);
   versioning.validate_config(package_json,opts);
   var napi_build_version;
   if (napi.get_napi_build_versions (package_json, opts)) {
       napi_build_version = napi.get_best_napi_build_version(package_json, opts);
   }
   opts = opts || {};
   if (!opts.module_root) opts.module_root = path.dirname(package_json_path);
   var meta = versioning.evaluate(package_json,opts,napi_build_version);
   return meta.module;
};

},{"../lib/util/versioning.js":"../node_modules/node-pre-gyp/lib/util/versioning.js","../lib/util/napi.js":"../node_modules/node-pre-gyp/lib/util/napi.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js"}],"../node_modules/node-pre-gyp/package.json":[function(require,module,exports) {
module.exports = {
  "_from": "node-pre-gyp@0.13.0",
  "_id": "node-pre-gyp@0.13.0",
  "_inBundle": false,
  "_integrity": "sha512-Md1D3xnEne8b/HGVQkZZwV27WUi1ZRuZBij24TNaZwUPU3ZAFtvT6xxJGaUVillfmMKnn5oD1HoGsp2Ftik7SQ==",
  "_location": "/node-pre-gyp",
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "node-pre-gyp@0.13.0",
    "name": "node-pre-gyp",
    "escapedName": "node-pre-gyp",
    "rawSpec": "0.13.0",
    "saveSpec": null,
    "fetchSpec": "0.13.0"
  },
  "_requiredBy": [
    "/@tensorflow/tfjs-node"
  ],
  "_resolved": "https://registry.npmjs.org/node-pre-gyp/-/node-pre-gyp-0.13.0.tgz",
  "_shasum": "df9ab7b68dd6498137717838e4f92a33fc9daa42",
  "_spec": "node-pre-gyp@0.13.0",
  "_where": "/Users/jsmney/Programming/FSA-immersive/seniorphase/capstone/brain-dancer/node_modules/@tensorflow/tfjs-node",
  "author": {
    "name": "Dane Springmeyer",
    "email": "dane@mapbox.com"
  },
  "bin": {
    "node-pre-gyp": "./bin/node-pre-gyp"
  },
  "bugs": {
    "url": "https://github.com/mapbox/node-pre-gyp/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "detect-libc": "^1.0.2",
    "mkdirp": "^0.5.1",
    "needle": "^2.2.1",
    "nopt": "^4.0.1",
    "npm-packlist": "^1.1.6",
    "npmlog": "^4.0.2",
    "rc": "^1.2.7",
    "rimraf": "^2.6.1",
    "semver": "^5.3.0",
    "tar": "^4"
  },
  "deprecated": false,
  "description": "Node.js native addon binary install tool",
  "devDependencies": {
    "aws-sdk": "^2.28.0",
    "jshint": "^2.9.5",
    "nock": "^9.2.3",
    "tape": "^4.6.3"
  },
  "homepage": "https://github.com/mapbox/node-pre-gyp#readme",
  "jshintConfig": {
    "node": true,
    "globalstrict": true,
    "undef": true,
    "unused": false,
    "noarg": true
  },
  "keywords": [
    "native",
    "addon",
    "module",
    "c",
    "c++",
    "bindings",
    "binary"
  ],
  "license": "BSD-3-Clause",
  "main": "./lib/node-pre-gyp.js",
  "name": "node-pre-gyp",
  "repository": {
    "type": "git",
    "url": "git://github.com/mapbox/node-pre-gyp.git"
  },
  "scripts": {
    "pretest": "jshint test/build.test.js test/s3_setup.test.js test/versioning.test.js test/fetch.test.js lib lib/util scripts bin/node-pre-gyp",
    "test": "jshint lib lib/util scripts bin/node-pre-gyp && tape test/*test.js",
    "update-crosswalk": "node scripts/abi_crosswalk.js"
  },
  "version": "0.13.0"
}
;
},{}],"../node_modules/node-pre-gyp/lib/node-pre-gyp.js":[function(require,module,exports) {
var process = require("process");
var __dirname = "/Users/jsmney/Programming/FSA-immersive/seniorphase/capstone/brain-dancer/node_modules/node-pre-gyp/lib";
"use strict";

/**
 * Module exports.
 */

module.exports = exports;

/**
 * Module dependencies.
 */

var fs = require('fs');
var path = require('path');
var nopt = require('nopt');
var log = require('npmlog');
log.disableProgress();
var napi = require('./util/napi.js');

var EE = require('events').EventEmitter;
var inherits = require('util').inherits;
var commands = [
      'clean',
      'install',
      'reinstall',
      'build',
      'rebuild',
      'package',
      'testpackage',
      'publish',
      'unpublish',
      'info',
      'testbinary',
      'reveal',
      'configure'
    ];
var aliases = {};

// differentiate node-pre-gyp's logs from npm's
log.heading = 'node-pre-gyp';

exports.find = require('./pre-binding').find;

function Run() {
  var self = this;

  this.commands = {};

  commands.forEach(function (command) {
    self.commands[command] = function (argv, callback) {
      log.verbose('command', command, argv);
      return require('./' + command)(self, argv, callback);
    };
  });
}
inherits(Run, EE);
exports.Run = Run;
var proto = Run.prototype;

/**
 * Export the contents of the package.json.
 */

proto.package = require('../package.json');

/**
 * nopt configuration definitions
 */

proto.configDefs = {
    help: Boolean,     // everywhere
    arch: String,      // 'configure'
    debug: Boolean,    // 'build'
    directory: String, // bin
    proxy: String,     // 'install'
    loglevel: String,  // everywhere
};

/**
 * nopt shorthands
 */

proto.shorthands = {
    release: '--no-debug',
    C: '--directory',
    debug: '--debug',
    j: '--jobs',
    silent: '--loglevel=silent',
    silly: '--loglevel=silly',
    verbose: '--loglevel=verbose',
};

/**
 * expose the command aliases for the bin file to use.
 */

proto.aliases = aliases;

/**
 * Parses the given argv array and sets the 'opts',
 * 'argv' and 'command' properties.
 */

proto.parseArgv = function parseOpts (argv) {
  this.opts = nopt(this.configDefs, this.shorthands, argv);
  this.argv = this.opts.argv.remain.slice();
  var commands = this.todo = [];

  // create a copy of the argv array with aliases mapped
  argv = this.argv.map(function (arg) {
    // is this an alias?
    if (arg in this.aliases) {
      arg = this.aliases[arg];
    }
    return arg;
  }, this);

  // process the mapped args into "command" objects ("name" and "args" props)
  argv.slice().forEach(function (arg) {
    if (arg in this.commands) {
      var args = argv.splice(0, argv.indexOf(arg));
      argv.shift();
      if (commands.length > 0) {
        commands[commands.length - 1].args = args;
      }
      commands.push({ name: arg, args: [] });
    }
  }, this);
  if (commands.length > 0) {
    commands[commands.length - 1].args = argv.splice(0);
  }

  // expand commands entries for multiple napi builds
  var dir = this.opts.directory;
  if (dir == null) dir = process.cwd();
  var package_json = JSON.parse(fs.readFileSync(path.join(dir,'package.json')));

  this.todo = napi.expand_commands (package_json, this.opts, commands);

  // support for inheriting config env variables from npm
  var npm_config_prefix = 'npm_config_';
  Object.keys(process.env).forEach(function (name) {
    if (name.indexOf(npm_config_prefix) !== 0) return;
    var val = process.env[name];
    if (name === npm_config_prefix + 'loglevel') {
      log.level = val;
    } else {
      // add the user-defined options to the config
      name = name.substring(npm_config_prefix.length);
      // avoid npm argv clobber already present args
      // which avoids problem of 'npm test' calling
      // script that runs unique npm install commands
      if (name === 'argv') {
         if (this.opts.argv &&
             this.opts.argv.remain &&
             this.opts.argv.remain.length) {
            // do nothing
         } else {
            this.opts[name] = val;
         }
      } else {
        this.opts[name] = val;
      }
    }
  }, this);

  if (this.opts.loglevel) {
    log.level = this.opts.loglevel;
  }
  log.resume();
};

/**
 * Returns the usage instructions for node-pre-gyp.
 */

proto.usage = function usage () {
  var str = [
      '',
      '  Usage: node-pre-gyp <command> [options]',
      '',
      '  where <command> is one of:',
      commands.map(function (c) {
        return '    - ' + c + ' - ' + require('./' + c).usage;
      }).join('\n'),
      '',
      'node-pre-gyp@' + this.version + '  ' + path.resolve(__dirname, '..'),
      'node@' + process.versions.node
  ].join('\n');
  return str;
};

/**
 * Version number getter.
 */

Object.defineProperty(proto, 'version', {
    get: function () {
      return this.package.version;
    },
    enumerable: true
});


},{"fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","nopt":"../node_modules/nopt/lib/nopt.js","npmlog":"../node_modules/npmlog/log.js","./util/napi.js":"../node_modules/node-pre-gyp/lib/util/napi.js","events":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/events/events.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","./pre-binding":"../node_modules/node-pre-gyp/lib/pre-binding.js","../package.json":"../node_modules/node-pre-gyp/package.json","process":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"../node_modules/@tensorflow/tfjs-node/dist/image.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfjs_core_1 = require("@tensorflow/tfjs-core");

var nodejs_kernel_backend_1 = require("./nodejs_kernel_backend");

var ImageType;

(function (ImageType) {
  ImageType["JPEG"] = "jpeg";
  ImageType["PNG"] = "png";
  ImageType["GIF"] = "gif";
  ImageType["BMP"] = "BMP";
})(ImageType = exports.ImageType || (exports.ImageType = {}));
/**
 * Decode a JPEG-encoded image to a 3D Tensor of dtype `int32`.
 *
 * @param contents The JPEG-encoded image in an Uint8Array.
 * @param channels An optional int. Defaults to 0. Accepted values are
 *     0: use the number of channels in the PNG-encoded image.
 *     1: output a grayscale image.
 *     3: output an RGB image.
 * @param ratio An optional int. Defaults to 1. Downscaling ratio. It is used
 *     when image is type Jpeg.
 * @param fancyUpscaling An optional bool. Defaults to True. If true use a
 *     slower but nicer upscaling of the chroma planes. It is used when image is
 *     type Jpeg.
 * @param tryRecoverTruncated An optional bool. Defaults to False. If true try
 *     to recover an image from truncated input. It is used when image is type
 *     Jpeg.
 * @param acceptableFraction An optional float. Defaults to 1. The minimum
 *     required fraction of lines before a truncated input is accepted. It is
 *     used when image is type Jpeg.
 * @param dctMethod An optional string. Defaults to "". string specifying a hint
 *     about the algorithm used for decompression. Defaults to "" which maps to
 *     a system-specific default. Currently valid values are ["INTEGER_FAST",
 *     "INTEGER_ACCURATE"]. The hint may be ignored (e.g., the internal jpeg
 *     library changes to a version that does not have that specific option.) It
 *     is used when image is type Jpeg.
 * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3].
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */


function decodeJpeg(contents, channels, ratio, fancyUpscaling, tryRecoverTruncated, acceptableFraction, dctMethod) {
  if (channels === void 0) {
    channels = 0;
  }

  if (ratio === void 0) {
    ratio = 1;
  }

  if (fancyUpscaling === void 0) {
    fancyUpscaling = true;
  }

  if (tryRecoverTruncated === void 0) {
    tryRecoverTruncated = false;
  }

  if (acceptableFraction === void 0) {
    acceptableFraction = 1;
  }

  if (dctMethod === void 0) {
    dctMethod = '';
  }

  nodejs_kernel_backend_1.ensureTensorflowBackend();
  return tfjs_core_1.tidy(function () {
    return nodejs_kernel_backend_1.nodeBackend().decodeJpeg(contents, channels, ratio, fancyUpscaling, tryRecoverTruncated, acceptableFraction, dctMethod).toInt();
  });
}

exports.decodeJpeg = decodeJpeg;
/**
 * Decode a PNG-encoded image to a 3D Tensor of dtype `int32`.
 *
 * @param contents The BMP-encoded image in an Uint8Array.
 * @param channels An optional int. Defaults to 0. Accepted values are
 *      0: use the number of channels in the PNG-encoded image.
 *      1: output a grayscale image.
 *      3: output an RGB image.
 *      4: output an RGBA image.
 * @param dtype The data type of the result. Only `int32` is supported at this
 *     time.
 * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3/4].
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */

function decodePng(contents, channels, dtype) {
  if (channels === void 0) {
    channels = 0;
  }

  if (dtype === void 0) {
    dtype = 'int32';
  }

  tfjs_core_1.util.assert(dtype === 'int32', function () {
    return 'decodeImage could only return Tensor of type `int32` for now.';
  });
  nodejs_kernel_backend_1.ensureTensorflowBackend();
  return tfjs_core_1.tidy(function () {
    return nodejs_kernel_backend_1.nodeBackend().decodePng(contents, channels).toInt();
  });
}

exports.decodePng = decodePng;
/**
 * Decode the first frame of a BMP-encoded image to a 3D Tensor of dtype
 * `int32`.
 *
 * @param contents The BMP-encoded image in an Uint8Array.
 * @param channels An optional int. Defaults to 0. Accepted values are
 *      0: use the number of channels in the BMP-encoded image.
 *      3: output an RGB image.
 *      4: output an RGBA image.
 * @returns A 3D Tensor of dtype `int32` with shape [height, width, 3/4].
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */

function decodeBmp(contents, channels) {
  if (channels === void 0) {
    channels = 0;
  }

  nodejs_kernel_backend_1.ensureTensorflowBackend();
  return tfjs_core_1.tidy(function () {
    return nodejs_kernel_backend_1.nodeBackend().decodeBmp(contents, channels).toInt();
  });
}

exports.decodeBmp = decodeBmp;
/**
 * Decode the frame(s) of a GIF-encoded image to a 4D Tensor of dtype `int32`.
 *
 * @param contents The GIF-encoded image in an Uint8Array.
 * @returns A 4D Tensor of dtype `int32` with shape [num_frames, height, width,
 *     3]. RGB channel order.
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */

function decodeGif(contents) {
  nodejs_kernel_backend_1.ensureTensorflowBackend();
  return tfjs_core_1.tidy(function () {
    return nodejs_kernel_backend_1.nodeBackend().decodeGif(contents).toInt();
  });
}

exports.decodeGif = decodeGif;
/**
 * Given the encoded bytes of an image, it returns a 3D or 4D tensor of the
 * decoded image. Supports BMP, GIF, JPEG and PNG formats.
 *
 * @param content The encoded image in an Uint8Array.
 * @param channels An optional int. Defaults to 0, use the number of channels in
 *     the image. Number of color channels for the decoded image. It is used
 *     when image is type Png, Bmp, or Jpeg.
 * @param dtype The data type of the result. Only `int32` is supported at this
 *     time.
 * @param expandAnimations A boolean which controls the shape of the returned
 *     op's output. If True, the returned op will produce a 3-D tensor for PNG,
 *     JPEG, and BMP files; and a 4-D tensor for all GIFs, whether animated or
 *     not. If, False, the returned op will produce a 3-D tensor for all file
 *     types and will truncate animated GIFs to the first frame.
 * @returns A Tensor with dtype `int32` and a 3- or 4-dimensional shape,
 *     depending on the file type. For gif file the returned Tensor shape is
 *     [num_frames, height, width, 3], and for jpeg/png/bmp the returned Tensor
 *     shape is []height, width, channels]
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */

function decodeImage(content, channels, dtype, expandAnimations) {
  if (channels === void 0) {
    channels = 0;
  }

  if (dtype === void 0) {
    dtype = 'int32';
  }

  if (expandAnimations === void 0) {
    expandAnimations = true;
  }

  tfjs_core_1.util.assert(dtype === 'int32', function () {
    return 'decodeImage could only return Tensor of type `int32` for now.';
  });
  var imageType = getImageType(content); // The return tensor has dtype uint8, which is not supported in
  // TensorFlow.js, casting it to int32 which is the default dtype for image
  // tensor. If the image is BMP, JPEG or PNG type, expanding the tensors
  // shape so it becomes Tensor4D, which is the default tensor shape for image
  // ([batch,imageHeight,imageWidth, depth]).

  switch (imageType) {
    case ImageType.JPEG:
      return decodeJpeg(content, channels);

    case ImageType.PNG:
      return decodePng(content, channels);

    case ImageType.GIF:
      // If not to expand animations, take first frame of the gif and return
      // as a 3D tensor.
      return tfjs_core_1.tidy(function () {
        var img = decodeGif(content);
        return expandAnimations ? img : img.slice(0, 1).squeeze([0]);
      });

    case ImageType.BMP:
      return decodeBmp(content, channels);

    default:
      return null;
  }
}

exports.decodeImage = decodeImage;
/**
 * Encodes an image tensor to JPEG.
 *
 * @param image A 3-D uint8 Tensor of shape [height, width, channels].
 * @param format An optional string from: "", "grayscale", "rgb".
 *     Defaults to "". Per pixel image format.
 *     - '': Use a default format based on the number of channels in the image.
 *     - grayscale: Output a grayscale JPEG image. The channels dimension of
 *       image must be 1.
 *     - rgb: Output an RGB JPEG image. The channels dimension of image must
 *       be 3.
 * @param quality An optional int. Defaults to 95. Quality of the compression
 *     from 0 to 100 (higher is better and slower).
 * @param progressive An optional bool. Defaults to False. If True, create a
 *     JPEG that loads progressively (coarse to fine).
 * @param optimizeSize An optional bool. Defaults to False. If True, spend
 *     CPU/RAM to reduce size with no quality change.
 * @param chromaDownsampling  An optional bool. Defaults to True.
 *     See http://en.wikipedia.org/wiki/Chroma_subsampling.
 * @param densityUnit An optional string from: "in", "cm". Defaults to "in".
 *     Unit used to specify x_density and y_density: pixels per inch ('in') or
 *     centimeter ('cm').
 * @param xDensity An optional int. Defaults to 300. Horizontal pixels per
 *     density unit.
 * @param yDensity An optional int. Defaults to 300. Vertical pixels per
 *     density unit.
 * @param xmpMetadata An optional string. Defaults to "". If not empty, embed
 *     this XMP metadata in the image header.
 * @returns The JPEG encoded data as an Uint8Array.
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */

function encodeJpeg(image, format, quality, progressive, optimizeSize, chromaDownsampling, densityUnit, xDensity, yDensity, xmpMetadata) {
  if (format === void 0) {
    format = '';
  }

  if (quality === void 0) {
    quality = 95;
  }

  if (progressive === void 0) {
    progressive = false;
  }

  if (optimizeSize === void 0) {
    optimizeSize = false;
  }

  if (chromaDownsampling === void 0) {
    chromaDownsampling = true;
  }

  if (densityUnit === void 0) {
    densityUnit = 'in';
  }

  if (xDensity === void 0) {
    xDensity = 300;
  }

  if (yDensity === void 0) {
    yDensity = 300;
  }

  if (xmpMetadata === void 0) {
    xmpMetadata = '';
  }

  return __awaiter(this, void 0, void 0, function () {
    var backendEncodeImage;
    return __generator(this, function (_a) {
      nodejs_kernel_backend_1.ensureTensorflowBackend();

      backendEncodeImage = function backendEncodeImage(imageData) {
        return nodejs_kernel_backend_1.nodeBackend().encodeJpeg(imageData, image.shape, format, quality, progressive, optimizeSize, chromaDownsampling, densityUnit, xDensity, yDensity, xmpMetadata);
      };

      return [2
      /*return*/
      , encodeImage(image, backendEncodeImage)];
    });
  });
}

exports.encodeJpeg = encodeJpeg;
/**
 * Encodes an image tensor to PNG.
 *
 * @param image A 3-D uint8 Tensor of shape [height, width, channels].
 * @param compression An optional int. Defaults to -1. Compression level.
 * @returns The PNG encoded data as an Uint8Array.
 */

/**
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'node'}
 */

function encodePng(image, compression) {
  if (compression === void 0) {
    compression = 1;
  }

  return __awaiter(this, void 0, void 0, function () {
    var backendEncodeImage;
    return __generator(this, function (_a) {
      nodejs_kernel_backend_1.ensureTensorflowBackend();

      backendEncodeImage = function backendEncodeImage(imageData) {
        return nodejs_kernel_backend_1.nodeBackend().encodePng(imageData, image.shape, compression);
      };

      return [2
      /*return*/
      , encodeImage(image, backendEncodeImage)];
    });
  });
}

exports.encodePng = encodePng;

function encodeImage(image, backendEncodeImage) {
  return __awaiter(this, void 0, void 0, function () {
    var encodedDataTensor, _a, _b, encodedPngData;

    return __generator(this, function (_c) {
      switch (_c.label) {
        case 0:
          _a = backendEncodeImage;
          _b = Uint8Array.bind;
          return [4
          /*yield*/
          , image.data()];

        case 1:
          encodedDataTensor = _a.apply(void 0, [new (_b.apply(Uint8Array, [void 0, _c.sent()]))()]); // tslint:disable-next-line:no-any

          return [4
          /*yield*/
          , encodedDataTensor.data()];

        case 2:
          encodedPngData = // tslint:disable-next-line:no-any
          _c.sent()[0];
          encodedDataTensor.dispose();
          return [2
          /*return*/
          , encodedPngData];
      }
    });
  });
}
/**
 * Helper function to get image type based on starting bytes of the image file.
 */


function getImageType(content) {
  // Classify the contents of a file based on starting bytes (aka magic number:
  // https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)
  // This aligns with TensorFlow Core code:
  // https://github.com/tensorflow/tensorflow/blob/4213d5c1bd921f8d5b7b2dc4bbf1eea78d0b5258/tensorflow/core/kernels/decode_image_op.cc#L44
  if (content.length > 3 && content[0] === 255 && content[1] === 216 && content[2] === 255) {
    // JPEG byte chunk starts with `ff d8 ff`
    return ImageType.JPEG;
  } else if (content.length > 4 && content[0] === 71 && content[1] === 73 && content[2] === 70 && content[3] === 56) {
    // GIF byte chunk starts with `47 49 46 38`
    return ImageType.GIF;
  } else if (content.length > 8 && content[0] === 137 && content[1] === 80 && content[2] === 78 && content[3] === 71 && content[4] === 13 && content[5] === 10 && content[6] === 26 && content[7] === 10) {
    // PNG byte chunk starts with `\211 P N G \r \n \032 \n (89 50 4E 47 0D 0A
    // 1A 0A)`
    return ImageType.PNG;
  } else if (content.length > 3 && content[0] === 66 && content[1] === 77) {
    // BMP byte chunk starts with `42 4d`
    return ImageType.BMP;
  } else {
    throw new Error('Expected image (JPEG, PNG, or GIF), but got unsupported image type');
  }
}

exports.getImageType = getImageType;
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./nodejs_kernel_backend":"../node_modules/@tensorflow/tfjs-node/dist/nodejs_kernel_backend.js"}],"../node_modules/google-protobuf/google-protobuf.js":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return{i:e,v:f}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};$jscomp.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).i}},"es6","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var e=a.length;0<e&&0<c;)if(b[--c]!=a[--e])return!1;return 0>=e}},"es6","es3");$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6","es3");
$jscomp.polyfill("String.prototype.startsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"startsWith");a+="";var e=b.length,f=a.length;c=Math.max(0,Math.min(c|0,b.length));for(var g=0;g<f&&c<e;)if(b[c++]!=a[g++])return!1;return g>=f}},"es6","es3");
$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");var COMPILED=!0,goog=goog||{};goog.global=this||self;goog.isDef=function(a){return void 0!==a};goog.isString=function(a){return"string"==typeof a};goog.isBoolean=function(a){return"boolean"==typeof a};
goog.isNumber=function(a){return"number"==typeof a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={}};
goog.define=function(a,b){if(!COMPILED){var c=goog.global.CLOSURE_UNCOMPILED_DEFINES,d=goog.global.CLOSURE_DEFINES;c&&void 0===c.nodeType&&Object.prototype.hasOwnProperty.call(c,a)?b=c[a]:d&&void 0===d.nodeType&&Object.prototype.hasOwnProperty.call(d,a)&&(b=d[a])}return b};goog.FEATURESET_YEAR=2012;goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=COMPILED&&!goog.DEBUG;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;
goog.provide=function(a){if(goog.isInModuleLoader_())throw Error("goog.provide cannot be used within a module.");if(!COMPILED&&goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');goog.constructNamespace_(a)};goog.constructNamespace_=function(a,b){if(!COMPILED){delete goog.implicitNamespaces_[a];for(var c=a;(c=c.substring(0,c.lastIndexOf(".")))&&!goog.getObjectByName(c);)goog.implicitNamespaces_[c]=!0}goog.exportPath_(a,b)};
goog.getScriptNonce=function(a){if(a&&a!=goog.global)return goog.getScriptNonce_(a.document);null===goog.cspNonce_&&(goog.cspNonce_=goog.getScriptNonce_(goog.global.document));return goog.cspNonce_};goog.NONCE_PATTERN_=/^[\w+/_-]+[=]{0,2}$/;goog.cspNonce_=null;goog.getScriptNonce_=function(a){return(a=a.querySelector&&a.querySelector("script[nonce]"))&&(a=a.nonce||a.getAttribute("nonce"))&&goog.NONCE_PATTERN_.test(a)?a:""};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInGoogModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;if(!COMPILED){if(goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');delete goog.implicitNamespaces_[a]}};goog.module.get=function(a){return goog.module.getInternal_(a)};
goog.module.getInternal_=function(a){if(!COMPILED){if(a in goog.loadedModules_)return goog.loadedModules_[a].exports;if(!goog.implicitNamespaces_[a])return a=goog.getObjectByName(a),null!=a?a:null}return null};goog.ModuleType={ES6:"es6",GOOG:"goog"};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return goog.isInGoogModuleLoader_()||goog.isInEs6ModuleLoader_()};goog.isInGoogModuleLoader_=function(){return!!goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.GOOG};
goog.isInEs6ModuleLoader_=function(){if(goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.ES6)return!0;var a=goog.global.$jscomp;return a?"function"!=typeof a.getCurrentModulePath?!1:!!a.getCurrentModulePath():!1};
goog.module.declareLegacyNamespace=function(){if(!COMPILED&&!goog.isInGoogModuleLoader_())throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");if(!COMPILED&&!goog.moduleLoaderState_.moduleName)throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");goog.moduleLoaderState_.declareLegacyNamespace=!0};
goog.declareModuleId=function(a){if(!COMPILED){if(!goog.isInEs6ModuleLoader_())throw Error("goog.declareModuleId may only be called from within an ES6 module");if(goog.moduleLoaderState_&&goog.moduleLoaderState_.moduleName)throw Error("goog.declareModuleId may only be called once per module.");if(a in goog.loadedModules_)throw Error('Module with namespace "'+a+'" already exists.');}if(goog.moduleLoaderState_)goog.moduleLoaderState_.moduleName=a;else{var b=goog.global.$jscomp;if(!b||"function"!=typeof b.getCurrentModulePath)throw Error('Module with namespace "'+
a+'" has been loaded incorrectly.');b=b.require(b.getCurrentModulePath());goog.loadedModules_[a]={exports:b,type:goog.ModuleType.ES6,moduleId:a}}};goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};
COMPILED||(goog.isProvided_=function(a){return a in goog.loadedModules_||!goog.implicitNamespaces_[a]&&goog.isDefAndNotNull(goog.getObjectByName(a))},goog.implicitNamespaces_={"goog.module":!0});goog.getObjectByName=function(a,b){a=a.split(".");b=b||goog.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog.isDefAndNotNull(b))return null;return b};goog.globalize=function(a,b){b=b||goog.global;for(var c in a)b[c]=a[c]};
goog.addDependency=function(a,b,c,d){!COMPILED&&goog.DEPENDENCIES_ENABLED&&goog.debugLoader_.addDependency(a,b,c,d)};goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a)};
goog.require=function(a){if(!COMPILED){goog.ENABLE_DEBUG_LOADER&&goog.debugLoader_.requested(a);if(goog.isProvided_(a)){if(goog.isInModuleLoader_())return goog.module.getInternal_(a)}else if(goog.ENABLE_DEBUG_LOADER){var b=goog.moduleLoaderState_;goog.moduleLoaderState_=null;try{goog.debugLoader_.load_(a)}finally{goog.moduleLoaderState_=b}}return null}};goog.requireType=function(a){return{}};goog.basePath="";goog.nullFunction=function(){};
goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a}};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED&&goog.ENABLE_DEBUG_LOADER;goog.TRANSPILE="detect";
goog.ASSUME_ES_MODULES_TRANSPILED=!1;goog.TRANSPILE_TO_LANGUAGE="";goog.TRANSPILER="transpile.js";goog.hasBadLetScoping=null;goog.useSafari10Workaround=function(){if(null==goog.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";')}catch(b){a=!1}goog.hasBadLetScoping=a}return goog.hasBadLetScoping};goog.workaroundSafari10EvalBug=function(a){return"(function(){"+a+"\n;})();\n"};
goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:"",declareLegacyNamespace:!1,type:goog.ModuleType.GOOG};if(goog.isFunction(a))var c=a.call(void 0,{});else if(goog.isString(a))goog.useSafari10Workaround()&&(a=goog.workaroundSafari10EvalBug(a)),c=goog.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;if(goog.isString(d)&&d)goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,
c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c),goog.loadedModules_[d]={exports:c,type:goog.ModuleType.GOOG,moduleId:goog.moduleLoaderState_.moduleName};else throw Error('Invalid module name "'+d+'"');}finally{goog.moduleLoaderState_=b}};goog.loadModuleFromSource_=function(a){eval(a);return{}};goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
goog.transpile_=function(a,b,c){var d=goog.global.$jscomp;d||(goog.global.$jscomp=d={});var e=d.transpile;if(!e){var f=goog.basePath+goog.TRANSPILER,g=goog.loadFileSync_(f);if(g){(function(){(0,eval)(g+"\n//# sourceURL="+f)}).call(goog.global);if(goog.global.$gwtExport&&goog.global.$gwtExport.$jscomp&&!goog.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog.global.$gwtExport));goog.global.$jscomp.transpile=
goog.global.$gwtExport.$jscomp.transpile;d=goog.global.$jscomp;e=d.transpile}}e||(e=d.transpile=function(a,b){goog.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return e(a,b,c)};
goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return"array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return"array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isFunction=function(a){return"function"==goog.typeOf(a)};
goog.isObject=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return!!a[goog.UID_PROPERTY_]};goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_]}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;
goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if("function"===typeof a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c]};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return+new Date};
goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_){try{goog.global.eval("var _evalTest_ = 1;")}catch(d){}if("undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_}catch(d){}goog.evalWorksForGlobals_=!0}else goog.evalWorksForGlobals_=!1}if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=
!1;c.appendChild(b.createTextNode(a));b.head.appendChild(c);b.head.removeChild(c)}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;
goog.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog.global.CLOSURE_CSS_NAME_MAP_FN?goog.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b};!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING&&(goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING);goog.getMsg=function(a,b,c){c&&c.html&&(a=a.replace(/</g,"&lt;"));b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,c){return null!=b&&c in b?b[c]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c)};
goog.exportProperty=function(a,b,c){a[b]=c};goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};
goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}if("string"!=typeof b&&"symbol"!=typeof b)throw Error("method names provided to goog.base must be a string or a symbol");
e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor.prototype;g;g=Object.getPrototypeOf(g))if(g[b]===d)f=!0;else if(f)return g[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){if(goog.isInModuleLoader_())throw Error("goog.scope is not supported within a module.");a.call(goog.global)};
COMPILED||(goog.global.COMPILED=COMPILED);goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};
goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;goog.defineClass.createSealingConstructor_=function(a,b){if(!goog.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])};
goog.tagUnsealableClass=function(a){!COMPILED&&goog.defineClass.SEAL_CLASS_INSTANCES&&(a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]=!0)};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
!COMPILED&&goog.DEPENDENCIES_ENABLED&&(goog.inHtmlDocument_=function(){var a=goog.global.document;return null!=a&&"write"in a},goog.isDocumentLoading_=function(){var a=goog.global.document;return a.attachEvent?"complete"!=a.readyState:"loading"==a.readyState},goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH)&&goog.isString(goog.global.CLOSURE_BASE_PATH))goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_()){var a=goog.global.document,b=a.currentScript;
a=b?[b]:a.getElementsByTagName("SCRIPT");for(b=a.length-1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?");d=-1==d?c.length:d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}}},goog.findBasePath_(),goog.Transpiler=function(){this.requiresTranspilation_=null;this.transpilationTarget_=goog.TRANSPILE_TO_LANGUAGE},goog.Transpiler.prototype.createRequiresTranspilation_=function(){function a(a,b){e?d[a]=!0:b()?(c=a,d[a]=!1):e=d[a]=!0}function b(a){try{return!!eval(a)}catch(h){return!1}}
var c="es3",d={es3:!1},e=!1,f=goog.global.navigator&&goog.global.navigator.userAgent?goog.global.navigator.userAgent:"";a("es5",function(){return b("[1,].length==1")});a("es6",function(){return f.match(/Edge\/(\d+)(\.\d)*/i)?!1:b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()')});
a("es7",function(){return b("2 ** 2 == 4")});a("es8",function(){return b("async () => 1, true")});a("es9",function(){return b("({...rest} = {}), true")});a("es_next",function(){return!1});return{target:c,map:d}},goog.Transpiler.prototype.needsTranspile=function(a,b){if("always"==goog.TRANSPILE)return!0;if("never"==goog.TRANSPILE)return!1;if(!this.requiresTranspilation_){var c=this.createRequiresTranspilation_();this.requiresTranspilation_=c.map;this.transpilationTarget_=this.transpilationTarget_||
c.target}if(a in this.requiresTranspilation_)return this.requiresTranspilation_[a]?!0:!goog.inHtmlDocument_()||"es6"!=b||"noModule"in goog.global.document.createElement("script")?!1:!0;throw Error("Unknown language mode: "+a);},goog.Transpiler.prototype.transpile=function(a,b){return goog.transpile_(a,b,this.transpilationTarget_)},goog.transpiler_=new goog.Transpiler,goog.protectScriptTag_=function(a){return a.replace(/<\/(SCRIPT)/ig,"\\x3c/$1")},goog.DebugLoader_=function(){this.dependencies_={};
this.idToPath_={};this.written_={};this.loadingDeps_=[];this.depsToLoad_=[];this.paused_=!1;this.factory_=new goog.DependencyFactory(goog.transpiler_);this.deferredCallbacks_={};this.deferredQueue_=[]},goog.DebugLoader_.prototype.bootstrap=function(a,b){function c(){d&&(goog.global.setTimeout(d,0),d=null)}var d=b;if(a.length){b=[];for(var e=0;e<a.length;e++){var f=this.getPathFromDeps_(a[e]);if(!f)throw Error("Unregonized namespace: "+a[e]);b.push(this.dependencies_[f])}f=goog.require;var g=0;for(e=
0;e<a.length;e++)f(a[e]),b[e].onLoad(function(){++g==a.length&&c()})}else c()},goog.DebugLoader_.prototype.loadClosureDeps=function(){this.depsToLoad_.push(this.factory_.createDependency(goog.normalizePath_(goog.basePath+"deps.js"),"deps.js",[],[],{},!1));this.loadDeps_()},goog.DebugLoader_.prototype.requested=function(a,b){(a=this.getPathFromDeps_(a))&&(b||this.areDepsLoaded_(this.dependencies_[a].requires))&&(b=this.deferredCallbacks_[a])&&(delete this.deferredCallbacks_[a],b())},goog.DebugLoader_.prototype.setDependencyFactory=
function(a){this.factory_=a},goog.DebugLoader_.prototype.load_=function(a){if(this.getPathFromDeps_(a)){var b=this,c=[],d=function(a){var e=b.getPathFromDeps_(a);if(!e)throw Error("Bad dependency path or symbol: "+a);if(!b.written_[e]){b.written_[e]=!0;a=b.dependencies_[e];for(e=0;e<a.requires.length;e++)goog.isProvided_(a.requires[e])||d(a.requires[e]);c.push(a)}};d(a);a=!!this.depsToLoad_.length;this.depsToLoad_=this.depsToLoad_.concat(c);this.paused_||a||this.loadDeps_()}else throw a="goog.require could not find: "+
a,goog.logToConsole_(a),Error(a);},goog.DebugLoader_.prototype.loadDeps_=function(){for(var a=this,b=this.paused_;this.depsToLoad_.length&&!b;)(function(){var c=!1,d=a.depsToLoad_.shift(),e=!1;a.loading_(d);var f={pause:function(){if(c)throw Error("Cannot call pause after the call to load.");b=!0},resume:function(){c?a.resume_():b=!1},loaded:function(){if(e)throw Error("Double call to loaded.");e=!0;a.loaded_(d)},pending:function(){for(var b=[],c=0;c<a.loadingDeps_.length;c++)b.push(a.loadingDeps_[c]);
return b},setModuleState:function(a){goog.moduleLoaderState_={type:a,moduleName:"",declareLegacyNamespace:!1}},registerEs6ModuleExports:function(a,b,c){c&&(goog.loadedModules_[c]={exports:b,type:goog.ModuleType.ES6,moduleId:c||""})},registerGoogModuleExports:function(a,b){goog.loadedModules_[a]={exports:b,type:goog.ModuleType.GOOG,moduleId:a}},clearModuleState:function(){goog.moduleLoaderState_=null},defer:function(b){if(c)throw Error("Cannot register with defer after the call to load.");a.defer_(d,
b)},areDepsLoaded:function(){return a.areDepsLoaded_(d.requires)}};try{d.load(f)}finally{c=!0}})();b&&this.pause_()},goog.DebugLoader_.prototype.pause_=function(){this.paused_=!0},goog.DebugLoader_.prototype.resume_=function(){this.paused_&&(this.paused_=!1,this.loadDeps_())},goog.DebugLoader_.prototype.loading_=function(a){this.loadingDeps_.push(a)},goog.DebugLoader_.prototype.loaded_=function(a){for(var b=0;b<this.loadingDeps_.length;b++)if(this.loadingDeps_[b]==a){this.loadingDeps_.splice(b,1);
break}for(b=0;b<this.deferredQueue_.length;b++)if(this.deferredQueue_[b]==a.path){this.deferredQueue_.splice(b,1);break}if(this.loadingDeps_.length==this.deferredQueue_.length&&!this.depsToLoad_.length)for(;this.deferredQueue_.length;)this.requested(this.deferredQueue_.shift(),!0);a.loaded()},goog.DebugLoader_.prototype.areDepsLoaded_=function(a){for(var b=0;b<a.length;b++){var c=this.getPathFromDeps_(a[b]);if(!c||!(c in this.deferredCallbacks_||goog.isProvided_(a[b])))return!1}return!0},goog.DebugLoader_.prototype.getPathFromDeps_=
function(a){return a in this.idToPath_?this.idToPath_[a]:a in this.dependencies_?a:null},goog.DebugLoader_.prototype.defer_=function(a,b){this.deferredCallbacks_[a.path]=b;this.deferredQueue_.push(a.path)},goog.LoadController=function(){},goog.LoadController.prototype.pause=function(){},goog.LoadController.prototype.resume=function(){},goog.LoadController.prototype.loaded=function(){},goog.LoadController.prototype.pending=function(){},goog.LoadController.prototype.registerEs6ModuleExports=function(a,
b,c){},goog.LoadController.prototype.setModuleState=function(a){},goog.LoadController.prototype.clearModuleState=function(){},goog.LoadController.prototype.defer=function(a){},goog.LoadController.prototype.areDepsLoaded=function(){},goog.Dependency=function(a,b,c,d,e){this.path=a;this.relativePath=b;this.provides=c;this.requires=d;this.loadFlags=e;this.loaded_=!1;this.loadCallbacks_=[]},goog.Dependency.prototype.getPathName=function(){var a=this.path,b=a.indexOf("://");0<=b&&(a=a.substring(b+3),b=
a.indexOf("/"),0<=b&&(a=a.substring(b+1)));return a},goog.Dependency.prototype.onLoad=function(a){this.loaded_?a():this.loadCallbacks_.push(a)},goog.Dependency.prototype.loaded=function(){this.loaded_=!0;var a=this.loadCallbacks_;this.loadCallbacks_=[];for(var b=0;b<a.length;b++)a[b]()},goog.Dependency.defer_=!1,goog.Dependency.callbackMap_={},goog.Dependency.registerCallback_=function(a){var b=Math.random().toString(32);goog.Dependency.callbackMap_[b]=a;return b},goog.Dependency.unregisterCallback_=
function(a){delete goog.Dependency.callbackMap_[a]},goog.Dependency.callback_=function(a,b){if(a in goog.Dependency.callbackMap_){for(var c=goog.Dependency.callbackMap_[a],d=[],e=1;e<arguments.length;e++)d.push(arguments[e]);c.apply(void 0,d)}else throw Error("Callback key "+a+" does not exist (was base.js loaded more than once?).");},goog.Dependency.prototype.load=function(a){if(goog.global.CLOSURE_IMPORT_SCRIPT)goog.global.CLOSURE_IMPORT_SCRIPT(this.path)?a.loaded():a.pause();else if(goog.inHtmlDocument_()){var b=
goog.global.document;if("complete"==b.readyState&&!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING){if(/\bdeps.js$/.test(this.path)){a.loaded();return}throw Error('Cannot write "'+this.path+'" after document load');}if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&goog.isDocumentLoading_()){var c=goog.Dependency.registerCallback_(function(b){goog.DebugLoader_.IS_OLD_IE_&&"complete"!=b.readyState||(goog.Dependency.unregisterCallback_(c),a.loaded())}),d=!goog.DebugLoader_.IS_OLD_IE_&&goog.getScriptNonce()?
' nonce="'+goog.getScriptNonce()+'"':"";d='<script src="'+this.path+'" '+(goog.DebugLoader_.IS_OLD_IE_?"onreadystatechange":"onload")+"=\"goog.Dependency.callback_('"+c+'\', this)" type="text/javascript" '+(goog.Dependency.defer_?"defer":"")+d+">\x3c/script>";b.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(d):d)}else{var e=b.createElement("script");e.defer=goog.Dependency.defer_;e.async=!1;e.type="text/javascript";(d=goog.getScriptNonce())&&e.setAttribute("nonce",d);goog.DebugLoader_.IS_OLD_IE_?
(a.pause(),e.onreadystatechange=function(){if("loaded"==e.readyState||"complete"==e.readyState)a.loaded(),a.resume()}):e.onload=function(){e.onload=null;a.loaded()};e.src=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path):this.path;b.head.appendChild(e)}}else goog.logToConsole_("Cannot use default debug loader outside of HTML documents."),"deps.js"==this.relativePath?(goog.logToConsole_("Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, or setting CLOSURE_NO_DEPS to true."),
a.loaded()):a.pause()},goog.Es6ModuleDependency=function(a,b,c,d,e){goog.Dependency.call(this,a,b,c,d,e)},goog.inherits(goog.Es6ModuleDependency,goog.Dependency),goog.Es6ModuleDependency.prototype.load=function(a){function b(a,b){a=b?'<script type="module" crossorigin>'+b+"\x3c/script>":'<script type="module" crossorigin src="'+a+'">\x3c/script>';d.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(a):a)}function c(a,b){var c=d.createElement("script");c.defer=!0;c.async=!1;c.type=
"module";c.setAttribute("crossorigin",!0);var e=goog.getScriptNonce();e&&c.setAttribute("nonce",e);b?c.textContent=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScript(b):b:c.src=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScriptURL(a):a;d.head.appendChild(c)}if(goog.global.CLOSURE_IMPORT_SCRIPT)goog.global.CLOSURE_IMPORT_SCRIPT(this.path)?a.loaded():a.pause();else if(goog.inHtmlDocument_()){var d=goog.global.document,e=this;if(goog.isDocumentLoading_()){var f=b;goog.Dependency.defer_=
!0}else f=c;var g=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(g);a.setModuleState(goog.ModuleType.ES6)});f(void 0,'goog.Dependency.callback_("'+g+'")');f(this.path,void 0);var h=goog.Dependency.registerCallback_(function(b){goog.Dependency.unregisterCallback_(h);a.registerEs6ModuleExports(e.path,b,goog.moduleLoaderState_.moduleName)});f(void 0,'import * as m from "'+this.path+'"; goog.Dependency.callback_("'+h+'", m)');var k=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(k);
a.clearModuleState();a.loaded()});f(void 0,'goog.Dependency.callback_("'+k+'")')}else goog.logToConsole_("Cannot use default debug loader outside of HTML documents."),a.pause()},goog.TransformedDependency=function(a,b,c,d,e){goog.Dependency.call(this,a,b,c,d,e);this.contents_=null;this.lazyFetch_=!goog.inHtmlDocument_()||!("noModule"in goog.global.document.createElement("script"))},goog.inherits(goog.TransformedDependency,goog.Dependency),goog.TransformedDependency.prototype.load=function(a){function b(){e.contents_=
goog.loadFileSync_(e.path);e.contents_&&(e.contents_=e.transform(e.contents_),e.contents_&&(e.contents_+="\n//# sourceURL="+e.path))}function c(){e.lazyFetch_&&b();if(e.contents_){f&&a.setModuleState(goog.ModuleType.ES6);try{var c=e.contents_;e.contents_=null;goog.globalEval(c);if(f)var d=goog.moduleLoaderState_.moduleName}finally{f&&a.clearModuleState()}f&&goog.global.$jscomp.require.ensure([e.getPathName()],function(){a.registerEs6ModuleExports(e.path,goog.global.$jscomp.require(e.getPathName()),
d)});a.loaded()}}function d(){var a=goog.global.document,b=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(b);c()}),d='<script type="text/javascript">'+goog.protectScriptTag_('goog.Dependency.callback_("'+b+'");')+"\x3c/script>";a.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(d):d)}var e=this;if(goog.global.CLOSURE_IMPORT_SCRIPT)b(),this.contents_&&goog.global.CLOSURE_IMPORT_SCRIPT("",this.contents_)?(this.contents_=null,a.loaded()):a.pause();
else{var f=this.loadFlags.module==goog.ModuleType.ES6;this.lazyFetch_||b();var g=1<a.pending().length,h=g&&goog.DebugLoader_.IS_OLD_IE_;g=goog.Dependency.defer_&&(g||goog.isDocumentLoading_());if(h||g)a.defer(function(){c()});else{var k=goog.global.document;h=goog.inHtmlDocument_()&&"ActiveXObject"in goog.global;if(f&&goog.inHtmlDocument_()&&goog.isDocumentLoading_()&&!h){goog.Dependency.defer_=!0;a.pause();var l=k.onreadystatechange;k.onreadystatechange=function(){"interactive"==k.readyState&&(k.onreadystatechange=
l,c(),a.resume());goog.isFunction(l)&&l.apply(void 0,arguments)}}else!goog.DebugLoader_.IS_OLD_IE_&&goog.inHtmlDocument_()&&goog.isDocumentLoading_()?d():c()}}},goog.TransformedDependency.prototype.transform=function(a){},goog.TranspiledDependency=function(a,b,c,d,e,f){goog.TransformedDependency.call(this,a,b,c,d,e);this.transpiler=f},goog.inherits(goog.TranspiledDependency,goog.TransformedDependency),goog.TranspiledDependency.prototype.transform=function(a){return this.transpiler.transpile(a,this.getPathName())},
goog.PreTranspiledEs6ModuleDependency=function(a,b,c,d,e){goog.TransformedDependency.call(this,a,b,c,d,e)},goog.inherits(goog.PreTranspiledEs6ModuleDependency,goog.TransformedDependency),goog.PreTranspiledEs6ModuleDependency.prototype.transform=function(a){return a},goog.GoogModuleDependency=function(a,b,c,d,e,f,g){goog.TransformedDependency.call(this,a,b,c,d,e);this.needsTranspile_=f;this.transpiler_=g},goog.inherits(goog.GoogModuleDependency,goog.TransformedDependency),goog.GoogModuleDependency.prototype.transform=
function(a){this.needsTranspile_&&(a=this.transpiler_.transpile(a,this.getPathName()));return goog.LOAD_MODULE_USING_EVAL&&goog.isDef(goog.global.JSON)?"goog.loadModule("+goog.global.JSON.stringify(a+"\n//# sourceURL="+this.path+"\n")+");":'goog.loadModule(function(exports) {"use strict";'+a+"\n;return exports});\n//# sourceURL="+this.path+"\n"},goog.DebugLoader_.IS_OLD_IE_=!(goog.global.atob||!goog.global.document||!goog.global.document.all),goog.DebugLoader_.prototype.addDependency=function(a,b,
c,d){b=b||[];a=a.replace(/\\/g,"/");var e=goog.normalizePath_(goog.basePath+a);d&&"boolean"!==typeof d||(d=d?{module:goog.ModuleType.GOOG}:{});c=this.factory_.createDependency(e,a,b,c,d,goog.transpiler_.needsTranspile(d.lang||"es3",d.module));this.dependencies_[e]=c;for(c=0;c<b.length;c++)this.idToPath_[b[c]]=e;this.idToPath_[a]=e},goog.DependencyFactory=function(a){this.transpiler=a},goog.DependencyFactory.prototype.createDependency=function(a,b,c,d,e,f){return e.module==goog.ModuleType.GOOG?new goog.GoogModuleDependency(a,
b,c,d,e,f,this.transpiler):f?new goog.TranspiledDependency(a,b,c,d,e,this.transpiler):e.module==goog.ModuleType.ES6?"never"==goog.TRANSPILE&&goog.ASSUME_ES_MODULES_TRANSPILED?new goog.PreTranspiledEs6ModuleDependency(a,b,c,d,e):new goog.Es6ModuleDependency(a,b,c,d,e):new goog.Dependency(a,b,c,d,e)},goog.debugLoader_=new goog.DebugLoader_,goog.loadClosureDeps=function(){goog.debugLoader_.loadClosureDeps()},goog.setDependencyFactory=function(a){goog.debugLoader_.setDependencyFactory(a)},goog.global.CLOSURE_NO_DEPS||
goog.debugLoader_.loadClosureDeps(),goog.bootstrap=function(a,b){goog.debugLoader_.bootstrap(a,b)});goog.TRUSTED_TYPES_POLICY_NAME="";goog.identity_=function(a){return a};goog.createTrustedTypesPolicy=function(a){var b=null;if("undefined"===typeof TrustedTypes||!TrustedTypes.createPolicy)return b;try{b=TrustedTypes.createPolicy(a,{createHTML:goog.identity_,createScript:goog.identity_,createScriptURL:goog.identity_,createURL:goog.identity_})}catch(c){goog.logToConsole_(c.message)}return b};
goog.TRUSTED_TYPES_POLICY_=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#base"):null;var jspb={BinaryConstants:{},ConstBinaryMessage:function(){},BinaryMessage:function(){}};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a));this.reportErrorToServer=!0};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){goog.debug.Error.call(this,goog.asserts.subs_(a,b));this.messagePattern=a};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
goog.asserts.subs_=function(a,b){a=a.split("%s");for(var c="",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:"%s");return c+a[d]};goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d}else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a)};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a)};
goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertExists=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&null==a&&goog.asserts.doAssertFailure_("Expected to exist: %s.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)))};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertFinite=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||"number"==typeof a&&isFinite(a)||goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.")};goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=2012<goog.FEATURESET_YEAR;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};
goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return-1};
goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};goog.array.forEachRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;--d)d in e&&b.call(c,e[d],d,a)};
goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k)}return e};
goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a)});return e};
goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a)});return e};
goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1};
goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d},c);return d};
goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
goog.array.findIndexRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return-1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b)};
goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b)};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b)};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d)};goog.array.remove=function(a,b){b=goog.array.indexOf(a,b);var c;(c=0<=b)&&goog.array.removeAt(a,b);return c};
goog.array.removeLast=function(a,b){b=goog.array.lastIndexOf(a,b);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++});return d};
goog.array.concat=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.join=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g]}else a.push(d)}};
goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;d={};for(var e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g)}b.length=e};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1;var l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l)}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare)};goog.array.stableSort=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]={index:d,value:a[d]};var e=b||goog.array.defaultCompare;goog.array.sort(c,function(a,b){return e(a.value,b.value)||a.index-b.index});for(d=0;d<a.length;d++)a[d]=c[d].value};
goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))})};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c)};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return!1}return!0};
goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return!1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return!1;return!0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
goog.array.inverseDefaultCompare=function(a,b){return-goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f)}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return[];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192){var f=goog.array.slice(d,e,e+8192);f=goog.array.flatten.apply(null,f);for(var g=0;g<f.length;g++)b.push(f[g])}else b.push(d)}return b};
goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0])};
goog.array.zip=function(a){if(!arguments.length)return[];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e)}return b};goog.array.shuffle=function(a,b){b=b||Math.random;for(var c=a.length-1;0<c;c--){var d=Math.floor(b()*(c+1)),e=a[c];a[c]=a[d];a[d]=e}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b])});return c};
goog.array.concatMap=function(a,b,c){return goog.array.concat.apply([],goog.array.map(a,b,c))};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);255<e&&(b[c++]=e&255,e>>=8);b[c++]=e}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192){var d=goog.array.slice(a,c,c+8192);b+=String.fromCharCode.apply(null,d)}return b};
goog.crypt.byteArrayToHex=function(a,b){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join(b||"")};goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};
goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63)}else if(239<e&&365>e){f=a[c++];var g=a[c++],h=a[c++];e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023))}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63)}return b.join("")};
goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.string={};goog.string.internal={};goog.string.internal.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.internal.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.internal.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(0,b.length))};goog.string.internal.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};
goog.string.internal.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.internal.isEmptyOrWhitespace=function(a){return/^[\s\xa0]*$/.test(a)};goog.string.internal.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return/^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};goog.string.internal.caseInsensitiveCompare=function(a,b){a=String(a).toLowerCase();b=String(b).toLowerCase();return a<b?-1:a==b?0:1};
goog.string.internal.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
goog.string.internal.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.internal.AMP_RE_,"&amp;").replace(goog.string.internal.LT_RE_,"&lt;").replace(goog.string.internal.GT_RE_,"&gt;").replace(goog.string.internal.QUOT_RE_,"&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.internal.NULL_RE_,"&#0;");else{if(!goog.string.internal.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.internal.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.internal.LT_RE_,
"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.internal.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.internal.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.internal.NULL_RE_,"&#0;"))}return a};goog.string.internal.AMP_RE_=/&/g;goog.string.internal.LT_RE_=/</g;goog.string.internal.GT_RE_=/>/g;goog.string.internal.QUOT_RE_=/"/g;goog.string.internal.SINGLE_QUOTE_RE_=/'/g;
goog.string.internal.NULL_RE_=/\x00/g;goog.string.internal.ALL_RE_=/[\x00&<>"']/;goog.string.internal.whitespaceEscape=function(a,b){return goog.string.internal.newLineToBr(a.replace(/  /g," &#160;"),b)};goog.string.internal.contains=function(a,b){return-1!=a.indexOf(b)};goog.string.internal.caseInsensitiveContains=function(a,b){return goog.string.internal.contains(a.toLowerCase(),b.toLowerCase())};
goog.string.internal.compareVersions=function(a,b){var c=0;a=goog.string.internal.trim(String(a)).split(".");b=goog.string.internal.trim(String(b)).split(".");for(var d=Math.max(a.length,b.length),e=0;0==c&&e<d;e++){var f=a[e]||"",g=b[e]||"";do{f=/(\d*)(\D*)(.*)/.exec(f)||["","","",""];g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];if(0==f[0].length&&0==g[0].length)break;c=0==f[1].length?0:parseInt(f[1],10);var h=0==g[1].length?0:parseInt(g[1],10);c=goog.string.internal.compareElements_(c,h)||goog.string.internal.compareElements_(0==
f[2].length,0==g[2].length)||goog.string.internal.compareElements_(f[2],g[2]);f=f[3];g=g[3]}while(0==c)}return c};goog.string.internal.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.TypedString=function(){};goog.string.Const=function(a,b){this.stringConstValueWithSecurityContract__googStringSecurityPrivate_=a===goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_&&b||"";this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_=goog.string.Const.TYPE_MARKER_};goog.string.Const.prototype.implementsGoogStringTypedString=!0;goog.string.Const.prototype.getTypedStringValue=function(){return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_};
goog.string.Const.prototype.toString=function(){return"Const{"+this.stringConstValueWithSecurityContract__googStringSecurityPrivate_+"}"};goog.string.Const.unwrap=function(a){if(a instanceof goog.string.Const&&a.constructor===goog.string.Const&&a.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_===goog.string.Const.TYPE_MARKER_)return a.stringConstValueWithSecurityContract__googStringSecurityPrivate_;goog.asserts.fail("expected object of type Const, got '"+a+"'");return"type_error:Const"};
goog.string.Const.from=function(a){return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_,a)};goog.string.Const.TYPE_MARKER_={};goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_={};goog.string.Const.EMPTY=goog.string.Const.from("");goog.fs={};goog.fs.url={};goog.fs.url.createObjectUrl=function(a){return goog.fs.url.getUrlObject_().createObjectURL(a)};goog.fs.url.revokeObjectUrl=function(a){goog.fs.url.getUrlObject_().revokeObjectURL(a)};goog.fs.url.getUrlObject_=function(){var a=goog.fs.url.findUrlObject_();if(null!=a)return a;throw Error("This browser doesn't seem to support blob URLs");};
goog.fs.url.findUrlObject_=function(){return goog.isDef(goog.global.URL)&&goog.isDef(goog.global.URL.createObjectURL)?goog.global.URL:goog.isDef(goog.global.webkitURL)&&goog.isDef(goog.global.webkitURL.createObjectURL)?goog.global.webkitURL:goog.isDef(goog.global.createObjectURL)?goog.global:null};goog.fs.url.browserSupportsObjectUrls=function(){return null!=goog.fs.url.findUrlObject_()};goog.html={};goog.html.trustedtypes={};goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#html"):null;goog.i18n={};goog.i18n.bidi={};goog.i18n.bidi.FORCE_RTL=!1;
goog.i18n.bidi.IS_RTL=goog.i18n.bidi.FORCE_RTL||("ar"==goog.LOCALE.substring(0,2).toLowerCase()||"fa"==goog.LOCALE.substring(0,2).toLowerCase()||"he"==goog.LOCALE.substring(0,2).toLowerCase()||"iw"==goog.LOCALE.substring(0,2).toLowerCase()||"ps"==goog.LOCALE.substring(0,2).toLowerCase()||"sd"==goog.LOCALE.substring(0,2).toLowerCase()||"ug"==goog.LOCALE.substring(0,2).toLowerCase()||"ur"==goog.LOCALE.substring(0,2).toLowerCase()||"yi"==goog.LOCALE.substring(0,2).toLowerCase())&&(2==goog.LOCALE.length||
"-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))||3<=goog.LOCALE.length&&"ckb"==goog.LOCALE.substring(0,3).toLowerCase()&&(3==goog.LOCALE.length||"-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))||7<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))&&("adlm"==goog.LOCALE.substring(3,7).toLowerCase()||"arab"==goog.LOCALE.substring(3,7).toLowerCase()||"hebr"==goog.LOCALE.substring(3,7).toLowerCase()||"nkoo"==goog.LOCALE.substring(3,
7).toLowerCase()||"rohg"==goog.LOCALE.substring(3,7).toLowerCase()||"thaa"==goog.LOCALE.substring(3,7).toLowerCase())||8<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))&&("adlm"==goog.LOCALE.substring(4,8).toLowerCase()||"arab"==goog.LOCALE.substring(4,8).toLowerCase()||"hebr"==goog.LOCALE.substring(4,8).toLowerCase()||"nkoo"==goog.LOCALE.substring(4,8).toLowerCase()||"rohg"==goog.LOCALE.substring(4,8).toLowerCase()||"thaa"==goog.LOCALE.substring(4,8).toLowerCase());
goog.i18n.bidi.Format={LRE:"\u202a",RLE:"\u202b",PDF:"\u202c",LRM:"\u200e",RLM:"\u200f"};goog.i18n.bidi.Dir={LTR:1,RTL:-1,NEUTRAL:0};goog.i18n.bidi.RIGHT="right";goog.i18n.bidi.LEFT="left";goog.i18n.bidi.I18N_RIGHT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.LEFT:goog.i18n.bidi.RIGHT;goog.i18n.bidi.I18N_LEFT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT;
goog.i18n.bidi.toDir=function(a,b){return"number"==typeof a?0<a?goog.i18n.bidi.Dir.LTR:0>a?goog.i18n.bidi.Dir.RTL:b?null:goog.i18n.bidi.Dir.NEUTRAL:null==a?null:a?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};goog.i18n.bidi.ltrChars_="A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";goog.i18n.bidi.rtlChars_="\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b\ufb1d-\ufdff\ufe70-\ufefc";
goog.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g;goog.i18n.bidi.stripHtmlIfNeeded_=function(a,b){return b?a.replace(goog.i18n.bidi.htmlSkipReg_,""):a};goog.i18n.bidi.rtlCharReg_=new RegExp("["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.ltrCharReg_=new RegExp("["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.hasAnyRtl=function(a,b){return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.hasRtlChar=goog.i18n.bidi.hasAnyRtl;
goog.i18n.bidi.hasAnyLtr=function(a,b){return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.ltrRe_=new RegExp("^["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlRe_=new RegExp("^["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.isRtlChar=function(a){return goog.i18n.bidi.rtlRe_.test(a)};goog.i18n.bidi.isLtrChar=function(a){return goog.i18n.bidi.ltrRe_.test(a)};goog.i18n.bidi.isNeutralChar=function(a){return!goog.i18n.bidi.isLtrChar(a)&&!goog.i18n.bidi.isRtlChar(a)};
goog.i18n.bidi.ltrDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.rtlChars_+"]*["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.ltrChars_+"]*["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.startsWithRtl=function(a,b){return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlText=goog.i18n.bidi.startsWithRtl;
goog.i18n.bidi.startsWithLtr=function(a,b){return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrText=goog.i18n.bidi.startsWithLtr;goog.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/;goog.i18n.bidi.isNeutralText=function(a,b){a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b);return goog.i18n.bidi.isRequiredLtrRe_.test(a)||!goog.i18n.bidi.hasAnyLtr(a)&&!goog.i18n.bidi.hasAnyRtl(a)};
goog.i18n.bidi.ltrExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.ltrChars_+"][^"+goog.i18n.bidi.rtlChars_+"]*$");goog.i18n.bidi.rtlExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.rtlChars_+"][^"+goog.i18n.bidi.ltrChars_+"]*$");goog.i18n.bidi.endsWithLtr=function(a,b){return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrExitText=goog.i18n.bidi.endsWithLtr;
goog.i18n.bidi.endsWithRtl=function(a,b){return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlExitText=goog.i18n.bidi.endsWithRtl;goog.i18n.bidi.rtlLocalesRe_=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;goog.i18n.bidi.isRtlLanguage=function(a){return goog.i18n.bidi.rtlLocalesRe_.test(a)};goog.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
goog.i18n.bidi.guardBracketInText=function(a,b){b=(void 0===b?goog.i18n.bidi.hasAnyRtl(a):b)?goog.i18n.bidi.Format.RLM:goog.i18n.bidi.Format.LRM;return a.replace(goog.i18n.bidi.bracketGuardTextRe_,b+"$&"+b)};goog.i18n.bidi.enforceRtlInHtml=function(a){return"<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=rtl"):"\n<span dir=rtl>"+a+"</span>"};goog.i18n.bidi.enforceRtlInText=function(a){return goog.i18n.bidi.Format.RLE+a+goog.i18n.bidi.Format.PDF};
goog.i18n.bidi.enforceLtrInHtml=function(a){return"<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=ltr"):"\n<span dir=ltr>"+a+"</span>"};goog.i18n.bidi.enforceLtrInText=function(a){return goog.i18n.bidi.Format.LRE+a+goog.i18n.bidi.Format.PDF};goog.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;goog.i18n.bidi.leftRe_=/left/gi;goog.i18n.bidi.rightRe_=/right/gi;goog.i18n.bidi.tempRe_=/%%%%/g;
goog.i18n.bidi.mirrorCSS=function(a){return a.replace(goog.i18n.bidi.dimensionsRe_,":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_,"%%%%").replace(goog.i18n.bidi.rightRe_,goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_,goog.i18n.bidi.RIGHT)};goog.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g;goog.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g;
goog.i18n.bidi.normalizeHebrewQuote=function(a){return a.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_,"$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_,"$1\u05f3")};goog.i18n.bidi.wordSeparatorRe_=/\s+/;goog.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/;goog.i18n.bidi.rtlDetectionThreshold_=.4;
goog.i18n.bidi.estimateDirection=function(a,b){var c=0,d=0,e=!1;a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b).split(goog.i18n.bidi.wordSeparatorRe_);for(b=0;b<a.length;b++){var f=a[b];goog.i18n.bidi.startsWithRtl(f)?(c++,d++):goog.i18n.bidi.isRequiredLtrRe_.test(f)?e=!0:goog.i18n.bidi.hasAnyLtr(f)?d++:goog.i18n.bidi.hasNumeralsRe_.test(f)&&(e=!0)}return 0==d?e?goog.i18n.bidi.Dir.LTR:goog.i18n.bidi.Dir.NEUTRAL:c/d>goog.i18n.bidi.rtlDetectionThreshold_?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};
goog.i18n.bidi.detectRtlDirectionality=function(a,b){return goog.i18n.bidi.estimateDirection(a,b)==goog.i18n.bidi.Dir.RTL};goog.i18n.bidi.setElementDirAndAlign=function(a,b){a&&(b=goog.i18n.bidi.toDir(b))&&(a.style.textAlign=b==goog.i18n.bidi.Dir.RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT,a.dir=b==goog.i18n.bidi.Dir.RTL?"rtl":"ltr")};
goog.i18n.bidi.setElementDirByTextDirectionality=function(a,b){switch(goog.i18n.bidi.estimateDirection(b)){case goog.i18n.bidi.Dir.LTR:a.dir="ltr";break;case goog.i18n.bidi.Dir.RTL:a.dir="rtl";break;default:a.removeAttribute("dir")}};goog.i18n.bidi.DirectionalString=function(){};goog.html.TrustedResourceUrl=function(){this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_="";this.trustedURL_=null;this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString=!0;goog.html.TrustedResourceUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString()};
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.TrustedResourceUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};
goog.html.TrustedResourceUrl.prototype.cloneWithParams=function(a,b){var c=goog.html.TrustedResourceUrl.unwrap(this);c=goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c);var d=c[3]||"";return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c[1]+goog.html.TrustedResourceUrl.stringifyParams_("?",c[2]||"",a)+goog.html.TrustedResourceUrl.stringifyParams_("#",d,b))};
goog.DEBUG&&(goog.html.TrustedResourceUrl.prototype.toString=function(){return"TrustedResourceUrl{"+this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_+"}"});goog.html.TrustedResourceUrl.unwrap=function(a){return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(a).toString()};
goog.html.TrustedResourceUrl.unwrapTrustedScriptURL=function(a){if(a instanceof goog.html.TrustedResourceUrl&&a.constructor===goog.html.TrustedResourceUrl&&a.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;goog.asserts.fail("expected object of type TrustedResourceUrl, got '"+a+"' of type "+goog.typeOf(a));return"type_error:TrustedResourceUrl"};
goog.html.TrustedResourceUrl.unwrapTrustedURL=function(a){return a.trustedURL_?a.trustedURL_:goog.html.TrustedResourceUrl.unwrap(a)};
goog.html.TrustedResourceUrl.format=function(a,b){var c=goog.string.Const.unwrap(a);if(!goog.html.TrustedResourceUrl.BASE_URL_.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof goog.string.Const?goog.string.Const.unwrap(a):
encodeURIComponent(String(a))});return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.TrustedResourceUrl.FORMAT_MARKER_=/%{(\w+)}/g;goog.html.TrustedResourceUrl.BASE_URL_=/^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;goog.html.TrustedResourceUrl.URL_PARAM_PARSER_=/^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
goog.html.TrustedResourceUrl.formatWithParams=function(a,b,c,d){return goog.html.TrustedResourceUrl.format(a,b).cloneWithParams(c,d)};goog.html.TrustedResourceUrl.fromConstant=function(a){return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};goog.html.TrustedResourceUrl.fromConstants=function(a){for(var b="",c=0;c<a.length;c++)b+=goog.string.Const.unwrap(a[c]);return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.TrustedResourceUrl;b.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a):a;goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY&&(b.trustedURL_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a));return b};
goog.html.TrustedResourceUrl.stringifyParams_=function(a,b,c){if(null==c)return b;if(goog.isString(c))return c?a+encodeURIComponent(c):"";for(var d in c){var e=c[d];e=goog.isArray(e)?e:[e];for(var f=0;f<e.length;f++){var g=e[f];null!=g&&(b||(b=a),b+=(b.length>a.length?"&":"")+encodeURIComponent(d)+"="+encodeURIComponent(String(g)))}}return b};goog.html.SafeUrl=function(){this.privateDoNotAccessOrElseSafeUrlWrappedValue_="";this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeUrl.INNOCUOUS_STRING="about:invalid#zClosurez";goog.html.SafeUrl.prototype.implementsGoogStringTypedString=!0;goog.html.SafeUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString()};
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};goog.DEBUG&&(goog.html.SafeUrl.prototype.toString=function(){return"SafeUrl{"+this.privateDoNotAccessOrElseSafeUrlWrappedValue_+"}"});goog.html.SafeUrl.unwrap=function(a){return goog.html.SafeUrl.unwrapTrustedURL(a).toString()};
goog.html.SafeUrl.unwrapTrustedURL=function(a){if(a instanceof goog.html.SafeUrl&&a.constructor===goog.html.SafeUrl&&a.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeUrlWrappedValue_;goog.asserts.fail("expected object of type SafeUrl, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeUrl"};goog.html.SafeUrl.fromConstant=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};
goog.html.SAFE_MIME_TYPE_PATTERN_=/^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i;goog.html.SafeUrl.isSafeMimeType=function(a){return goog.html.SAFE_MIME_TYPE_PATTERN_.test(a)};goog.html.SafeUrl.fromBlob=function(a){a=goog.html.SAFE_MIME_TYPE_PATTERN_.test(a.type)?goog.fs.url.createObjectUrl(a):goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.DATA_URL_PATTERN_=/^data:([^,]*);base64,[a-z0-9+\/]+=*$/i;goog.html.SafeUrl.fromDataUrl=function(a){a=a.replace(/(%0A|%0D)/g,"");var b=a.match(goog.html.DATA_URL_PATTERN_);b=b&&goog.html.SAFE_MIME_TYPE_PATTERN_.test(b[1]);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b?a:goog.html.SafeUrl.INNOCUOUS_STRING)};goog.html.SafeUrl.fromTelUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"tel:")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SIP_URL_PATTERN_=/^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;goog.html.SafeUrl.fromSipUrl=function(a){goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(a))||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromFacebookMessengerUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"fb-messenger://share")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.fromWhatsAppUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"whatsapp://send")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromSmsUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"sms:")&&goog.html.SafeUrl.isSmsUrlBodyValid_(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.isSmsUrlBodyValid_=function(a){var b=a.indexOf("#");0<b&&(a=a.substring(0,b));b=a.match(/[?&]body=/gi);if(!b)return!0;if(1<b.length)return!1;a=a.match(/[?&]body=([^&]*)/)[1];if(!a)return!0;try{decodeURIComponent(a)}catch(c){return!1}return/^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a)};goog.html.SafeUrl.fromSshUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"ssh://")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeChromeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeFirefoxExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeEdgeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//,a,b)};
goog.html.SafeUrl.sanitizeExtensionUrl_=function(a,b,c){(a=a.exec(b))?(a=a[1],-1==(c instanceof goog.string.Const?[goog.string.Const.unwrap(c)]:c.map(function(a){return goog.string.Const.unwrap(a)})).indexOf(a)&&(b=goog.html.SafeUrl.INNOCUOUS_STRING)):b=goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};goog.html.SafeUrl.fromTrustedResourceUrl=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(a))};
goog.html.SAFE_URL_PATTERN_=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;goog.html.SafeUrl.SAFE_URL_PATTERN=goog.html.SAFE_URL_PATTERN_;goog.html.SafeUrl.sanitize=function(a){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);goog.html.SAFE_URL_PATTERN_.test(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeAssertUnchanged=function(a,b){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);if(b&&/^data:/i.test(a)&&(b=goog.html.SafeUrl.fromDataUrl(a),b.getTypedStringValue()==a))return b;goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(a),"%s does not match the safe URL pattern",a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.SafeUrl;b.privateDoNotAccessOrElseSafeUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a):a;return b};goog.html.SafeUrl.ABOUT_BLANK=goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");goog.html.SafeStyle=function(){this.privateDoNotAccessOrElseSafeStyleWrappedValue_="";this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeStyle.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyle.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyle.EMPTY;goog.asserts.assert(goog.string.internal.endsWith(a,";"),"Last character of style string is not ';': "+a);goog.asserts.assert(goog.string.internal.contains(a,":"),"Style string must contain at least one ':', to specify a \"name: value\" pair: "+a);return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeStyle.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleWrappedValue_};goog.DEBUG&&(goog.html.SafeStyle.prototype.toString=function(){return"SafeStyle{"+this.privateDoNotAccessOrElseSafeStyleWrappedValue_+"}"});
goog.html.SafeStyle.unwrap=function(a){if(a instanceof goog.html.SafeStyle&&a.constructor===goog.html.SafeStyle&&a.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleWrappedValue_;goog.asserts.fail("expected object of type SafeStyle, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeStyle"};goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleWrappedValue_=a;return this};goog.html.SafeStyle.EMPTY=goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");goog.html.SafeStyle.INNOCUOUS_STRING="zClosurez";
goog.html.SafeStyle.create=function(a){var b="",c;for(c in a){if(!/^[-_a-zA-Z0-9]+$/.test(c))throw Error("Name allows only [-_a-zA-Z0-9], got: "+c);var d=a[c];null!=d&&(d=goog.isArray(d)?goog.array.map(d,goog.html.SafeStyle.sanitizePropertyValue_).join(" "):goog.html.SafeStyle.sanitizePropertyValue_(d),b+=c+":"+d+";")}return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};
goog.html.SafeStyle.sanitizePropertyValue_=function(a){if(a instanceof goog.html.SafeUrl)return'url("'+goog.html.SafeUrl.unwrap(a).replace(/</g,"%3c").replace(/[\\"]/g,"\\$&")+'")';a=a instanceof goog.string.Const?goog.string.Const.unwrap(a):goog.html.SafeStyle.sanitizePropertyValueString_(String(a));if(/[{;}]/.test(a))throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.",[a]);return a};
goog.html.SafeStyle.sanitizePropertyValueString_=function(a){var b=a.replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.URL_RE_,"url");if(goog.html.SafeStyle.VALUE_RE_.test(b)){if(goog.html.SafeStyle.COMMENT_RE_.test(a))return goog.asserts.fail("String value disallows comments, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedQuotes_(a))return goog.asserts.fail("String value requires balanced quotes, got: "+
a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedSquareBrackets_(a))return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING}else return goog.asserts.fail("String value allows only "+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+" and simple functions, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;return goog.html.SafeStyle.sanitizeUrl_(a)};
goog.html.SafeStyle.hasBalancedQuotes_=function(a){for(var b=!0,c=!0,d=0;d<a.length;d++){var e=a.charAt(d);"'"==e&&c?b=!b:'"'==e&&b&&(c=!c)}return b&&c};goog.html.SafeStyle.hasBalancedSquareBrackets_=function(a){for(var b=!0,c=/^[-_a-zA-Z0-9]$/,d=0;d<a.length;d++){var e=a.charAt(d);if("]"==e){if(b)return!1;b=!0}else if("["==e){if(!b)return!1;b=!1}else if(!b&&!c.test(e))return!1}return b};goog.html.SafeStyle.VALUE_ALLOWED_CHARS_="[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
goog.html.SafeStyle.VALUE_RE_=new RegExp("^"+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+"+$");goog.html.SafeStyle.URL_RE_=/\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;goog.html.SafeStyle.FUNCTIONS_RE_=/\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g;goog.html.SafeStyle.COMMENT_RE_=/\/\*/;
goog.html.SafeStyle.sanitizeUrl_=function(a){return a.replace(goog.html.SafeStyle.URL_RE_,function(a,c,d,e){var b="";d=d.replace(/^(['"])(.*)\1$/,function(a,c,d){b=c;return d});a=goog.html.SafeUrl.sanitize(d).getTypedStringValue();return c+b+a+b+e})};goog.html.SafeStyle.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyle.unwrap(a)};goog.array.forEach(arguments,c);return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};goog.html.SafeScript=function(){this.privateDoNotAccessOrElseSafeScriptWrappedValue_="";this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeScript.prototype.implementsGoogStringTypedString=!0;goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeScript.fromConstant=function(a){a=goog.string.Const.unwrap(a);return 0===a.length?goog.html.SafeScript.EMPTY:goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeScript.fromConstantAndArgs=function(a,b){for(var c=[],d=1;d<arguments.length;d++)c.push(goog.html.SafeScript.stringify_(arguments[d]));return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("("+goog.string.Const.unwrap(a)+")("+c.join(", ")+");")};goog.html.SafeScript.fromJson=function(a){return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(a))};goog.html.SafeScript.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeScript.prototype.toString=function(){return"SafeScript{"+this.privateDoNotAccessOrElseSafeScriptWrappedValue_+"}"});goog.html.SafeScript.unwrap=function(a){return goog.html.SafeScript.unwrapTrustedScript(a).toString()};
goog.html.SafeScript.unwrapTrustedScript=function(a){if(a instanceof goog.html.SafeScript&&a.constructor===goog.html.SafeScript&&a.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeScriptWrappedValue_;goog.asserts.fail("expected object of type SafeScript, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeScript"};
goog.html.SafeScript.stringify_=function(a){return JSON.stringify(a).replace(/</g,"\\x3c")};goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeScriptWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a):a;return this};goog.html.SafeScript.EMPTY=goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");goog.object={};goog.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a)};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return!0;return!1};
goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return!1;return!0};goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};
goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};goog.object.getValueByKeys=function(a,b){var c=goog.isArrayLike(b),d=c?b:arguments;for(c=c?0:1;c<d.length;c++){if(null==a)return;a=a[d[c]]}return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return!0;return!1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};
goog.object.findValue=function(a,b,c){return(b=goog.object.findKey(a,b,c))&&a[b]};goog.object.isEmpty=function(a){for(var b in a)return!1;return!0};goog.object.clear=function(a){for(var b in a)delete a[b]};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c)};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};
goog.object.set=function(a,b,c){a[b]=c};goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(var d in b)if(!(d in a))return!1;return!0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};
goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return!!Object.isFrozen&&Object.isFrozen(a)};
goog.object.getAllPropertyNames=function(a,b,c){if(!a)return[];if(!Object.getOwnPropertyNames||!Object.getPrototypeOf)return goog.object.getKeys(a);for(var d={};a&&(a!==Object.prototype||b)&&(a!==Function.prototype||c);){for(var e=Object.getOwnPropertyNames(a),f=0;f<e.length;f++)d[e[f]]=!0;a=Object.getPrototypeOf(a)}return goog.object.getKeys(d)};goog.object.getSuperClass=function(a){return(a=Object.getPrototypeOf(a.prototype))&&a.constructor};goog.html.SafeStyleSheet=function(){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_="";this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyleSheet.createRule=function(a,b){if(goog.string.internal.contains(a,"<"))throw Error("Selector does not allow '<', got: "+a);var c=a.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g,"");if(!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c))throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: "+a);if(!goog.html.SafeStyleSheet.hasBalancedBrackets_(c))throw Error("() and [] in selector must be balanced, got: "+a);b instanceof goog.html.SafeStyle||(b=goog.html.SafeStyle.create(b));
a=a+"{"+goog.html.SafeStyle.unwrap(b).replace(/</g,"\\3C ")+"}";return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.hasBalancedBrackets_=function(a){for(var b={"(":")","[":"]"},c=[],d=0;d<a.length;d++){var e=a[d];if(b[e])c.push(b[e]);else if(goog.object.contains(b,e)&&c.pop()!=e)return!1}return 0==c.length};
goog.html.SafeStyleSheet.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyleSheet.unwrap(a)};goog.array.forEach(arguments,c);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.SafeStyleSheet.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyleSheet.EMPTY;goog.asserts.assert(!goog.string.internal.contains(a,"<"),"Forbidden '<' character in style sheet string: "+a);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_};
goog.DEBUG&&(goog.html.SafeStyleSheet.prototype.toString=function(){return"SafeStyleSheet{"+this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_+"}"});
goog.html.SafeStyleSheet.unwrap=function(a){if(a instanceof goog.html.SafeStyleSheet&&a.constructor===goog.html.SafeStyleSheet&&a.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;goog.asserts.fail("expected object of type SafeStyleSheet, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeStyleSheet"};
goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(a)};goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_=a;return this};goog.html.SafeStyleSheet.EMPTY=goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");goog.dom.tags={};goog.dom.tags.VOID_TAGS_={area:!0,base:!0,br:!0,col:!0,command:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};goog.dom.tags.isVoidTag=function(a){return!0===goog.dom.tags.VOID_TAGS_[a]};goog.dom.HtmlElement=function(){};goog.dom.TagName=function(a){this.tagName_=a};goog.dom.TagName.prototype.toString=function(){return this.tagName_};goog.dom.TagName.A=new goog.dom.TagName("A");goog.dom.TagName.ABBR=new goog.dom.TagName("ABBR");goog.dom.TagName.ACRONYM=new goog.dom.TagName("ACRONYM");goog.dom.TagName.ADDRESS=new goog.dom.TagName("ADDRESS");goog.dom.TagName.APPLET=new goog.dom.TagName("APPLET");goog.dom.TagName.AREA=new goog.dom.TagName("AREA");goog.dom.TagName.ARTICLE=new goog.dom.TagName("ARTICLE");
goog.dom.TagName.ASIDE=new goog.dom.TagName("ASIDE");goog.dom.TagName.AUDIO=new goog.dom.TagName("AUDIO");goog.dom.TagName.B=new goog.dom.TagName("B");goog.dom.TagName.BASE=new goog.dom.TagName("BASE");goog.dom.TagName.BASEFONT=new goog.dom.TagName("BASEFONT");goog.dom.TagName.BDI=new goog.dom.TagName("BDI");goog.dom.TagName.BDO=new goog.dom.TagName("BDO");goog.dom.TagName.BIG=new goog.dom.TagName("BIG");goog.dom.TagName.BLOCKQUOTE=new goog.dom.TagName("BLOCKQUOTE");goog.dom.TagName.BODY=new goog.dom.TagName("BODY");
goog.dom.TagName.BR=new goog.dom.TagName("BR");goog.dom.TagName.BUTTON=new goog.dom.TagName("BUTTON");goog.dom.TagName.CANVAS=new goog.dom.TagName("CANVAS");goog.dom.TagName.CAPTION=new goog.dom.TagName("CAPTION");goog.dom.TagName.CENTER=new goog.dom.TagName("CENTER");goog.dom.TagName.CITE=new goog.dom.TagName("CITE");goog.dom.TagName.CODE=new goog.dom.TagName("CODE");goog.dom.TagName.COL=new goog.dom.TagName("COL");goog.dom.TagName.COLGROUP=new goog.dom.TagName("COLGROUP");
goog.dom.TagName.COMMAND=new goog.dom.TagName("COMMAND");goog.dom.TagName.DATA=new goog.dom.TagName("DATA");goog.dom.TagName.DATALIST=new goog.dom.TagName("DATALIST");goog.dom.TagName.DD=new goog.dom.TagName("DD");goog.dom.TagName.DEL=new goog.dom.TagName("DEL");goog.dom.TagName.DETAILS=new goog.dom.TagName("DETAILS");goog.dom.TagName.DFN=new goog.dom.TagName("DFN");goog.dom.TagName.DIALOG=new goog.dom.TagName("DIALOG");goog.dom.TagName.DIR=new goog.dom.TagName("DIR");goog.dom.TagName.DIV=new goog.dom.TagName("DIV");
goog.dom.TagName.DL=new goog.dom.TagName("DL");goog.dom.TagName.DT=new goog.dom.TagName("DT");goog.dom.TagName.EM=new goog.dom.TagName("EM");goog.dom.TagName.EMBED=new goog.dom.TagName("EMBED");goog.dom.TagName.FIELDSET=new goog.dom.TagName("FIELDSET");goog.dom.TagName.FIGCAPTION=new goog.dom.TagName("FIGCAPTION");goog.dom.TagName.FIGURE=new goog.dom.TagName("FIGURE");goog.dom.TagName.FONT=new goog.dom.TagName("FONT");goog.dom.TagName.FOOTER=new goog.dom.TagName("FOOTER");goog.dom.TagName.FORM=new goog.dom.TagName("FORM");
goog.dom.TagName.FRAME=new goog.dom.TagName("FRAME");goog.dom.TagName.FRAMESET=new goog.dom.TagName("FRAMESET");goog.dom.TagName.H1=new goog.dom.TagName("H1");goog.dom.TagName.H2=new goog.dom.TagName("H2");goog.dom.TagName.H3=new goog.dom.TagName("H3");goog.dom.TagName.H4=new goog.dom.TagName("H4");goog.dom.TagName.H5=new goog.dom.TagName("H5");goog.dom.TagName.H6=new goog.dom.TagName("H6");goog.dom.TagName.HEAD=new goog.dom.TagName("HEAD");goog.dom.TagName.HEADER=new goog.dom.TagName("HEADER");
goog.dom.TagName.HGROUP=new goog.dom.TagName("HGROUP");goog.dom.TagName.HR=new goog.dom.TagName("HR");goog.dom.TagName.HTML=new goog.dom.TagName("HTML");goog.dom.TagName.I=new goog.dom.TagName("I");goog.dom.TagName.IFRAME=new goog.dom.TagName("IFRAME");goog.dom.TagName.IMG=new goog.dom.TagName("IMG");goog.dom.TagName.INPUT=new goog.dom.TagName("INPUT");goog.dom.TagName.INS=new goog.dom.TagName("INS");goog.dom.TagName.ISINDEX=new goog.dom.TagName("ISINDEX");goog.dom.TagName.KBD=new goog.dom.TagName("KBD");
goog.dom.TagName.KEYGEN=new goog.dom.TagName("KEYGEN");goog.dom.TagName.LABEL=new goog.dom.TagName("LABEL");goog.dom.TagName.LEGEND=new goog.dom.TagName("LEGEND");goog.dom.TagName.LI=new goog.dom.TagName("LI");goog.dom.TagName.LINK=new goog.dom.TagName("LINK");goog.dom.TagName.MAIN=new goog.dom.TagName("MAIN");goog.dom.TagName.MAP=new goog.dom.TagName("MAP");goog.dom.TagName.MARK=new goog.dom.TagName("MARK");goog.dom.TagName.MATH=new goog.dom.TagName("MATH");goog.dom.TagName.MENU=new goog.dom.TagName("MENU");
goog.dom.TagName.MENUITEM=new goog.dom.TagName("MENUITEM");goog.dom.TagName.META=new goog.dom.TagName("META");goog.dom.TagName.METER=new goog.dom.TagName("METER");goog.dom.TagName.NAV=new goog.dom.TagName("NAV");goog.dom.TagName.NOFRAMES=new goog.dom.TagName("NOFRAMES");goog.dom.TagName.NOSCRIPT=new goog.dom.TagName("NOSCRIPT");goog.dom.TagName.OBJECT=new goog.dom.TagName("OBJECT");goog.dom.TagName.OL=new goog.dom.TagName("OL");goog.dom.TagName.OPTGROUP=new goog.dom.TagName("OPTGROUP");
goog.dom.TagName.OPTION=new goog.dom.TagName("OPTION");goog.dom.TagName.OUTPUT=new goog.dom.TagName("OUTPUT");goog.dom.TagName.P=new goog.dom.TagName("P");goog.dom.TagName.PARAM=new goog.dom.TagName("PARAM");goog.dom.TagName.PICTURE=new goog.dom.TagName("PICTURE");goog.dom.TagName.PRE=new goog.dom.TagName("PRE");goog.dom.TagName.PROGRESS=new goog.dom.TagName("PROGRESS");goog.dom.TagName.Q=new goog.dom.TagName("Q");goog.dom.TagName.RP=new goog.dom.TagName("RP");goog.dom.TagName.RT=new goog.dom.TagName("RT");
goog.dom.TagName.RTC=new goog.dom.TagName("RTC");goog.dom.TagName.RUBY=new goog.dom.TagName("RUBY");goog.dom.TagName.S=new goog.dom.TagName("S");goog.dom.TagName.SAMP=new goog.dom.TagName("SAMP");goog.dom.TagName.SCRIPT=new goog.dom.TagName("SCRIPT");goog.dom.TagName.SECTION=new goog.dom.TagName("SECTION");goog.dom.TagName.SELECT=new goog.dom.TagName("SELECT");goog.dom.TagName.SMALL=new goog.dom.TagName("SMALL");goog.dom.TagName.SOURCE=new goog.dom.TagName("SOURCE");goog.dom.TagName.SPAN=new goog.dom.TagName("SPAN");
goog.dom.TagName.STRIKE=new goog.dom.TagName("STRIKE");goog.dom.TagName.STRONG=new goog.dom.TagName("STRONG");goog.dom.TagName.STYLE=new goog.dom.TagName("STYLE");goog.dom.TagName.SUB=new goog.dom.TagName("SUB");goog.dom.TagName.SUMMARY=new goog.dom.TagName("SUMMARY");goog.dom.TagName.SUP=new goog.dom.TagName("SUP");goog.dom.TagName.SVG=new goog.dom.TagName("SVG");goog.dom.TagName.TABLE=new goog.dom.TagName("TABLE");goog.dom.TagName.TBODY=new goog.dom.TagName("TBODY");goog.dom.TagName.TD=new goog.dom.TagName("TD");
goog.dom.TagName.TEMPLATE=new goog.dom.TagName("TEMPLATE");goog.dom.TagName.TEXTAREA=new goog.dom.TagName("TEXTAREA");goog.dom.TagName.TFOOT=new goog.dom.TagName("TFOOT");goog.dom.TagName.TH=new goog.dom.TagName("TH");goog.dom.TagName.THEAD=new goog.dom.TagName("THEAD");goog.dom.TagName.TIME=new goog.dom.TagName("TIME");goog.dom.TagName.TITLE=new goog.dom.TagName("TITLE");goog.dom.TagName.TR=new goog.dom.TagName("TR");goog.dom.TagName.TRACK=new goog.dom.TagName("TRACK");goog.dom.TagName.TT=new goog.dom.TagName("TT");
goog.dom.TagName.U=new goog.dom.TagName("U");goog.dom.TagName.UL=new goog.dom.TagName("UL");goog.dom.TagName.VAR=new goog.dom.TagName("VAR");goog.dom.TagName.VIDEO=new goog.dom.TagName("VIDEO");goog.dom.TagName.WBR=new goog.dom.TagName("WBR");goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_()};
goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.caseInsensitiveContains(b,a)};
goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=/(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g,c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdgeHtml_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchEdgeChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("Edg/")};
goog.labs.userAgent.browser.matchOperaChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")||goog.labs.userAgent.util.matchUserAgent("FxiOS")};
goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdgeHtml_()||goog.labs.userAgent.browser.matchEdgeChromium_()||goog.labs.userAgent.browser.matchOperaChromium_()||goog.labs.userAgent.browser.matchFirefox_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};
goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};goog.labs.userAgent.browser.matchIosWebview_=function(){return(goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&!goog.labs.userAgent.browser.matchFirefox_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
goog.labs.userAgent.browser.matchChrome_=function(){return(goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchEdgeHtml_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdgeHtml_;goog.labs.userAgent.browser.isEdgeChromium=goog.labs.userAgent.browser.matchEdgeChromium_;goog.labs.userAgent.browser.isOperaChromium=goog.labs.userAgent.browser.matchOperaChromium_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;
goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);b=goog.labs.userAgent.util.extractVersionTuples(b);var c={};goog.array.forEach(b,function(a){c[a[0]]=a[1]});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera"]):goog.labs.userAgent.browser.isEdge()?a(["Edge"]):
goog.labs.userAgent.browser.isEdgeChromium()?a(["Edg"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];b="";var c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0"}else b="7.0";else b=c[1];return b};goog.html.SafeHtml=function(){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_="";this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;this.dir_=null};goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeHtml.prototype.getDirection=function(){return this.dir_};goog.html.SafeHtml.prototype.implementsGoogStringTypedString=!0;goog.html.SafeHtml.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeHtml.prototype.toString=function(){return"SafeHtml{"+this.privateDoNotAccessOrElseSafeHtmlWrappedValue_+"}"});goog.html.SafeHtml.unwrap=function(a){return goog.html.SafeHtml.unwrapTrustedHTML(a).toString()};
goog.html.SafeHtml.unwrapTrustedHTML=function(a){if(a instanceof goog.html.SafeHtml&&a.constructor===goog.html.SafeHtml&&a.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeHtmlWrappedValue_;goog.asserts.fail("expected object of type SafeHtml, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeHtml"};
goog.html.SafeHtml.htmlEscape=function(a){if(a instanceof goog.html.SafeHtml)return a;var b="object"==typeof a,c=null;b&&a.implementsGoogI18nBidiDirectionalString&&(c=a.getDirection());a=b&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(a),c)};
goog.html.SafeHtml.htmlEscapePreservingNewlines=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(a)),a.getDirection())};
goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(a)),a.getDirection())};goog.html.SafeHtml.from=goog.html.SafeHtml.htmlEscape;goog.html.SafeHtml.VALID_NAMES_IN_TAG_=/^[a-zA-Z0-9-]+$/;
goog.html.SafeHtml.URL_ATTRIBUTES_={action:!0,cite:!0,data:!0,formaction:!0,href:!0,manifest:!0,poster:!0,src:!0};goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_={APPLET:!0,BASE:!0,EMBED:!0,IFRAME:!0,LINK:!0,MATH:!0,META:!0,OBJECT:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};goog.html.SafeHtml.create=function(a,b,c){goog.html.SafeHtml.verifyTagName(String(a));return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a),b,c)};
goog.html.SafeHtml.verifyTagName=function(a){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a))throw Error("Invalid tag name <"+a+">.");if(a.toUpperCase()in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)throw Error("Tag name <"+a+"> is not allowed for SafeHtml.");};
goog.html.SafeHtml.createIframe=function(a,b,c,d){a&&goog.html.TrustedResourceUrl.unwrap(a);var e={};e.src=a||null;e.srcdoc=b&&goog.html.SafeHtml.unwrap(b);a=goog.html.SafeHtml.combineAttributes(e,{sandbox:""},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.createSandboxIframe=function(a,b,c,d){if(!goog.html.SafeHtml.canUseSandboxIframe())throw Error("The browser does not support sandboxed iframes.");var e={};e.src=a?goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a)):null;e.srcdoc=b||null;e.sandbox="";a=goog.html.SafeHtml.combineAttributes(e,{},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.canUseSandboxIframe=function(){return goog.global.HTMLIFrameElement&&"sandbox"in goog.global.HTMLIFrameElement.prototype};goog.html.SafeHtml.createScriptSrc=function(a,b){goog.html.TrustedResourceUrl.unwrap(a);a=goog.html.SafeHtml.combineAttributes({src:a},{},b);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",a)};
goog.html.SafeHtml.createScript=function(a,b){for(var c in b){var d=c.toLowerCase();if("language"==d||"src"==d||"text"==d||"type"==d)throw Error('Cannot set "'+d+'" attribute');}c="";a=goog.array.concat(a);for(d=0;d<a.length;d++)c+=goog.html.SafeScript.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",b,a)};
goog.html.SafeHtml.createStyle=function(a,b){b=goog.html.SafeHtml.combineAttributes({type:"text/css"},{},b);var c="";a=goog.array.concat(a);for(var d=0;d<a.length;d++)c+=goog.html.SafeStyleSheet.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",b,a)};
goog.html.SafeHtml.createMetaRefresh=function(a,b){a=goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a));(goog.labs.userAgent.browser.isIE()||goog.labs.userAgent.browser.isEdge())&&goog.string.internal.contains(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'");return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta",{"http-equiv":"refresh",content:(b||0)+"; url="+a})};
goog.html.SafeHtml.getAttrNameAndValue_=function(a,b,c){if(c instanceof goog.string.Const)c=goog.string.Const.unwrap(c);else if("style"==b.toLowerCase())c=goog.html.SafeHtml.getStyleValue_(c);else{if(/^on/i.test(b))throw Error('Attribute "'+b+'" requires goog.string.Const value, "'+c+'" given.');if(b.toLowerCase()in goog.html.SafeHtml.URL_ATTRIBUTES_)if(c instanceof goog.html.TrustedResourceUrl)c=goog.html.TrustedResourceUrl.unwrap(c);else if(c instanceof goog.html.SafeUrl)c=goog.html.SafeUrl.unwrap(c);
else if(goog.isString(c))c=goog.html.SafeUrl.sanitize(c).getTypedStringValue();else throw Error('Attribute "'+b+'" on tag "'+a+'" requires goog.html.SafeUrl, goog.string.Const, or string, value "'+c+'" given.');}c.implementsGoogStringTypedString&&(c=c.getTypedStringValue());goog.asserts.assert(goog.isString(c)||goog.isNumber(c),"String or number value expected, got "+typeof c+" with value: "+c);return b+'="'+goog.string.internal.htmlEscape(String(c))+'"'};
goog.html.SafeHtml.getStyleValue_=function(a){if(!goog.isObject(a))throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, '+typeof a+" given: "+a);a instanceof goog.html.SafeStyle||(a=goog.html.SafeStyle.create(a));return goog.html.SafeStyle.unwrap(a)};goog.html.SafeHtml.createWithDir=function(a,b,c,d){b=goog.html.SafeHtml.create(b,c,d);b.dir_=a;return b};
goog.html.SafeHtml.join=function(a,b){a=goog.html.SafeHtml.htmlEscape(a);var c=a.getDirection(),d=[],e=function(a){goog.isArray(a)?goog.array.forEach(a,e):(a=goog.html.SafeHtml.htmlEscape(a),d.push(goog.html.SafeHtml.unwrap(a)),a=a.getDirection(),c==goog.i18n.bidi.Dir.NEUTRAL?c=a:a!=goog.i18n.bidi.Dir.NEUTRAL&&c!=a&&(c=null))};goog.array.forEach(b,e);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d.join(goog.html.SafeHtml.unwrap(a)),c)};
goog.html.SafeHtml.concat=function(a){return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY,Array.prototype.slice.call(arguments))};goog.html.SafeHtml.concatWithDir=function(a,b){var c=goog.html.SafeHtml.concat(goog.array.slice(arguments,1));c.dir_=a;return c};goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse=function(a,b){return(new goog.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(a,b)};
goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a,b){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a):a;this.dir_=b;return this};
goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse=function(a,b,c){var d=null;var e="<"+a+goog.html.SafeHtml.stringifyAttributes(a,b);goog.isDefAndNotNull(c)?goog.isArray(c)||(c=[c]):c=[];goog.dom.tags.isVoidTag(a.toLowerCase())?(goog.asserts.assert(!c.length,"Void tag <"+a+"> does not allow content."),e+=">"):(d=goog.html.SafeHtml.concat(c),e+=">"+goog.html.SafeHtml.unwrap(d)+"</"+a+">",d=d.getDirection());(a=b&&b.dir)&&(d=/^(ltr|rtl|auto)$/i.test(a)?goog.i18n.bidi.Dir.NEUTRAL:
null);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e,d)};goog.html.SafeHtml.stringifyAttributes=function(a,b){var c="";if(b)for(var d in b){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d))throw Error('Invalid attribute name "'+d+'".');var e=b[d];goog.isDefAndNotNull(e)&&(c+=" "+goog.html.SafeHtml.getAttrNameAndValue_(a,d,e))}return c};
goog.html.SafeHtml.combineAttributes=function(a,b,c){var d={},e;for(e in a)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=a[e];for(e in b)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=b[e];for(e in c){var f=e.toLowerCase();if(f in a)throw Error('Cannot override "'+f+'" attribute, got "'+e+'" with value "'+c[e]+'"');f in b&&delete d[f];d[e]=c[e]}return d};
goog.html.SafeHtml.DOCTYPE_HTML=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.EMPTY=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.BR=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.uncheckedconversions={};goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract=function(a,b,c){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b,c||null)};
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};goog.dom.asserts={};goog.dom.asserts.assertIsLocation=function(a){if(goog.asserts.ENABLE_ASSERTS){var b=goog.dom.asserts.getWindow_(a);b&&(!a||!(a instanceof b.Location)&&a instanceof b.Element)&&goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s",goog.dom.asserts.debugStringForType_(a))}return a};
goog.dom.asserts.assertIsElementType_=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=goog.dom.asserts.getWindow_(a);c&&"undefined"!=typeof c[b]&&(a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element))||goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,goog.dom.asserts.debugStringForType_(a)))}return a};goog.dom.asserts.assertIsHTMLAnchorElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAnchorElement")};
goog.dom.asserts.assertIsHTMLButtonElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLButtonElement")};goog.dom.asserts.assertIsHTMLLinkElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLLinkElement")};goog.dom.asserts.assertIsHTMLImageElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLImageElement")};goog.dom.asserts.assertIsHTMLAudioElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAudioElement")};
goog.dom.asserts.assertIsHTMLVideoElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLVideoElement")};goog.dom.asserts.assertIsHTMLInputElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLInputElement")};goog.dom.asserts.assertIsHTMLTextAreaElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLTextAreaElement")};goog.dom.asserts.assertIsHTMLCanvasElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLCanvasElement")};
goog.dom.asserts.assertIsHTMLEmbedElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLEmbedElement")};goog.dom.asserts.assertIsHTMLFormElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFormElement")};goog.dom.asserts.assertIsHTMLFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFrameElement")};goog.dom.asserts.assertIsHTMLIFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLIFrameElement")};
goog.dom.asserts.assertIsHTMLObjectElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLObjectElement")};goog.dom.asserts.assertIsHTMLScriptElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLScriptElement")};
goog.dom.asserts.debugStringForType_=function(a){if(goog.isObject(a))try{return a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a)}catch(b){return"<object could not be stringified>"}else return void 0===a?"undefined":null===a?"null":typeof a};goog.dom.asserts.getWindow_=function(a){try{var b=a&&a.ownerDocument,c=b&&(b.defaultView||b.parentWindow);c=c||goog.global;if(c.Element&&c.Location)return c}catch(d){}return null};goog.functions={};goog.functions.constant=function(a){return function(){return a}};goog.functions.FALSE=function(){return!1};goog.functions.TRUE=function(){return!0};goog.functions.NULL=function(){return null};goog.functions.identity=function(a,b){return a};goog.functions.error=function(a){return function(){throw Error(a);}};goog.functions.fail=function(a){return function(){throw a;}};
goog.functions.lock=function(a,b){b=b||0;return function(){return a.apply(this,Array.prototype.slice.call(arguments,0,b))}};goog.functions.nth=function(a){return function(){return arguments[a]}};goog.functions.partialRight=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.push.apply(b,c);return a.apply(this,b)}};goog.functions.withReturnValue=function(a,b){return goog.functions.sequence(a,goog.functions.constant(b))};
goog.functions.equalTo=function(a,b){return function(c){return b?a==c:a===c}};goog.functions.compose=function(a,b){var c=arguments,d=c.length;return function(){var a;d&&(a=c[d-1].apply(this,arguments));for(var b=d-2;0<=b;b--)a=c[b].call(this,a);return a}};goog.functions.sequence=function(a){var b=arguments,c=b.length;return function(){for(var a,e=0;e<c;e++)a=b[e].apply(this,arguments);return a}};
goog.functions.and=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(!b[a].apply(this,arguments))return!1;return!0}};goog.functions.or=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(b[a].apply(this,arguments))return!0;return!1}};goog.functions.not=function(a){return function(){return!a.apply(this,arguments)}};
goog.functions.create=function(a,b){var c=function(){};c.prototype=a.prototype;c=new c;a.apply(c,Array.prototype.slice.call(arguments,1));return c};goog.functions.CACHE_RETURN_VALUE=!0;goog.functions.cacheReturnValue=function(a){var b=!1,c;return function(){if(!goog.functions.CACHE_RETURN_VALUE)return a();b||(c=a(),b=!0);return c}};goog.functions.once=function(a){var b=a;return function(){if(b){var a=b;b=null;a()}}};
goog.functions.debounce=function(a,b,c){var d=0;return function(e){goog.global.clearTimeout(d);var f=arguments;d=goog.global.setTimeout(function(){a.apply(c,f)},b)}};goog.functions.throttle=function(a,b,c){var d=0,e=!1,f=[],g=function(){d=0;e&&(e=!1,h())},h=function(){d=goog.global.setTimeout(g,b);a.apply(c,f)};return function(a){f=arguments;d?e=!0:h()}};goog.functions.rateLimit=function(a,b,c){var d=0,e=function(){d=0};return function(f){d||(d=goog.global.setTimeout(e,b),a.apply(c,arguments))}};goog.dom.safe={};goog.dom.safe.InsertAdjacentHtmlPosition={AFTERBEGIN:"afterbegin",AFTEREND:"afterend",BEFOREBEGIN:"beforebegin",BEFOREEND:"beforeend"};goog.dom.safe.insertAdjacentHtml=function(a,b,c){a.insertAdjacentHTML(b,goog.html.SafeHtml.unwrapTrustedHTML(c))};goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_={MATH:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};
goog.dom.safe.isInnerHtmlCleanupRecursive_=goog.functions.cacheReturnValue(function(){if(goog.DEBUG&&"undefined"===typeof document)return!1;var a=document.createElement("div"),b=document.createElement("div");b.appendChild(document.createElement("div"));a.appendChild(b);if(goog.DEBUG&&!a.firstChild)return!1;b=a.firstChild.firstChild;a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);return!b.parentElement});
goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse=function(a,b){if(goog.dom.safe.isInnerHtmlCleanupRecursive_())for(;a.lastChild;)a.removeChild(a.lastChild);a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setInnerHtml=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=a.tagName.toUpperCase();if(goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c])throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of "+a.tagName+".");}goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a,b)};goog.dom.safe.setOuterHtml=function(a,b){a.outerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setFormElementAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLFormElement(a).action=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setButtonFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLButtonElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setInputFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLInputElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setStyle=function(a,b){a.style.cssText=goog.html.SafeStyle.unwrap(b)};goog.dom.safe.documentWrite=function(a,b){a.write(goog.html.SafeHtml.unwrapTrustedHTML(b))};
goog.dom.safe.setAnchorHref=function(a,b){goog.dom.asserts.assertIsHTMLAnchorElement(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setImageSrc=function(a,b){goog.dom.asserts.assertIsHTMLImageElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:image\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setAudioSrc=function(a,b){goog.dom.asserts.assertIsHTMLAudioElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:audio\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setVideoSrc=function(a,b){goog.dom.asserts.assertIsHTMLVideoElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:video\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setEmbedSrc=function(a,b){goog.dom.asserts.assertIsHTMLEmbedElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b)};goog.dom.safe.setFrameSrc=function(a,b){goog.dom.asserts.assertIsHTMLFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)};goog.dom.safe.setIframeSrc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)};
goog.dom.safe.setIframeSrcdoc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.srcdoc=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setLinkHrefAndRel=function(a,b,c){goog.dom.asserts.assertIsHTMLLinkElement(a);a.rel=c;goog.string.internal.caseInsensitiveContains(c,"stylesheet")?(goog.asserts.assert(b instanceof goog.html.TrustedResourceUrl,'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'),a.href=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)):a.href=b instanceof goog.html.TrustedResourceUrl?goog.html.TrustedResourceUrl.unwrapTrustedURL(b):b instanceof goog.html.SafeUrl?goog.html.SafeUrl.unwrapTrustedURL(b):
goog.html.SafeUrl.unwrapTrustedURL(goog.html.SafeUrl.sanitizeAssertUnchanged(b))};goog.dom.safe.setObjectData=function(a,b){goog.dom.asserts.assertIsHTMLObjectElement(a);a.data=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b)};goog.dom.safe.setScriptSrc=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b)};
goog.dom.safe.setScriptContent=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.text=goog.html.SafeScript.unwrapTrustedScript(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b)};goog.dom.safe.setLocationHref=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.assignLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.assign(goog.html.SafeUrl.unwrapTrustedURL(b))};goog.dom.safe.replaceLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.replace(goog.html.SafeUrl.unwrapTrustedURL(b))};
goog.dom.safe.openInWindow=function(a,b,c,d,e){a=a instanceof goog.html.SafeUrl?a:goog.html.SafeUrl.sanitizeAssertUnchanged(a);return(b||goog.global).open(goog.html.SafeUrl.unwrapTrustedURL(a),c?goog.string.Const.unwrap(c):"",d,e)};goog.dom.safe.parseFromStringHtml=function(a,b){return goog.dom.safe.parseFromString(a,b,"text/html")};goog.dom.safe.parseFromString=function(a,b,c){return a.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(b),c)};
goog.dom.safe.createImageFromBlob=function(a){if(!/^image\/.*/g.test(a.type))throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");var b=goog.global.URL.createObjectURL(a);a=new goog.global.Image;a.onload=function(){goog.global.URL.revokeObjectURL(b)};goog.dom.safe.setImageSrc(a,goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."),b));return a};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=goog.string.internal.startsWith;goog.string.endsWith=goog.string.internal.endsWith;goog.string.caseInsensitiveStartsWith=goog.string.internal.caseInsensitiveStartsWith;goog.string.caseInsensitiveEndsWith=goog.string.internal.caseInsensitiveEndsWith;goog.string.caseInsensitiveEquals=goog.string.internal.caseInsensitiveEquals;
goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};goog.string.isEmptyOrWhitespace=goog.string.internal.isEmptyOrWhitespace;goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};
goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return!/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return!/[^a-zA-Z]/.test(a)};goog.string.isNumeric=function(a){return!/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return!/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return" "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};
goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.string.internal.trim;
goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=goog.string.internal.caseInsensitiveCompare;
goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return-1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=goog.string.internal.newLineToBr;
goog.string.htmlEscape=function(a,b){a=goog.string.internal.htmlEscape(a,b);goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));return a};goog.string.E_RE_=/e/g;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'};var d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var e=c[a];if(e)return e;"#"==b.charAt(0)&&(b=Number("0"+b.substr(1)),isNaN(b)||(e=String.fromCharCode(b)));e||(goog.dom.safe.setInnerHtml(d,goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."),
a+" ")),e=d.firstChild.nodeValue.slice(0,-1));return c[a]=e})};goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return"&";case "lt":return"<";case "gt":return">";case "quot":return'"';default:return"#"!=c.charAt(0)||(c=Number("0"+c.substr(1)),isNaN(c))?a:String.fromCharCode(c)}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e)}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"\\u003C"};goog.string.jsEscapeCache_={"'":"\\'"};
goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d))}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b=a.charCodeAt(0);if(31<b&&127>b)var c=a;else{if(256>b){if(c="\\x",16>b||256<b)c+="0"}else c="\\u",4096>b&&(c+="0");c+=b.toString(16).toUpperCase()}return goog.string.jsEscapeCache_[a]=c};goog.string.contains=goog.string.internal.contains;goog.string.caseInsensitiveContains=goog.string.internal.caseInsensitiveContains;
goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){return a.replace(b,"")};goog.string.removeAll=function(a,b){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,"")};goog.string.replaceAll=function(a,b,c){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,c.replace(/\$/g,"$$$$"))};
goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};
goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};goog.string.compareVersions=goog.string.internal.compareVersions;goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;
goog.string.createUniqueString=function(){return"goog_"+goog.string.uniqueStringCounter_++};goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return/^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return/^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};
goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};goog.string.toTitleCase=function(a,b){b=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(b?"|["+b+"]+":"")+")([a-z])","g"),function(a,b,e){return b+e.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};
goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.lastComponent=function(a,b){if(b)"string"==typeof b&&(b=[b]);else return a;for(var c=-1,d=0;d<b.length;d++)if(""!=b[d]){var e=a.lastIndexOf(b[d]);e>c&&(c=e)}return-1==c?a:a.slice(c+1)};
goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f]}return d[b.length]};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};goog.labs.userAgent.platform.isChromecast=function(){return goog.labs.userAgent.util.matchUserAgent("CrKey")};goog.labs.userAgent.platform.isKaiOS=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")};goog.labs.userAgent.platform.isGo2Phone=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP")};
goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isKaiOS()?(b=/(?:KaiOS)\/(\S+)/i,
b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.reflect={};goog.reflect.object=function(a,b){return b};goog.reflect.objectProperty=function(a,b){return a};goog.reflect.sinkValue=function(a){goog.reflect.sinkValue[" "](a);return a};goog.reflect.sinkValue[" "]=goog.nullFunction;goog.reflect.canAccessProperty=function(a,b){try{return goog.reflect.sinkValue(a[b]),!0}catch(c){}return!1};goog.reflect.cache=function(a,b,c,d){d=d?d(b):b;return Object.prototype.hasOwnProperty.call(a,d)?a[d]:a[d]=c(b)};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){a=goog.labs.userAgent.util.extractVersionTuples(a);var b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return"Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];a=a[0];var c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return""};
goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){return(a=goog.array.find(a,function(a){return b==a[0]}))&&a[1]||""};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
goog.userAgent.getNavigatorTyped=function(){return goog.global.navigator||null};goog.userAgent.getNavigator=function(){return goog.userAgent.getNavigatorTyped()};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();
goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};
goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigatorTyped();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;
goog.userAgent.ASSUME_IPAD=!1;goog.userAgent.ASSUME_IPOD=!1;goog.userAgent.ASSUME_KAIOS=!1;goog.userAgent.ASSUME_GO2PHONE=!1;goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();
goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigatorTyped();return!!a&&goog.string.contains(a.appVersion||"","X11")};
goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();
goog.userAgent.IPOD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIpod();goog.userAgent.IOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIos();goog.userAgent.KAIOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_KAIOS:goog.labs.userAgent.platform.isKaiOS();goog.userAgent.GO2PHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_GO2PHONE:goog.labs.userAgent.platform.isGo2Phone();
goog.userAgent.determineVersion_=function(){var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),null!=b&&b>parseFloat(a))?String(b):a};
goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return/rv:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return/Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return/WebKit\/(\S+)/.exec(a);if(goog.userAgent.OPERA)return/(?:Version)[ \/]?(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};
goog.userAgent.VERSION=goog.userAgent.determineVersion_();goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_,a,function(){return 0<=goog.string.compareVersions(goog.userAgent.VERSION,a)})};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){if(goog.global.document&&goog.userAgent.IE)return goog.userAgent.getDocumentMode_()}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.DEFAULT_ALPHABET_COMMON_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"-_.";goog.crypt.base64.Alphabet={DEFAULT:0,NO_PADDING:1,WEBSAFE:2,WEBSAFE_DOT_PADDING:3,WEBSAFE_NO_PADDING:4};goog.crypt.base64.paddingChars_="=.";
goog.crypt.base64.isPadding_=function(a){return goog.string.contains(goog.crypt.base64.paddingChars_,a)};goog.crypt.base64.byteToCharMaps_={};goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;
goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");void 0===b&&(b=goog.crypt.base64.Alphabet.DEFAULT);goog.crypt.base64.init_();b=goog.crypt.base64.byteToCharMaps_[b];for(var c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,l=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[l],b[e],b[g]||"",b[k]||"")}return c.join("")};
goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a)});return c};
goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a)});return c};
goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=a.length,c=3*b/4;c%3?c=Math.floor(c):goog.crypt.base64.isPadding_(a[b-1])&&(c=goog.crypt.base64.isPadding_(a[b-2])?c-2:c-1);var d=new Uint8Array(c),e=0;goog.crypt.base64.decodeStringInternal_(a,function(a){d[e++]=a});return d.subarray(0,e)};
goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h))}};
goog.crypt.base64.init_=function(){if(!goog.crypt.base64.charToByteMap_){goog.crypt.base64.charToByteMap_={};for(var a=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));goog.crypt.base64.byteToCharMaps_[c]=d;for(var e=0;e<d.length;e++){var f=d[e],g=goog.crypt.base64.charToByteMap_[f];void 0===g?goog.crypt.base64.charToByteMap_[f]=e:goog.asserts.assert(g===e)}}}};jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a};
jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c};
jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648);else if(isNaN(a))jspb.utils.split64High=0,jspb.utils.split64Low=2147483647;else if(a>jspb.BinaryConstants.FLOAT32_MAX)jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0;else if(a<jspb.BinaryConstants.FLOAT32_MIN)a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|
a)>>>0;else{var c=Math.floor(Math.log(a)/Math.LN2);a*=Math.pow(2,-c);a=Math.round(a*jspb.BinaryConstants.TWO_TO_23)&8388607;jspb.utils.split64High=0;jspb.utils.split64Low=(b<<31|c+127<<23|a)>>>0}};
jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0}else{var d=
Math.floor(Math.log(a)/Math.LN2);1024==d&&(d=1023);c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c}};
jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+(a>>>0)};
jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));a=jspb.utils.joinUint64(a,b);return c?-a:a};jspb.utils.toZigzag64=function(a,b,c){var d=b>>31;return c(a<<1^d,(b<<1|a>>>31)^d)};jspb.utils.joinZigzag64=function(a,b){return jspb.utils.fromZigzag64(a,b,jspb.utils.joinInt64)};jspb.utils.fromZigzag64=function(a,b,c){var d=-(a&1);return c((a>>>1|b<<31)^d,b>>>1^d)};
jspb.utils.joinFloat32=function(a,b){b=2*(a>>31)+1;var c=a>>>23&255;a&=8388607;return 255==c?a?NaN:Infinity*b:0==c?b*Math.pow(2,-149)*a:b*Math.pow(2,c-150)*(a+Math.pow(2,23))};jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047;a=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?a?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*a:c*Math.pow(2,d-1075)*(a+jspb.BinaryConstants.TWO_TO_52)};
jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");jspb.utils.ZERO_CHAR_CODE_=48;jspb.utils.A_CHAR_CODE_=97;
jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a,b){a=a?String(a):"";return b?"0000000".slice(a.length)+a:a}if(2097151>=b)return""+(jspb.BinaryConstants.TWO_TO_32*b+a);var d=(a>>>24|b<<8)>>>0&16777215;b=b>>16&65535;a=(a&16777215)+6777216*d+6710656*b;d+=8147497*b;b*=2;1E7<=a&&(d+=Math.floor(a/1E7),a%=1E7);1E7<=d&&(b+=Math.floor(d/1E7),d%=1E7);return c(b,0)+c(d,b)+c(a,1)};
jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);a=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+a:a};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(a,c):jspb.utils.joinUnsignedDecimalString(a,c)};
jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++)b=a*e[c]+b,e[c]=b&255,b>>>=8}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,a.charCodeAt(f)-jspb.utils.ZERO_CHAR_CODE_);d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a))};
jspb.utils.toHexDigit_=function(a){return String.fromCharCode(10>a?jspb.utils.ZERO_CHAR_CODE_+a:jspb.utils.A_CHAR_CODE_-10+a)};jspb.utils.fromHexCharCode_=function(a){return a>=jspb.utils.A_CHAR_CODE_?a-jspb.utils.A_CHAR_CODE_+10:a-jspb.utils.ZERO_CHAR_CODE_};jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.toHexDigit_(d>>4);b[2*c+3]=jspb.utils.toHexDigit_(d&15)}return b.join("")};
jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++){var d=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+2)),e=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+3));b=String.fromCharCode(16*d+e)+b}return b};
jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinInt64(a,c):jspb.utils.joinUint64(a,c)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7}if(a[b++]!=g)break;f++;b+=e}return f};
jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16)}return b+'"'};
jspb.utils.debugScalarToTextFormat=function(a){return goog.isString(a)?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d}return b};
jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||"undefined"!=typeof Buffer&&a.constructor===Buffer||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c)};jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this)};
jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};
jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=goog.isDef(b)?b:0;this.end_=goog.isDef(c)?this.start_+c:this.bytes_.length;this.cursor_=this.start_};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};
jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_)};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
jspb.BinaryDecoder.prototype.readSplitVarint64=function(a){for(var b=128,c=0,d=0,e=0;4>e&&128<=b;e++)b=this.bytes_[this.cursor_++],c|=(b&127)<<7*e;128<=b&&(b=this.bytes_[this.cursor_++],c|=(b&127)<<28,d|=(b&127)>>4);if(128<=b)for(e=0;5>e&&128<=b;e++)b=this.bytes_[this.cursor_++],d|=(b&127)<<7*e+3;if(128>b)return a(c>>>0,d>>>0);goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=!0};
jspb.BinaryDecoder.prototype.readSplitZigzagVarint64=function(a){return this.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryDecoder.prototype.readSplitFixed64=function(a){var b=this.bytes_,c=this.cursor_;this.cursor_+=8;for(var d=0,e=0,f=c+7;f>=c;f--)d=d<<8|b[f],e=e<<8|b[f+4];return a(d,e)};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++};
jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--};
jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a=this.bytes_;var b=a[this.cursor_+0];var c=b&127;if(128>b)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+1];c|=(b&127)<<7;if(128>b)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+2];c|=(b&127)<<14;if(128>b)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+3];c|=(b&127)<<21;if(128>b)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
this.end_),c;b=a[this.cursor_+4];c|=(b&15)<<28;if(128>b)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinUint64)};jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString)};
jspb.BinaryDecoder.prototype.readSignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinInt64)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){return this.readSplitVarint64(jspb.utils.joinZigzag64)};jspb.BinaryDecoder.prototype.readZigzagVarintHash64=function(){return this.readSplitZigzagVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};
jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return(a<<0|b<<8|c<<16|d<<24)>>>0};jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};
jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return(a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return!!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63)}else if(240>f){g=b[c++];var h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63)}else if(248>f){g=b[c++];h=b[c++];var k=b[c++];f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63;f-=65536;d.push((f>>10&1023)+55296,(f&1023)+56320)}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0)}e+=goog.crypt.byteArrayToString(d);
this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};jspb.BinaryDecoder.prototype.readVarintHash64=function(){return this.readSplitVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6];a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null};jspb.BinaryReader.instanceCache_=[];
jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this)};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};
jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID};jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a)};
jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return!1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3;a&=7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type: %s (at position %s)",
a,this.fieldCursor_),this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return!0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_)};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader()};
jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint()};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else{var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a)}};
jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4)};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8)};
jspb.BinaryReader.prototype.skipGroup=function(){var a=this.nextField_;do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP){this.nextField_!=a&&(goog.asserts.fail("Unmatched end-group tag"),this.error_=!0);break}this.skipField()}while(1)};
jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.")}};
jspb.BinaryReader.prototype.registerReadCallback=function(a,b){goog.isNull(this.readCallbacks_)&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(!goog.isNull(this.readCallbacks_));a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
default:goog.asserts.fail("Invalid field type in readAny()")}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32();d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c)};
jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0)};
jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a;a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return!!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readSintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarintHash64()};jspb.BinaryReader.prototype.readSplitVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(a)};
jspb.BinaryReader.prototype.readSplitZigzagVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
jspb.BinaryReader.prototype.readSplitFixed64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readSplitFixed64(a)};jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var b=this.decoder_.readUnsignedVarint32();b=this.decoder_.getCursor()+b;for(var c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};
jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};
jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};
jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};
jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};
jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};
jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.Map=function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_()};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1])}this.arrClean=!0};
jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray()}}}else{this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value])}this.arrClean=!0}return this.arr_};
jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value])}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f)}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a};
jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};"undefined"!=typeof Symbol&&(jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1};
jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value])}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)])}return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this)}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage()}};
jspb.Map.deserializeBinary=function(a,b,c,d,e,f,g){for(;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g||(g=new a.valueCtor_),d.call(b,g,e)):g=d.call(b))}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g)};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return!!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.hiddenES6Property_=function(){};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedPrimitiveFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b])};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:goog.isArray(a)};jspb.Message.isExtensionObject_=function(a){return null!==a&&"object"==typeof a&&!jspb.Message.isArray_(a)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)};
jspb.Message.initPivotAndExtensionObject_=function(a,b){var c=a.array.length,d=-1;if(c&&(d=c-1,c=a.array[d],jspb.Message.isExtensionObject_(c))){a.pivot_=jspb.Message.getFieldNumber_(a,d);a.extensionObject_=c;return}-1<b?(a.pivot_=Math.max(b,jspb.Message.getFieldNumber_(a,d+1)),a.extensionObject_=null):a.pivot_=Number.MAX_VALUE};jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={})};
jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h}}};
jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
else f.binaryWriterFn.call(b,g.fieldIndex,h)}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");if(c.isMessageType()){var g=new c.ctor;f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn)}else g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g)}else b.skipField()};
jspb.Message.getField=function(a,b){if(b<a.pivot_){b=jspb.Message.getIndex_(a,b);var c=a.array[b];return c===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[b]=[]:c}if(a.extensionObject_)return c=a.extensionObject_[b],c===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:c};jspb.Message.getRepeatedField=function(a,b){return jspb.Message.getField(a,b)};jspb.Message.getOptionalFloatingPointField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:+a};
jspb.Message.getBooleanField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:!!a};jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedPrimitiveFields_[b]=!0}return c};
jspb.Message.getRepeatedBooleanField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=!!c[d];a.convertedPrimitiveFields_[b]=!0}return c};
jspb.Message.bytesAsB64=function(a){if(null==a||goog.isString(a))return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if(goog.isString(a))return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return!a.length||goog.isString(a[0])?a:goog.array.map(a,jspb.Message.bytesAsB64)};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return!a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b)})}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getBooleanFieldWithDefault=function(a,b,c){a=jspb.Message.getBooleanField(a,b);return null==a?c:a};
jspb.Message.getFloatingPointFieldWithDefault=function(a,b,c){a=jspb.Message.getOptionalFloatingPointField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];var e=jspb.Message.getField(a,b);if(!e){if(c)return;e=[];jspb.Message.setField(a,b,e)}return a.wrappers_[b]=new jspb.Map(e,d)};
jspb.Message.setField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);return a};jspb.Message.setProto3IntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};jspb.Message.setProto3FloatField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3BooleanField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,!1)};jspb.Message.setProto3StringField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3BytesField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3EnumField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3StringIntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"0")};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);c!==d?jspb.Message.setField(a,b,c):a.array[jspb.Message.getIndex_(a,b)]=null;return a};jspb.Message.addToRepeatedField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);b=jspb.Message.getRepeatedField(a,b);void 0!=d?b.splice(d,0,c):b.push(c);return a};
jspb.Message.setOneofField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));return jspb.Message.setField(a,b,d)};jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0))}return c?(jspb.Message.setField(a,c,d),c):0};
jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e)}return a.wrappers_[c]};jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};
jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e}};jspb.Message.setWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
jspb.Message.setOneofWrapperField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;return jspb.Message.setOneofField(a,b,c,e)};jspb.Message.setRepeatedWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(goog.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray()}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return!this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray();b=b.toArray();var d=[],e=0,f=c.length>b.length?c.length:b.length;a.getJsPbMessageId()&&(d[0]=a.getJsPbMessageId(),e=1);for(;e<f;e++)jspb.Message.compareFields(c[e],b[e])||(d[e]=b[e]);return new a.constructor(d)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return!1;return!0};
jspb.Message.compareFields=function(a,b){if(a==b)return!0;if(!goog.isObject(a)||!goog.isObject(b))return goog.isNumber(a)&&isNaN(a)||goog.isNumber(b)&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return!1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return!1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return!1;return!0}if(a.constructor===Array){var d=void 0,e=void 0,f=Math.max(a.length,b.length);for(c=0;c<f;c++){var g=a[c],h=b[c];g&&g.constructor==
Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return!1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");a=jspb.Message.clone(a);for(var c=b.toArray(),d=a.toArray(),e=c.length=0;e<d.length;e++)c[e]=d[e];b.wrappers_=a.wrappers_;b.extensionObject_=a.extensionObject_};
jspb.Message.clone_=function(a){if(goog.isArray(a)){for(var b=Array(a.length),c=0;c<a.length;c++){var d=a[c];null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d)}return b}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);b={};for(c in a)d=a[c],null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);return b};jspb.Message.registerMessageType=function(a,b){b.messageId=a};jspb.Message.messageSetExtensions={};
jspb.Message.messageSetExtensionsBinary={};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
jspb.arith.UInt64.prototype.msb=function(){return!!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return!!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){var c=a&65535;a>>>=16;var d=b&65535,e=b>>>16;b=c*d+65536*(c*e&65535)+65536*(a*d&65535);for(c=a*e+(c*e>>>16)+(a*d>>>16);4294967296<=b;)b-=4294967296,c+=1;return new jspb.arith.UInt64(b>>>0,c>>>0)};
jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
jspb.arith.UInt64.prototype.div=function(a){if(0==a)return[];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return[b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();){b=b.div(10);var c=b[0];a=b[1].lo+a;b=c}""==a&&(a="0");return a};
jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c)}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b};
jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return(a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryEncoder=function(){this.buffer_=[]};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a)};
jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b)};
jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a)};
jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else{for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1)}};
jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0)};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(a))};jspb.BinaryEncoder.prototype.writeZigzagVarintHash64=function(a){var b=this;jspb.utils.splitHash64(a);jspb.utils.toZigzag64(jspb.utils.split64Low,jspb.utils.split64High,function(a,d){b.writeSplitVarint64(a>>>0,d>>>0)})};
jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255)};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255)};
jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255)};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255)};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255)};
jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255)};
jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low)};
jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert(goog.isBoolean(a)||goog.isNumber(a));this.buffer_.push(a?1:0)};
jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a)};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a)};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++)}else this.buffer_.push(d>>
12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128)}return this.buffer_.length-b};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[]};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length};
jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop();b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++};
jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c))};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c)};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[]};
jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a))};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop())};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b)};
jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()")}};
jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b))};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b))};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b))};
jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b))};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b))};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b))};
jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b))};jspb.BinaryWriter.prototype.writeZigzagVarintHash64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarintHash64(b))};
jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeInt32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b))};
jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b))};jspb.BinaryWriter.prototype.writeInt64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi))};
jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeUint32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b))};
jspb.BinaryWriter.prototype.writeUint64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi))};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b))};
jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b))};jspb.BinaryWriter.prototype.writeSintHash64=function(a,b){null!=b&&this.writeZigzagVarintHash64_(a,b)};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&this.writeZigzagVarint64String_(a,b)};
jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b))};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b))};
jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi))};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b))};
jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b))};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi))};
jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b))};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b))};jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert(goog.isBoolean(b)||goog.isNumber(b)),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b))};
jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b))};jspb.BinaryWriter.prototype.writeString=function(a,b){null!=b&&(a=this.beginDelimited_(a),this.encoder_.writeString(b),this.endDelimited_(a))};
jspb.BinaryWriter.prototype.writeBytes=function(a,b){null!=b&&(b=jspb.utils.byteSourceToUint8Array(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),this.appendUint8Array_(b))};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a))};
jspb.BinaryWriter.prototype.writeMessageSet=function(a,b,c){null!=b&&(this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.START_GROUP),this.writeFieldHeader_(2,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(a),a=this.beginDelimited_(3),c(b,this),this.endDelimited_(a),this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.END_GROUP))};
jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP))};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b))};
jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b))};jspb.BinaryWriter.prototype.writeSplitFixed64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(b,c)};
jspb.BinaryWriter.prototype.writeSplitVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(b,c)};jspb.BinaryWriter.prototype.writeSplitZigzagVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);var d=this.encoder_;jspb.utils.toZigzag64(b,c,function(a,b){d.writeSplitVarint64(a>>>0,b>>>0)})};
jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitFixed64(a,c(b[e]),d(b[e]))};jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitVarint64(a,c(b[e]),d(b[e]))};jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitZigzagVarint64(a,c(b[e]),d(b[e]))};
jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarintHash64_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e)}};
jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP)};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c])};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(parseInt(b[c],10));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSplitFixed64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitFixed64(c(b[e]),d(b[e]));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSplitVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitVarint64(c(b[e]),d(b[e]));this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=this.encoder_,f=0;f<b.length;f++)jspb.utils.toZigzag64(c(b[f]),d(b[f]),function(a,b){e.writeSplitVarint64(a>>>0,b>>>0)});this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.Int64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi)}this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(parseInt(b[c],10));this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint64(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi)}this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint32(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(b[c]));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeUint32(b[a])};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeUint64(b[a])};
jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++){var c=jspb.arith.UInt64.fromString(b[a]);this.encoder_.writeSplitFixed64(c.lo,c.hi)}};
jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeInt32(b[a])};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64(b[a])};
jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64String(b[a])};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeFloat(b[a])};
jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeDouble(b[a])};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),a=0;a<b.length;a++)this.encoder_.writeBool(b[a])};
jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeEnum(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeFixedHash64(b[a])};
jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeVarintHash64(b[c]);this.endDelimited_(a)}};jspb.Export={};exports.Map=jspb.Map;exports.Message=jspb.Message;exports.BinaryReader=jspb.BinaryReader;exports.BinaryWriter=jspb.BinaryWriter;exports.ExtensionFieldInfo=jspb.ExtensionFieldInfo;exports.ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo;exports.exportSymbol=goog.exportSymbol;exports.inherits=goog.inherits;exports.object={extend:goog.object.extend};exports.typeOf=goog.typeOf;

},{"buffer":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../node_modules/@tensorflow/tfjs-node/dist/proto/api_pb.js":[function(require,module,exports) {

// source: api.proto

/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
var jspb = require('google-protobuf');

var goog = jspb;
var global = Function('return this')();
goog.exportSymbol('proto.tensorflow.Any', null, global);
goog.exportSymbol('proto.tensorflow.AssetFileDef', null, global);
goog.exportSymbol('proto.tensorflow.AttrValue', null, global);
goog.exportSymbol('proto.tensorflow.AttrValue.ListValue', null, global);
goog.exportSymbol('proto.tensorflow.AttrValue.ValueCase', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef.AnyList', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef.BytesList', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef.FloatList', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef.Int64List', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef.KindCase', null, global);
goog.exportSymbol('proto.tensorflow.CollectionDef.NodeList', null, global);
goog.exportSymbol('proto.tensorflow.DataType', null, global);
goog.exportSymbol('proto.tensorflow.FunctionDef', null, global);
goog.exportSymbol('proto.tensorflow.FunctionDefLibrary', null, global);
goog.exportSymbol('proto.tensorflow.GradientDef', null, global);
goog.exportSymbol('proto.tensorflow.GraphDef', null, global);
goog.exportSymbol('proto.tensorflow.MetaGraphDef', null, global);
goog.exportSymbol('proto.tensorflow.MetaGraphDef.MetaInfoDef', null, global);
goog.exportSymbol('proto.tensorflow.NameAttrList', null, global);
goog.exportSymbol('proto.tensorflow.NodeDef', null, global);
goog.exportSymbol('proto.tensorflow.OpDef', null, global);
goog.exportSymbol('proto.tensorflow.OpDef.ArgDef', null, global);
goog.exportSymbol('proto.tensorflow.OpDef.AttrDef', null, global);
goog.exportSymbol('proto.tensorflow.OpDef.OpDeprecation', null, global);
goog.exportSymbol('proto.tensorflow.OpList', null, global);
goog.exportSymbol('proto.tensorflow.SavedModel', null, global);
goog.exportSymbol('proto.tensorflow.SaverDef', null, global);
goog.exportSymbol('proto.tensorflow.SaverDef.CheckpointFormatVersion', null, global);
goog.exportSymbol('proto.tensorflow.SignatureDef', null, global);
goog.exportSymbol('proto.tensorflow.Tensor', null, global);
goog.exportSymbol('proto.tensorflow.TensorInfo', null, global);
goog.exportSymbol('proto.tensorflow.TensorInfo.CooSparse', null, global);
goog.exportSymbol('proto.tensorflow.TensorInfo.EncodingCase', null, global);
goog.exportSymbol('proto.tensorflow.TensorShape', null, global);
goog.exportSymbol('proto.tensorflow.TensorShape.Dim', null, global);
goog.exportSymbol('proto.tensorflow.VersionDef', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */

proto.tensorflow.Any = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.Any, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.Any.displayName = 'proto.tensorflow.Any';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.TensorShape = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.TensorShape.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.TensorShape, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.TensorShape.displayName = 'proto.tensorflow.TensorShape';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.TensorShape.Dim = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.TensorShape.Dim, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.TensorShape.Dim.displayName = 'proto.tensorflow.TensorShape.Dim';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.Tensor = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.Tensor.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.Tensor, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.Tensor.displayName = 'proto.tensorflow.Tensor';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.AttrValue = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.tensorflow.AttrValue.oneofGroups_);
};

goog.inherits(proto.tensorflow.AttrValue, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.AttrValue.displayName = 'proto.tensorflow.AttrValue';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.AttrValue.ListValue = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.AttrValue.ListValue.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.AttrValue.ListValue, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.AttrValue.ListValue.displayName = 'proto.tensorflow.AttrValue.ListValue';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.NameAttrList = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.NameAttrList, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.NameAttrList.displayName = 'proto.tensorflow.NameAttrList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.NodeDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.NodeDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.NodeDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.NodeDef.displayName = 'proto.tensorflow.NodeDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.VersionDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.VersionDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.VersionDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.VersionDef.displayName = 'proto.tensorflow.VersionDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.GraphDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.GraphDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.GraphDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.GraphDef.displayName = 'proto.tensorflow.GraphDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.CollectionDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.tensorflow.CollectionDef.oneofGroups_);
};

goog.inherits(proto.tensorflow.CollectionDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.CollectionDef.displayName = 'proto.tensorflow.CollectionDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.CollectionDef.NodeList = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.CollectionDef.NodeList.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.CollectionDef.NodeList, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.CollectionDef.NodeList.displayName = 'proto.tensorflow.CollectionDef.NodeList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.CollectionDef.BytesList = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.CollectionDef.BytesList.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.CollectionDef.BytesList, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.CollectionDef.BytesList.displayName = 'proto.tensorflow.CollectionDef.BytesList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.CollectionDef.Int64List = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.CollectionDef.Int64List.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.CollectionDef.Int64List, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.CollectionDef.Int64List.displayName = 'proto.tensorflow.CollectionDef.Int64List';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.CollectionDef.FloatList = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.CollectionDef.FloatList.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.CollectionDef.FloatList, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.CollectionDef.FloatList.displayName = 'proto.tensorflow.CollectionDef.FloatList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.CollectionDef.AnyList = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.CollectionDef.AnyList.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.CollectionDef.AnyList, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.CollectionDef.AnyList.displayName = 'proto.tensorflow.CollectionDef.AnyList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.SaverDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.SaverDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.SaverDef.displayName = 'proto.tensorflow.SaverDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.TensorInfo = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.tensorflow.TensorInfo.oneofGroups_);
};

goog.inherits(proto.tensorflow.TensorInfo, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.TensorInfo.displayName = 'proto.tensorflow.TensorInfo';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.TensorInfo.CooSparse = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.TensorInfo.CooSparse, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.TensorInfo.CooSparse.displayName = 'proto.tensorflow.TensorInfo.CooSparse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.SignatureDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.SignatureDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.SignatureDef.displayName = 'proto.tensorflow.SignatureDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.AssetFileDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.AssetFileDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.AssetFileDef.displayName = 'proto.tensorflow.AssetFileDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.OpDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.OpDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.OpDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.OpDef.displayName = 'proto.tensorflow.OpDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.OpDef.ArgDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.OpDef.ArgDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.OpDef.ArgDef.displayName = 'proto.tensorflow.OpDef.ArgDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.OpDef.AttrDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.OpDef.AttrDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.OpDef.AttrDef.displayName = 'proto.tensorflow.OpDef.AttrDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.OpDef.OpDeprecation = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.OpDef.OpDeprecation, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.OpDef.OpDeprecation.displayName = 'proto.tensorflow.OpDef.OpDeprecation';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.OpList = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.OpList.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.OpList, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.OpList.displayName = 'proto.tensorflow.OpList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.MetaGraphDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.MetaGraphDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.MetaGraphDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.MetaGraphDef.displayName = 'proto.tensorflow.MetaGraphDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.MetaGraphDef.MetaInfoDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.MetaGraphDef.MetaInfoDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.MetaGraphDef.MetaInfoDef.displayName = 'proto.tensorflow.MetaGraphDef.MetaInfoDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.SavedModel = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.SavedModel.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.SavedModel, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.SavedModel.displayName = 'proto.tensorflow.SavedModel';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.FunctionDefLibrary = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.FunctionDefLibrary.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.FunctionDefLibrary, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.FunctionDefLibrary.displayName = 'proto.tensorflow.FunctionDefLibrary';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.FunctionDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.tensorflow.FunctionDef.repeatedFields_, null);
};

goog.inherits(proto.tensorflow.FunctionDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.FunctionDef.displayName = 'proto.tensorflow.FunctionDef';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */


proto.tensorflow.GradientDef = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};

goog.inherits(proto.tensorflow.GradientDef, jspb.Message);

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.tensorflow.GradientDef.displayName = 'proto.tensorflow.GradientDef';
}

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.Any.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.Any.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.Any} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.Any.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      typeUrl: jspb.Message.getFieldWithDefault(msg, 1, ""),
      value: msg.getValue_asB64()
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.Any}
 */


proto.tensorflow.Any.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.Any();
  return proto.tensorflow.Any.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.Any} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.Any}
 */


proto.tensorflow.Any.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setTypeUrl(value);
        break;

      case 2:
        var value =
        /** @type {!Uint8Array} */
        reader.readBytes();
        msg.setValue(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.Any.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.Any.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.Any} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.Any.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getTypeUrl();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getValue_asU8();

  if (f.length > 0) {
    writer.writeBytes(2, f);
  }
};
/**
 * optional string type_url = 1;
 * @return {string}
 */


proto.tensorflow.Any.prototype.getTypeUrl = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.Any.prototype.setTypeUrl = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional bytes value = 2;
 * @return {!(string|Uint8Array)}
 */


proto.tensorflow.Any.prototype.getValue = function () {
  return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/**
 * optional bytes value = 2;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */


proto.tensorflow.Any.prototype.getValue_asB64 = function () {
  return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getValue())
  );
};
/**
 * optional bytes value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */


proto.tensorflow.Any.prototype.getValue_asU8 = function () {
  return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getValue())
  );
};
/** @param {!(string|Uint8Array)} value */


proto.tensorflow.Any.prototype.setValue = function (value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.TensorShape.repeatedFields_ = [2];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.TensorShape.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.TensorShape.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.TensorShape} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.TensorShape.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      dimList: jspb.Message.toObjectList(msg.getDimList(), proto.tensorflow.TensorShape.Dim.toObject, includeInstance),
      unknownRank: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.TensorShape}
 */


proto.tensorflow.TensorShape.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.TensorShape();
  return proto.tensorflow.TensorShape.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.TensorShape} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.TensorShape}
 */


proto.tensorflow.TensorShape.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 2:
        var value = new proto.tensorflow.TensorShape.Dim();
        reader.readMessage(value, proto.tensorflow.TensorShape.Dim.deserializeBinaryFromReader);
        msg.addDim(value);
        break;

      case 3:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setUnknownRank(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.TensorShape.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.TensorShape.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.TensorShape} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.TensorShape.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getDimList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(2, f, proto.tensorflow.TensorShape.Dim.serializeBinaryToWriter);
  }

  f = message.getUnknownRank();

  if (f) {
    writer.writeBool(3, f);
  }
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.TensorShape.Dim.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.TensorShape.Dim.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.TensorShape.Dim} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.TensorShape.Dim.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      size: jspb.Message.getFieldWithDefault(msg, 1, 0),
      name: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.TensorShape.Dim}
 */


proto.tensorflow.TensorShape.Dim.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.TensorShape.Dim();
  return proto.tensorflow.TensorShape.Dim.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.TensorShape.Dim} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.TensorShape.Dim}
 */


proto.tensorflow.TensorShape.Dim.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {number} */
        reader.readInt64();
        msg.setSize(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.TensorShape.Dim.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.TensorShape.Dim.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.TensorShape.Dim} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.TensorShape.Dim.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getSize();

  if (f !== 0) {
    writer.writeInt64(1, f);
  }

  f = message.getName();

  if (f.length > 0) {
    writer.writeString(2, f);
  }
};
/**
 * optional int64 size = 1;
 * @return {number}
 */


proto.tensorflow.TensorShape.Dim.prototype.getSize = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};
/** @param {number} value */


proto.tensorflow.TensorShape.Dim.prototype.setSize = function (value) {
  jspb.Message.setProto3IntField(this, 1, value);
};
/**
 * optional string name = 2;
 * @return {string}
 */


proto.tensorflow.TensorShape.Dim.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.TensorShape.Dim.prototype.setName = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * repeated Dim dim = 2;
 * @return {!Array<!proto.tensorflow.TensorShape.Dim>}
 */


proto.tensorflow.TensorShape.prototype.getDimList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.TensorShape.Dim>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.TensorShape.Dim, 2)
  );
};
/** @param {!Array<!proto.tensorflow.TensorShape.Dim>} value */


proto.tensorflow.TensorShape.prototype.setDimList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};
/**
 * @param {!proto.tensorflow.TensorShape.Dim=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.TensorShape.Dim}
 */


proto.tensorflow.TensorShape.prototype.addDim = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tensorflow.TensorShape.Dim, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.TensorShape.prototype.clearDimList = function () {
  this.setDimList([]);
};
/**
 * optional bool unknown_rank = 3;
 * @return {boolean}
 */


proto.tensorflow.TensorShape.prototype.getUnknownRank = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 3, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.TensorShape.prototype.setUnknownRank = function (value) {
  jspb.Message.setProto3BooleanField(this, 3, value);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.Tensor.repeatedFields_ = [5, 6, 7, 8, 9, 10, 11, 16, 17];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.Tensor.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.Tensor.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.Tensor} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.Tensor.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      dtype: jspb.Message.getFieldWithDefault(msg, 1, 0),
      tensorShape: (f = msg.getTensorShape()) && proto.tensorflow.TensorShape.toObject(includeInstance, f),
      versionNumber: jspb.Message.getFieldWithDefault(msg, 3, 0),
      tensorContent: msg.getTensorContent_asB64(),
      floatValList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 5)) == null ? undefined : f,
      doubleValList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 6)) == null ? undefined : f,
      intValList: (f = jspb.Message.getRepeatedField(msg, 7)) == null ? undefined : f,
      stringValList: msg.getStringValList_asB64(),
      scomplexValList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 9)) == null ? undefined : f,
      int64ValList: (f = jspb.Message.getRepeatedField(msg, 10)) == null ? undefined : f,
      boolValList: (f = jspb.Message.getRepeatedBooleanField(msg, 11)) == null ? undefined : f,
      uint32ValList: (f = jspb.Message.getRepeatedField(msg, 16)) == null ? undefined : f,
      uint64ValList: (f = jspb.Message.getRepeatedField(msg, 17)) == null ? undefined : f
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.Tensor}
 */


proto.tensorflow.Tensor.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.Tensor();
  return proto.tensorflow.Tensor.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.Tensor} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.Tensor}
 */


proto.tensorflow.Tensor.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {!proto.tensorflow.DataType} */
        reader.readEnum();
        msg.setDtype(value);
        break;

      case 2:
        var value = new proto.tensorflow.TensorShape();
        reader.readMessage(value, proto.tensorflow.TensorShape.deserializeBinaryFromReader);
        msg.setTensorShape(value);
        break;

      case 3:
        var value =
        /** @type {number} */
        reader.readInt32();
        msg.setVersionNumber(value);
        break;

      case 4:
        var value =
        /** @type {!Uint8Array} */
        reader.readBytes();
        msg.setTensorContent(value);
        break;

      case 5:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedFloat();
        msg.setFloatValList(value);
        break;

      case 6:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedDouble();
        msg.setDoubleValList(value);
        break;

      case 7:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedInt32();
        msg.setIntValList(value);
        break;

      case 8:
        var value =
        /** @type {!Uint8Array} */
        reader.readBytes();
        msg.addStringVal(value);
        break;

      case 9:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedFloat();
        msg.setScomplexValList(value);
        break;

      case 10:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedInt64();
        msg.setInt64ValList(value);
        break;

      case 11:
        var value =
        /** @type {!Array<boolean>} */
        reader.readPackedBool();
        msg.setBoolValList(value);
        break;

      case 16:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedUint32();
        msg.setUint32ValList(value);
        break;

      case 17:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedUint64();
        msg.setUint64ValList(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.Tensor.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.Tensor.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.Tensor} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.Tensor.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getDtype();

  if (f !== 0.0) {
    writer.writeEnum(1, f);
  }

  f = message.getTensorShape();

  if (f != null) {
    writer.writeMessage(2, f, proto.tensorflow.TensorShape.serializeBinaryToWriter);
  }

  f = message.getVersionNumber();

  if (f !== 0) {
    writer.writeInt32(3, f);
  }

  f = message.getTensorContent_asU8();

  if (f.length > 0) {
    writer.writeBytes(4, f);
  }

  f = message.getFloatValList();

  if (f.length > 0) {
    writer.writePackedFloat(5, f);
  }

  f = message.getDoubleValList();

  if (f.length > 0) {
    writer.writePackedDouble(6, f);
  }

  f = message.getIntValList();

  if (f.length > 0) {
    writer.writePackedInt32(7, f);
  }

  f = message.getStringValList_asU8();

  if (f.length > 0) {
    writer.writeRepeatedBytes(8, f);
  }

  f = message.getScomplexValList();

  if (f.length > 0) {
    writer.writePackedFloat(9, f);
  }

  f = message.getInt64ValList();

  if (f.length > 0) {
    writer.writePackedInt64(10, f);
  }

  f = message.getBoolValList();

  if (f.length > 0) {
    writer.writePackedBool(11, f);
  }

  f = message.getUint32ValList();

  if (f.length > 0) {
    writer.writePackedUint32(16, f);
  }

  f = message.getUint64ValList();

  if (f.length > 0) {
    writer.writePackedUint64(17, f);
  }
};
/**
 * optional DataType dtype = 1;
 * @return {!proto.tensorflow.DataType}
 */


proto.tensorflow.Tensor.prototype.getDtype = function () {
  return (
    /** @type {!proto.tensorflow.DataType} */
    jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};
/** @param {!proto.tensorflow.DataType} value */


proto.tensorflow.Tensor.prototype.setDtype = function (value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};
/**
 * optional TensorShape tensor_shape = 2;
 * @return {?proto.tensorflow.TensorShape}
 */


proto.tensorflow.Tensor.prototype.getTensorShape = function () {
  return (
    /** @type{?proto.tensorflow.TensorShape} */
    jspb.Message.getWrapperField(this, proto.tensorflow.TensorShape, 2)
  );
};
/** @param {?proto.tensorflow.TensorShape|undefined} value */


proto.tensorflow.Tensor.prototype.setTensorShape = function (value) {
  jspb.Message.setWrapperField(this, 2, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.Tensor.prototype.clearTensorShape = function () {
  this.setTensorShape(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.Tensor.prototype.hasTensorShape = function () {
  return jspb.Message.getField(this, 2) != null;
};
/**
 * optional int32 version_number = 3;
 * @return {number}
 */


proto.tensorflow.Tensor.prototype.getVersionNumber = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 3, 0)
  );
};
/** @param {number} value */


proto.tensorflow.Tensor.prototype.setVersionNumber = function (value) {
  jspb.Message.setProto3IntField(this, 3, value);
};
/**
 * optional bytes tensor_content = 4;
 * @return {!(string|Uint8Array)}
 */


proto.tensorflow.Tensor.prototype.getTensorContent = function () {
  return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 4, "")
  );
};
/**
 * optional bytes tensor_content = 4;
 * This is a type-conversion wrapper around `getTensorContent()`
 * @return {string}
 */


proto.tensorflow.Tensor.prototype.getTensorContent_asB64 = function () {
  return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getTensorContent())
  );
};
/**
 * optional bytes tensor_content = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTensorContent()`
 * @return {!Uint8Array}
 */


proto.tensorflow.Tensor.prototype.getTensorContent_asU8 = function () {
  return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getTensorContent())
  );
};
/** @param {!(string|Uint8Array)} value */


proto.tensorflow.Tensor.prototype.setTensorContent = function (value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};
/**
 * repeated float float_val = 5;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getFloatValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedFloatingPointField(this, 5)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setFloatValList = function (value) {
  jspb.Message.setField(this, 5, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addFloatVal = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearFloatValList = function () {
  this.setFloatValList([]);
};
/**
 * repeated double double_val = 6;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getDoubleValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedFloatingPointField(this, 6)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setDoubleValList = function (value) {
  jspb.Message.setField(this, 6, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addDoubleVal = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 6, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearDoubleValList = function () {
  this.setDoubleValList([]);
};
/**
 * repeated int32 int_val = 7;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getIntValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 7)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setIntValList = function (value) {
  jspb.Message.setField(this, 7, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addIntVal = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 7, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearIntValList = function () {
  this.setIntValList([]);
};
/**
 * repeated bytes string_val = 8;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */


proto.tensorflow.Tensor.prototype.getStringValList = function () {
  return (
    /** @type {!(Array<!Uint8Array>|Array<string>)} */
    jspb.Message.getRepeatedField(this, 8)
  );
};
/**
 * repeated bytes string_val = 8;
 * This is a type-conversion wrapper around `getStringValList()`
 * @return {!Array<string>}
 */


proto.tensorflow.Tensor.prototype.getStringValList_asB64 = function () {
  return (
    /** @type {!Array<string>} */
    jspb.Message.bytesListAsB64(this.getStringValList())
  );
};
/**
 * repeated bytes string_val = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStringValList()`
 * @return {!Array<!Uint8Array>}
 */


proto.tensorflow.Tensor.prototype.getStringValList_asU8 = function () {
  return (
    /** @type {!Array<!Uint8Array>} */
    jspb.Message.bytesListAsU8(this.getStringValList())
  );
};
/** @param {!(Array<!Uint8Array>|Array<string>)} value */


proto.tensorflow.Tensor.prototype.setStringValList = function (value) {
  jspb.Message.setField(this, 8, value || []);
};
/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addStringVal = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 8, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearStringValList = function () {
  this.setStringValList([]);
};
/**
 * repeated float scomplex_val = 9;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getScomplexValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedFloatingPointField(this, 9)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setScomplexValList = function (value) {
  jspb.Message.setField(this, 9, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addScomplexVal = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 9, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearScomplexValList = function () {
  this.setScomplexValList([]);
};
/**
 * repeated int64 int64_val = 10;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getInt64ValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 10)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setInt64ValList = function (value) {
  jspb.Message.setField(this, 10, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addInt64Val = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 10, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearInt64ValList = function () {
  this.setInt64ValList([]);
};
/**
 * repeated bool bool_val = 11;
 * @return {!Array<boolean>}
 */


proto.tensorflow.Tensor.prototype.getBoolValList = function () {
  return (
    /** @type {!Array<boolean>} */
    jspb.Message.getRepeatedBooleanField(this, 11)
  );
};
/** @param {!Array<boolean>} value */


proto.tensorflow.Tensor.prototype.setBoolValList = function (value) {
  jspb.Message.setField(this, 11, value || []);
};
/**
 * @param {boolean} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addBoolVal = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 11, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearBoolValList = function () {
  this.setBoolValList([]);
};
/**
 * repeated uint32 uint32_val = 16;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getUint32ValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 16)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setUint32ValList = function (value) {
  jspb.Message.setField(this, 16, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addUint32Val = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 16, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearUint32ValList = function () {
  this.setUint32ValList([]);
};
/**
 * repeated uint64 uint64_val = 17;
 * @return {!Array<number>}
 */


proto.tensorflow.Tensor.prototype.getUint64ValList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 17)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.Tensor.prototype.setUint64ValList = function (value) {
  jspb.Message.setField(this, 17, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.Tensor.prototype.addUint64Val = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 17, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.Tensor.prototype.clearUint64ValList = function () {
  this.setUint64ValList([]);
};
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */


proto.tensorflow.AttrValue.oneofGroups_ = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]];
/**
 * @enum {number}
 */

proto.tensorflow.AttrValue.ValueCase = {
  VALUE_NOT_SET: 0,
  LIST: 1,
  S: 2,
  I: 3,
  F: 4,
  B: 5,
  TYPE: 6,
  SHAPE: 7,
  TENSOR: 8,
  PLACEHOLDER: 9,
  FUNC: 10
};
/**
 * @return {proto.tensorflow.AttrValue.ValueCase}
 */

proto.tensorflow.AttrValue.prototype.getValueCase = function () {
  return (
    /** @type {proto.tensorflow.AttrValue.ValueCase} */
    jspb.Message.computeOneofCase(this, proto.tensorflow.AttrValue.oneofGroups_[0])
  );
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.AttrValue.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.AttrValue.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.AttrValue} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.AttrValue.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      list: (f = msg.getList()) && proto.tensorflow.AttrValue.ListValue.toObject(includeInstance, f),
      s: msg.getS_asB64(),
      i: jspb.Message.getFieldWithDefault(msg, 3, 0),
      f: jspb.Message.getFloatingPointFieldWithDefault(msg, 4, 0.0),
      b: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
      type: jspb.Message.getFieldWithDefault(msg, 6, 0),
      shape: (f = msg.getShape()) && proto.tensorflow.TensorShape.toObject(includeInstance, f),
      tensor: (f = msg.getTensor()) && proto.tensorflow.Tensor.toObject(includeInstance, f),
      placeholder: jspb.Message.getFieldWithDefault(msg, 9, ""),
      func: (f = msg.getFunc()) && proto.tensorflow.NameAttrList.toObject(includeInstance, f)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.AttrValue}
 */


proto.tensorflow.AttrValue.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.AttrValue();
  return proto.tensorflow.AttrValue.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.AttrValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.AttrValue}
 */


proto.tensorflow.AttrValue.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.AttrValue.ListValue();
        reader.readMessage(value, proto.tensorflow.AttrValue.ListValue.deserializeBinaryFromReader);
        msg.setList(value);
        break;

      case 2:
        var value =
        /** @type {!Uint8Array} */
        reader.readBytes();
        msg.setS(value);
        break;

      case 3:
        var value =
        /** @type {number} */
        reader.readInt64();
        msg.setI(value);
        break;

      case 4:
        var value =
        /** @type {number} */
        reader.readFloat();
        msg.setF(value);
        break;

      case 5:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setB(value);
        break;

      case 6:
        var value =
        /** @type {!proto.tensorflow.DataType} */
        reader.readEnum();
        msg.setType(value);
        break;

      case 7:
        var value = new proto.tensorflow.TensorShape();
        reader.readMessage(value, proto.tensorflow.TensorShape.deserializeBinaryFromReader);
        msg.setShape(value);
        break;

      case 8:
        var value = new proto.tensorflow.Tensor();
        reader.readMessage(value, proto.tensorflow.Tensor.deserializeBinaryFromReader);
        msg.setTensor(value);
        break;

      case 9:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setPlaceholder(value);
        break;

      case 10:
        var value = new proto.tensorflow.NameAttrList();
        reader.readMessage(value, proto.tensorflow.NameAttrList.deserializeBinaryFromReader);
        msg.setFunc(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.AttrValue.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.AttrValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.AttrValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.AttrValue.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getList();

  if (f != null) {
    writer.writeMessage(1, f, proto.tensorflow.AttrValue.ListValue.serializeBinaryToWriter);
  }

  f =
  /** @type {!(string|Uint8Array)} */
  jspb.Message.getField(message, 2);

  if (f != null) {
    writer.writeBytes(2, f);
  }

  f =
  /** @type {number} */
  jspb.Message.getField(message, 3);

  if (f != null) {
    writer.writeInt64(3, f);
  }

  f =
  /** @type {number} */
  jspb.Message.getField(message, 4);

  if (f != null) {
    writer.writeFloat(4, f);
  }

  f =
  /** @type {boolean} */
  jspb.Message.getField(message, 5);

  if (f != null) {
    writer.writeBool(5, f);
  }

  f =
  /** @type {!proto.tensorflow.DataType} */
  jspb.Message.getField(message, 6);

  if (f != null) {
    writer.writeEnum(6, f);
  }

  f = message.getShape();

  if (f != null) {
    writer.writeMessage(7, f, proto.tensorflow.TensorShape.serializeBinaryToWriter);
  }

  f = message.getTensor();

  if (f != null) {
    writer.writeMessage(8, f, proto.tensorflow.Tensor.serializeBinaryToWriter);
  }

  f =
  /** @type {string} */
  jspb.Message.getField(message, 9);

  if (f != null) {
    writer.writeString(9, f);
  }

  f = message.getFunc();

  if (f != null) {
    writer.writeMessage(10, f, proto.tensorflow.NameAttrList.serializeBinaryToWriter);
  }
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.AttrValue.ListValue.repeatedFields_ = [2, 3, 4, 5, 6, 7, 8, 9];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.AttrValue.ListValue.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.AttrValue.ListValue.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.AttrValue.ListValue} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.AttrValue.ListValue.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      sList: msg.getSList_asB64(),
      iList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f,
      fList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 4)) == null ? undefined : f,
      bList: (f = jspb.Message.getRepeatedBooleanField(msg, 5)) == null ? undefined : f,
      typeList: (f = jspb.Message.getRepeatedField(msg, 6)) == null ? undefined : f,
      shapeList: jspb.Message.toObjectList(msg.getShapeList(), proto.tensorflow.TensorShape.toObject, includeInstance),
      tensorList: jspb.Message.toObjectList(msg.getTensorList(), proto.tensorflow.Tensor.toObject, includeInstance),
      funcList: jspb.Message.toObjectList(msg.getFuncList(), proto.tensorflow.NameAttrList.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.AttrValue.ListValue}
 */


proto.tensorflow.AttrValue.ListValue.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.AttrValue.ListValue();
  return proto.tensorflow.AttrValue.ListValue.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.AttrValue.ListValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.AttrValue.ListValue}
 */


proto.tensorflow.AttrValue.ListValue.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 2:
        var value =
        /** @type {!Uint8Array} */
        reader.readBytes();
        msg.addS(value);
        break;

      case 3:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedInt64();
        msg.setIList(value);
        break;

      case 4:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedFloat();
        msg.setFList(value);
        break;

      case 5:
        var value =
        /** @type {!Array<boolean>} */
        reader.readPackedBool();
        msg.setBList(value);
        break;

      case 6:
        var value =
        /** @type {!Array<!proto.tensorflow.DataType>} */
        reader.readPackedEnum();
        msg.setTypeList(value);
        break;

      case 7:
        var value = new proto.tensorflow.TensorShape();
        reader.readMessage(value, proto.tensorflow.TensorShape.deserializeBinaryFromReader);
        msg.addShape(value);
        break;

      case 8:
        var value = new proto.tensorflow.Tensor();
        reader.readMessage(value, proto.tensorflow.Tensor.deserializeBinaryFromReader);
        msg.addTensor(value);
        break;

      case 9:
        var value = new proto.tensorflow.NameAttrList();
        reader.readMessage(value, proto.tensorflow.NameAttrList.deserializeBinaryFromReader);
        msg.addFunc(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.AttrValue.ListValue.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.AttrValue.ListValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.AttrValue.ListValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.AttrValue.ListValue.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getSList_asU8();

  if (f.length > 0) {
    writer.writeRepeatedBytes(2, f);
  }

  f = message.getIList();

  if (f.length > 0) {
    writer.writePackedInt64(3, f);
  }

  f = message.getFList();

  if (f.length > 0) {
    writer.writePackedFloat(4, f);
  }

  f = message.getBList();

  if (f.length > 0) {
    writer.writePackedBool(5, f);
  }

  f = message.getTypeList();

  if (f.length > 0) {
    writer.writePackedEnum(6, f);
  }

  f = message.getShapeList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(7, f, proto.tensorflow.TensorShape.serializeBinaryToWriter);
  }

  f = message.getTensorList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(8, f, proto.tensorflow.Tensor.serializeBinaryToWriter);
  }

  f = message.getFuncList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(9, f, proto.tensorflow.NameAttrList.serializeBinaryToWriter);
  }
};
/**
 * repeated bytes s = 2;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getSList = function () {
  return (
    /** @type {!(Array<!Uint8Array>|Array<string>)} */
    jspb.Message.getRepeatedField(this, 2)
  );
};
/**
 * repeated bytes s = 2;
 * This is a type-conversion wrapper around `getSList()`
 * @return {!Array<string>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getSList_asB64 = function () {
  return (
    /** @type {!Array<string>} */
    jspb.Message.bytesListAsB64(this.getSList())
  );
};
/**
 * repeated bytes s = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSList()`
 * @return {!Array<!Uint8Array>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getSList_asU8 = function () {
  return (
    /** @type {!Array<!Uint8Array>} */
    jspb.Message.bytesListAsU8(this.getSList())
  );
};
/** @param {!(Array<!Uint8Array>|Array<string>)} value */


proto.tensorflow.AttrValue.ListValue.prototype.setSList = function (value) {
  jspb.Message.setField(this, 2, value || []);
};
/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */


proto.tensorflow.AttrValue.ListValue.prototype.addS = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearSList = function () {
  this.setSList([]);
};
/**
 * repeated int64 i = 3;
 * @return {!Array<number>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getIList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 3)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setIList = function (value) {
  jspb.Message.setField(this, 3, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.AttrValue.ListValue.prototype.addI = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearIList = function () {
  this.setIList([]);
};
/**
 * repeated float f = 4;
 * @return {!Array<number>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getFList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedFloatingPointField(this, 4)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setFList = function (value) {
  jspb.Message.setField(this, 4, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.AttrValue.ListValue.prototype.addF = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearFList = function () {
  this.setFList([]);
};
/**
 * repeated bool b = 5;
 * @return {!Array<boolean>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getBList = function () {
  return (
    /** @type {!Array<boolean>} */
    jspb.Message.getRepeatedBooleanField(this, 5)
  );
};
/** @param {!Array<boolean>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setBList = function (value) {
  jspb.Message.setField(this, 5, value || []);
};
/**
 * @param {boolean} value
 * @param {number=} opt_index
 */


proto.tensorflow.AttrValue.ListValue.prototype.addB = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearBList = function () {
  this.setBList([]);
};
/**
 * repeated DataType type = 6;
 * @return {!Array<!proto.tensorflow.DataType>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getTypeList = function () {
  return (
    /** @type {!Array<!proto.tensorflow.DataType>} */
    jspb.Message.getRepeatedField(this, 6)
  );
};
/** @param {!Array<!proto.tensorflow.DataType>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setTypeList = function (value) {
  jspb.Message.setField(this, 6, value || []);
};
/**
 * @param {!proto.tensorflow.DataType} value
 * @param {number=} opt_index
 */


proto.tensorflow.AttrValue.ListValue.prototype.addType = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 6, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearTypeList = function () {
  this.setTypeList([]);
};
/**
 * repeated TensorShape shape = 7;
 * @return {!Array<!proto.tensorflow.TensorShape>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getShapeList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.TensorShape>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.TensorShape, 7)
  );
};
/** @param {!Array<!proto.tensorflow.TensorShape>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setShapeList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 7, value);
};
/**
 * @param {!proto.tensorflow.TensorShape=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.TensorShape}
 */


proto.tensorflow.AttrValue.ListValue.prototype.addShape = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.tensorflow.TensorShape, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearShapeList = function () {
  this.setShapeList([]);
};
/**
 * repeated Tensor tensor = 8;
 * @return {!Array<!proto.tensorflow.Tensor>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getTensorList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.Tensor>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.Tensor, 8)
  );
};
/** @param {!Array<!proto.tensorflow.Tensor>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setTensorList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 8, value);
};
/**
 * @param {!proto.tensorflow.Tensor=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.Tensor}
 */


proto.tensorflow.AttrValue.ListValue.prototype.addTensor = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 8, opt_value, proto.tensorflow.Tensor, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearTensorList = function () {
  this.setTensorList([]);
};
/**
 * repeated NameAttrList func = 9;
 * @return {!Array<!proto.tensorflow.NameAttrList>}
 */


proto.tensorflow.AttrValue.ListValue.prototype.getFuncList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.NameAttrList>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.NameAttrList, 9)
  );
};
/** @param {!Array<!proto.tensorflow.NameAttrList>} value */


proto.tensorflow.AttrValue.ListValue.prototype.setFuncList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 9, value);
};
/**
 * @param {!proto.tensorflow.NameAttrList=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.NameAttrList}
 */


proto.tensorflow.AttrValue.ListValue.prototype.addFunc = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 9, opt_value, proto.tensorflow.NameAttrList, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.AttrValue.ListValue.prototype.clearFuncList = function () {
  this.setFuncList([]);
};
/**
 * optional ListValue list = 1;
 * @return {?proto.tensorflow.AttrValue.ListValue}
 */


proto.tensorflow.AttrValue.prototype.getList = function () {
  return (
    /** @type{?proto.tensorflow.AttrValue.ListValue} */
    jspb.Message.getWrapperField(this, proto.tensorflow.AttrValue.ListValue, 1)
  );
};
/** @param {?proto.tensorflow.AttrValue.ListValue|undefined} value */


proto.tensorflow.AttrValue.prototype.setList = function (value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearList = function () {
  this.setList(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasList = function () {
  return jspb.Message.getField(this, 1) != null;
};
/**
 * optional bytes s = 2;
 * @return {!(string|Uint8Array)}
 */


proto.tensorflow.AttrValue.prototype.getS = function () {
  return (
    /** @type {!(string|Uint8Array)} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/**
 * optional bytes s = 2;
 * This is a type-conversion wrapper around `getS()`
 * @return {string}
 */


proto.tensorflow.AttrValue.prototype.getS_asB64 = function () {
  return (
    /** @type {string} */
    jspb.Message.bytesAsB64(this.getS())
  );
};
/**
 * optional bytes s = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getS()`
 * @return {!Uint8Array}
 */


proto.tensorflow.AttrValue.prototype.getS_asU8 = function () {
  return (
    /** @type {!Uint8Array} */
    jspb.Message.bytesAsU8(this.getS())
  );
};
/** @param {!(string|Uint8Array)} value */


proto.tensorflow.AttrValue.prototype.setS = function (value) {
  jspb.Message.setOneofField(this, 2, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearS = function () {
  jspb.Message.setOneofField(this, 2, proto.tensorflow.AttrValue.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasS = function () {
  return jspb.Message.getField(this, 2) != null;
};
/**
 * optional int64 i = 3;
 * @return {number}
 */


proto.tensorflow.AttrValue.prototype.getI = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 3, 0)
  );
};
/** @param {number} value */


proto.tensorflow.AttrValue.prototype.setI = function (value) {
  jspb.Message.setOneofField(this, 3, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearI = function () {
  jspb.Message.setOneofField(this, 3, proto.tensorflow.AttrValue.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasI = function () {
  return jspb.Message.getField(this, 3) != null;
};
/**
 * optional float f = 4;
 * @return {number}
 */


proto.tensorflow.AttrValue.prototype.getF = function () {
  return (
    /** @type {number} */
    jspb.Message.getFloatingPointFieldWithDefault(this, 4, 0.0)
  );
};
/** @param {number} value */


proto.tensorflow.AttrValue.prototype.setF = function (value) {
  jspb.Message.setOneofField(this, 4, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearF = function () {
  jspb.Message.setOneofField(this, 4, proto.tensorflow.AttrValue.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasF = function () {
  return jspb.Message.getField(this, 4) != null;
};
/**
 * optional bool b = 5;
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.getB = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 5, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.AttrValue.prototype.setB = function (value) {
  jspb.Message.setOneofField(this, 5, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearB = function () {
  jspb.Message.setOneofField(this, 5, proto.tensorflow.AttrValue.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasB = function () {
  return jspb.Message.getField(this, 5) != null;
};
/**
 * optional DataType type = 6;
 * @return {!proto.tensorflow.DataType}
 */


proto.tensorflow.AttrValue.prototype.getType = function () {
  return (
    /** @type {!proto.tensorflow.DataType} */
    jspb.Message.getFieldWithDefault(this, 6, 0)
  );
};
/** @param {!proto.tensorflow.DataType} value */


proto.tensorflow.AttrValue.prototype.setType = function (value) {
  jspb.Message.setOneofField(this, 6, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearType = function () {
  jspb.Message.setOneofField(this, 6, proto.tensorflow.AttrValue.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasType = function () {
  return jspb.Message.getField(this, 6) != null;
};
/**
 * optional TensorShape shape = 7;
 * @return {?proto.tensorflow.TensorShape}
 */


proto.tensorflow.AttrValue.prototype.getShape = function () {
  return (
    /** @type{?proto.tensorflow.TensorShape} */
    jspb.Message.getWrapperField(this, proto.tensorflow.TensorShape, 7)
  );
};
/** @param {?proto.tensorflow.TensorShape|undefined} value */


proto.tensorflow.AttrValue.prototype.setShape = function (value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearShape = function () {
  this.setShape(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasShape = function () {
  return jspb.Message.getField(this, 7) != null;
};
/**
 * optional Tensor tensor = 8;
 * @return {?proto.tensorflow.Tensor}
 */


proto.tensorflow.AttrValue.prototype.getTensor = function () {
  return (
    /** @type{?proto.tensorflow.Tensor} */
    jspb.Message.getWrapperField(this, proto.tensorflow.Tensor, 8)
  );
};
/** @param {?proto.tensorflow.Tensor|undefined} value */


proto.tensorflow.AttrValue.prototype.setTensor = function (value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearTensor = function () {
  this.setTensor(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasTensor = function () {
  return jspb.Message.getField(this, 8) != null;
};
/**
 * optional string placeholder = 9;
 * @return {string}
 */


proto.tensorflow.AttrValue.prototype.getPlaceholder = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 9, "")
  );
};
/** @param {string} value */


proto.tensorflow.AttrValue.prototype.setPlaceholder = function (value) {
  jspb.Message.setOneofField(this, 9, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearPlaceholder = function () {
  jspb.Message.setOneofField(this, 9, proto.tensorflow.AttrValue.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasPlaceholder = function () {
  return jspb.Message.getField(this, 9) != null;
};
/**
 * optional NameAttrList func = 10;
 * @return {?proto.tensorflow.NameAttrList}
 */


proto.tensorflow.AttrValue.prototype.getFunc = function () {
  return (
    /** @type{?proto.tensorflow.NameAttrList} */
    jspb.Message.getWrapperField(this, proto.tensorflow.NameAttrList, 10)
  );
};
/** @param {?proto.tensorflow.NameAttrList|undefined} value */


proto.tensorflow.AttrValue.prototype.setFunc = function (value) {
  jspb.Message.setOneofWrapperField(this, 10, proto.tensorflow.AttrValue.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.AttrValue.prototype.clearFunc = function () {
  this.setFunc(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AttrValue.prototype.hasFunc = function () {
  return jspb.Message.getField(this, 10) != null;
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.NameAttrList.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.NameAttrList.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.NameAttrList} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.NameAttrList.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      attrMap: (f = msg.getAttrMap()) ? f.toObject(includeInstance, proto.tensorflow.AttrValue.toObject) : []
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.NameAttrList}
 */


proto.tensorflow.NameAttrList.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.NameAttrList();
  return proto.tensorflow.NameAttrList.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.NameAttrList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.NameAttrList}
 */


proto.tensorflow.NameAttrList.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      case 2:
        var value = msg.getAttrMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.AttrValue.deserializeBinaryFromReader, "");
        });
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.NameAttrList.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.NameAttrList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.NameAttrList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.NameAttrList.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getAttrMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.AttrValue.serializeBinaryToWriter);
  }
};
/**
 * optional string name = 1;
 * @return {string}
 */


proto.tensorflow.NameAttrList.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.NameAttrList.prototype.setName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * map<string, AttrValue> attr = 2;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.AttrValue>}
 */


proto.tensorflow.NameAttrList.prototype.getAttrMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.AttrValue>} */
    jspb.Message.getMapField(this, 2, opt_noLazyCreate, proto.tensorflow.AttrValue)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.NameAttrList.prototype.clearAttrMap = function () {
  this.getAttrMap().clear();
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.NodeDef.repeatedFields_ = [3];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.NodeDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.NodeDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.NodeDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.NodeDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      op: jspb.Message.getFieldWithDefault(msg, 2, ""),
      inputList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f,
      device: jspb.Message.getFieldWithDefault(msg, 4, ""),
      attrMap: (f = msg.getAttrMap()) ? f.toObject(includeInstance, proto.tensorflow.AttrValue.toObject) : []
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.NodeDef}
 */


proto.tensorflow.NodeDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.NodeDef();
  return proto.tensorflow.NodeDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.NodeDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.NodeDef}
 */


proto.tensorflow.NodeDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setOp(value);
        break;

      case 3:
        var value =
        /** @type {string} */
        reader.readString();
        msg.addInput(value);
        break;

      case 4:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setDevice(value);
        break;

      case 5:
        var value = msg.getAttrMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.AttrValue.deserializeBinaryFromReader, "");
        });
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.NodeDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.NodeDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.NodeDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.NodeDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getOp();

  if (f.length > 0) {
    writer.writeString(2, f);
  }

  f = message.getInputList();

  if (f.length > 0) {
    writer.writeRepeatedString(3, f);
  }

  f = message.getDevice();

  if (f.length > 0) {
    writer.writeString(4, f);
  }

  f = message.getAttrMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.AttrValue.serializeBinaryToWriter);
  }
};
/**
 * optional string name = 1;
 * @return {string}
 */


proto.tensorflow.NodeDef.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.NodeDef.prototype.setName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string op = 2;
 * @return {string}
 */


proto.tensorflow.NodeDef.prototype.getOp = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.NodeDef.prototype.setOp = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * repeated string input = 3;
 * @return {!Array<string>}
 */


proto.tensorflow.NodeDef.prototype.getInputList = function () {
  return (
    /** @type {!Array<string>} */
    jspb.Message.getRepeatedField(this, 3)
  );
};
/** @param {!Array<string>} value */


proto.tensorflow.NodeDef.prototype.setInputList = function (value) {
  jspb.Message.setField(this, 3, value || []);
};
/**
 * @param {string} value
 * @param {number=} opt_index
 */


proto.tensorflow.NodeDef.prototype.addInput = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.NodeDef.prototype.clearInputList = function () {
  this.setInputList([]);
};
/**
 * optional string device = 4;
 * @return {string}
 */


proto.tensorflow.NodeDef.prototype.getDevice = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 4, "")
  );
};
/** @param {string} value */


proto.tensorflow.NodeDef.prototype.setDevice = function (value) {
  jspb.Message.setProto3StringField(this, 4, value);
};
/**
 * map<string, AttrValue> attr = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.AttrValue>}
 */


proto.tensorflow.NodeDef.prototype.getAttrMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.AttrValue>} */
    jspb.Message.getMapField(this, 5, opt_noLazyCreate, proto.tensorflow.AttrValue)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.NodeDef.prototype.clearAttrMap = function () {
  this.getAttrMap().clear();
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.VersionDef.repeatedFields_ = [3];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.VersionDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.VersionDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.VersionDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.VersionDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      producer: jspb.Message.getFieldWithDefault(msg, 1, 0),
      minConsumer: jspb.Message.getFieldWithDefault(msg, 2, 0),
      badConsumersList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.VersionDef}
 */


proto.tensorflow.VersionDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.VersionDef();
  return proto.tensorflow.VersionDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.VersionDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.VersionDef}
 */


proto.tensorflow.VersionDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {number} */
        reader.readInt32();
        msg.setProducer(value);
        break;

      case 2:
        var value =
        /** @type {number} */
        reader.readInt32();
        msg.setMinConsumer(value);
        break;

      case 3:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedInt32();
        msg.setBadConsumersList(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.VersionDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.VersionDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.VersionDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.VersionDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getProducer();

  if (f !== 0) {
    writer.writeInt32(1, f);
  }

  f = message.getMinConsumer();

  if (f !== 0) {
    writer.writeInt32(2, f);
  }

  f = message.getBadConsumersList();

  if (f.length > 0) {
    writer.writePackedInt32(3, f);
  }
};
/**
 * optional int32 producer = 1;
 * @return {number}
 */


proto.tensorflow.VersionDef.prototype.getProducer = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};
/** @param {number} value */


proto.tensorflow.VersionDef.prototype.setProducer = function (value) {
  jspb.Message.setProto3IntField(this, 1, value);
};
/**
 * optional int32 min_consumer = 2;
 * @return {number}
 */


proto.tensorflow.VersionDef.prototype.getMinConsumer = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 2, 0)
  );
};
/** @param {number} value */


proto.tensorflow.VersionDef.prototype.setMinConsumer = function (value) {
  jspb.Message.setProto3IntField(this, 2, value);
};
/**
 * repeated int32 bad_consumers = 3;
 * @return {!Array<number>}
 */


proto.tensorflow.VersionDef.prototype.getBadConsumersList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 3)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.VersionDef.prototype.setBadConsumersList = function (value) {
  jspb.Message.setField(this, 3, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.VersionDef.prototype.addBadConsumers = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.VersionDef.prototype.clearBadConsumersList = function () {
  this.setBadConsumersList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.GraphDef.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.GraphDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.GraphDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.GraphDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.GraphDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      nodeList: jspb.Message.toObjectList(msg.getNodeList(), proto.tensorflow.NodeDef.toObject, includeInstance),
      versions: (f = msg.getVersions()) && proto.tensorflow.VersionDef.toObject(includeInstance, f),
      library: (f = msg.getLibrary()) && proto.tensorflow.FunctionDefLibrary.toObject(includeInstance, f)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.GraphDef}
 */


proto.tensorflow.GraphDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.GraphDef();
  return proto.tensorflow.GraphDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.GraphDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.GraphDef}
 */


proto.tensorflow.GraphDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.NodeDef();
        reader.readMessage(value, proto.tensorflow.NodeDef.deserializeBinaryFromReader);
        msg.addNode(value);
        break;

      case 4:
        var value = new proto.tensorflow.VersionDef();
        reader.readMessage(value, proto.tensorflow.VersionDef.deserializeBinaryFromReader);
        msg.setVersions(value);
        break;

      case 2:
        var value = new proto.tensorflow.FunctionDefLibrary();
        reader.readMessage(value, proto.tensorflow.FunctionDefLibrary.deserializeBinaryFromReader);
        msg.setLibrary(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.GraphDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.GraphDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.GraphDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.GraphDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getNodeList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(1, f, proto.tensorflow.NodeDef.serializeBinaryToWriter);
  }

  f = message.getVersions();

  if (f != null) {
    writer.writeMessage(4, f, proto.tensorflow.VersionDef.serializeBinaryToWriter);
  }

  f = message.getLibrary();

  if (f != null) {
    writer.writeMessage(2, f, proto.tensorflow.FunctionDefLibrary.serializeBinaryToWriter);
  }
};
/**
 * repeated NodeDef node = 1;
 * @return {!Array<!proto.tensorflow.NodeDef>}
 */


proto.tensorflow.GraphDef.prototype.getNodeList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.NodeDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.NodeDef, 1)
  );
};
/** @param {!Array<!proto.tensorflow.NodeDef>} value */


proto.tensorflow.GraphDef.prototype.setNodeList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};
/**
 * @param {!proto.tensorflow.NodeDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.NodeDef}
 */


proto.tensorflow.GraphDef.prototype.addNode = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tensorflow.NodeDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.GraphDef.prototype.clearNodeList = function () {
  this.setNodeList([]);
};
/**
 * optional VersionDef versions = 4;
 * @return {?proto.tensorflow.VersionDef}
 */


proto.tensorflow.GraphDef.prototype.getVersions = function () {
  return (
    /** @type{?proto.tensorflow.VersionDef} */
    jspb.Message.getWrapperField(this, proto.tensorflow.VersionDef, 4)
  );
};
/** @param {?proto.tensorflow.VersionDef|undefined} value */


proto.tensorflow.GraphDef.prototype.setVersions = function (value) {
  jspb.Message.setWrapperField(this, 4, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.GraphDef.prototype.clearVersions = function () {
  this.setVersions(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.GraphDef.prototype.hasVersions = function () {
  return jspb.Message.getField(this, 4) != null;
};
/**
 * optional FunctionDefLibrary library = 2;
 * @return {?proto.tensorflow.FunctionDefLibrary}
 */


proto.tensorflow.GraphDef.prototype.getLibrary = function () {
  return (
    /** @type{?proto.tensorflow.FunctionDefLibrary} */
    jspb.Message.getWrapperField(this, proto.tensorflow.FunctionDefLibrary, 2)
  );
};
/** @param {?proto.tensorflow.FunctionDefLibrary|undefined} value */


proto.tensorflow.GraphDef.prototype.setLibrary = function (value) {
  jspb.Message.setWrapperField(this, 2, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.GraphDef.prototype.clearLibrary = function () {
  this.setLibrary(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.GraphDef.prototype.hasLibrary = function () {
  return jspb.Message.getField(this, 2) != null;
};
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */


proto.tensorflow.CollectionDef.oneofGroups_ = [[1, 2, 3, 4, 5]];
/**
 * @enum {number}
 */

proto.tensorflow.CollectionDef.KindCase = {
  KIND_NOT_SET: 0,
  NODE_LIST: 1,
  BYTES_LIST: 2,
  INT64_LIST: 3,
  FLOAT_LIST: 4,
  ANY_LIST: 5
};
/**
 * @return {proto.tensorflow.CollectionDef.KindCase}
 */

proto.tensorflow.CollectionDef.prototype.getKindCase = function () {
  return (
    /** @type {proto.tensorflow.CollectionDef.KindCase} */
    jspb.Message.computeOneofCase(this, proto.tensorflow.CollectionDef.oneofGroups_[0])
  );
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.CollectionDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.CollectionDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.CollectionDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.CollectionDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      nodeList: (f = msg.getNodeList()) && proto.tensorflow.CollectionDef.NodeList.toObject(includeInstance, f),
      bytesList: (f = msg.getBytesList()) && proto.tensorflow.CollectionDef.BytesList.toObject(includeInstance, f),
      int64List: (f = msg.getInt64List()) && proto.tensorflow.CollectionDef.Int64List.toObject(includeInstance, f),
      floatList: (f = msg.getFloatList()) && proto.tensorflow.CollectionDef.FloatList.toObject(includeInstance, f),
      anyList: (f = msg.getAnyList()) && proto.tensorflow.CollectionDef.AnyList.toObject(includeInstance, f)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.CollectionDef}
 */


proto.tensorflow.CollectionDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.CollectionDef();
  return proto.tensorflow.CollectionDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.CollectionDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.CollectionDef}
 */


proto.tensorflow.CollectionDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.CollectionDef.NodeList();
        reader.readMessage(value, proto.tensorflow.CollectionDef.NodeList.deserializeBinaryFromReader);
        msg.setNodeList(value);
        break;

      case 2:
        var value = new proto.tensorflow.CollectionDef.BytesList();
        reader.readMessage(value, proto.tensorflow.CollectionDef.BytesList.deserializeBinaryFromReader);
        msg.setBytesList(value);
        break;

      case 3:
        var value = new proto.tensorflow.CollectionDef.Int64List();
        reader.readMessage(value, proto.tensorflow.CollectionDef.Int64List.deserializeBinaryFromReader);
        msg.setInt64List(value);
        break;

      case 4:
        var value = new proto.tensorflow.CollectionDef.FloatList();
        reader.readMessage(value, proto.tensorflow.CollectionDef.FloatList.deserializeBinaryFromReader);
        msg.setFloatList(value);
        break;

      case 5:
        var value = new proto.tensorflow.CollectionDef.AnyList();
        reader.readMessage(value, proto.tensorflow.CollectionDef.AnyList.deserializeBinaryFromReader);
        msg.setAnyList(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.CollectionDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.CollectionDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.CollectionDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.CollectionDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getNodeList();

  if (f != null) {
    writer.writeMessage(1, f, proto.tensorflow.CollectionDef.NodeList.serializeBinaryToWriter);
  }

  f = message.getBytesList();

  if (f != null) {
    writer.writeMessage(2, f, proto.tensorflow.CollectionDef.BytesList.serializeBinaryToWriter);
  }

  f = message.getInt64List();

  if (f != null) {
    writer.writeMessage(3, f, proto.tensorflow.CollectionDef.Int64List.serializeBinaryToWriter);
  }

  f = message.getFloatList();

  if (f != null) {
    writer.writeMessage(4, f, proto.tensorflow.CollectionDef.FloatList.serializeBinaryToWriter);
  }

  f = message.getAnyList();

  if (f != null) {
    writer.writeMessage(5, f, proto.tensorflow.CollectionDef.AnyList.serializeBinaryToWriter);
  }
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.CollectionDef.NodeList.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.CollectionDef.NodeList.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.CollectionDef.NodeList.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.CollectionDef.NodeList} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.CollectionDef.NodeList.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      valueList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.CollectionDef.NodeList}
 */


proto.tensorflow.CollectionDef.NodeList.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.CollectionDef.NodeList();
  return proto.tensorflow.CollectionDef.NodeList.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.CollectionDef.NodeList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.CollectionDef.NodeList}
 */


proto.tensorflow.CollectionDef.NodeList.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.addValue(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.CollectionDef.NodeList.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.CollectionDef.NodeList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.CollectionDef.NodeList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.CollectionDef.NodeList.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getValueList();

  if (f.length > 0) {
    writer.writeRepeatedString(1, f);
  }
};
/**
 * repeated string value = 1;
 * @return {!Array<string>}
 */


proto.tensorflow.CollectionDef.NodeList.prototype.getValueList = function () {
  return (
    /** @type {!Array<string>} */
    jspb.Message.getRepeatedField(this, 1)
  );
};
/** @param {!Array<string>} value */


proto.tensorflow.CollectionDef.NodeList.prototype.setValueList = function (value) {
  jspb.Message.setField(this, 1, value || []);
};
/**
 * @param {string} value
 * @param {number=} opt_index
 */


proto.tensorflow.CollectionDef.NodeList.prototype.addValue = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.CollectionDef.NodeList.prototype.clearValueList = function () {
  this.setValueList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.CollectionDef.BytesList.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.CollectionDef.BytesList.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.CollectionDef.BytesList.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.CollectionDef.BytesList} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.CollectionDef.BytesList.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      valueList: msg.getValueList_asB64()
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.CollectionDef.BytesList}
 */


proto.tensorflow.CollectionDef.BytesList.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.CollectionDef.BytesList();
  return proto.tensorflow.CollectionDef.BytesList.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.CollectionDef.BytesList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.CollectionDef.BytesList}
 */


proto.tensorflow.CollectionDef.BytesList.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {!Uint8Array} */
        reader.readBytes();
        msg.addValue(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.CollectionDef.BytesList.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.CollectionDef.BytesList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.CollectionDef.BytesList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.CollectionDef.BytesList.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getValueList_asU8();

  if (f.length > 0) {
    writer.writeRepeatedBytes(1, f);
  }
};
/**
 * repeated bytes value = 1;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */


proto.tensorflow.CollectionDef.BytesList.prototype.getValueList = function () {
  return (
    /** @type {!(Array<!Uint8Array>|Array<string>)} */
    jspb.Message.getRepeatedField(this, 1)
  );
};
/**
 * repeated bytes value = 1;
 * This is a type-conversion wrapper around `getValueList()`
 * @return {!Array<string>}
 */


proto.tensorflow.CollectionDef.BytesList.prototype.getValueList_asB64 = function () {
  return (
    /** @type {!Array<string>} */
    jspb.Message.bytesListAsB64(this.getValueList())
  );
};
/**
 * repeated bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValueList()`
 * @return {!Array<!Uint8Array>}
 */


proto.tensorflow.CollectionDef.BytesList.prototype.getValueList_asU8 = function () {
  return (
    /** @type {!Array<!Uint8Array>} */
    jspb.Message.bytesListAsU8(this.getValueList())
  );
};
/** @param {!(Array<!Uint8Array>|Array<string>)} value */


proto.tensorflow.CollectionDef.BytesList.prototype.setValueList = function (value) {
  jspb.Message.setField(this, 1, value || []);
};
/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */


proto.tensorflow.CollectionDef.BytesList.prototype.addValue = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.CollectionDef.BytesList.prototype.clearValueList = function () {
  this.setValueList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.CollectionDef.Int64List.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.CollectionDef.Int64List.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.CollectionDef.Int64List.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.CollectionDef.Int64List} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.CollectionDef.Int64List.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      valueList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.CollectionDef.Int64List}
 */


proto.tensorflow.CollectionDef.Int64List.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.CollectionDef.Int64List();
  return proto.tensorflow.CollectionDef.Int64List.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.CollectionDef.Int64List} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.CollectionDef.Int64List}
 */


proto.tensorflow.CollectionDef.Int64List.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedInt64();
        msg.setValueList(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.CollectionDef.Int64List.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.CollectionDef.Int64List.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.CollectionDef.Int64List} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.CollectionDef.Int64List.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getValueList();

  if (f.length > 0) {
    writer.writePackedInt64(1, f);
  }
};
/**
 * repeated int64 value = 1;
 * @return {!Array<number>}
 */


proto.tensorflow.CollectionDef.Int64List.prototype.getValueList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedField(this, 1)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.CollectionDef.Int64List.prototype.setValueList = function (value) {
  jspb.Message.setField(this, 1, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.CollectionDef.Int64List.prototype.addValue = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.CollectionDef.Int64List.prototype.clearValueList = function () {
  this.setValueList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.CollectionDef.FloatList.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.CollectionDef.FloatList.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.CollectionDef.FloatList.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.CollectionDef.FloatList} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.CollectionDef.FloatList.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      valueList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 1)) == null ? undefined : f
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.CollectionDef.FloatList}
 */


proto.tensorflow.CollectionDef.FloatList.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.CollectionDef.FloatList();
  return proto.tensorflow.CollectionDef.FloatList.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.CollectionDef.FloatList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.CollectionDef.FloatList}
 */


proto.tensorflow.CollectionDef.FloatList.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {!Array<number>} */
        reader.readPackedFloat();
        msg.setValueList(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.CollectionDef.FloatList.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.CollectionDef.FloatList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.CollectionDef.FloatList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.CollectionDef.FloatList.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getValueList();

  if (f.length > 0) {
    writer.writePackedFloat(1, f);
  }
};
/**
 * repeated float value = 1;
 * @return {!Array<number>}
 */


proto.tensorflow.CollectionDef.FloatList.prototype.getValueList = function () {
  return (
    /** @type {!Array<number>} */
    jspb.Message.getRepeatedFloatingPointField(this, 1)
  );
};
/** @param {!Array<number>} value */


proto.tensorflow.CollectionDef.FloatList.prototype.setValueList = function (value) {
  jspb.Message.setField(this, 1, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 */


proto.tensorflow.CollectionDef.FloatList.prototype.addValue = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.CollectionDef.FloatList.prototype.clearValueList = function () {
  this.setValueList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.CollectionDef.AnyList.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.CollectionDef.AnyList.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.CollectionDef.AnyList.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.CollectionDef.AnyList} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.CollectionDef.AnyList.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      valueList: jspb.Message.toObjectList(msg.getValueList(), proto.tensorflow.Any.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.CollectionDef.AnyList}
 */


proto.tensorflow.CollectionDef.AnyList.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.CollectionDef.AnyList();
  return proto.tensorflow.CollectionDef.AnyList.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.CollectionDef.AnyList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.CollectionDef.AnyList}
 */


proto.tensorflow.CollectionDef.AnyList.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.Any();
        reader.readMessage(value, proto.tensorflow.Any.deserializeBinaryFromReader);
        msg.addValue(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.CollectionDef.AnyList.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.CollectionDef.AnyList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.CollectionDef.AnyList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.CollectionDef.AnyList.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getValueList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(1, f, proto.tensorflow.Any.serializeBinaryToWriter);
  }
};
/**
 * repeated Any value = 1;
 * @return {!Array<!proto.tensorflow.Any>}
 */


proto.tensorflow.CollectionDef.AnyList.prototype.getValueList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.Any>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.Any, 1)
  );
};
/** @param {!Array<!proto.tensorflow.Any>} value */


proto.tensorflow.CollectionDef.AnyList.prototype.setValueList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};
/**
 * @param {!proto.tensorflow.Any=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.Any}
 */


proto.tensorflow.CollectionDef.AnyList.prototype.addValue = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tensorflow.Any, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.CollectionDef.AnyList.prototype.clearValueList = function () {
  this.setValueList([]);
};
/**
 * optional NodeList node_list = 1;
 * @return {?proto.tensorflow.CollectionDef.NodeList}
 */


proto.tensorflow.CollectionDef.prototype.getNodeList = function () {
  return (
    /** @type{?proto.tensorflow.CollectionDef.NodeList} */
    jspb.Message.getWrapperField(this, proto.tensorflow.CollectionDef.NodeList, 1)
  );
};
/** @param {?proto.tensorflow.CollectionDef.NodeList|undefined} value */


proto.tensorflow.CollectionDef.prototype.setNodeList = function (value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.tensorflow.CollectionDef.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.CollectionDef.prototype.clearNodeList = function () {
  this.setNodeList(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.CollectionDef.prototype.hasNodeList = function () {
  return jspb.Message.getField(this, 1) != null;
};
/**
 * optional BytesList bytes_list = 2;
 * @return {?proto.tensorflow.CollectionDef.BytesList}
 */


proto.tensorflow.CollectionDef.prototype.getBytesList = function () {
  return (
    /** @type{?proto.tensorflow.CollectionDef.BytesList} */
    jspb.Message.getWrapperField(this, proto.tensorflow.CollectionDef.BytesList, 2)
  );
};
/** @param {?proto.tensorflow.CollectionDef.BytesList|undefined} value */


proto.tensorflow.CollectionDef.prototype.setBytesList = function (value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.tensorflow.CollectionDef.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.CollectionDef.prototype.clearBytesList = function () {
  this.setBytesList(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.CollectionDef.prototype.hasBytesList = function () {
  return jspb.Message.getField(this, 2) != null;
};
/**
 * optional Int64List int64_list = 3;
 * @return {?proto.tensorflow.CollectionDef.Int64List}
 */


proto.tensorflow.CollectionDef.prototype.getInt64List = function () {
  return (
    /** @type{?proto.tensorflow.CollectionDef.Int64List} */
    jspb.Message.getWrapperField(this, proto.tensorflow.CollectionDef.Int64List, 3)
  );
};
/** @param {?proto.tensorflow.CollectionDef.Int64List|undefined} value */


proto.tensorflow.CollectionDef.prototype.setInt64List = function (value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.tensorflow.CollectionDef.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.CollectionDef.prototype.clearInt64List = function () {
  this.setInt64List(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.CollectionDef.prototype.hasInt64List = function () {
  return jspb.Message.getField(this, 3) != null;
};
/**
 * optional FloatList float_list = 4;
 * @return {?proto.tensorflow.CollectionDef.FloatList}
 */


proto.tensorflow.CollectionDef.prototype.getFloatList = function () {
  return (
    /** @type{?proto.tensorflow.CollectionDef.FloatList} */
    jspb.Message.getWrapperField(this, proto.tensorflow.CollectionDef.FloatList, 4)
  );
};
/** @param {?proto.tensorflow.CollectionDef.FloatList|undefined} value */


proto.tensorflow.CollectionDef.prototype.setFloatList = function (value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.tensorflow.CollectionDef.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.CollectionDef.prototype.clearFloatList = function () {
  this.setFloatList(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.CollectionDef.prototype.hasFloatList = function () {
  return jspb.Message.getField(this, 4) != null;
};
/**
 * optional AnyList any_list = 5;
 * @return {?proto.tensorflow.CollectionDef.AnyList}
 */


proto.tensorflow.CollectionDef.prototype.getAnyList = function () {
  return (
    /** @type{?proto.tensorflow.CollectionDef.AnyList} */
    jspb.Message.getWrapperField(this, proto.tensorflow.CollectionDef.AnyList, 5)
  );
};
/** @param {?proto.tensorflow.CollectionDef.AnyList|undefined} value */


proto.tensorflow.CollectionDef.prototype.setAnyList = function (value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.tensorflow.CollectionDef.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.CollectionDef.prototype.clearAnyList = function () {
  this.setAnyList(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.CollectionDef.prototype.hasAnyList = function () {
  return jspb.Message.getField(this, 5) != null;
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.SaverDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.SaverDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.SaverDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.SaverDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      filenameTensorName: jspb.Message.getFieldWithDefault(msg, 1, ""),
      saveTensorName: jspb.Message.getFieldWithDefault(msg, 2, ""),
      restoreOpName: jspb.Message.getFieldWithDefault(msg, 3, ""),
      maxToKeep: jspb.Message.getFieldWithDefault(msg, 4, 0),
      sharded: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
      keepCheckpointEveryNHours: jspb.Message.getFloatingPointFieldWithDefault(msg, 6, 0.0),
      version: jspb.Message.getFieldWithDefault(msg, 7, 0)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.SaverDef}
 */


proto.tensorflow.SaverDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.SaverDef();
  return proto.tensorflow.SaverDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.SaverDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.SaverDef}
 */


proto.tensorflow.SaverDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setFilenameTensorName(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setSaveTensorName(value);
        break;

      case 3:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setRestoreOpName(value);
        break;

      case 4:
        var value =
        /** @type {number} */
        reader.readInt32();
        msg.setMaxToKeep(value);
        break;

      case 5:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setSharded(value);
        break;

      case 6:
        var value =
        /** @type {number} */
        reader.readFloat();
        msg.setKeepCheckpointEveryNHours(value);
        break;

      case 7:
        var value =
        /** @type {!proto.tensorflow.SaverDef.CheckpointFormatVersion} */
        reader.readEnum();
        msg.setVersion(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.SaverDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.SaverDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.SaverDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.SaverDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getFilenameTensorName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getSaveTensorName();

  if (f.length > 0) {
    writer.writeString(2, f);
  }

  f = message.getRestoreOpName();

  if (f.length > 0) {
    writer.writeString(3, f);
  }

  f = message.getMaxToKeep();

  if (f !== 0) {
    writer.writeInt32(4, f);
  }

  f = message.getSharded();

  if (f) {
    writer.writeBool(5, f);
  }

  f = message.getKeepCheckpointEveryNHours();

  if (f !== 0.0) {
    writer.writeFloat(6, f);
  }

  f = message.getVersion();

  if (f !== 0.0) {
    writer.writeEnum(7, f);
  }
};
/**
 * @enum {number}
 */


proto.tensorflow.SaverDef.CheckpointFormatVersion = {
  LEGACY: 0,
  V1: 1,
  V2: 2
};
/**
 * optional string filename_tensor_name = 1;
 * @return {string}
 */

proto.tensorflow.SaverDef.prototype.getFilenameTensorName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.SaverDef.prototype.setFilenameTensorName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string save_tensor_name = 2;
 * @return {string}
 */


proto.tensorflow.SaverDef.prototype.getSaveTensorName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.SaverDef.prototype.setSaveTensorName = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * optional string restore_op_name = 3;
 * @return {string}
 */


proto.tensorflow.SaverDef.prototype.getRestoreOpName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 3, "")
  );
};
/** @param {string} value */


proto.tensorflow.SaverDef.prototype.setRestoreOpName = function (value) {
  jspb.Message.setProto3StringField(this, 3, value);
};
/**
 * optional int32 max_to_keep = 4;
 * @return {number}
 */


proto.tensorflow.SaverDef.prototype.getMaxToKeep = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 4, 0)
  );
};
/** @param {number} value */


proto.tensorflow.SaverDef.prototype.setMaxToKeep = function (value) {
  jspb.Message.setProto3IntField(this, 4, value);
};
/**
 * optional bool sharded = 5;
 * @return {boolean}
 */


proto.tensorflow.SaverDef.prototype.getSharded = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 5, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.SaverDef.prototype.setSharded = function (value) {
  jspb.Message.setProto3BooleanField(this, 5, value);
};
/**
 * optional float keep_checkpoint_every_n_hours = 6;
 * @return {number}
 */


proto.tensorflow.SaverDef.prototype.getKeepCheckpointEveryNHours = function () {
  return (
    /** @type {number} */
    jspb.Message.getFloatingPointFieldWithDefault(this, 6, 0.0)
  );
};
/** @param {number} value */


proto.tensorflow.SaverDef.prototype.setKeepCheckpointEveryNHours = function (value) {
  jspb.Message.setProto3FloatField(this, 6, value);
};
/**
 * optional CheckpointFormatVersion version = 7;
 * @return {!proto.tensorflow.SaverDef.CheckpointFormatVersion}
 */


proto.tensorflow.SaverDef.prototype.getVersion = function () {
  return (
    /** @type {!proto.tensorflow.SaverDef.CheckpointFormatVersion} */
    jspb.Message.getFieldWithDefault(this, 7, 0)
  );
};
/** @param {!proto.tensorflow.SaverDef.CheckpointFormatVersion} value */


proto.tensorflow.SaverDef.prototype.setVersion = function (value) {
  jspb.Message.setProto3EnumField(this, 7, value);
};
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */


proto.tensorflow.TensorInfo.oneofGroups_ = [[1, 4]];
/**
 * @enum {number}
 */

proto.tensorflow.TensorInfo.EncodingCase = {
  ENCODING_NOT_SET: 0,
  NAME: 1,
  COO_SPARSE: 4
};
/**
 * @return {proto.tensorflow.TensorInfo.EncodingCase}
 */

proto.tensorflow.TensorInfo.prototype.getEncodingCase = function () {
  return (
    /** @type {proto.tensorflow.TensorInfo.EncodingCase} */
    jspb.Message.computeOneofCase(this, proto.tensorflow.TensorInfo.oneofGroups_[0])
  );
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.TensorInfo.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.TensorInfo.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.TensorInfo} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.TensorInfo.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      cooSparse: (f = msg.getCooSparse()) && proto.tensorflow.TensorInfo.CooSparse.toObject(includeInstance, f),
      dtype: jspb.Message.getFieldWithDefault(msg, 2, 0),
      tensorShape: (f = msg.getTensorShape()) && proto.tensorflow.TensorShape.toObject(includeInstance, f)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.TensorInfo}
 */


proto.tensorflow.TensorInfo.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.TensorInfo();
  return proto.tensorflow.TensorInfo.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.TensorInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.TensorInfo}
 */


proto.tensorflow.TensorInfo.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      case 4:
        var value = new proto.tensorflow.TensorInfo.CooSparse();
        reader.readMessage(value, proto.tensorflow.TensorInfo.CooSparse.deserializeBinaryFromReader);
        msg.setCooSparse(value);
        break;

      case 2:
        var value =
        /** @type {!proto.tensorflow.DataType} */
        reader.readEnum();
        msg.setDtype(value);
        break;

      case 3:
        var value = new proto.tensorflow.TensorShape();
        reader.readMessage(value, proto.tensorflow.TensorShape.deserializeBinaryFromReader);
        msg.setTensorShape(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.TensorInfo.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.TensorInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.TensorInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.TensorInfo.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f =
  /** @type {string} */
  jspb.Message.getField(message, 1);

  if (f != null) {
    writer.writeString(1, f);
  }

  f = message.getCooSparse();

  if (f != null) {
    writer.writeMessage(4, f, proto.tensorflow.TensorInfo.CooSparse.serializeBinaryToWriter);
  }

  f = message.getDtype();

  if (f !== 0.0) {
    writer.writeEnum(2, f);
  }

  f = message.getTensorShape();

  if (f != null) {
    writer.writeMessage(3, f, proto.tensorflow.TensorShape.serializeBinaryToWriter);
  }
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.TensorInfo.CooSparse.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.TensorInfo.CooSparse.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.TensorInfo.CooSparse} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.TensorInfo.CooSparse.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      valuesTensorName: jspb.Message.getFieldWithDefault(msg, 1, ""),
      indicesTensorName: jspb.Message.getFieldWithDefault(msg, 2, ""),
      denseShapeTensorName: jspb.Message.getFieldWithDefault(msg, 3, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.TensorInfo.CooSparse}
 */


proto.tensorflow.TensorInfo.CooSparse.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.TensorInfo.CooSparse();
  return proto.tensorflow.TensorInfo.CooSparse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.TensorInfo.CooSparse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.TensorInfo.CooSparse}
 */


proto.tensorflow.TensorInfo.CooSparse.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setValuesTensorName(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setIndicesTensorName(value);
        break;

      case 3:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setDenseShapeTensorName(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.TensorInfo.CooSparse.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.TensorInfo.CooSparse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.TensorInfo.CooSparse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.TensorInfo.CooSparse.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getValuesTensorName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getIndicesTensorName();

  if (f.length > 0) {
    writer.writeString(2, f);
  }

  f = message.getDenseShapeTensorName();

  if (f.length > 0) {
    writer.writeString(3, f);
  }
};
/**
 * optional string values_tensor_name = 1;
 * @return {string}
 */


proto.tensorflow.TensorInfo.CooSparse.prototype.getValuesTensorName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.TensorInfo.CooSparse.prototype.setValuesTensorName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string indices_tensor_name = 2;
 * @return {string}
 */


proto.tensorflow.TensorInfo.CooSparse.prototype.getIndicesTensorName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.TensorInfo.CooSparse.prototype.setIndicesTensorName = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * optional string dense_shape_tensor_name = 3;
 * @return {string}
 */


proto.tensorflow.TensorInfo.CooSparse.prototype.getDenseShapeTensorName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 3, "")
  );
};
/** @param {string} value */


proto.tensorflow.TensorInfo.CooSparse.prototype.setDenseShapeTensorName = function (value) {
  jspb.Message.setProto3StringField(this, 3, value);
};
/**
 * optional string name = 1;
 * @return {string}
 */


proto.tensorflow.TensorInfo.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.TensorInfo.prototype.setName = function (value) {
  jspb.Message.setOneofField(this, 1, proto.tensorflow.TensorInfo.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 */


proto.tensorflow.TensorInfo.prototype.clearName = function () {
  jspb.Message.setOneofField(this, 1, proto.tensorflow.TensorInfo.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.TensorInfo.prototype.hasName = function () {
  return jspb.Message.getField(this, 1) != null;
};
/**
 * optional CooSparse coo_sparse = 4;
 * @return {?proto.tensorflow.TensorInfo.CooSparse}
 */


proto.tensorflow.TensorInfo.prototype.getCooSparse = function () {
  return (
    /** @type{?proto.tensorflow.TensorInfo.CooSparse} */
    jspb.Message.getWrapperField(this, proto.tensorflow.TensorInfo.CooSparse, 4)
  );
};
/** @param {?proto.tensorflow.TensorInfo.CooSparse|undefined} value */


proto.tensorflow.TensorInfo.prototype.setCooSparse = function (value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.tensorflow.TensorInfo.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.TensorInfo.prototype.clearCooSparse = function () {
  this.setCooSparse(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.TensorInfo.prototype.hasCooSparse = function () {
  return jspb.Message.getField(this, 4) != null;
};
/**
 * optional DataType dtype = 2;
 * @return {!proto.tensorflow.DataType}
 */


proto.tensorflow.TensorInfo.prototype.getDtype = function () {
  return (
    /** @type {!proto.tensorflow.DataType} */
    jspb.Message.getFieldWithDefault(this, 2, 0)
  );
};
/** @param {!proto.tensorflow.DataType} value */


proto.tensorflow.TensorInfo.prototype.setDtype = function (value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};
/**
 * optional TensorShape tensor_shape = 3;
 * @return {?proto.tensorflow.TensorShape}
 */


proto.tensorflow.TensorInfo.prototype.getTensorShape = function () {
  return (
    /** @type{?proto.tensorflow.TensorShape} */
    jspb.Message.getWrapperField(this, proto.tensorflow.TensorShape, 3)
  );
};
/** @param {?proto.tensorflow.TensorShape|undefined} value */


proto.tensorflow.TensorInfo.prototype.setTensorShape = function (value) {
  jspb.Message.setWrapperField(this, 3, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.TensorInfo.prototype.clearTensorShape = function () {
  this.setTensorShape(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.TensorInfo.prototype.hasTensorShape = function () {
  return jspb.Message.getField(this, 3) != null;
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.SignatureDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.SignatureDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.SignatureDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.SignatureDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      inputsMap: (f = msg.getInputsMap()) ? f.toObject(includeInstance, proto.tensorflow.TensorInfo.toObject) : [],
      outputsMap: (f = msg.getOutputsMap()) ? f.toObject(includeInstance, proto.tensorflow.TensorInfo.toObject) : [],
      methodName: jspb.Message.getFieldWithDefault(msg, 3, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.SignatureDef}
 */


proto.tensorflow.SignatureDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.SignatureDef();
  return proto.tensorflow.SignatureDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.SignatureDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.SignatureDef}
 */


proto.tensorflow.SignatureDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = msg.getInputsMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.TensorInfo.deserializeBinaryFromReader, "");
        });
        break;

      case 2:
        var value = msg.getOutputsMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.TensorInfo.deserializeBinaryFromReader, "");
        });
        break;

      case 3:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setMethodName(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.SignatureDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.SignatureDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.SignatureDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.SignatureDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getInputsMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.TensorInfo.serializeBinaryToWriter);
  }

  f = message.getOutputsMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.TensorInfo.serializeBinaryToWriter);
  }

  f = message.getMethodName();

  if (f.length > 0) {
    writer.writeString(3, f);
  }
};
/**
 * map<string, TensorInfo> inputs = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.TensorInfo>}
 */


proto.tensorflow.SignatureDef.prototype.getInputsMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.TensorInfo>} */
    jspb.Message.getMapField(this, 1, opt_noLazyCreate, proto.tensorflow.TensorInfo)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.SignatureDef.prototype.clearInputsMap = function () {
  this.getInputsMap().clear();
};
/**
 * map<string, TensorInfo> outputs = 2;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.TensorInfo>}
 */


proto.tensorflow.SignatureDef.prototype.getOutputsMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.TensorInfo>} */
    jspb.Message.getMapField(this, 2, opt_noLazyCreate, proto.tensorflow.TensorInfo)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.SignatureDef.prototype.clearOutputsMap = function () {
  this.getOutputsMap().clear();
};
/**
 * optional string method_name = 3;
 * @return {string}
 */


proto.tensorflow.SignatureDef.prototype.getMethodName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 3, "")
  );
};
/** @param {string} value */


proto.tensorflow.SignatureDef.prototype.setMethodName = function (value) {
  jspb.Message.setProto3StringField(this, 3, value);
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.AssetFileDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.AssetFileDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.AssetFileDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.AssetFileDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      tensorInfo: (f = msg.getTensorInfo()) && proto.tensorflow.TensorInfo.toObject(includeInstance, f),
      filename: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.AssetFileDef}
 */


proto.tensorflow.AssetFileDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.AssetFileDef();
  return proto.tensorflow.AssetFileDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.AssetFileDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.AssetFileDef}
 */


proto.tensorflow.AssetFileDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.TensorInfo();
        reader.readMessage(value, proto.tensorflow.TensorInfo.deserializeBinaryFromReader);
        msg.setTensorInfo(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setFilename(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.AssetFileDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.AssetFileDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.AssetFileDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.AssetFileDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getTensorInfo();

  if (f != null) {
    writer.writeMessage(1, f, proto.tensorflow.TensorInfo.serializeBinaryToWriter);
  }

  f = message.getFilename();

  if (f.length > 0) {
    writer.writeString(2, f);
  }
};
/**
 * optional TensorInfo tensor_info = 1;
 * @return {?proto.tensorflow.TensorInfo}
 */


proto.tensorflow.AssetFileDef.prototype.getTensorInfo = function () {
  return (
    /** @type{?proto.tensorflow.TensorInfo} */
    jspb.Message.getWrapperField(this, proto.tensorflow.TensorInfo, 1)
  );
};
/** @param {?proto.tensorflow.TensorInfo|undefined} value */


proto.tensorflow.AssetFileDef.prototype.setTensorInfo = function (value) {
  jspb.Message.setWrapperField(this, 1, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.AssetFileDef.prototype.clearTensorInfo = function () {
  this.setTensorInfo(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.AssetFileDef.prototype.hasTensorInfo = function () {
  return jspb.Message.getField(this, 1) != null;
};
/**
 * optional string filename = 2;
 * @return {string}
 */


proto.tensorflow.AssetFileDef.prototype.getFilename = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.AssetFileDef.prototype.setFilename = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.OpDef.repeatedFields_ = [2, 3, 4];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.OpDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.OpDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.OpDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.OpDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      inputArgList: jspb.Message.toObjectList(msg.getInputArgList(), proto.tensorflow.OpDef.ArgDef.toObject, includeInstance),
      outputArgList: jspb.Message.toObjectList(msg.getOutputArgList(), proto.tensorflow.OpDef.ArgDef.toObject, includeInstance),
      attrList: jspb.Message.toObjectList(msg.getAttrList(), proto.tensorflow.OpDef.AttrDef.toObject, includeInstance),
      deprecation: (f = msg.getDeprecation()) && proto.tensorflow.OpDef.OpDeprecation.toObject(includeInstance, f),
      summary: jspb.Message.getFieldWithDefault(msg, 5, ""),
      description: jspb.Message.getFieldWithDefault(msg, 6, ""),
      isCommutative: jspb.Message.getBooleanFieldWithDefault(msg, 18, false),
      isAggregate: jspb.Message.getBooleanFieldWithDefault(msg, 16, false),
      isStateful: jspb.Message.getBooleanFieldWithDefault(msg, 17, false),
      allowsUninitializedInput: jspb.Message.getBooleanFieldWithDefault(msg, 19, false)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.OpDef}
 */


proto.tensorflow.OpDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.OpDef();
  return proto.tensorflow.OpDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.OpDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.OpDef}
 */


proto.tensorflow.OpDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      case 2:
        var value = new proto.tensorflow.OpDef.ArgDef();
        reader.readMessage(value, proto.tensorflow.OpDef.ArgDef.deserializeBinaryFromReader);
        msg.addInputArg(value);
        break;

      case 3:
        var value = new proto.tensorflow.OpDef.ArgDef();
        reader.readMessage(value, proto.tensorflow.OpDef.ArgDef.deserializeBinaryFromReader);
        msg.addOutputArg(value);
        break;

      case 4:
        var value = new proto.tensorflow.OpDef.AttrDef();
        reader.readMessage(value, proto.tensorflow.OpDef.AttrDef.deserializeBinaryFromReader);
        msg.addAttr(value);
        break;

      case 8:
        var value = new proto.tensorflow.OpDef.OpDeprecation();
        reader.readMessage(value, proto.tensorflow.OpDef.OpDeprecation.deserializeBinaryFromReader);
        msg.setDeprecation(value);
        break;

      case 5:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setSummary(value);
        break;

      case 6:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setDescription(value);
        break;

      case 18:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setIsCommutative(value);
        break;

      case 16:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setIsAggregate(value);
        break;

      case 17:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setIsStateful(value);
        break;

      case 19:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setAllowsUninitializedInput(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.OpDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.OpDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.OpDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.OpDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getInputArgList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(2, f, proto.tensorflow.OpDef.ArgDef.serializeBinaryToWriter);
  }

  f = message.getOutputArgList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(3, f, proto.tensorflow.OpDef.ArgDef.serializeBinaryToWriter);
  }

  f = message.getAttrList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(4, f, proto.tensorflow.OpDef.AttrDef.serializeBinaryToWriter);
  }

  f = message.getDeprecation();

  if (f != null) {
    writer.writeMessage(8, f, proto.tensorflow.OpDef.OpDeprecation.serializeBinaryToWriter);
  }

  f = message.getSummary();

  if (f.length > 0) {
    writer.writeString(5, f);
  }

  f = message.getDescription();

  if (f.length > 0) {
    writer.writeString(6, f);
  }

  f = message.getIsCommutative();

  if (f) {
    writer.writeBool(18, f);
  }

  f = message.getIsAggregate();

  if (f) {
    writer.writeBool(16, f);
  }

  f = message.getIsStateful();

  if (f) {
    writer.writeBool(17, f);
  }

  f = message.getAllowsUninitializedInput();

  if (f) {
    writer.writeBool(19, f);
  }
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.OpDef.ArgDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.OpDef.ArgDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.OpDef.ArgDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.OpDef.ArgDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      description: jspb.Message.getFieldWithDefault(msg, 2, ""),
      type: jspb.Message.getFieldWithDefault(msg, 3, 0),
      typeAttr: jspb.Message.getFieldWithDefault(msg, 4, ""),
      numberAttr: jspb.Message.getFieldWithDefault(msg, 5, ""),
      typeListAttr: jspb.Message.getFieldWithDefault(msg, 6, ""),
      isRef: jspb.Message.getBooleanFieldWithDefault(msg, 16, false)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.OpDef.ArgDef}
 */


proto.tensorflow.OpDef.ArgDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.OpDef.ArgDef();
  return proto.tensorflow.OpDef.ArgDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.OpDef.ArgDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.OpDef.ArgDef}
 */


proto.tensorflow.OpDef.ArgDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setDescription(value);
        break;

      case 3:
        var value =
        /** @type {!proto.tensorflow.DataType} */
        reader.readEnum();
        msg.setType(value);
        break;

      case 4:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setTypeAttr(value);
        break;

      case 5:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setNumberAttr(value);
        break;

      case 6:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setTypeListAttr(value);
        break;

      case 16:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setIsRef(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.OpDef.ArgDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.OpDef.ArgDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.OpDef.ArgDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.OpDef.ArgDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getDescription();

  if (f.length > 0) {
    writer.writeString(2, f);
  }

  f = message.getType();

  if (f !== 0.0) {
    writer.writeEnum(3, f);
  }

  f = message.getTypeAttr();

  if (f.length > 0) {
    writer.writeString(4, f);
  }

  f = message.getNumberAttr();

  if (f.length > 0) {
    writer.writeString(5, f);
  }

  f = message.getTypeListAttr();

  if (f.length > 0) {
    writer.writeString(6, f);
  }

  f = message.getIsRef();

  if (f) {
    writer.writeBool(16, f);
  }
};
/**
 * optional string name = 1;
 * @return {string}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.ArgDef.prototype.setName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string description = 2;
 * @return {string}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getDescription = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.ArgDef.prototype.setDescription = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * optional DataType type = 3;
 * @return {!proto.tensorflow.DataType}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getType = function () {
  return (
    /** @type {!proto.tensorflow.DataType} */
    jspb.Message.getFieldWithDefault(this, 3, 0)
  );
};
/** @param {!proto.tensorflow.DataType} value */


proto.tensorflow.OpDef.ArgDef.prototype.setType = function (value) {
  jspb.Message.setProto3EnumField(this, 3, value);
};
/**
 * optional string type_attr = 4;
 * @return {string}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getTypeAttr = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 4, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.ArgDef.prototype.setTypeAttr = function (value) {
  jspb.Message.setProto3StringField(this, 4, value);
};
/**
 * optional string number_attr = 5;
 * @return {string}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getNumberAttr = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 5, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.ArgDef.prototype.setNumberAttr = function (value) {
  jspb.Message.setProto3StringField(this, 5, value);
};
/**
 * optional string type_list_attr = 6;
 * @return {string}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getTypeListAttr = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 6, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.ArgDef.prototype.setTypeListAttr = function (value) {
  jspb.Message.setProto3StringField(this, 6, value);
};
/**
 * optional bool is_ref = 16;
 * @return {boolean}
 */


proto.tensorflow.OpDef.ArgDef.prototype.getIsRef = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 16, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.OpDef.ArgDef.prototype.setIsRef = function (value) {
  jspb.Message.setProto3BooleanField(this, 16, value);
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.OpDef.AttrDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.OpDef.AttrDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.OpDef.AttrDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.OpDef.AttrDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      type: jspb.Message.getFieldWithDefault(msg, 2, ""),
      defaultValue: (f = msg.getDefaultValue()) && proto.tensorflow.AttrValue.toObject(includeInstance, f),
      description: jspb.Message.getFieldWithDefault(msg, 4, ""),
      hasMinimum: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
      minimum: jspb.Message.getFieldWithDefault(msg, 6, 0),
      allowedValues: (f = msg.getAllowedValues()) && proto.tensorflow.AttrValue.toObject(includeInstance, f)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.OpDef.AttrDef}
 */


proto.tensorflow.OpDef.AttrDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.OpDef.AttrDef();
  return proto.tensorflow.OpDef.AttrDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.OpDef.AttrDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.OpDef.AttrDef}
 */


proto.tensorflow.OpDef.AttrDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setName(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setType(value);
        break;

      case 3:
        var value = new proto.tensorflow.AttrValue();
        reader.readMessage(value, proto.tensorflow.AttrValue.deserializeBinaryFromReader);
        msg.setDefaultValue(value);
        break;

      case 4:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setDescription(value);
        break;

      case 5:
        var value =
        /** @type {boolean} */
        reader.readBool();
        msg.setHasMinimum(value);
        break;

      case 6:
        var value =
        /** @type {number} */
        reader.readInt64();
        msg.setMinimum(value);
        break;

      case 7:
        var value = new proto.tensorflow.AttrValue();
        reader.readMessage(value, proto.tensorflow.AttrValue.deserializeBinaryFromReader);
        msg.setAllowedValues(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.OpDef.AttrDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.OpDef.AttrDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.OpDef.AttrDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.OpDef.AttrDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getType();

  if (f.length > 0) {
    writer.writeString(2, f);
  }

  f = message.getDefaultValue();

  if (f != null) {
    writer.writeMessage(3, f, proto.tensorflow.AttrValue.serializeBinaryToWriter);
  }

  f = message.getDescription();

  if (f.length > 0) {
    writer.writeString(4, f);
  }

  f = message.getHasMinimum();

  if (f) {
    writer.writeBool(5, f);
  }

  f = message.getMinimum();

  if (f !== 0) {
    writer.writeInt64(6, f);
  }

  f = message.getAllowedValues();

  if (f != null) {
    writer.writeMessage(7, f, proto.tensorflow.AttrValue.serializeBinaryToWriter);
  }
};
/**
 * optional string name = 1;
 * @return {string}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.AttrDef.prototype.setName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string type = 2;
 * @return {string}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getType = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.AttrDef.prototype.setType = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * optional AttrValue default_value = 3;
 * @return {?proto.tensorflow.AttrValue}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getDefaultValue = function () {
  return (
    /** @type{?proto.tensorflow.AttrValue} */
    jspb.Message.getWrapperField(this, proto.tensorflow.AttrValue, 3)
  );
};
/** @param {?proto.tensorflow.AttrValue|undefined} value */


proto.tensorflow.OpDef.AttrDef.prototype.setDefaultValue = function (value) {
  jspb.Message.setWrapperField(this, 3, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.OpDef.AttrDef.prototype.clearDefaultValue = function () {
  this.setDefaultValue(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.OpDef.AttrDef.prototype.hasDefaultValue = function () {
  return jspb.Message.getField(this, 3) != null;
};
/**
 * optional string description = 4;
 * @return {string}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getDescription = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 4, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.AttrDef.prototype.setDescription = function (value) {
  jspb.Message.setProto3StringField(this, 4, value);
};
/**
 * optional bool has_minimum = 5;
 * @return {boolean}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getHasMinimum = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 5, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.OpDef.AttrDef.prototype.setHasMinimum = function (value) {
  jspb.Message.setProto3BooleanField(this, 5, value);
};
/**
 * optional int64 minimum = 6;
 * @return {number}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getMinimum = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 6, 0)
  );
};
/** @param {number} value */


proto.tensorflow.OpDef.AttrDef.prototype.setMinimum = function (value) {
  jspb.Message.setProto3IntField(this, 6, value);
};
/**
 * optional AttrValue allowed_values = 7;
 * @return {?proto.tensorflow.AttrValue}
 */


proto.tensorflow.OpDef.AttrDef.prototype.getAllowedValues = function () {
  return (
    /** @type{?proto.tensorflow.AttrValue} */
    jspb.Message.getWrapperField(this, proto.tensorflow.AttrValue, 7)
  );
};
/** @param {?proto.tensorflow.AttrValue|undefined} value */


proto.tensorflow.OpDef.AttrDef.prototype.setAllowedValues = function (value) {
  jspb.Message.setWrapperField(this, 7, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.OpDef.AttrDef.prototype.clearAllowedValues = function () {
  this.setAllowedValues(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.OpDef.AttrDef.prototype.hasAllowedValues = function () {
  return jspb.Message.getField(this, 7) != null;
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.OpDef.OpDeprecation.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.OpDef.OpDeprecation.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.OpDef.OpDeprecation} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.OpDef.OpDeprecation.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      version: jspb.Message.getFieldWithDefault(msg, 1, 0),
      explanation: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.OpDef.OpDeprecation}
 */


proto.tensorflow.OpDef.OpDeprecation.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.OpDef.OpDeprecation();
  return proto.tensorflow.OpDef.OpDeprecation.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.OpDef.OpDeprecation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.OpDef.OpDeprecation}
 */


proto.tensorflow.OpDef.OpDeprecation.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {number} */
        reader.readInt32();
        msg.setVersion(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setExplanation(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.OpDef.OpDeprecation.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.OpDef.OpDeprecation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.OpDef.OpDeprecation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.OpDef.OpDeprecation.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getVersion();

  if (f !== 0) {
    writer.writeInt32(1, f);
  }

  f = message.getExplanation();

  if (f.length > 0) {
    writer.writeString(2, f);
  }
};
/**
 * optional int32 version = 1;
 * @return {number}
 */


proto.tensorflow.OpDef.OpDeprecation.prototype.getVersion = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};
/** @param {number} value */


proto.tensorflow.OpDef.OpDeprecation.prototype.setVersion = function (value) {
  jspb.Message.setProto3IntField(this, 1, value);
};
/**
 * optional string explanation = 2;
 * @return {string}
 */


proto.tensorflow.OpDef.OpDeprecation.prototype.getExplanation = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.OpDeprecation.prototype.setExplanation = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * optional string name = 1;
 * @return {string}
 */


proto.tensorflow.OpDef.prototype.getName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.prototype.setName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * repeated ArgDef input_arg = 2;
 * @return {!Array<!proto.tensorflow.OpDef.ArgDef>}
 */


proto.tensorflow.OpDef.prototype.getInputArgList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.OpDef.ArgDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.OpDef.ArgDef, 2)
  );
};
/** @param {!Array<!proto.tensorflow.OpDef.ArgDef>} value */


proto.tensorflow.OpDef.prototype.setInputArgList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};
/**
 * @param {!proto.tensorflow.OpDef.ArgDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.OpDef.ArgDef}
 */


proto.tensorflow.OpDef.prototype.addInputArg = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tensorflow.OpDef.ArgDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.OpDef.prototype.clearInputArgList = function () {
  this.setInputArgList([]);
};
/**
 * repeated ArgDef output_arg = 3;
 * @return {!Array<!proto.tensorflow.OpDef.ArgDef>}
 */


proto.tensorflow.OpDef.prototype.getOutputArgList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.OpDef.ArgDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.OpDef.ArgDef, 3)
  );
};
/** @param {!Array<!proto.tensorflow.OpDef.ArgDef>} value */


proto.tensorflow.OpDef.prototype.setOutputArgList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};
/**
 * @param {!proto.tensorflow.OpDef.ArgDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.OpDef.ArgDef}
 */


proto.tensorflow.OpDef.prototype.addOutputArg = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.tensorflow.OpDef.ArgDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.OpDef.prototype.clearOutputArgList = function () {
  this.setOutputArgList([]);
};
/**
 * repeated AttrDef attr = 4;
 * @return {!Array<!proto.tensorflow.OpDef.AttrDef>}
 */


proto.tensorflow.OpDef.prototype.getAttrList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.OpDef.AttrDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.OpDef.AttrDef, 4)
  );
};
/** @param {!Array<!proto.tensorflow.OpDef.AttrDef>} value */


proto.tensorflow.OpDef.prototype.setAttrList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};
/**
 * @param {!proto.tensorflow.OpDef.AttrDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.OpDef.AttrDef}
 */


proto.tensorflow.OpDef.prototype.addAttr = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.tensorflow.OpDef.AttrDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.OpDef.prototype.clearAttrList = function () {
  this.setAttrList([]);
};
/**
 * optional OpDeprecation deprecation = 8;
 * @return {?proto.tensorflow.OpDef.OpDeprecation}
 */


proto.tensorflow.OpDef.prototype.getDeprecation = function () {
  return (
    /** @type{?proto.tensorflow.OpDef.OpDeprecation} */
    jspb.Message.getWrapperField(this, proto.tensorflow.OpDef.OpDeprecation, 8)
  );
};
/** @param {?proto.tensorflow.OpDef.OpDeprecation|undefined} value */


proto.tensorflow.OpDef.prototype.setDeprecation = function (value) {
  jspb.Message.setWrapperField(this, 8, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.OpDef.prototype.clearDeprecation = function () {
  this.setDeprecation(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.OpDef.prototype.hasDeprecation = function () {
  return jspb.Message.getField(this, 8) != null;
};
/**
 * optional string summary = 5;
 * @return {string}
 */


proto.tensorflow.OpDef.prototype.getSummary = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 5, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.prototype.setSummary = function (value) {
  jspb.Message.setProto3StringField(this, 5, value);
};
/**
 * optional string description = 6;
 * @return {string}
 */


proto.tensorflow.OpDef.prototype.getDescription = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 6, "")
  );
};
/** @param {string} value */


proto.tensorflow.OpDef.prototype.setDescription = function (value) {
  jspb.Message.setProto3StringField(this, 6, value);
};
/**
 * optional bool is_commutative = 18;
 * @return {boolean}
 */


proto.tensorflow.OpDef.prototype.getIsCommutative = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 18, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.OpDef.prototype.setIsCommutative = function (value) {
  jspb.Message.setProto3BooleanField(this, 18, value);
};
/**
 * optional bool is_aggregate = 16;
 * @return {boolean}
 */


proto.tensorflow.OpDef.prototype.getIsAggregate = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 16, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.OpDef.prototype.setIsAggregate = function (value) {
  jspb.Message.setProto3BooleanField(this, 16, value);
};
/**
 * optional bool is_stateful = 17;
 * @return {boolean}
 */


proto.tensorflow.OpDef.prototype.getIsStateful = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 17, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.OpDef.prototype.setIsStateful = function (value) {
  jspb.Message.setProto3BooleanField(this, 17, value);
};
/**
 * optional bool allows_uninitialized_input = 19;
 * @return {boolean}
 */


proto.tensorflow.OpDef.prototype.getAllowsUninitializedInput = function () {
  return (
    /** @type {boolean} */
    jspb.Message.getBooleanFieldWithDefault(this, 19, false)
  );
};
/** @param {boolean} value */


proto.tensorflow.OpDef.prototype.setAllowsUninitializedInput = function (value) {
  jspb.Message.setProto3BooleanField(this, 19, value);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.OpList.repeatedFields_ = [1];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.OpList.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.OpList.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.OpList} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.OpList.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      opList: jspb.Message.toObjectList(msg.getOpList(), proto.tensorflow.OpDef.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.OpList}
 */


proto.tensorflow.OpList.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.OpList();
  return proto.tensorflow.OpList.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.OpList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.OpList}
 */


proto.tensorflow.OpList.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.OpDef();
        reader.readMessage(value, proto.tensorflow.OpDef.deserializeBinaryFromReader);
        msg.addOp(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.OpList.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.OpList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.OpList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.OpList.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getOpList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(1, f, proto.tensorflow.OpDef.serializeBinaryToWriter);
  }
};
/**
 * repeated OpDef op = 1;
 * @return {!Array<!proto.tensorflow.OpDef>}
 */


proto.tensorflow.OpList.prototype.getOpList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.OpDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.OpDef, 1)
  );
};
/** @param {!Array<!proto.tensorflow.OpDef>} value */


proto.tensorflow.OpList.prototype.setOpList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};
/**
 * @param {!proto.tensorflow.OpDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.OpDef}
 */


proto.tensorflow.OpList.prototype.addOp = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tensorflow.OpDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.OpList.prototype.clearOpList = function () {
  this.setOpList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.MetaGraphDef.repeatedFields_ = [6];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.MetaGraphDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.MetaGraphDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.MetaGraphDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.MetaGraphDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      metaInfoDef: (f = msg.getMetaInfoDef()) && proto.tensorflow.MetaGraphDef.MetaInfoDef.toObject(includeInstance, f),
      graphDef: (f = msg.getGraphDef()) && proto.tensorflow.GraphDef.toObject(includeInstance, f),
      saverDef: (f = msg.getSaverDef()) && proto.tensorflow.SaverDef.toObject(includeInstance, f),
      collectionDefMap: (f = msg.getCollectionDefMap()) ? f.toObject(includeInstance, proto.tensorflow.CollectionDef.toObject) : [],
      signatureDefMap: (f = msg.getSignatureDefMap()) ? f.toObject(includeInstance, proto.tensorflow.SignatureDef.toObject) : [],
      assetFileDefList: jspb.Message.toObjectList(msg.getAssetFileDefList(), proto.tensorflow.AssetFileDef.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.MetaGraphDef}
 */


proto.tensorflow.MetaGraphDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.MetaGraphDef();
  return proto.tensorflow.MetaGraphDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.MetaGraphDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.MetaGraphDef}
 */


proto.tensorflow.MetaGraphDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.MetaGraphDef.MetaInfoDef();
        reader.readMessage(value, proto.tensorflow.MetaGraphDef.MetaInfoDef.deserializeBinaryFromReader);
        msg.setMetaInfoDef(value);
        break;

      case 2:
        var value = new proto.tensorflow.GraphDef();
        reader.readMessage(value, proto.tensorflow.GraphDef.deserializeBinaryFromReader);
        msg.setGraphDef(value);
        break;

      case 3:
        var value = new proto.tensorflow.SaverDef();
        reader.readMessage(value, proto.tensorflow.SaverDef.deserializeBinaryFromReader);
        msg.setSaverDef(value);
        break;

      case 4:
        var value = msg.getCollectionDefMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.CollectionDef.deserializeBinaryFromReader, "");
        });
        break;

      case 5:
        var value = msg.getSignatureDefMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.SignatureDef.deserializeBinaryFromReader, "");
        });
        break;

      case 6:
        var value = new proto.tensorflow.AssetFileDef();
        reader.readMessage(value, proto.tensorflow.AssetFileDef.deserializeBinaryFromReader);
        msg.addAssetFileDef(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.MetaGraphDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.MetaGraphDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.MetaGraphDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.MetaGraphDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getMetaInfoDef();

  if (f != null) {
    writer.writeMessage(1, f, proto.tensorflow.MetaGraphDef.MetaInfoDef.serializeBinaryToWriter);
  }

  f = message.getGraphDef();

  if (f != null) {
    writer.writeMessage(2, f, proto.tensorflow.GraphDef.serializeBinaryToWriter);
  }

  f = message.getSaverDef();

  if (f != null) {
    writer.writeMessage(3, f, proto.tensorflow.SaverDef.serializeBinaryToWriter);
  }

  f = message.getCollectionDefMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.CollectionDef.serializeBinaryToWriter);
  }

  f = message.getSignatureDefMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.SignatureDef.serializeBinaryToWriter);
  }

  f = message.getAssetFileDefList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(6, f, proto.tensorflow.AssetFileDef.serializeBinaryToWriter);
  }
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.repeatedFields_ = [4];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.MetaGraphDef.MetaInfoDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.MetaGraphDef.MetaInfoDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.MetaGraphDef.MetaInfoDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      metaGraphVersion: jspb.Message.getFieldWithDefault(msg, 1, ""),
      strippedOpList: (f = msg.getStrippedOpList()) && proto.tensorflow.OpList.toObject(includeInstance, f),
      anyInfo: (f = msg.getAnyInfo()) && proto.tensorflow.Any.toObject(includeInstance, f),
      tagsList: (f = jspb.Message.getRepeatedField(msg, 4)) == null ? undefined : f,
      tensorflowVersion: jspb.Message.getFieldWithDefault(msg, 5, ""),
      tensorflowGitVersion: jspb.Message.getFieldWithDefault(msg, 6, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.MetaGraphDef.MetaInfoDef}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.MetaGraphDef.MetaInfoDef();
  return proto.tensorflow.MetaGraphDef.MetaInfoDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.MetaGraphDef.MetaInfoDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.MetaGraphDef.MetaInfoDef}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setMetaGraphVersion(value);
        break;

      case 2:
        var value = new proto.tensorflow.OpList();
        reader.readMessage(value, proto.tensorflow.OpList.deserializeBinaryFromReader);
        msg.setStrippedOpList(value);
        break;

      case 3:
        var value = new proto.tensorflow.Any();
        reader.readMessage(value, proto.tensorflow.Any.deserializeBinaryFromReader);
        msg.setAnyInfo(value);
        break;

      case 4:
        var value =
        /** @type {string} */
        reader.readString();
        msg.addTags(value);
        break;

      case 5:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setTensorflowVersion(value);
        break;

      case 6:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setTensorflowGitVersion(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.MetaGraphDef.MetaInfoDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.MetaGraphDef.MetaInfoDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getMetaGraphVersion();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getStrippedOpList();

  if (f != null) {
    writer.writeMessage(2, f, proto.tensorflow.OpList.serializeBinaryToWriter);
  }

  f = message.getAnyInfo();

  if (f != null) {
    writer.writeMessage(3, f, proto.tensorflow.Any.serializeBinaryToWriter);
  }

  f = message.getTagsList();

  if (f.length > 0) {
    writer.writeRepeatedString(4, f);
  }

  f = message.getTensorflowVersion();

  if (f.length > 0) {
    writer.writeString(5, f);
  }

  f = message.getTensorflowGitVersion();

  if (f.length > 0) {
    writer.writeString(6, f);
  }
};
/**
 * optional string meta_graph_version = 1;
 * @return {string}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.getMetaGraphVersion = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.setMetaGraphVersion = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional OpList stripped_op_list = 2;
 * @return {?proto.tensorflow.OpList}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.getStrippedOpList = function () {
  return (
    /** @type{?proto.tensorflow.OpList} */
    jspb.Message.getWrapperField(this, proto.tensorflow.OpList, 2)
  );
};
/** @param {?proto.tensorflow.OpList|undefined} value */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.setStrippedOpList = function (value) {
  jspb.Message.setWrapperField(this, 2, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.clearStrippedOpList = function () {
  this.setStrippedOpList(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.hasStrippedOpList = function () {
  return jspb.Message.getField(this, 2) != null;
};
/**
 * optional Any any_info = 3;
 * @return {?proto.tensorflow.Any}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.getAnyInfo = function () {
  return (
    /** @type{?proto.tensorflow.Any} */
    jspb.Message.getWrapperField(this, proto.tensorflow.Any, 3)
  );
};
/** @param {?proto.tensorflow.Any|undefined} value */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.setAnyInfo = function (value) {
  jspb.Message.setWrapperField(this, 3, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.clearAnyInfo = function () {
  this.setAnyInfo(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.hasAnyInfo = function () {
  return jspb.Message.getField(this, 3) != null;
};
/**
 * repeated string tags = 4;
 * @return {!Array<string>}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.getTagsList = function () {
  return (
    /** @type {!Array<string>} */
    jspb.Message.getRepeatedField(this, 4)
  );
};
/** @param {!Array<string>} value */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.setTagsList = function (value) {
  jspb.Message.setField(this, 4, value || []);
};
/**
 * @param {string} value
 * @param {number=} opt_index
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.addTags = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.clearTagsList = function () {
  this.setTagsList([]);
};
/**
 * optional string tensorflow_version = 5;
 * @return {string}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.getTensorflowVersion = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 5, "")
  );
};
/** @param {string} value */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.setTensorflowVersion = function (value) {
  jspb.Message.setProto3StringField(this, 5, value);
};
/**
 * optional string tensorflow_git_version = 6;
 * @return {string}
 */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.getTensorflowGitVersion = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 6, "")
  );
};
/** @param {string} value */


proto.tensorflow.MetaGraphDef.MetaInfoDef.prototype.setTensorflowGitVersion = function (value) {
  jspb.Message.setProto3StringField(this, 6, value);
};
/**
 * optional MetaInfoDef meta_info_def = 1;
 * @return {?proto.tensorflow.MetaGraphDef.MetaInfoDef}
 */


proto.tensorflow.MetaGraphDef.prototype.getMetaInfoDef = function () {
  return (
    /** @type{?proto.tensorflow.MetaGraphDef.MetaInfoDef} */
    jspb.Message.getWrapperField(this, proto.tensorflow.MetaGraphDef.MetaInfoDef, 1)
  );
};
/** @param {?proto.tensorflow.MetaGraphDef.MetaInfoDef|undefined} value */


proto.tensorflow.MetaGraphDef.prototype.setMetaInfoDef = function (value) {
  jspb.Message.setWrapperField(this, 1, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.MetaGraphDef.prototype.clearMetaInfoDef = function () {
  this.setMetaInfoDef(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.MetaGraphDef.prototype.hasMetaInfoDef = function () {
  return jspb.Message.getField(this, 1) != null;
};
/**
 * optional GraphDef graph_def = 2;
 * @return {?proto.tensorflow.GraphDef}
 */


proto.tensorflow.MetaGraphDef.prototype.getGraphDef = function () {
  return (
    /** @type{?proto.tensorflow.GraphDef} */
    jspb.Message.getWrapperField(this, proto.tensorflow.GraphDef, 2)
  );
};
/** @param {?proto.tensorflow.GraphDef|undefined} value */


proto.tensorflow.MetaGraphDef.prototype.setGraphDef = function (value) {
  jspb.Message.setWrapperField(this, 2, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.MetaGraphDef.prototype.clearGraphDef = function () {
  this.setGraphDef(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.MetaGraphDef.prototype.hasGraphDef = function () {
  return jspb.Message.getField(this, 2) != null;
};
/**
 * optional SaverDef saver_def = 3;
 * @return {?proto.tensorflow.SaverDef}
 */


proto.tensorflow.MetaGraphDef.prototype.getSaverDef = function () {
  return (
    /** @type{?proto.tensorflow.SaverDef} */
    jspb.Message.getWrapperField(this, proto.tensorflow.SaverDef, 3)
  );
};
/** @param {?proto.tensorflow.SaverDef|undefined} value */


proto.tensorflow.MetaGraphDef.prototype.setSaverDef = function (value) {
  jspb.Message.setWrapperField(this, 3, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.MetaGraphDef.prototype.clearSaverDef = function () {
  this.setSaverDef(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.MetaGraphDef.prototype.hasSaverDef = function () {
  return jspb.Message.getField(this, 3) != null;
};
/**
 * map<string, CollectionDef> collection_def = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.CollectionDef>}
 */


proto.tensorflow.MetaGraphDef.prototype.getCollectionDefMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.CollectionDef>} */
    jspb.Message.getMapField(this, 4, opt_noLazyCreate, proto.tensorflow.CollectionDef)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.MetaGraphDef.prototype.clearCollectionDefMap = function () {
  this.getCollectionDefMap().clear();
};
/**
 * map<string, SignatureDef> signature_def = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.SignatureDef>}
 */


proto.tensorflow.MetaGraphDef.prototype.getSignatureDefMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.SignatureDef>} */
    jspb.Message.getMapField(this, 5, opt_noLazyCreate, proto.tensorflow.SignatureDef)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.MetaGraphDef.prototype.clearSignatureDefMap = function () {
  this.getSignatureDefMap().clear();
};
/**
 * repeated AssetFileDef asset_file_def = 6;
 * @return {!Array<!proto.tensorflow.AssetFileDef>}
 */


proto.tensorflow.MetaGraphDef.prototype.getAssetFileDefList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.AssetFileDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.AssetFileDef, 6)
  );
};
/** @param {!Array<!proto.tensorflow.AssetFileDef>} value */


proto.tensorflow.MetaGraphDef.prototype.setAssetFileDefList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value);
};
/**
 * @param {!proto.tensorflow.AssetFileDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.AssetFileDef}
 */


proto.tensorflow.MetaGraphDef.prototype.addAssetFileDef = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.tensorflow.AssetFileDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.MetaGraphDef.prototype.clearAssetFileDefList = function () {
  this.setAssetFileDefList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.SavedModel.repeatedFields_ = [2];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.SavedModel.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.SavedModel.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.SavedModel} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.SavedModel.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      savedModelSchemaVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
      metaGraphsList: jspb.Message.toObjectList(msg.getMetaGraphsList(), proto.tensorflow.MetaGraphDef.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.SavedModel}
 */


proto.tensorflow.SavedModel.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.SavedModel();
  return proto.tensorflow.SavedModel.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.SavedModel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.SavedModel}
 */


proto.tensorflow.SavedModel.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {number} */
        reader.readInt64();
        msg.setSavedModelSchemaVersion(value);
        break;

      case 2:
        var value = new proto.tensorflow.MetaGraphDef();
        reader.readMessage(value, proto.tensorflow.MetaGraphDef.deserializeBinaryFromReader);
        msg.addMetaGraphs(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.SavedModel.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.SavedModel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.SavedModel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.SavedModel.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getSavedModelSchemaVersion();

  if (f !== 0) {
    writer.writeInt64(1, f);
  }

  f = message.getMetaGraphsList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(2, f, proto.tensorflow.MetaGraphDef.serializeBinaryToWriter);
  }
};
/**
 * optional int64 saved_model_schema_version = 1;
 * @return {number}
 */


proto.tensorflow.SavedModel.prototype.getSavedModelSchemaVersion = function () {
  return (
    /** @type {number} */
    jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};
/** @param {number} value */


proto.tensorflow.SavedModel.prototype.setSavedModelSchemaVersion = function (value) {
  jspb.Message.setProto3IntField(this, 1, value);
};
/**
 * repeated MetaGraphDef meta_graphs = 2;
 * @return {!Array<!proto.tensorflow.MetaGraphDef>}
 */


proto.tensorflow.SavedModel.prototype.getMetaGraphsList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.MetaGraphDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.MetaGraphDef, 2)
  );
};
/** @param {!Array<!proto.tensorflow.MetaGraphDef>} value */


proto.tensorflow.SavedModel.prototype.setMetaGraphsList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};
/**
 * @param {!proto.tensorflow.MetaGraphDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.MetaGraphDef}
 */


proto.tensorflow.SavedModel.prototype.addMetaGraphs = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tensorflow.MetaGraphDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.SavedModel.prototype.clearMetaGraphsList = function () {
  this.setMetaGraphsList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.FunctionDefLibrary.repeatedFields_ = [1, 2];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.FunctionDefLibrary.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.FunctionDefLibrary.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.FunctionDefLibrary} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.FunctionDefLibrary.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      functionList: jspb.Message.toObjectList(msg.getFunctionList(), proto.tensorflow.FunctionDef.toObject, includeInstance),
      gradientList: jspb.Message.toObjectList(msg.getGradientList(), proto.tensorflow.GradientDef.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.FunctionDefLibrary}
 */


proto.tensorflow.FunctionDefLibrary.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.FunctionDefLibrary();
  return proto.tensorflow.FunctionDefLibrary.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.FunctionDefLibrary} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.FunctionDefLibrary}
 */


proto.tensorflow.FunctionDefLibrary.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.FunctionDef();
        reader.readMessage(value, proto.tensorflow.FunctionDef.deserializeBinaryFromReader);
        msg.addFunction(value);
        break;

      case 2:
        var value = new proto.tensorflow.GradientDef();
        reader.readMessage(value, proto.tensorflow.GradientDef.deserializeBinaryFromReader);
        msg.addGradient(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.FunctionDefLibrary.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.FunctionDefLibrary.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.FunctionDefLibrary} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.FunctionDefLibrary.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getFunctionList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(1, f, proto.tensorflow.FunctionDef.serializeBinaryToWriter);
  }

  f = message.getGradientList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(2, f, proto.tensorflow.GradientDef.serializeBinaryToWriter);
  }
};
/**
 * repeated FunctionDef function = 1;
 * @return {!Array<!proto.tensorflow.FunctionDef>}
 */


proto.tensorflow.FunctionDefLibrary.prototype.getFunctionList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.FunctionDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.FunctionDef, 1)
  );
};
/** @param {!Array<!proto.tensorflow.FunctionDef>} value */


proto.tensorflow.FunctionDefLibrary.prototype.setFunctionList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};
/**
 * @param {!proto.tensorflow.FunctionDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.FunctionDef}
 */


proto.tensorflow.FunctionDefLibrary.prototype.addFunction = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tensorflow.FunctionDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.FunctionDefLibrary.prototype.clearFunctionList = function () {
  this.setFunctionList([]);
};
/**
 * repeated GradientDef gradient = 2;
 * @return {!Array<!proto.tensorflow.GradientDef>}
 */


proto.tensorflow.FunctionDefLibrary.prototype.getGradientList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.GradientDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.GradientDef, 2)
  );
};
/** @param {!Array<!proto.tensorflow.GradientDef>} value */


proto.tensorflow.FunctionDefLibrary.prototype.setGradientList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};
/**
 * @param {!proto.tensorflow.GradientDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.GradientDef}
 */


proto.tensorflow.FunctionDefLibrary.prototype.addGradient = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tensorflow.GradientDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.FunctionDefLibrary.prototype.clearGradientList = function () {
  this.setGradientList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */


proto.tensorflow.FunctionDef.repeatedFields_ = [3];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.FunctionDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.FunctionDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.FunctionDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.FunctionDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      signature: (f = msg.getSignature()) && proto.tensorflow.OpDef.toObject(includeInstance, f),
      attrMap: (f = msg.getAttrMap()) ? f.toObject(includeInstance, proto.tensorflow.AttrValue.toObject) : [],
      nodeDefList: jspb.Message.toObjectList(msg.getNodeDefList(), proto.tensorflow.NodeDef.toObject, includeInstance),
      retMap: (f = msg.getRetMap()) ? f.toObject(includeInstance, undefined) : []
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.FunctionDef}
 */


proto.tensorflow.FunctionDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.FunctionDef();
  return proto.tensorflow.FunctionDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.FunctionDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.FunctionDef}
 */


proto.tensorflow.FunctionDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value = new proto.tensorflow.OpDef();
        reader.readMessage(value, proto.tensorflow.OpDef.deserializeBinaryFromReader);
        msg.setSignature(value);
        break;

      case 5:
        var value = msg.getAttrMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.tensorflow.AttrValue.deserializeBinaryFromReader, "");
        });
        break;

      case 3:
        var value = new proto.tensorflow.NodeDef();
        reader.readMessage(value, proto.tensorflow.NodeDef.deserializeBinaryFromReader);
        msg.addNodeDef(value);
        break;

      case 4:
        var value = msg.getRetMap();
        reader.readMessage(value, function (message, reader) {
          jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "");
        });
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.FunctionDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.FunctionDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.FunctionDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.FunctionDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getSignature();

  if (f != null) {
    writer.writeMessage(1, f, proto.tensorflow.OpDef.serializeBinaryToWriter);
  }

  f = message.getAttrMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.tensorflow.AttrValue.serializeBinaryToWriter);
  }

  f = message.getNodeDefList();

  if (f.length > 0) {
    writer.writeRepeatedMessage(3, f, proto.tensorflow.NodeDef.serializeBinaryToWriter);
  }

  f = message.getRetMap(true);

  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
};
/**
 * optional OpDef signature = 1;
 * @return {?proto.tensorflow.OpDef}
 */


proto.tensorflow.FunctionDef.prototype.getSignature = function () {
  return (
    /** @type{?proto.tensorflow.OpDef} */
    jspb.Message.getWrapperField(this, proto.tensorflow.OpDef, 1)
  );
};
/** @param {?proto.tensorflow.OpDef|undefined} value */


proto.tensorflow.FunctionDef.prototype.setSignature = function (value) {
  jspb.Message.setWrapperField(this, 1, value);
};
/**
 * Clears the message field making it undefined.
 */


proto.tensorflow.FunctionDef.prototype.clearSignature = function () {
  this.setSignature(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */


proto.tensorflow.FunctionDef.prototype.hasSignature = function () {
  return jspb.Message.getField(this, 1) != null;
};
/**
 * map<string, AttrValue> attr = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.tensorflow.AttrValue>}
 */


proto.tensorflow.FunctionDef.prototype.getAttrMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,!proto.tensorflow.AttrValue>} */
    jspb.Message.getMapField(this, 5, opt_noLazyCreate, proto.tensorflow.AttrValue)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.FunctionDef.prototype.clearAttrMap = function () {
  this.getAttrMap().clear();
};
/**
 * repeated NodeDef node_def = 3;
 * @return {!Array<!proto.tensorflow.NodeDef>}
 */


proto.tensorflow.FunctionDef.prototype.getNodeDefList = function () {
  return (
    /** @type{!Array<!proto.tensorflow.NodeDef>} */
    jspb.Message.getRepeatedWrapperField(this, proto.tensorflow.NodeDef, 3)
  );
};
/** @param {!Array<!proto.tensorflow.NodeDef>} value */


proto.tensorflow.FunctionDef.prototype.setNodeDefList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};
/**
 * @param {!proto.tensorflow.NodeDef=} opt_value
 * @param {number=} opt_index
 * @return {!proto.tensorflow.NodeDef}
 */


proto.tensorflow.FunctionDef.prototype.addNodeDef = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.tensorflow.NodeDef, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 */


proto.tensorflow.FunctionDef.prototype.clearNodeDefList = function () {
  this.setNodeDefList([]);
};
/**
 * map<string, string> ret = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */


proto.tensorflow.FunctionDef.prototype.getRetMap = function (opt_noLazyCreate) {
  return (
    /** @type {!jspb.Map<string,string>} */
    jspb.Message.getMapField(this, 4, opt_noLazyCreate, null)
  );
};
/**
 * Clears values from the map. The map will be non-null.
 */


proto.tensorflow.FunctionDef.prototype.clearRetMap = function () {
  this.getRetMap().clear();
};

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * Optional fields that are not set will be set to undefined.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
   * @param {boolean=} opt_includeInstance Deprecated. whether to include the
   *     JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.tensorflow.GradientDef.prototype.toObject = function (opt_includeInstance) {
    return proto.tensorflow.GradientDef.toObject(opt_includeInstance, this);
  };
  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Deprecated. Whether to include
   *     the JSPB instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.tensorflow.GradientDef} msg The msg instance to transform.
   * @return {!Object}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */


  proto.tensorflow.GradientDef.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      functionName: jspb.Message.getFieldWithDefault(msg, 1, ""),
      gradientFunc: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }

    return obj;
  };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.tensorflow.GradientDef}
 */


proto.tensorflow.GradientDef.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.tensorflow.GradientDef();
  return proto.tensorflow.GradientDef.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.tensorflow.GradientDef} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.tensorflow.GradientDef}
 */


proto.tensorflow.GradientDef.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }

    var field = reader.getFieldNumber();

    switch (field) {
      case 1:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setFunctionName(value);
        break;

      case 2:
        var value =
        /** @type {string} */
        reader.readString();
        msg.setGradientFunc(value);
        break;

      default:
        reader.skipField();
        break;
    }
  }

  return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */


proto.tensorflow.GradientDef.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  proto.tensorflow.GradientDef.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.tensorflow.GradientDef} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */


proto.tensorflow.GradientDef.serializeBinaryToWriter = function (message, writer) {
  var f = undefined;
  f = message.getFunctionName();

  if (f.length > 0) {
    writer.writeString(1, f);
  }

  f = message.getGradientFunc();

  if (f.length > 0) {
    writer.writeString(2, f);
  }
};
/**
 * optional string function_name = 1;
 * @return {string}
 */


proto.tensorflow.GradientDef.prototype.getFunctionName = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 1, "")
  );
};
/** @param {string} value */


proto.tensorflow.GradientDef.prototype.setFunctionName = function (value) {
  jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string gradient_func = 2;
 * @return {string}
 */


proto.tensorflow.GradientDef.prototype.getGradientFunc = function () {
  return (
    /** @type {string} */
    jspb.Message.getFieldWithDefault(this, 2, "")
  );
};
/** @param {string} value */


proto.tensorflow.GradientDef.prototype.setGradientFunc = function (value) {
  jspb.Message.setProto3StringField(this, 2, value);
};
/**
 * @enum {number}
 */


proto.tensorflow.DataType = {
  DT_INVALID: 0,
  DT_FLOAT: 1,
  DT_DOUBLE: 2,
  DT_INT32: 3,
  DT_UINT8: 4,
  DT_INT16: 5,
  DT_INT8: 6,
  DT_STRING: 7,
  DT_COMPLEX64: 8,
  DT_INT64: 9,
  DT_BOOL: 10,
  DT_QINT8: 11,
  DT_QUINT8: 12,
  DT_QINT32: 13,
  DT_BFLOAT16: 14,
  DT_FLOAT_REF: 101,
  DT_DOUBLE_REF: 102,
  DT_INT32_REF: 103,
  DT_UINT8_REF: 104,
  DT_INT16_REF: 105,
  DT_INT8_REF: 106,
  DT_STRING_REF: 107,
  DT_COMPLEX64_REF: 108,
  DT_INT64_REF: 109,
  DT_BOOL_REF: 110,
  DT_QINT8_REF: 111,
  DT_QUINT8_REF: 112,
  DT_QINT32_REF: 113,
  DT_BFLOAT16_REF: 114
};
goog.object.extend(exports, proto.tensorflow);
},{"google-protobuf":"../node_modules/google-protobuf/google-protobuf.js"}],"../node_modules/@tensorflow/tfjs-node/dist/saved_model.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tfjs_1 = require("@tensorflow/tfjs");

var fs = require("fs");

var util_1 = require("util");

var nodejs_kernel_backend_1 = require("./nodejs_kernel_backend");

var readFile = util_1.promisify(fs.readFile); // tslint:disable-next-line:no-require-imports

var messages = require('./proto/api_pb');

var SAVED_MODEL_FILE_NAME = '/saved_model.pb';
var SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op'; // This map is used to keep track of loaded SavedModel metagraph mapping
// information. The map key is TFSavedModel id in JavaScript, value is
// an object of path to the SavedModel, metagraph tags, and loaded Session ID in
// the c++ bindings. When user loads a SavedModel signature, it will go through
// entries in this map to find if the corresponding SavedModel session has
// already been loaded in C++ addon and will reuse it if existing.

var loadedSavedModelPathMap = new Map(); // The ID of loaded TFSavedModel. This ID is used to keep track of loaded
// TFSavedModel, so the loaded session in c++ bindings for the corresponding
// TFSavedModel can be properly reused/disposed.

var nextTFSavedModelId = 0;
/**
 * Get a key in an object by its value. This is used to get protobuf enum value
 * from index.
 *
 * @param object
 * @param value
 */
// tslint:disable-next-line:no-any

function getEnumKeyFromValue(object, value) {
  return Object.keys(object).find(function (key) {
    return object[key] === value;
  });
}

exports.getEnumKeyFromValue = getEnumKeyFromValue;
/**
 * Read SavedModel proto message from path.
 *
 * @param path Path to SavedModel folder.
 */

function readSavedModelProto(path) {
  return __awaiter(this, void 0, void 0, function () {
    var modelFile, array;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          // Load the SavedModel pb file and deserialize it into message.
          try {
            fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);
          } catch (error) {
            throw new Error('There is no saved_model.pb file in the directory: ' + path);
          }

          return [4
          /*yield*/
          , readFile(path + SAVED_MODEL_FILE_NAME)];

        case 1:
          modelFile = _a.sent();
          array = new Uint8Array(modelFile);
          return [2
          /*return*/
          , messages.SavedModel.deserializeBinary(array)];
      }
    });
  });
}

exports.readSavedModelProto = readSavedModelProto;
/**
 * Inspect the MetaGraphs of the SavedModel from the provided path. This
 * function will return an array of `MetaGraphInfo` objects.
 *
 * @param path Path to SavedModel folder.
 */

/**
 * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}
 */

function getMetaGraphsFromSavedModel(path) {
  return __awaiter(this, void 0, void 0, function () {
    var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          result = [];
          return [4
          /*yield*/
          , readSavedModelProto(path)];

        case 1:
          modelMessage = _a.sent();
          metaGraphList = modelMessage.getMetaGraphsList();

          for (i = 0; i < metaGraphList.length; i++) {
            metaGraph = {};
            tags = metaGraphList[i].getMetaInfoDef().getTagsList();
            metaGraph.tags = tags;
            signatureDef = {};
            signatureDefMap = metaGraphList[i].getSignatureDefMap();
            signatureDefKeys = signatureDefMap.keys(); // Go through all signatureDefs

            while (true) {
              key = signatureDefKeys.next();

              if (key.done) {
                break;
              } // Skip TensorFlow internal Signature '__saved_model_init_op'.


              if (key.value === SAVED_MODEL_INIT_OP_KEY) {
                continue;
              }

              signatureDefEntry = signatureDefMap.get(key.value);
              inputsMapMessage = signatureDefEntry.getInputsMap();
              inputsMapKeys = inputsMapMessage.keys();
              inputs = {};

              while (true) {
                inputsMapKey = inputsMapKeys.next();

                if (inputsMapKey.done) {
                  break;
                }

                inputTensor = inputsMapMessage.get(inputsMapKey.value);
                inputTensorInfo = {};
                inputTensorInfo.dtype = mapTFDtypeToJSDtype(getEnumKeyFromValue(messages.DataType, inputTensor.getDtype()));
                inputTensorInfo.name = inputTensor.getName();
                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();
                inputs[inputsMapKey.value] = inputTensorInfo;
              }

              outputsMapMessage = signatureDefEntry.getOutputsMap();
              outputsMapKeys = outputsMapMessage.keys();
              outputs = {};

              while (true) {
                outputsMapKey = outputsMapKeys.next();

                if (outputsMapKey.done) {
                  break;
                }

                outputTensor = outputsMapMessage.get(outputsMapKey.value);
                outputTensorInfo = {};
                outputTensorInfo.dtype = mapTFDtypeToJSDtype(getEnumKeyFromValue(messages.DataType, outputTensor.getDtype()));
                outputTensorInfo.name = outputTensor.getName();
                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();
                outputs[outputsMapKey.value] = outputTensorInfo;
              }

              signatureDef[key.value] = {
                inputs: inputs,
                outputs: outputs
              };
            }

            metaGraph.signatureDefs = signatureDef;
            result.push(metaGraph);
          }

          return [2
          /*return*/
          , result];
      }
    });
  });
}

exports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;
/**
 * Get input and output node names from SavedModel metagraphs info. The
 * input.output node names will be used when executing a SavedModel signature.
 *
 * @param savedModelInfo The MetaGraphInfo array loaded through
 *     getMetaGraphsFromSavedModel().
 * @param tags The tags of the MetaGraph to get input/output node names from.
 * @param signature The signature to get input/output node names from.
 */

function getInputAndOutputNodeNameFromMetaGraphInfo(savedModelInfo, tags, signature) {
  for (var i = 0; i < savedModelInfo.length; i++) {
    var metaGraphInfo = savedModelInfo[i];

    if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {
      if (metaGraphInfo.signatureDefs[signature] == null) {
        throw new Error('The SavedModel does not have signature: ' + signature);
      }

      var inputNodeNames = {};
      var outputNodeNames = {};

      for (var _i = 0, _a = Object.keys(metaGraphInfo.signatureDefs); _i < _a.length; _i++) {
        var signatureDef = _a[_i];

        if (signatureDef === signature) {
          for (var _b = 0, _c = Object.keys(metaGraphInfo.signatureDefs[signature].inputs); _b < _c.length; _b++) {
            var tensorName = _c[_b];
            inputNodeNames[tensorName] = metaGraphInfo.signatureDefs[signature].inputs[tensorName].name;
          }

          for (var _d = 0, _e = Object.keys(metaGraphInfo.signatureDefs[signature].outputs); _d < _e.length; _d++) {
            var tensorName = _e[_d];
            outputNodeNames[tensorName] = metaGraphInfo.signatureDefs[signature].outputs[tensorName].name;
          }
        }
      }

      return [inputNodeNames, outputNodeNames];
    }
  }

  throw new Error("The SavedModel does not have tags: " + tags);
}

exports.getInputAndOutputNodeNameFromMetaGraphInfo = getInputAndOutputNodeNameFromMetaGraphInfo;
/**
 * A `tf.TFSavedModel` is a signature loaded from a SavedModel
 * metagraph, and allows inference execution.
 */

/**
 * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}
 */

var TFSavedModel =
/** @class */
function () {
  function TFSavedModel(sessionId, jsid, inputNodeNames, outputNodeNames, backend) {
    this.sessionId = sessionId;
    this.jsid = jsid;
    this.inputNodeNames = inputNodeNames;
    this.outputNodeNames = outputNodeNames;
    this.backend = backend;
    this.disposed = false;
  }

  Object.defineProperty(TFSavedModel.prototype, "inputs", {
    /**
     * Return the array of input tensor info.
     */

    /** @doc {heading: 'Models', subheading: 'SavedModel'} */
    get: function get() {
      throw new Error('SavedModel inputs information is not available yet.');
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TFSavedModel.prototype, "outputs", {
    /**
     * Return the array of output tensor info.
     */

    /** @doc {heading: 'Models', subheading: 'SavedModel'} */
    get: function get() {
      throw new Error('SavedModel outputs information is not available yet.');
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Delete the SavedModel from nodeBackend and delete corresponding session in
   * the C++ backend if the session is only used by this TFSavedModel.
   */

  /** @doc {heading: 'Models', subheading: 'SavedModel'} */

  TFSavedModel.prototype.dispose = function () {
    if (!this.disposed) {
      this.disposed = true;
      loadedSavedModelPathMap.delete(this.jsid);

      for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {
        var id = _a[_i];
        var value = loadedSavedModelPathMap.get(id);

        if (value.sessionId === this.sessionId) {
          return;
        }
      }

      this.backend.deleteSavedModel(this.sessionId);
    } else {
      throw new Error('This SavedModel has already been deleted.');
    }
  };
  /**
   * Execute the inference for the input tensors.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a Tensor. For models with multiple inputs, inputs
   * params should be in either Tensor[] if the input order is fixed, or
   * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the
   * name of input tensors in SavedModel signatureDef. It can be found through
   * `tf.node.getMetaGraphsFromSavedModel()`.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   *
   * @returns Inference result tensors. The output would be single Tensor if
   * model has single output node, otherwise Tensor[] or NamedTensorMap[] will
   * be returned for model with multiple outputs.
   */

  /** @doc {heading: 'Models', subheading: 'SavedModel'} */


  TFSavedModel.prototype.predict = function (inputs, config) {
    var _this = this;

    if (this.disposed) {
      throw new Error('The TFSavedModel has already been deleted!');
    } else {
      var inputTensors = [];

      if (inputs instanceof tfjs_1.Tensor) {
        inputTensors.push(inputs);
        return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.inputNodeNames), Object.values(this.outputNodeNames))[0];
      } else if (Array.isArray(inputs)) {
        inputTensors = inputs;
        return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.inputNodeNames), Object.values(this.outputNodeNames));
      } else {
        var inputTensorNames = Object.keys(this.inputNodeNames);
        var providedInputNames = Object.keys(inputs);

        if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {
          throw new Error("The model signatureDef input names are " + inputTensorNames.join() + ", however the provided input names are " + providedInputNames.join() + ".");
        }

        var inputNodeNamesArray = [];

        for (var i = 0; i < inputTensorNames.length; i++) {
          inputTensors.push(inputs[inputTensorNames[i]]);
          inputNodeNamesArray.push(this.inputNodeNames[inputTensorNames[i]]);
        }

        var outputTensorNames = Object.keys(this.outputNodeNames);
        var outputNodeNamesArray = [];

        for (var i = 0; i < outputTensorNames.length; i++) {
          outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);
        }

        var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);
        tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () {
          return 'Output tensors do not match output node names, ' + ("receive " + outputTensors_1.length + ") output tensors but ") + ("there are " + _this.outputNodeNames.length + " output nodes.");
        });
        var outputMap = {};

        for (var i = 0; i < outputTensorNames.length; i++) {
          outputMap[outputTensorNames[i]] = outputTensors_1[i];
        }

        return outputMap;
      }
    }
  };
  /**
   * Execute the inference for the input tensors and return activation
   * values for specified output node names without batching.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a Tensor. For models with multiple inputs, inputs
   * params should be in either Tensor[] if the input order is fixed, or
   * otherwise NamedTensorMap format.
   *
   * @param outputs string|string[]. List of output node names to retrieve
   * activation from.
   *
   * @returns Activation values for the output nodes result tensors. The return
   * type matches specified parameter outputs type. The output would be single
   * Tensor if single output is specified, otherwise Tensor[] for multiple
   * outputs.
   */

  /** @doc {heading: 'Models', subheading: 'SavedModel'} */


  TFSavedModel.prototype.execute = function (inputs, outputs) {
    throw new Error('execute() of TFSavedModel is not supported yet.');
  };

  return TFSavedModel;
}();

exports.TFSavedModel = TFSavedModel;
/**
 * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different
 * from TensorFlow.js model format. A SavedModel is a directory containing
 * serialized signatures and the states needed to run them. The directory has a
 * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow
 * program, or model, and a set of named signatures, each identifying a
 * function. The directory also has a variables directory contains a standard
 * training checkpoint. The directory may also has a assets directory contains
 * files used by the TensorFlow graph, for example text files used to initialize
 * vocabulary tables. For more information, see this guide:
 * https://www.tensorflow.org/guide/saved_model.
 *
 * @param path The path to the SavedModel.
 * @param tags The tags of the MetaGraph to load. The available tags of a
 *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()
 *     API. Defaults to ['serve'].
 * @param signature The name of the SignatureDef to load. The available
 *     SignatureDefs of a SavedModel can be retrieved through
 *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.
 */

/** @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'} */

function loadSavedModel(path, tags, signature) {
  if (tags === void 0) {
    tags = ['serve'];
  }

  if (signature === void 0) {
    signature = 'serving_default';
  }

  return __awaiter(this, void 0, void 0, function () {
    var backend, savedModelInfo, _a, inputNodeNames, outputNodeNames, sessionId, _i, _b, id_1, modelInfo, tagsString, id, savedModel;

    return __generator(this, function (_c) {
      switch (_c.label) {
        case 0:
          nodejs_kernel_backend_1.ensureTensorflowBackend();
          backend = nodejs_kernel_backend_1.nodeBackend();
          return [4
          /*yield*/
          , getMetaGraphsFromSavedModel(path)];

        case 1:
          savedModelInfo = _c.sent();
          _a = getInputAndOutputNodeNameFromMetaGraphInfo(savedModelInfo, tags, signature), inputNodeNames = _a[0], outputNodeNames = _a[1];

          for (_i = 0, _b = Array.from(loadedSavedModelPathMap.keys()); _i < _b.length; _i++) {
            id_1 = _b[_i];
            modelInfo = loadedSavedModelPathMap.get(id_1);

            if (modelInfo.path === path && stringArraysHaveSameElements(modelInfo.tags, tags)) {
              sessionId = modelInfo.sessionId;
            }
          }

          if (sessionId == null) {
            tagsString = tags.join(',');
            sessionId = backend.loadSavedModelMetaGraph(path, tagsString);
          }

          id = nextTFSavedModelId++;
          savedModel = new TFSavedModel(sessionId, id, inputNodeNames, outputNodeNames, backend);
          loadedSavedModelPathMap.set(id, {
            path: path,
            tags: tags,
            sessionId: sessionId
          });
          return [2
          /*return*/
          , savedModel];
      }
    });
  });
}

exports.loadSavedModel = loadSavedModel;
/**
 * Compare if two unsorted arrays of string have the same elements.
 * @param arrayA
 * @param arrayB
 */

function stringArraysHaveSameElements(arrayA, arrayB) {
  if (arrayA.length === arrayB.length && arrayA.sort().join() === arrayB.sort().join()) {
    return true;
  }

  return false;
}

function mapTFDtypeToJSDtype(tfDtype) {
  switch (tfDtype) {
    case 'DT_FLOAT':
      return 'float32';

    case 'DT_INT32':
      return 'int32';

    case 'DT_BOOL':
      return 'bool';

    case 'DT_COMPLEX64':
      return 'complex64';

    case 'DT_STRING':
      return 'string';

    default:
      throw new Error('Unsupported tensor DataType: ' + tfDtype);
  }
}
},{"@tensorflow/tfjs":"../node_modules/@tensorflow/tfjs/dist/tf.esm.js","fs":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js","util":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/util/util.js","./nodejs_kernel_backend":"../node_modules/@tensorflow/tfjs-node/dist/nodejs_kernel_backend.js","./proto/api_pb":"../node_modules/@tensorflow/tfjs-node/dist/proto/api_pb.js"}],"../node_modules/@tensorflow/tfjs-node/dist/node.js":[function(require,module,exports) {
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Public API symbols under the tf.node.* namespace.
 */

var callbacks_1 = require("./callbacks");

var image_1 = require("./image");

var saved_model_1 = require("./saved_model");

var tensorboard_1 = require("./tensorboard");

exports.node = {
  decodeImage: image_1.decodeImage,
  decodeBmp: image_1.decodeBmp,
  decodeGif: image_1.decodeGif,
  decodePng: image_1.decodePng,
  decodeJpeg: image_1.decodeJpeg,
  encodeJpeg: image_1.encodeJpeg,
  encodePng: image_1.encodePng,
  summaryFileWriter: tensorboard_1.summaryFileWriter,
  tensorBoard: callbacks_1.tensorBoard,
  getMetaGraphsFromSavedModel: saved_model_1.getMetaGraphsFromSavedModel,
  loadSavedModel: saved_model_1.loadSavedModel
};
},{"./callbacks":"../node_modules/@tensorflow/tfjs-node/dist/callbacks.js","./image":"../node_modules/@tensorflow/tfjs-node/dist/image.js","./saved_model":"../node_modules/@tensorflow/tfjs-node/dist/saved_model.js","./tensorboard":"../node_modules/@tensorflow/tfjs-node/dist/tensorboard.js"}],"../node_modules/@tensorflow/tfjs-node/package.json":[function(require,module,exports) {
module.exports = {
  "_from": "@tensorflow/tfjs-node",
  "_id": "@tensorflow/tfjs-node@1.3.2",
  "_inBundle": false,
  "_integrity": "sha512-inWEd+WmVUU/UdLjYSNugTAa2MBuKUd6QtcGDk8u1+yV54/ulxYQlsITB4g/6KPnABlnpM49J342pt+/j2Z8uA==",
  "_location": "/@tensorflow/tfjs-node",
  "_phantomChildren": {},
  "_requested": {
    "type": "tag",
    "registry": true,
    "raw": "@tensorflow/tfjs-node",
    "name": "@tensorflow/tfjs-node",
    "escapedName": "@tensorflow%2ftfjs-node",
    "scope": "@tensorflow",
    "rawSpec": "",
    "saveSpec": null,
    "fetchSpec": "latest"
  },
  "_requiredBy": ["#USER", "/"],
  "_resolved": "https://registry.npmjs.org/@tensorflow/tfjs-node/-/tfjs-node-1.3.2.tgz",
  "_shasum": "98e71faeefac1284610e8d3bcd4c1ef36ea28255",
  "_spec": "@tensorflow/tfjs-node",
  "_where": "/Users/jsmney/Programming/FSA-immersive/seniorphase/capstone/brain-dancer",
  "binary": {
    "module_name": "tfjs_binding",
    "module_path": "./lib/napi-v{napi_build_version}",
    "host": "https://storage.googleapis.com/tf-builds/pre-built-binary",
    "remote_path": "./napi-v{napi_build_version}/{version}/",
    "napi_versions": [3, 4]
  },
  "bugs": {
    "url": "https://github.com/tensorflow/tfjs/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "@tensorflow/tfjs": "1.3.2",
    "adm-zip": "^0.4.11",
    "google-protobuf": "^3.9.2",
    "https-proxy-agent": "^2.2.1",
    "node-pre-gyp": "0.13.0",
    "progress": "^2.0.0",
    "rimraf": "^2.6.2",
    "tar": "^4.4.6"
  },
  "deprecated": false,
  "description": "This repository provides native TensorFlow execution in backend JavaScript applications under the Node.js runtime, accelerated by the TensorFlow C binary under the hood. It provides the same API as [TensorFlow.js](https://js.tensorflow.org/api/latest/).",
  "devDependencies": {
    "@types/jasmine": "~2.8.6",
    "@types/node": "^10.5.1",
    "@types/progress": "^2.0.1",
    "@types/rimraf": "~2.0.2",
    "@types/yargs": "^13.0.3",
    "clang-format": "~1.2.2",
    "jasmine": "~3.1.0",
    "node-fetch": "^2.3.0",
    "nyc": "^13.3.0",
    "tmp": "^0.0.33",
    "ts-node": "^5.0.1",
    "tslint": "~5.9.1",
    "tslint-no-circular-imports": "^0.7.0",
    "typescript": "3.5.3",
    "yalc": "~1.0.0-pre.21",
    "yargs": "^14.2.0"
  },
  "engines": {
    "node": ">=8.11.0"
  },
  "gypfile": true,
  "homepage": "https://github.com/tensorflow/tfjs#readme",
  "main": "dist/index.js",
  "name": "@tensorflow/tfjs-node",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tensorflow/tfjs.git"
  },
  "scripts": {
    "build": "tsc && mkdir -p dist/proto && cp src/proto/api_pb.js dist/proto/api_pb.js",
    "build-addon": "./scripts/build-and-upload-addon.sh",
    "build-addon-from-source": "node-pre-gyp install --build-from-source",
    "build-npm": "./scripts/build-npm.sh",
    "clean-deps": "rm -rf deps && rm -rf lib",
    "coverage": "nyc ts-node src/run_tests.ts",
    "enable-gpu": "node scripts/install.js gpu download && yarn && yarn build-addon-from-source",
    "ensure-cpu-gpu-packages-align": "node scripts/ensure-cpu-gpu-packages-align.js",
    "format": "clang-format -i -style=Google binding/*.cc binding/*.h",
    "install": "node scripts/install.js",
    "install-from-source": "yarn clean-deps && yarn && yarn build-addon-from-source",
    "link-local": "yalc link",
    "lint": "tslint -p . -t verbose",
    "prep": "cd node_modules/@tensorflow/tfjs-core && yarn && yarn build",
    "publish-local": "yarn prep && yalc push",
    "test": "ts-node src/run_tests.ts",
    "test-ci": "./scripts/test-ci.sh",
    "test-ts-integration": "./scripts/test-ts-integration.sh",
    "upload-windows-addon": "./scripts/build-and-upload-windows-addon.bat"
  },
  "types": "dist/index.d.ts",
  "version": "1.3.2"
};
},{}],"../node_modules/@tensorflow/tfjs-node/dist/index.js":[function(require,module,exports) {
var __dirname = "/Users/jsmney/Programming/FSA-immersive/seniorphase/capstone/brain-dancer/node_modules/@tensorflow/tfjs-node/dist";
"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tf = require("@tensorflow/tfjs");

var path = require("path");

var callbacks_1 = require("./callbacks");

var file_system_1 = require("./io/file_system");

var nodeIo = require("./io/index");

var nodejs_kernel_backend_1 = require("./nodejs_kernel_backend");

var nodeVersion = require("./version"); // tslint:disable-next-line:no-require-imports


var binary = require('node-pre-gyp');

var bindingPath = binary.find(path.resolve(path.join(__dirname, '/../package.json'))); // tslint:disable-next-line:no-require-imports

var bindings = require(bindingPath); // Merge version and io namespaces.


exports.version = __assign({}, tf.version, {
  'tfjs-node': nodeVersion.version
});
exports.io = __assign({}, tf.io, nodeIo); // Export all union package symbols

__export(require("@tensorflow/tfjs"));

__export(require("./node")); // tslint:disable-next-line:no-require-imports


var pjson = require('../package.json');

tf.registerBackend('tensorflow', function () {
  return new nodejs_kernel_backend_1.NodeJSKernelBackend(bindings, pjson.name);
}, 3
/* priority */
);
var success = tf.setBackend('tensorflow');

if (!success) {
  throw new Error("Could not initialize TensorFlow backend.");
} // Register the model saving and loading handlers for the 'file://' URL scheme.


tf.io.registerLoadRouter(file_system_1.nodeFileSystemRouter);
tf.io.registerSaveRouter(file_system_1.nodeFileSystemRouter); // Register the ProgbarLogger for Model.fit() at verbosity level 1.

tf.registerCallbackConstructor(1, callbacks_1.ProgbarLogger);
},{"@tensorflow/tfjs":"../node_modules/@tensorflow/tfjs/dist/tf.esm.js","path":"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","./callbacks":"../node_modules/@tensorflow/tfjs-node/dist/callbacks.js","./io/file_system":"../node_modules/@tensorflow/tfjs-node/dist/io/file_system.js","./io/index":"../node_modules/@tensorflow/tfjs-node/dist/io/index.js","./nodejs_kernel_backend":"../node_modules/@tensorflow/tfjs-node/dist/nodejs_kernel_backend.js","./version":"../node_modules/@tensorflow/tfjs-node/dist/version.js","node-pre-gyp":"../node_modules/node-pre-gyp/lib/node-pre-gyp.js","./node":"../node_modules/@tensorflow/tfjs-node/dist/node.js","../package.json":"../node_modules/@tensorflow/tfjs-node/package.json"}],"../node_modules/@tensorflow-models/posenet/dist/posenet.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeMultiplePoses = decodeMultiplePoses;
exports.decodeSinglePose = decodeSinglePose;
exports.load = load;
exports.getAdjacentKeyPoints = getAdjacentKeyPoints;
exports.getBoundingBox = getBoundingBox;
exports.getBoundingBoxPoints = getBoundingBoxPoints;
exports.scaleAndFlipPoses = scaleAndFlipPoses;
exports.scalePose = scalePose;
exports.PoseNet = exports.poseChain = exports.partNames = exports.partIds = exports.partChannels = exports.MobileNet = void 0;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _tfjsConverter = require("@tensorflow/tfjs-converter");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
    * @license
    * Copyright 2019 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
var extendStatics = function (e, t) {
  return (extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (e, t) {
    e.__proto__ = t;
  } || function (e, t) {
    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
  })(e, t);
};

function __extends(e, t) {
  function n() {
    this.constructor = e;
  }

  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
}

var __assign = function () {
  return (__assign = Object.assign || function (e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);

    return e;
  }).apply(this, arguments);
};

function __awaiter(e, t, n, r) {
  return new (n || (n = Promise))(function (o, i) {
    function s(e) {
      try {
        a(r.next(e));
      } catch (e) {
        i(e);
      }
    }

    function u(e) {
      try {
        a(r.throw(e));
      } catch (e) {
        i(e);
      }
    }

    function a(e) {
      e.done ? o(e.value) : new n(function (t) {
        t(e.value);
      }).then(s, u);
    }

    a((r = r.apply(e, t || [])).next());
  });
}

function __generator(e, t) {
  var n,
      r,
      o,
      i,
      s = {
    label: 0,
    sent: function () {
      if (1 & o[0]) throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return i = {
    next: u(0),
    throw: u(1),
    return: u(2)
  }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
    return this;
  }), i;

  function u(i) {
    return function (u) {
      return function (i) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; s;) try {
          if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;

          switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {
            case 0:
            case 1:
              o = i;
              break;

            case 4:
              return s.label++, {
                value: i[1],
                done: !1
              };

            case 5:
              s.label++, r = i[1], i = [0];
              continue;

            case 7:
              i = s.ops.pop(), s.trys.pop();
              continue;

            default:
              if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {
                s = 0;
                continue;
              }

              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                s.label = i[1];
                break;
              }

              if (6 === i[0] && s.label < o[1]) {
                s.label = o[1], o = i;
                break;
              }

              if (o && s.label < o[2]) {
                s.label = o[2], s.ops.push(i);
                break;
              }

              o[2] && s.ops.pop(), s.trys.pop();
              continue;
          }

          i = t.call(e, s);
        } catch (e) {
          i = [6, e], r = 0;
        } finally {
          n = o = 0;
        }

        if (5 & i[0]) throw i[1];
        return {
          value: i[0] ? i[1] : void 0,
          done: !0
        };
      }([i, u]);
    };
  }
}

var BaseModel = function () {
  function e(e, t) {
    this.model = e, this.outputStride = t;
    var n = this.model.inputs[0].shape;
    tf.util.assert(-1 === n[1] && -1 === n[2], function () {
      return "Input shape [" + n[1] + ", " + n[2] + "] must both be equal to or -1";
    });
  }

  return e.prototype.predict = function (e) {
    var t = this;
    return (0, tf.tidy)(function () {
      var n = t.preprocessInput(e.toFloat()).expandDims(0),
          r = t.model.predict(n).map(function (e) {
        return e.squeeze([0]);
      }),
          o = t.nameOutputResults(r);
      return {
        heatmapScores: o.heatmap.sigmoid(),
        offsets: o.offsets,
        displacementFwd: o.displacementFwd,
        displacementBwd: o.displacementBwd
      };
    });
  }, e.prototype.dispose = function () {
    this.model.dispose();
  }, e;
}(),
    MobileNet = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.preprocessInput = function (e) {
    return (0, tf.tidy)(function () {
      return (0, tf.div)(e, 127.5).sub(1);
    });
  }, t.prototype.nameOutputResults = function (e) {
    return {
      offsets: e[0],
      heatmap: e[1],
      displacementFwd: e[2],
      displacementBwd: e[3]
    };
  }, t;
}(BaseModel);

exports.MobileNet = MobileNet;

function half(e) {
  return Math.floor(e / 2);
}

var MaxHeap = function () {
  function e(e, t) {
    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;
  }

  return e.prototype.enqueue = function (e) {
    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);
  }, e.prototype.dequeue = function () {
    var e = this.priorityQueue[0];
    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;
  }, e.prototype.empty = function () {
    return -1 === this.numberOfElements;
  }, e.prototype.size = function () {
    return this.numberOfElements + 1;
  }, e.prototype.all = function () {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }, e.prototype.max = function () {
    return this.priorityQueue[0];
  }, e.prototype.swim = function (e) {
    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);
  }, e.prototype.sink = function (e) {
    for (; 2 * e <= this.numberOfElements;) {
      var t = 2 * e;
      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;
      this.exchange(e, t), e = t;
    }
  }, e.prototype.getValueAt = function (e) {
    return this.getElementValue(this.priorityQueue[e]);
  }, e.prototype.less = function (e, t) {
    return this.getValueAt(e) < this.getValueAt(t);
  }, e.prototype.exchange = function (e, t) {
    var n = this.priorityQueue[e];
    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;
  }, e;
}();

function scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {
  for (var s = i.shape, u = s[0], a = s[1], l = !0, p = Math.max(n - o, 0), c = Math.min(n + o + 1, u), f = p; f < c; ++f) {
    for (var d = Math.max(r - o, 0), h = Math.min(r + o + 1, a), m = d; m < h; ++m) if (i.get(f, m, e) > t) {
      l = !1;
      break;
    }

    if (!l) break;
  }

  return l;
}

function buildPartWithScoreQueue(e, t, n) {
  for (var r = n.shape, o = r[0], i = r[1], s = r[2], u = new MaxHeap(o * i * s, function (e) {
    return e.score;
  }), a = 0; a < o; ++a) for (var l = 0; l < i; ++l) for (var p = 0; p < s; ++p) {
    var c = n.get(a, l, p);
    c < e || scoreIsMaximumInLocalWindow(p, c, a, l, t, n) && u.enqueue({
      score: c,
      part: {
        heatmapY: a,
        heatmapX: l,
        id: p
      }
    });
  }

  return u;
}

var partNames = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"],
    NUM_KEYPOINTS = partNames.length,
    partIds = partNames.reduce(function (e, t, n) {
  return e[t] = n, e;
}, {}),
    connectedPartNames = [["leftHip", "leftShoulder"], ["leftElbow", "leftShoulder"], ["leftElbow", "leftWrist"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["rightHip", "rightShoulder"], ["rightElbow", "rightShoulder"], ["rightElbow", "rightWrist"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"], ["leftShoulder", "rightShoulder"], ["leftHip", "rightHip"]],
    poseChain = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]],
    connectedPartIndices = connectedPartNames.map(function (e) {
  var t = e[0],
      n = e[1];
  return [partIds[t], partIds[n]];
}),
    partChannels = ["left_face", "right_face", "right_upper_leg_front", "right_lower_leg_back", "right_upper_leg_back", "left_lower_leg_front", "left_upper_leg_front", "left_upper_leg_back", "left_lower_leg_back", "right_feet", "right_lower_leg_front", "left_feet", "torso_front", "torso_back", "right_upper_arm_front", "right_upper_arm_back", "right_lower_arm_back", "left_lower_arm_front", "left_upper_arm_front", "left_upper_arm_back", "left_lower_arm_back", "right_hand", "right_lower_arm_front", "left_hand"];
exports.partChannels = partChannels;
exports.poseChain = poseChain;
exports.partIds = partIds;
exports.partNames = partNames;

function getOffsetPoint(e, t, n, r) {
  return {
    y: r.get(e, t, n),
    x: r.get(e, t, n + NUM_KEYPOINTS)
  };
}

function getImageCoords(e, t, n) {
  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),
      o = r.y,
      i = r.x;
  return {
    x: e.heatmapX * t + i,
    y: e.heatmapY * t + o
  };
}

function clamp(e, t, n) {
  return e < t ? t : e > n ? n : e;
}

function squaredDistance(e, t, n, r) {
  var o = n - e,
      i = r - t;
  return o * o + i * i;
}

function addVectors(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}

var parentChildrenTuples = poseChain.map(function (e) {
  var t = e[0],
      n = e[1];
  return [partIds[t], partIds[n]];
}),
    parentToChildEdges = parentChildrenTuples.map(function (e) {
  return e[1];
}),
    childToParentEdges = parentChildrenTuples.map(function (e) {
  return e[0];
});

function getDisplacement(e, t, n) {
  var r = n.shape[2] / 2;
  return {
    y: n.get(t.y, t.x, e),
    x: n.get(t.y, t.x, r + e)
  };
}

function getStridedIndexNearPoint(e, t, n, r) {
  return {
    y: clamp(Math.round(e.y / t), 0, n - 1),
    x: clamp(Math.round(e.x / t), 0, r - 1)
  };
}

function traverseToTargetKeypoint(e, t, n, r, o, i, s, u) {
  void 0 === u && (u = 2);

  for (var a = r.shape, l = a[0], p = a[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, p), s), f = addVectors(t.position, c), d = 0; d < u; d++) {
    var h = getStridedIndexNearPoint(f, i, l, p),
        m = getOffsetPoint(h.y, h.x, n, o);
    f = addVectors({
      x: h.x * i,
      y: h.y * i
    }, {
      x: m.x,
      y: m.y
    });
  }

  var g = getStridedIndexNearPoint(f, i, l, p),
      _ = r.get(g.y, g.x, n);

  return {
    position: f,
    part: partNames[n],
    score: _
  };
}

function decodePose(e, t, n, r, o, i) {
  var s = t.shape[2],
      u = parentToChildEdges.length,
      a = new Array(s),
      l = e.part,
      p = e.score,
      c = getImageCoords(l, r, n);
  a[l.id] = {
    score: p,
    part: partNames[l.id],
    position: c
  };

  for (var f = u - 1; f >= 0; --f) {
    var d = parentToChildEdges[f],
        h = childToParentEdges[f];
    a[d] && !a[h] && (a[h] = traverseToTargetKeypoint(f, a[d], h, t, n, r, i));
  }

  for (f = 0; f < u; ++f) {
    d = childToParentEdges[f], h = parentToChildEdges[f];
    a[d] && !a[h] && (a[h] = traverseToTargetKeypoint(f, a[d], h, t, n, r, o));
  }

  return a;
}

function withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {
  var o = n.x,
      i = n.y;
  return e.some(function (e) {
    var n = e.keypoints[r].position;
    return squaredDistance(i, o, n.y, n.x) <= t;
  });
}

function getInstanceScore(e, t, n) {
  return n.reduce(function (n, r, o) {
    var i = r.position,
        s = r.score;
    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += s), n;
  }, 0) / n.length;
}

var kLocalMaximumRadius = 1;

function decodeMultiplePoses(e, t, n, r, o, i, s, u) {
  void 0 === s && (s = .5), void 0 === u && (u = 20);

  for (var a = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), p = u * u; a.length < i && !l.empty();) {
    var c = l.dequeue();

    if (!withinNmsRadiusOfCorrespondingPoint(a, p, getImageCoords(c.part, o, t), c.part.id)) {
      var f = decodePose(c, e, t, o, n, r),
          d = getInstanceScore(a, p, f);
      a.push({
        keypoints: f,
        score: d
      });
    }
  }

  return a;
}

function mod(e, t) {
  return (0, tf.tidy)(function () {
    var n = e.div((0, tf.scalar)(t, "int32"));
    return e.sub(n.mul((0, tf.scalar)(t, "int32")));
  });
}

function argmax2d(e) {
  var t = e.shape,
      n = t[0],
      r = t[1],
      o = t[2];
  return (0, tf.tidy)(function () {
    var t = e.reshape([n * r, o]).argMax(0),
        i = t.div((0, tf.scalar)(r, "int32")).expandDims(1),
        s = mod(t, r).expandDims(1);
    return (0, tf.concat)([i, s], 1);
  });
}

function getPointsConfidence(e, t) {
  for (var n = t.shape[0], r = new Float32Array(n), o = 0; o < n; o++) {
    var i = t.get(o, 0),
        s = t.get(o, 1);
    r[o] = e.get(i, s, o);
  }

  return r;
}

function getOffsetPoint$1(e, t, n, r) {
  return {
    y: r.get(e, t, n),
    x: r.get(e, t, n + NUM_KEYPOINTS)
  };
}

function getOffsetVectors(e, t) {
  for (var n = [], r = 0; r < NUM_KEYPOINTS; r++) {
    var o = getOffsetPoint$1(e.get(r, 0).valueOf(), e.get(r, 1).valueOf(), r, t),
        i = o.x,
        s = o.y;
    n.push(s), n.push(i);
  }

  return (0, tf.tensor2d)(n, [NUM_KEYPOINTS, 2]);
}

function getOffsetPoints(e, t, n) {
  return (0, tf.tidy)(function () {
    var r = getOffsetVectors(e, n);
    return e.toTensor().mul((0, tf.scalar)(t, "int32")).toFloat().add(r);
  });
}

function decodeSinglePose(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, o, i, s, u, a, l, p, c, f;
    return __generator(this, function (d) {
      switch (d.label) {
        case 0:
          return r = 0, o = argmax2d(e), [4, Promise.all([e.buffer(), t.buffer(), o.buffer()])];

        case 1:
          return i = d.sent(), s = i[0], u = i[1], a = i[2], [4, (l = getOffsetPoints(a, n, u)).buffer()];

        case 2:
          return p = d.sent(), c = Array.from(getPointsConfidence(s, a)), f = c.map(function (e, t) {
            return r += e, {
              position: {
                y: p.get(t, 0),
                x: p.get(t, 1)
              },
              part: partNames[t],
              score: e
            };
          }), o.dispose(), l.dispose(), [2, {
            keypoints: f,
            score: r / f.length
          }];
      }
    });
  });
}

var MOBILENET_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",
    RESNET50_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";

function resNet50Checkpoint(e, t) {
  var n = "model-stride" + e + ".json";
  return 4 === t ? RESNET50_BASE_URL + "float/" + n : RESNET50_BASE_URL + "quant" + t + "/" + n;
}

function mobileNetCheckpoint(e, t, n) {
  var r = {
    1: "100",
    .75: "075",
    .5: "050"
  },
      o = "model-stride" + e + ".json";
  return 4 === n ? MOBILENET_BASE_URL + "float/" + r[t] + "/" + o : MOBILENET_BASE_URL + "quant" + n + "/" + r[t] + "/" + o;
}

var imageNetMean = [-123.15, -115.9, -103.06],
    ResNet = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.preprocessInput = function (e) {
    return e.add(imageNetMean);
  }, t.prototype.nameOutputResults = function (e) {
    var t = e[0],
        n = e[1];
    return {
      offsets: e[2],
      heatmap: e[3],
      displacementFwd: t,
      displacementBwd: n
    };
  }, t;
}(BaseModel);

function eitherPointDoesntMeetConfidence(e, t, n) {
  return e < n || t < n;
}

function getAdjacentKeyPoints(e, t) {
  return connectedPartIndices.reduce(function (n, r) {
    var o = r[0],
        i = r[1];
    return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? n : (n.push([e[o], e[i]]), n);
  }, []);
}

var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

function getBoundingBox(e) {
  return e.reduce(function (e, t) {
    var n = e.maxX,
        r = e.maxY,
        o = e.minX,
        i = e.minY,
        s = t.position,
        u = s.x,
        a = s.y;
    return {
      maxX: Math.max(n, u),
      maxY: Math.max(r, a),
      minX: Math.min(o, u),
      minY: Math.min(i, a)
    };
  }, {
    maxX: NEGATIVE_INFINITY,
    maxY: NEGATIVE_INFINITY,
    minX: POSITIVE_INFINITY,
    minY: POSITIVE_INFINITY
  });
}

function getBoundingBoxPoints(e) {
  var t = getBoundingBox(e),
      n = t.minX,
      r = t.minY,
      o = t.maxX,
      i = t.maxY;
  return [{
    x: n,
    y: r
  }, {
    x: o,
    y: r
  }, {
    x: o,
    y: i
  }, {
    x: n,
    y: i
  }];
}

function toTensorBuffers3D(e) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (t) {
      return [2, Promise.all(e.map(function (e) {
        return e.buffer();
      }))];
    });
  });
}

function scalePose(e, t, n, r, o) {
  return void 0 === r && (r = 0), void 0 === o && (o = 0), {
    score: e.score,
    keypoints: e.keypoints.map(function (e) {
      var i = e.score,
          s = e.part,
          u = e.position;
      return {
        score: i,
        part: s,
        position: {
          x: u.x * n + o,
          y: u.y * t + r
        }
      };
    })
  };
}

function scalePoses(e, t, n, r, o) {
  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {
    return scalePose(e, t, n, r, o);
  });
}

function flipPoseHorizontal(e, t) {
  return {
    score: e.score,
    keypoints: e.keypoints.map(function (e) {
      var n = e.score,
          r = e.part,
          o = e.position;
      return {
        score: n,
        part: r,
        position: {
          x: t - 1 - o.x,
          y: o.y
        }
      };
    })
  };
}

function flipPosesHorizontal(e, t) {
  return t <= 0 ? e : e.map(function (e) {
    return flipPoseHorizontal(e, t);
  });
}

function toValidInputResolution(e, t) {
  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;
}

function validateInputResolution(e) {
  tf.util.assert("number" == typeof e || "object" == typeof e, function () {
    return "Invalid inputResolution " + e + ". Should be a number or an object with width and height";
  }), "object" == typeof e && (tf.util.assert("number" == typeof e.width, function () {
    return "inputResolution.width has a value of " + e.width + " which is invalid; it must be a number";
  }), tf.util.assert("number" == typeof e.height, function () {
    return "inputResolution.height has a value of " + e.height + " which is invalid; it must be a number";
  }));
}

function getValidInputResolutionDimensions(e, t) {
  return validateInputResolution(e), "object" == typeof e ? [toValidInputResolution(e.height, t), toValidInputResolution(e.width, t)] : [toValidInputResolution(e, t), toValidInputResolution(e, t)];
}

var VALID_OUTPUT_STRIDES = [8, 16, 32];

function assertValidOutputStride(e) {
  tf.util.assert("number" == typeof e, function () {
    return "outputStride is not a number";
  }), tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {
    return "outputStride of " + e + " is invalid. It must be either 8, 16, or 32";
  });
}

function isValidInputResolution(e, t) {
  return (e - 1) % t == 0;
}

function assertValidResolution(e, t) {
  tf.util.assert("number" == typeof e[0] && "number" == typeof e[1], function () {
    return "both resolution values must be a number but had values " + e;
  }), tf.util.assert(isValidInputResolution(e[0], t), function () {
    return "height of " + e[0] + " is invalid for output stride " + t + ".";
  }), tf.util.assert(isValidInputResolution(e[1], t), function () {
    return "width of " + e[1] + " is invalid for output stride " + t + ".";
  });
}

function getInputTensorDimensions(e) {
  return e instanceof tf.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];
}

function toInputTensor(e) {
  return e instanceof tf.Tensor ? e : tf.browser.fromPixels(e);
}

function padAndResizeTo(e, t) {
  var n = t[0],
      r = t[1],
      o = getInputTensorDimensions(e),
      i = o[0],
      s = o[1],
      u = r / n,
      a = [0, 0, 0, 0],
      l = a[0],
      p = a[1],
      c = a[2],
      f = a[3];
  return s / i < u ? (l = 0, p = 0, c = Math.round(.5 * (u * i - s)), f = Math.round(.5 * (u * i - s))) : (l = Math.round(.5 * (1 / u * s - i)), p = Math.round(.5 * (1 / u * s - i)), c = 0, f = 0), {
    resized: (0, tf.tidy)(function () {
      var t = toInputTensor(e);
      return (t = (0, tf.pad3d)(t, [[l, p], [c, f], [0, 0]])).resizeBilinear([n, r]);
    }),
    padding: {
      top: l,
      left: c,
      right: f,
      bottom: p
    }
  };
}

function scaleAndFlipPoses(e, t, n, r, o) {
  var i = t[0],
      s = t[1],
      u = n[0],
      a = n[1],
      l = scalePoses(e, (i + r.top + r.bottom) / u, (s + r.left + r.right) / a, -r.top, -r.left);
  return o ? flipPosesHorizontal(l, s) : l;
}

var MOBILENET_V1_CONFIG = {
  architecture: "MobileNetV1",
  outputStride: 16,
  multiplier: .75,
  inputResolution: 257
},
    VALID_ARCHITECTURE = ["MobileNetV1", "ResNet50"],
    VALID_STRIDE = {
  MobileNetV1: [8, 16, 32],
  ResNet50: [32, 16]
},
    VALID_MULTIPLIER = {
  MobileNetV1: [.5, .75, 1],
  ResNet50: [1]
},
    VALID_QUANT_BYTES = [1, 2, 4];

function validateModelConfig(e) {
  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = "MobileNetV1"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error("Invalid architecture " + e.architecture + ". Should be one of " + VALID_ARCHITECTURE);
  if (null == e.inputResolution && (e.inputResolution = 257), validateInputResolution(e.inputResolution), null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error("Invalid outputStride " + e.outputStride + ". Should be one of " + VALID_STRIDE[e.architecture] + " for architecutre " + e.architecture + ".");
  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error("Invalid multiplier " + e.multiplier + ". Should be one of " + VALID_MULTIPLIER[e.architecture] + " for architecutre " + e.architecture + ".");
  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error("Invalid quantBytes " + e.quantBytes + ". Should be one of " + VALID_QUANT_BYTES + " for architecutre " + e.architecture + ".");
  return e;
}

var SINGLE_PERSON_INFERENCE_CONFIG = {
  flipHorizontal: !1
},
    MULTI_PERSON_INFERENCE_CONFIG = {
  flipHorizontal: !1,
  maxDetections: 5,
  scoreThreshold: .5,
  nmsRadius: 20
};

function validateMultiPersonInputConfig(e) {
  var t = e.maxDetections,
      n = e.scoreThreshold,
      r = e.nmsRadius;
  if (t <= 0) throw new Error("Invalid maxDetections " + t + ". Should be > 0");
  if (n < 0 || n > 1) throw new Error("Invalid scoreThreshold " + n + ". Should be in range [0.0, 1.0]");
  if (r <= 0) throw new Error("Invalid nmsRadius " + r + ".");
}

var PoseNet = function () {
  function e(e, t) {
    assertValidOutputStride(e.outputStride), assertValidResolution(t, e.outputStride), this.baseModel = e, this.inputResolution = t;
  }

  return e.prototype.estimateMultiplePoses = function (e, t) {
    return void 0 === t && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {
      var n, r, o, i, s, u, a, l, p, c, f, d, h, m, g, _, I, v, y, E, b;

      return __generator(this, function (N) {
        switch (N.label) {
          case 0:
            return n = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), f = c.heatmapScores, d = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([f, d, h, m])];

          case 1:
            return g = N.sent(), _ = g[0], I = g[1], v = g[2], y = g[3], [4, decodeMultiplePoses(_, I, v, y, r, n.maxDetections, n.scoreThreshold, n.nmsRadius)];

          case 2:
            return E = N.sent(), b = scaleAndFlipPoses(E, [s, u], o, p, n.flipHorizontal), f.dispose(), d.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, b];
        }
      });
    });
  }, e.prototype.estimateSinglePose = function (e, t) {
    return void 0 === t && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {
      var n, r, o, i, s, u, a, l, p, c, f, d, h, m, g, _;

      return __generator(this, function (I) {
        switch (I.label) {
          case 0:
            return n = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), f = c.heatmapScores, d = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(f, d, r)];

          case 1:
            return g = I.sent(), _ = scaleAndFlipPoses([g], [s, u], o, p, n.flipHorizontal), f.dispose(), d.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];
        }
      });
    });
  }, e.prototype.estimatePoses = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return "single-person" !== t.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e, t)];

          case 1:
            return [2, [n.sent()]];

          case 2:
            return [2, this.estimateMultiplePoses(e, t)];
        }
      });
    });
  }, e.prototype.dispose = function () {
    this.baseModel.dispose();
  }, e;
}();

exports.PoseNet = PoseNet;

function loadMobileNet(e) {
  return __awaiter(this, void 0, void 0, function () {
    var t, n, r, o, i, s, u;
    return __generator(this, function (a) {
      switch (a.label) {
        case 0:
          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return o = mobileNetCheckpoint(t, r, n), [4, (0, _tfjsConverter.loadGraphModel)(e.modelUrl || o)];

        case 1:
          return i = a.sent(), s = new MobileNet(i, t), u = getValidInputResolutionDimensions(e.inputResolution, s.outputStride), [2, new PoseNet(s, u)];
      }
    });
  });
}

function loadResNet(e) {
  return __awaiter(this, void 0, void 0, function () {
    var t, n, r, o, i, s;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return r = resNet50Checkpoint(t, n), [4, (0, _tfjsConverter.loadGraphModel)(e.modelUrl || r)];

        case 1:
          return o = u.sent(), i = new ResNet(o, t), s = getValidInputResolutionDimensions(e.inputResolution, i.outputStride), [2, new PoseNet(i, s)];
      }
    });
  });
}

function load(e) {
  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (t) {
      return "ResNet50" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : "MobileNetV1" === e.architecture ? [2, loadMobileNet(e)] : [2, null];
    });
  });
}
},{"@tensorflow/tfjs-core":"../node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","@tensorflow/tfjs-converter":"../node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js"}],"../brain/posenet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rightHandPosition = exports.leftHandPosition = exports.handsKeyPoints = void 0;

require("babel-polyfill");

var _tfjsNode = _interopRequireDefault(require("@tensorflow/tfjs-node"));

var _posenet = _interopRequireDefault(require("@tensorflow-models/posenet"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// const posenet = require('@tensorflow-models/posenet');
var videoWidth = window.innerWidth || 640;
var videoHeight = window.innerHeight || 360;
var handsKeyPoints;
exports.handsKeyPoints = handsKeyPoints;
var leftHandPosition;
exports.leftHandPosition = leftHandPosition;
var rightHandPosition;
exports.rightHandPosition = rightHandPosition;

function setupCamera() {
  var video, stream;
  return regeneratorRuntime.async(function setupCamera$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)) {
            _context.next = 2;
            break;
          }

          throw new Error('Browser API navigator.mediaDevices.getUserMedia not available');

        case 2:
          video = document.getElementById('video');
          video.width = videoWidth;
          video.height = videoHeight;
          _context.next = 7;
          return regeneratorRuntime.awrap(navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
              width: videoWidth,
              height: videoHeight
            }
          }));

        case 7:
          stream = _context.sent;
          video.srcObject = stream;
          return _context.abrupt("return", new Promise(function (resolve) {
            video.onloadedmetadata = function () {
              return resolve(video);
            };
          }));

        case 10:
        case "end":
          return _context.stop();
      }
    }
  });
}

var net;
var poseNetConfig = {
  algorithm: 'single-pose',
  //other option: multi-pose
  input: {
    architecture: 'MobileNetV1',
    outputStride: 16,
    inputResolution: {
      width: 640,
      height: 360
    },
    multiplier: 0.75,
    quantBytes: 2
  },
  singlePoseDetection: {
    minPoseConfidence: 0.1,
    minPartConfidence: 0.5
  },
  output: {
    showVideo: true,
    showPoints: true
  } // net: null

}; //call getWireframe function (something from ./wireframe.js) that pulls keypoints from posenet read, and returns an object

function getLeftHand(keypoints) {
  for (var i = 0; i < keypoints.length; i++) {
    if (keypoints[i].part === 'leftWrist') {
      return keypoints[i].position;
    }
  }
}

function getRightHand(keypoints) {
  for (var i = 0; i < keypoints.length; i++) {
    if (keypoints[i].part === 'rightWrist') {
      return keypoints[i].position;
    }
  }
}

function detectPoseInRealTime(video, net) {
  var canvas = document.getElementById('output');
  var ctx = canvas.getContext('2d'); // since images are being fed from a webcam, we want to feed in the
  // original image and then just flip the keypoints' x coordinates. If instead
  // we flip the image, then correcting left-right keypoint pairs requires a
  // permutation on all the keypoints.

  var flipPoseHorizontal = true;
  canvas.width = videoWidth;
  canvas.height = videoHeight;

  function poseDetectionFrame() {
    var poses, minPoseConfidence, minPartConfidence, pose;
    return regeneratorRuntime.async(function poseDetectionFrame$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            poses = [];
            _context2.t0 = poseNetConfig.algorithm;
            _context2.next = _context2.t0 === 'single-pose' ? 4 : 11;
            break;

          case 4:
            _context2.next = 6;
            return regeneratorRuntime.awrap(net.estimatePoses(video, {
              flipHorizontal: flipPoseHorizontal,
              decodingMethod: 'single-person'
            }));

          case 6:
            pose = _context2.sent;
            poses = poses.concat(pose);
            minPoseConfidence = +poseNetConfig.singlePoseDetection.minPoseConfidence;
            minPartConfidence = +poseNetConfig.singlePoseDetection.minPartConfidence;
            return _context2.abrupt("break", 11);

          case 11:
            ctx.clearRect(0, 0, videoWidth, videoHeight);

            if (poseNetConfig.output.showVideo) {
              ctx.save();
              ctx.scale(-1, 1);
              ctx.translate(-videoWidth, 0);
              ctx.drawImage(video, 0, 0, videoWidth, videoHeight);
              ctx.restore();
            }

            poses.forEach(function (_ref) {
              var score = _ref.score,
                  keypoints = _ref.keypoints;

              if (score >= minPoseConfidence) {
                if (poseNetConfig.output.showPoints) {
                  exports.handsKeyPoints = handsKeyPoints = keypoints;
                  exports.leftHandPosition = leftHandPosition = getLeftHand(keypoints);
                  exports.rightHandPosition = rightHandPosition = getRightHand(keypoints);
                }
              }
            });
            requestAnimationFrame(poseDetectionFrame);

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    });
  }

  poseDetectionFrame();
}

function init() {
  var video;
  return regeneratorRuntime.async(function init$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(_posenet.default.load({
            architecture: poseNetConfig.input.architecture,
            outputStride: poseNetConfig.input.outputStride,
            inputResolution: poseNetConfig.input.inputResolution,
            multiplier: poseNetConfig.input.multiplier,
            quantBytes: poseNetConfig.input.quantBytes
          }));

        case 2:
          net = _context3.sent;
          _context3.prev = 3;
          _context3.next = 6;
          return regeneratorRuntime.awrap(setupCamera());

        case 6:
          video = _context3.sent;
          video.play();
          _context3.next = 13;
          break;

        case 10:
          _context3.prev = 10;
          _context3.t0 = _context3["catch"](3);
          throw _context3.t0;

        case 13:
          detectPoseInRealTime(video, net);

        case 14:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[3, 10]]);
}

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia; // console.log(net);

init();
},{"babel-polyfill":"../node_modules/babel-polyfill/lib/index.js","@tensorflow/tfjs-node":"../node_modules/@tensorflow/tfjs-node/dist/index.js","@tensorflow-models/posenet":"../node_modules/@tensorflow-models/posenet/dist/posenet.esm.js"}],"../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "60070" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] â¨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] ð¨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ð¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","../brain/posenet.js"], null)
//# sourceMappingURL=/posenet.8d38e87c.js.map